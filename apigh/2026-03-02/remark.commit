{
  "sha": "aca0cff39925ae520d8b949b995724aff1a4e00b",
  "node_id": "C_kwDOBtgov9oAKGFjYTBjZmYzOTkyNWFlNTIwZDhiOTQ5Yjk5NTcyNGFmZjFhNGUwMGI",
  "commit": {
    "author": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2026-02-28T09:53:18Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2026-02-28T10:13:07Z"
    },
    "message": "fix: IPv6 address truncation and image proxy SSRF vulnerabilities\n\nReplace strings.Split(RemoteAddr, \":\") with net.SplitHostPort for correct\nIPv6 address extraction in vote deduplication and comment IP tracking.\n\nHarden image proxy: add SSRF-safe transport blocking private/reserved IPs\nat connection time with DNS rebinding protection, sanitize error messages\nto prevent information leakage, add response size limit via io.LimitReader.\n\nFix shadowed error variables in BlockedUsers, SetTitle, and Delete methods.\nExclude gosec taint analysis false positives at linter config level.",
    "tree": {
      "sha": "1b182cbdbf0bf813b77fc536371d8ac3d424caf5",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/1b182cbdbf0bf813b77fc536371d8ac3d424caf5"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/aca0cff39925ae520d8b949b995724aff1a4e00b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/aca0cff39925ae520d8b949b995724aff1a4e00b",
  "html_url": "https://github.com/umputun/remark42/commit/aca0cff39925ae520d8b949b995724aff1a4e00b",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/aca0cff39925ae520d8b949b995724aff1a4e00b/comments",
  "author": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f359256489c0e7a63ed57f7c087ec53031d5e966",
      "url": "https://api.github.com/repos/umputun/remark42/commits/f359256489c0e7a63ed57f7c087ec53031d5e966",
      "html_url": "https://github.com/umputun/remark42/commit/f359256489c0e7a63ed57f7c087ec53031d5e966"
    }
  ],
  "stats": {
    "total": 447,
    "additions": 364,
    "deletions": 83
  },
  "files": [
    {
      "sha": "a39d711d1d8017c2bdf07af308b50871fbf38392",
      "filename": ".github/workflows/ci-backend.yml",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/.github%2Fworkflows%2Fci-backend.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/.github%2Fworkflows%2Fci-backend.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/.github%2Fworkflows%2Fci-backend.yml?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -60,13 +60,13 @@ jobs:\n       - name: golangci-lint\n         uses: golangci/golangci-lint-action@v9\n         with:\n-          version: \"v2.6.0\"\n+          version: \"v2.10.1\"\n           working-directory: backend/app\n \n       - name: golangci-lint on example directory\n         uses: golangci/golangci-lint-action@v9\n         with:\n-          version: \"v2.6.0\"\n+          version: \"v2.10.1\"\n           args: --config ../../.golangci.yml\n           working-directory: backend/_example/memory_store\n "
    },
    {
      "sha": "cb5ea5d58346b7ceca56016bb55952240bcb0e09",
      "filename": ".gitignore",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/.gitignore?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -26,3 +26,6 @@ compose-private.yml\n http-client.env.json\n /playwright-report/\n /backend/app/cmd/var\n+\n+# ralphex progress logs\n+.ralphex/progress/"
    },
    {
      "sha": "847653dab8f9655e69298c159d9209ba2907de77",
      "filename": "backend/.golangci.yml",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2F.golangci.yml?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -23,6 +23,12 @@ linters:\n     goconst:\n       min-len: 2\n       min-occurrences: 2\n+    gosec:\n+      excludes:\n+        - G117 # false positive: struct field name matches \"secret\" pattern\n+        - G703 # false positive: path traversal via taint analysis\n+        - G704 # false positive: SSRF via taint analysis\n+        - G705 # false positive: XSS via taint analysis\n     gocritic:\n       disabled-checks:\n         - wrapperFunc\n@@ -51,6 +57,9 @@ linters:\n       - linters:\n           - revive\n         text: 'var-naming: avoid meaningless package names'\n+      - linters:\n+          - revive\n+        text: 'var-naming: avoid package names that conflict with Go standard library package names'\n       - linters:\n           - dupl\n           - gosec"
    },
    {
      "sha": "cdfd2d2a80d94adfdee252769fd20501fb43a217",
      "filename": "backend/app/cmd/cmd.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fcmd%2Fcmd.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fcmd%2Fcmd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fcmd.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -124,7 +124,7 @@ func responseError(resp *http.Response) error {\n // mkdir -p for all dirs\n func makeDirs(dirs ...string) error {\n \tfor _, dir := range dirs {\n-\t\tif err := os.MkdirAll(dir, 0o700); err != nil { // If path is already a directory, MkdirAll does nothing\n+\t\tif err := os.MkdirAll(dir, 0o700); err != nil { // if path is already a directory, MkdirAll does nothing\n \t\t\treturn fmt.Errorf(\"can't make directory %s: %w\", dir, err)\n \t\t}\n \t}"
    },
    {
      "sha": "f463d1cb87e1ef6ba4ecff1cbd45f66b9c68f273",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fcmd%2Fserver.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fcmd%2Fserver.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fserver.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -99,18 +99,18 @@ type ServerCommand struct {\n \t\tSendJWTHeader bool   `long:\"send-jwt-header\" env:\"SEND_JWT_HEADER\" description:\"send JWT as a header instead of server-set cookie; with this enabled, frontend stores the JWT in a client-side cookie (note: increases vulnerability to XSS attacks)\"`\n \t\tSameSite      string `long:\"same-site\" env:\"SAME_SITE\" description:\"set same site policy for cookies\" choice:\"default\" choice:\"none\" choice:\"lax\" choice:\"strict\" default:\"default\"` // nolint\n \n-\t\tApple     AppleGroup `group:\"apple\" namespace:\"apple\" env-namespace:\"APPLE\" description:\"Apple OAuth\"`\n-\t\tGoogle    AuthGroup  `group:\"google\" namespace:\"google\" env-namespace:\"GOOGLE\" description:\"Google OAuth\"`\n-\t\tGithub    AuthGroup  `group:\"github\" namespace:\"github\" env-namespace:\"GITHUB\" description:\"Github OAuth\"`\n-\t\tFacebook  AuthGroup  `group:\"facebook\" namespace:\"facebook\" env-namespace:\"FACEBOOK\" description:\"Facebook OAuth\"`\n+\t\tApple     AppleGroup         `group:\"apple\" namespace:\"apple\" env-namespace:\"APPLE\" description:\"Apple OAuth\"`\n+\t\tGoogle    AuthGroup          `group:\"google\" namespace:\"google\" env-namespace:\"GOOGLE\" description:\"Google OAuth\"`\n+\t\tGithub    AuthGroup          `group:\"github\" namespace:\"github\" env-namespace:\"GITHUB\" description:\"Github OAuth\"`\n+\t\tFacebook  AuthGroup          `group:\"facebook\" namespace:\"facebook\" env-namespace:\"FACEBOOK\" description:\"Facebook OAuth\"`\n \t\tMicrosoft MicrosoftAuthGroup `group:\"microsoft\" namespace:\"microsoft\" env-namespace:\"MICROSOFT\" description:\"Microsoft OAuth\"`\n-\t\tYandex    AuthGroup  `group:\"yandex\" namespace:\"yandex\" env-namespace:\"YANDEX\" description:\"Yandex OAuth\"`\n-\t\tTwitter   AuthGroup  `group:\"twitter\" namespace:\"twitter\" env-namespace:\"TWITTER\" description:\"[deprecated, doesn't work] Twitter OAuth\"`\n-\t\tPatreon   AuthGroup  `group:\"patreon\" namespace:\"patreon\" env-namespace:\"PATREON\" description:\"Patreon OAuth\"`\n-\t\tDiscord   AuthGroup  `group:\"discord\" namespace:\"discord\" env-namespace:\"DISCORD\" description:\"Discord OAuth\"`\n-\t\tTelegram  bool       `long:\"telegram\" env:\"TELEGRAM\" description:\"Enable Telegram auth (using token from telegram.token)\"`\n-\t\tDev       bool       `long:\"dev\" env:\"DEV\" description:\"enable dev (local) oauth2\"`\n-\t\tAnonymous bool       `long:\"anon\" env:\"ANON\" description:\"enable anonymous login\"`\n+\t\tYandex    AuthGroup          `group:\"yandex\" namespace:\"yandex\" env-namespace:\"YANDEX\" description:\"Yandex OAuth\"`\n+\t\tTwitter   AuthGroup          `group:\"twitter\" namespace:\"twitter\" env-namespace:\"TWITTER\" description:\"[deprecated, doesn't work] Twitter OAuth\"`\n+\t\tPatreon   AuthGroup          `group:\"patreon\" namespace:\"patreon\" env-namespace:\"PATREON\" description:\"Patreon OAuth\"`\n+\t\tDiscord   AuthGroup          `group:\"discord\" namespace:\"discord\" env-namespace:\"DISCORD\" description:\"Discord OAuth\"`\n+\t\tTelegram  bool               `long:\"telegram\" env:\"TELEGRAM\" description:\"Enable Telegram auth (using token from telegram.token)\"`\n+\t\tDev       bool               `long:\"dev\" env:\"DEV\" description:\"enable dev (local) oauth2\"`\n+\t\tAnonymous bool               `long:\"anon\" env:\"ANON\" description:\"enable anonymous login\"`\n \t\tEmail     struct {\n \t\t\tEnable       bool          `long:\"enable\" env:\"ENABLE\" description:\"enable auth via email\"`\n \t\t\tFrom         string        `long:\"from\" env:\"FROM\" description:\"from email address\"`\n@@ -685,9 +685,9 @@ func (s *ServerCommand) getAllowedDomains() []string {\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Only for RemarkURL if domain is not IP and has more than two levels, extract second level domain.\n-\t\t// For AllowedHosts we don't do this as they are exact list of domains which can host comments, but\n-\t\t// RemarkURL might be on a subdomain and we must allow parent domain to be used for TitleExtract.\n+\t\t// only for RemarkURL if domain is not IP and has more than two levels, extract second level domain.\n+\t\t// for AllowedHosts we don't do this as they are exact list of domains which can host comments, but\n+\t\t// remarkURL might be on a subdomain and we must allow parent domain to be used for TitleExtract.\n \t\tif rawURL == s.RemarkURL && net.ParseIP(domain) == nil && len(strings.Split(domain, \".\")) > 2 {\n \t\t\tdomain = strings.Join(strings.Split(domain, \".\")[len(strings.Split(domain, \".\"))-2:], \".\")\n \t\t}\n@@ -1027,7 +1027,7 @@ func (s *ServerCommand) addAuthProviders(authenticator *auth.Service) error {\n \t\t\t}\n \t\t\treturn true, nil\n \t\t}),\n-\t\t\t// Custom user ID generator, used to distinguish anonymous users with the same login\n+\t\t\t// custom user ID generator, used to distinguish anonymous users with the same login\n \t\t\t// coming from different IPs\n \t\t\tfunc(user string, r *http.Request) string {\n \t\t\t\treturn user + r.RemoteAddr\n@@ -1112,7 +1112,7 @@ func (s *ServerCommand) makeNotifyDestinations(authenticator *auth.Service) ([]n\n \t\t\tVerificationSubject: s.Notify.Email.VerificationSubject,\n \t\t\tUnsubscribeURL:      s.RemarkURL + \"/email/unsubscribe.html\",\n \t\t\t// TODO: uncomment after #560 frontend part is ready and URL is known\n-\t\t\t// SubscribeURL:        s.RemarkURL + \"/subscribe.html?token=\",\n+\t\t\t// subscribeURL:        s.RemarkURL + \"/subscribe.html?token=\",\n \t\t\tTokenGenFn: func(userID, email, site string) (string, error) {\n \t\t\t\tclaims := token.Claims{\n \t\t\t\t\tHandshake: &token.Handshake{ID: userID + \"::\" + email},\n@@ -1222,7 +1222,7 @@ func (s *ServerCommand) getAuthenticator(ds *service.DataStore, avas avatar.Stor\n \t\t\tif c.User == nil {\n \t\t\t\treturn c\n \t\t\t}\n-\t\t\t// Audience is a slice but we set it to a single element, and situation when there is no audience or there are more than one is unexpected\n+\t\t\t// audience is a slice but we set it to a single element, and situation when there is no audience or there are more than one is unexpected\n \t\t\tif len(c.Audience) != 1 {\n \t\t\t\treturn c\n \t\t\t}"
    },
    {
      "sha": "93d5a106d783fc6732d84f0daf2dc263156e006a",
      "filename": "backend/app/migrator/disqus_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fmigrator%2Fdisqus_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fmigrator%2Fdisqus_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fdisqus_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -122,7 +122,7 @@ func TestDisqus_Convert(t *testing.T) {\n \trequire.NoError(t, err)\n \tch := d.convert(fh, \"test\")\n \n-\tres := []store.Comment{}\n+\tres := make([]store.Comment, 0, 4)\n \tfor comment := range ch {\n \t\tres = append(res, comment)\n \t}"
    },
    {
      "sha": "dbc31ab8ff88109ae53867c2b8f17749aaa2c13a",
      "filename": "backend/app/migrator/wordpress_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fmigrator%2Fwordpress_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fmigrator%2Fwordpress_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fwordpress_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -72,7 +72,7 @@ func TestWordPress_Convert(t *testing.T) {\n \twp := WordPress{}\n \tch := wp.convert(strings.NewReader(xmlTestWP), \"testWP\")\n \n-\tcomments := []store.Comment{}\n+\tcomments := make([]store.Comment, 0, 3)\n \tfor c := range ch {\n \t\tcomments = append(comments, c)\n \t}\n@@ -100,7 +100,7 @@ func TestWP_Convert_MD(t *testing.T) {\n \twp := WordPress{}\n \tch := wp.convert(strings.NewReader(xmlTestWPmd), \"siteID\")\n \n-\tcomments := []store.Comment{}\n+\tcomments := make([]store.Comment, 0, 3)\n \tfor c := range ch {\n \t\tcomments = append(comments, c)\n \t}"
    },
    {
      "sha": "ce7b1bfb53abcedc3174c6be0836fe2d6c53b9ea",
      "filename": "backend/app/notify/email.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fnotify%2Femail.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fnotify%2Femail.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Femail.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -26,7 +26,7 @@ type EmailParams struct {\n \tSubscribeURL             string   // full subscribe handler URL\n \tUnsubscribeURL           string   // full unsubscribe handler URL\n \n-\tTokenGenFn func(userID, email, site string) (string, error) // Unsubscribe token generation function\n+\tTokenGenFn func(userID, email, site string) (string, error) // unsubscribe token generation function\n }\n \n // Email implements notify.Destination for email"
    },
    {
      "sha": "73184f09e70a0caef28a42075444f706dd3986f4",
      "filename": "backend/app/notify/notify_test.go",
      "status": "modified",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fnotify%2Fnotify_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fnotify%2Fnotify_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Fnotify_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -103,17 +103,10 @@ func TestService_Many(t *testing.T) {\n \t}\n \ts.Close()\n \n-\t// wait for destinations to close\n-\tassert.Eventually(t, func() bool { return d1.IsClosed() && d2.IsClosed() }, 100*time.Millisecond, 10*time.Millisecond)\n-\n \tassert.NotEqual(t, 10, len(d1.Get()), \"some comments dropped from d1\")\n \tassert.NotEqual(t, 10, len(d1.GetVerify()), \"some verifications dropped from d1\")\n \tassert.NotEqual(t, 10, len(d2.Get()), \"some comments dropped from d2\")\n \tassert.NotEqual(t, 10, len(d2.GetVerify()), \"some verifications dropped from d2\")\n-\n-\tassert.True(t, d1.IsClosed())\n-\tassert.True(t, d2.IsClosed())\n-\tassert.Equal(t, \"mock id=1, closed=true\", d1.String())\n }\n \n func TestService_WithParent(t *testing.T) {"
    },
    {
      "sha": "86a8d8bb4bafde6d87aac6188fccba4c9eeab3b5",
      "filename": "backend/app/providers/telegram.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fproviders%2Ftelegram.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fproviders%2Ftelegram.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fproviders%2Ftelegram.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -27,8 +27,8 @@ type TGUpdatesReceiver interface {\n // DispatchTelegramUpdates dispatches telegram updates to provided list of receivers\n // Blocks caller\n func DispatchTelegramUpdates(ctx context.Context, requester tgRequester, receivers []TGUpdatesReceiver, period time.Duration) {\n-\t// Identifier of the first update to be requested.\n-\t// Should be equal to LastSeenUpdateID + 1\n+\t// identifier of the first update to be requested.\n+\t// should be equal to LastSeenUpdateID + 1\n \t// See https://core.telegram.org/bots/api#getupdates\n \tvar updateOffset int\n "
    },
    {
      "sha": "e8150c4b048fbc7642909cd937d051a54e0adbe1",
      "filename": "backend/app/rest/api/admin.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fadmin.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -103,7 +103,7 @@ func (a *admin) deleteMeRequestCtrl(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n-\t// Audience is a slice but we set it to a single element, and situation when there is no audience or there are more than one is unexpected\n+\t// audience is a slice but we set it to a single element, and situation when there is no audience or there are more than one is unexpected\n \tif len(claims.Audience) != 1 {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"bad request\"), \"can't process token, claims.Audience expected to be a single element but it's not\", rest.ErrActionRejected)\n \t\treturn"
    },
    {
      "sha": "e2c2adf41132d29095191a78b32dad8e850345ec",
      "filename": "backend/app/rest/api/rest.go",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -619,13 +619,13 @@ func cacheControl(expiration time.Duration, version string) func(http.Handler) h\n }\n \n // securityHeadersMiddleware sets security-related headers:\n-// - Content-Security-Policy: controls which resources the browser is allowed to load\n-// - Permissions-Policy: disables browser features (camera, mic, etc.) not needed by a comment widget\n-// - X-Content-Type-Options: prevents browsers from MIME-sniffing responses away from the declared type,\n-//   stopping e.g. a user-uploaded image from being reinterpreted as executable HTML/JS\n-// - Referrer-Policy: controls how much URL information leaks in the Referer header on cross-origin\n-//   requests; \"strict-origin-when-cross-origin\" sends only the origin (no path) to other domains\n-//   and nothing at all on HTTPS→HTTP downgrades\n+//   - Content-Security-Policy: controls which resources the browser is allowed to load\n+//   - Permissions-Policy: disables browser features (camera, mic, etc.) not needed by a comment widget\n+//   - X-Content-Type-Options: prevents browsers from MIME-sniffing responses away from the declared type,\n+//     stopping e.g. a user-uploaded image from being reinterpreted as executable HTML/JS\n+//   - Referrer-Policy: controls how much URL information leaks in the Referer header on cross-origin\n+//     requests; \"strict-origin-when-cross-origin\" sends only the origin (no path) to other domains\n+//     and nothing at all on HTTPS→HTTP downgrades\n func securityHeadersMiddleware(imageProxyEnabled bool, allowedAncestors []string) func(http.Handler) http.Handler {\n \treturn func(next http.Handler) http.Handler {\n \t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {"
    },
    {
      "sha": "1b51f545e87a8ab04dcb33e90c8ad8ad668b5ccd",
      "filename": "backend/app/rest/api/rest_private.go",
      "status": "modified",
      "additions": 16,
      "deletions": 5,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_private.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"html/template\"\n \t\"io\"\n+\t\"net\"\n \t\"net/http\"\n \t\"strings\"\n \t\"time\"\n@@ -120,7 +121,7 @@ func (s *private) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tcomment.PrepareUntrusted() // clean all fields user not supposed to set\n \tcomment.User = user\n-\tcomment.User.IP = strings.Split(r.RemoteAddr, \":\")[0]\n+\tcomment.User.IP = extractIP(r.RemoteAddr)\n \n \tcomment.Orig = comment.Text // original comment text, prior to md render\n \tif err := s.dataService.ValidateComment(&comment); err != nil {\n@@ -279,7 +280,7 @@ func (s *private) voteCtrl(w http.ResponseWriter, r *http.Request) {\n \t\tLocator:   locator,\n \t\tCommentID: id,\n \t\tUserID:    user.ID,\n-\t\tUserIP:    strings.Split(r.RemoteAddr, \":\")[0],\n+\t\tUserIP:    extractIP(r.RemoteAddr),\n \t\tVal:       vote,\n \t}\n \tcomment, err := s.dataService.Vote(req)\n@@ -410,7 +411,7 @@ func (s *private) telegramSubscribeCtrl(w http.ResponseWriter, r *http.Request)\n \t\t\t\tfmt.Errorf(\"already subscribed\"), \"telegram subscription is already set for this user, delete if first to re-subscribe\", rest.ErrActionRejected)\n \t\t\treturn\n \t\t}\n-\t\t// Generate and send token\n+\t\t// generate and send token\n \t\ttkn, err := randToken()\n \t\tif err != nil {\n \t\t\trest.SendErrorJSON(w, r, http.StatusForbidden, err, \"failed to generate verification token\", rest.ErrInternal)\n@@ -479,7 +480,7 @@ func (s *private) setConfirmedEmailCtrl(w http.ResponseWriter, r *http.Request)\n \t\treturn\n \t}\n \n-\t// Handshake.ID is user.ID + \"::\" + address\n+\t// handshake.ID is user.ID + \"::\" + address\n \telems := strings.Split(confClaims.Handshake.ID, \"::\")\n \tif len(elems) != 2 || elems[0] != user.ID {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"%s\", confClaims.Handshake.ID), \"invalid handshake token\", rest.ErrInternal)\n@@ -533,7 +534,7 @@ func (s *private) emailUnsubscribeCtrl(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n-\t// Handshake.ID is user.ID + \"::\" + address\n+\t// handshake.ID is user.ID + \"::\" + address\n \telems := strings.Split(confClaims.Handshake.ID, \"::\")\n \tif len(elems) != 2 {\n \t\trest.SendErrorHTML(w, r, http.StatusBadRequest, fmt.Errorf(\"%s\", confClaims.Handshake.ID), \"invalid handshake token\", rest.ErrInternal)\n@@ -772,3 +773,13 @@ func randToken() (string, error) {\n \t}\n \treturn fmt.Sprintf(\"%x\", s.Sum(nil)), nil\n }\n+\n+// extractIP returns the IP portion of the remote address, handling both IPv4 and IPv6 formats.\n+// supports \"ip:port\", \"[ip]:port\", and bare \"ip\" formats.\n+func extractIP(remoteAddr string) string {\n+\tip, _, err := net.SplitHostPort(remoteAddr)\n+\tif err != nil {\n+\t\treturn remoteAddr // already a bare IP (no port)\n+\t}\n+\treturn ip\n+}"
    },
    {
      "sha": "edcf34e7e4edd8971ee5587b5497c762a29ec635",
      "filename": "backend/app/rest/api/rest_private_test.go",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -93,6 +93,7 @@ func TestRest_CreateAndPreviewWithImage(t *testing.T) {\n \t\tRoutePath:     \"/api/v1/img\",\n \t\tRemarkURL:     srv.RemarkURL,\n \t\tImageService:  srv.ImageService,\n+\t\tTransport:     http.DefaultTransport,\n \t}\n \tsrv.CommentFormatter = store.NewCommentFormatter(srv.ImageProxy)\n \t// need to recreate the server with new ImageProxy, otherwise old one will be used\n@@ -1690,3 +1691,26 @@ func (m *mockTelegram) CheckToken(string, string) (telegram, site string, err er\n \t}\n \treturn \"good_telegram\", m.site, nil\n }\n+\n+func TestExtractIP(t *testing.T) {\n+\ttbl := []struct {\n+\t\taddr string\n+\t\texp  string\n+\t}{\n+\t\t{\"127.0.0.1:8080\", \"127.0.0.1\"},\n+\t\t{\"127.0.0.1\", \"127.0.0.1\"},\n+\t\t{\"192.168.1.1:443\", \"192.168.1.1\"},\n+\t\t{\"[::1]:8080\", \"::1\"},\n+\t\t{\"::1\", \"::1\"},\n+\t\t{\"[2001:db8::1]:8080\", \"2001:db8::1\"},\n+\t\t{\"2001:db8::1\", \"2001:db8::1\"},\n+\t\t{\"[fe80::1%25eth0]:80\", \"fe80::1%25eth0\"},\n+\t\t{\"\", \"\"},\n+\t}\n+\n+\tfor _, tt := range tbl {\n+\t\tt.Run(tt.addr, func(t *testing.T) {\n+\t\t\tassert.Equal(t, tt.exp, extractIP(tt.addr))\n+\t\t})\n+\t}\n+}"
    },
    {
      "sha": "b14cf61535d665652a8595631127752e21905a6c",
      "filename": "backend/app/rest/api/rest_public_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_public_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_public_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_public_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -562,8 +562,8 @@ func TestPublic_FindCommentsCtrl_ConsistentCount(t *testing.T) {\n \t\t}\n \t}\n \n-\t// Adding initial comments (8 to test-url and 1 to another-url) and voting, and delete two of comments to the first post.\n-\t// With sleep so that at least few millisecond pass between each comment\n+\t// adding initial comments (8 to test-url and 1 to another-url) and voting, and delete two of comments to the first post.\n+\t// with sleep so that at least few millisecond pass between each comment\n \t// and later we would be able to use that in \"since\" filter with millisecond precision\n \tids := make([]string, 9)\n \ttimestamps := make([]time.Time, 9)"
    },
    {
      "sha": "7dd6698473f50ff5d193758b1bd43f72ca2874ca",
      "filename": "backend/app/rest/api/rest_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -320,7 +320,7 @@ func TestRest_frameAncestors(t *testing.T) {\n \t\to.AllowedAncestors = []string{\"'self'\", \"https://example.com\"}\n \t})\n \n-\t// Test case with frame-ancestors\n+\t// test case with frame-ancestors\n \tclient := http.Client{}\n \tresp, err := client.Get(ts.URL + \"/web/index.html\")\n \trequire.NoError(t, err)\n@@ -329,7 +329,7 @@ func TestRest_frameAncestors(t *testing.T) {\n \tassert.Contains(t, resp.Header.Get(\"Content-Security-Policy\"), \"frame-ancestors 'self' https://example.com;\")\n \tteardown()\n \n-\t// Test case without frame-ancestors\n+\t// test case without frame-ancestors\n \tts, _, teardown = startupT(t, func(srv *Rest) {\n \t\tsrv.AllowedAncestors = []string{}\n \t})"
    },
    {
      "sha": "38bf2f7c9b02e47bd0aa63cdb1d81cb4e9794f44",
      "filename": "backend/app/rest/proxy/image.go",
      "status": "modified",
      "additions": 94,
      "deletions": 7,
      "changes": 101,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fproxy%2Fimage.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fproxy%2Fimage.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fproxy%2Fimage.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -6,6 +6,7 @@ import (\n \t\"encoding/base64\"\n \t\"fmt\"\n \t\"io\"\n+\t\"net\"\n \t\"net/http\"\n \t\"strings\"\n \t\"time\"\n@@ -27,6 +28,7 @@ type Image struct {\n \tCacheExternal bool\n \tTimeout       time.Duration\n \tImageService  *image.Service\n+\tTransport     http.RoundTripper // if nil, uses SSRF-safe transport blocking private IPs\n }\n \n // Convert img src links to proxied links depends on enabled options\n@@ -90,19 +92,20 @@ func (p Image) Handler(w http.ResponseWriter, r *http.Request) {\n \tvar img []byte\n \timgID, err := image.CachedImgID(imgURL)\n \tif err != nil {\n-\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't parse image url \"+imgURL, rest.ErrAssetNotFound)\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"invalid image url\"), \"can't parse image url\", rest.ErrAssetNotFound)\n \t\treturn\n \t}\n \t// try to load from cache for case it was saved when CacheExternal was enabled\n \timg, _ = p.ImageService.Load(imgID)\n \tif img == nil {\n \t\timg, err = p.downloadImage(context.Background(), imgURL)\n \t\tif err != nil {\n+\t\t\tlog.Printf(\"[WARN] failed to download image: %v\", err)\n \t\t\tif strings.Contains(err.Error(), \"invalid content type\") {\n-\t\t\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"invalid content type\", rest.ErrImgNotFound)\n+\t\t\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"invalid content type\"), \"invalid content type\", rest.ErrImgNotFound)\n \t\t\t\treturn\n \t\t\t}\n-\t\t\trest.SendErrorJSON(w, r, http.StatusNotFound, err, \"can't get image \"+imgURL, rest.ErrAssetNotFound)\n+\t\t\trest.SendErrorJSON(w, r, http.StatusNotFound, fmt.Errorf(\"failed to fetch\"), \"can't get image\", rest.ErrAssetNotFound)\n \t\t\treturn\n \t\t}\n \t\tif p.CacheExternal {\n@@ -148,7 +151,14 @@ func (p Image) downloadImage(ctx context.Context, imgURL string) ([]byte, error)\n \tctx, cancel := context.WithTimeout(ctx, timeout)\n \tdefer cancel()\n \n-\tclient := http.Client{Timeout: 30 * time.Second}\n+\ttransport := p.Transport\n+\tif transport == nil {\n+\t\ttransport = ssrfSafeTransport()\n+\t}\n+\tclient := http.Client{\n+\t\tTimeout:   30 * time.Second,\n+\t\tTransport: transport,\n+\t}\n \tdefer client.CloseIdleConnections()\n \tvar resp *http.Response\n \terr := repeater.NewFixed(5, time.Second).Do(ctx, func() error {\n@@ -157,7 +167,7 @@ func (p Image) downloadImage(ctx context.Context, imgURL string) ([]byte, error)\n \t\tif e != nil {\n \t\t\treturn fmt.Errorf(\"failed to make request for %s: %w\", imgURL, e)\n \t\t}\n-\t\tresp, e = client.Do(req.WithContext(ctx)) //nolint:bodyclose // need a refactor to fix that\n+\t\tresp, e = client.Do(req.WithContext(ctx)) //nolint:bodyclose,gosec // body closed in defer; SSRF mitigated by ssrfSafeTransport\n \t\treturn e\n \t})\n \tif err != nil {\n@@ -174,9 +184,86 @@ func (p Image) downloadImage(ctx context.Context, imgURL string) ([]byte, error)\n \t\treturn nil, fmt.Errorf(\"invalid content type %s\", contentType)\n \t}\n \n-\timgData, err := io.ReadAll(resp.Body)\n+\tmaxSize := 5 * 1024 * 1024 // 5MB default\n+\tif p.ImageService != nil && p.ImageService.MaxSize > 0 {\n+\t\tmaxSize = p.ImageService.MaxSize\n+\t}\n+\tlr := io.LimitReader(resp.Body, int64(maxSize)+1)\n+\timgData, err := io.ReadAll(lr)\n \tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"unable to read image body\")\n+\t\treturn nil, fmt.Errorf(\"unable to read image body: %w\", err)\n+\t}\n+\tif len(imgData) > maxSize {\n+\t\treturn nil, fmt.Errorf(\"image is too large\")\n \t}\n \treturn imgData, nil\n }\n+\n+// ssrfSafeTransport returns an http.Transport with a dialer that blocks connections to private IP addresses.\n+// it resolves the host, validates all IPs, then dials using the resolved IP to prevent DNS rebinding attacks.\n+// tries each resolved IP in order to handle dual-stack hosts where the first IP may be unreachable.\n+func ssrfSafeTransport() *http.Transport {\n+\tdialer := &net.Dialer{Timeout: 30 * time.Second}\n+\treturn &http.Transport{\n+\t\tDialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {\n+\t\t\thost, port, err := net.SplitHostPort(addr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid address %s: %w\", addr, err)\n+\t\t\t}\n+\n+\t\t\t// resolve the host to IP addresses\n+\t\t\tips, err := net.DefaultResolver.LookupIPAddr(ctx, host)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"can't resolve host %s: %w\", host, err)\n+\t\t\t}\n+\t\t\tif len(ips) == 0 {\n+\t\t\t\treturn nil, fmt.Errorf(\"no IP addresses resolved for host %s\", host)\n+\t\t\t}\n+\n+\t\t\tfor _, ip := range ips {\n+\t\t\t\tif isPrivateIP(ip.IP) {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"access to private address is not allowed\")\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// try each resolved IP to handle dual-stack hosts where some IPs may be unreachable\n+\t\t\tvar lastErr error\n+\t\t\tfor _, ip := range ips {\n+\t\t\t\tconn, dialErr := dialer.DialContext(ctx, network, net.JoinHostPort(ip.String(), port))\n+\t\t\t\tif dialErr == nil {\n+\t\t\t\t\treturn conn, nil\n+\t\t\t\t}\n+\t\t\t\tlastErr = dialErr\n+\t\t\t}\n+\t\t\treturn nil, fmt.Errorf(\"can't connect to %s: %w\", host, lastErr)\n+\t\t},\n+\t}\n+}\n+\n+// privateCIDRs holds pre-parsed private/reserved CIDR blocks for SSRF protection.\n+var privateCIDRs = func() []*net.IPNet {\n+\tcidrs := []string{\n+\t\t\"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\",\n+\t\t\"100.64.0.0/10\", \"127.0.0.0/8\", \"169.254.0.0/16\",\n+\t\t\"::1/128\", \"fc00::/7\", \"fe80::/10\",\n+\t}\n+\tblocks := make([]*net.IPNet, 0, len(cidrs))\n+\tfor _, cidr := range cidrs {\n+\t\t_, block, _ := net.ParseCIDR(cidr)\n+\t\tblocks = append(blocks, block)\n+\t}\n+\treturn blocks\n+}()\n+\n+// isPrivateIP checks if the given IP belongs to a private/reserved range.\n+func isPrivateIP(ip net.IP) bool {\n+\tif ip.IsUnspecified() {\n+\t\treturn true\n+\t}\n+\tfor _, block := range privateCIDRs {\n+\t\tif block.Contains(ip) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"
    },
    {
      "sha": "1abd54e2dcff39d8124a504a9c3d3ac5be317c9e",
      "filename": "backend/app/rest/proxy/image_test.go",
      "status": "modified",
      "additions": 154,
      "deletions": 2,
      "changes": 156,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fproxy%2Fimage_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Frest%2Fproxy%2Fimage_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fproxy%2Fimage_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -4,6 +4,7 @@ import (\n \t\"encoding/base64\"\n \t\"fmt\"\n \t\"io\"\n+\t\"net\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n \t\"strconv\"\n@@ -100,6 +101,7 @@ func TestImage_Routes(t *testing.T) {\n \t\tRemarkURL:    \"https://demo.remark42.com\",\n \t\tRoutePath:    \"/api/v1/proxy\",\n \t\tImageService: image.NewService(&imageStore, image.ServiceParams{}),\n+\t\tTransport:    http.DefaultTransport,\n \t}\n \n \tts := httptest.NewServer(http.HandlerFunc(img.Handler))\n@@ -150,6 +152,7 @@ func TestImage_DisabledCachingAndHTTP2HTTPS(t *testing.T) {\n \t\tRemarkURL:    \"https://demo.remark42.com\",\n \t\tRoutePath:    \"/api/v1/proxy\",\n \t\tImageService: image.NewService(&imageStore, image.ServiceParams{}),\n+\t\tTransport:    http.DefaultTransport,\n \t}\n \n \tts := httptest.NewServer(http.HandlerFunc(img.Handler))\n@@ -183,6 +186,7 @@ func TestImage_RoutesCachingImage(t *testing.T) {\n \t\tRemarkURL:     \"https://demo.remark42.com\",\n \t\tRoutePath:     \"/api/v1/proxy\",\n \t\tImageService:  image.NewService(&imageStore, image.ServiceParams{MaxSize: 1500}),\n+\t\tTransport:     http.DefaultTransport,\n \t}\n \n \tts := httptest.NewServer(http.HandlerFunc(img.Handler))\n@@ -207,7 +211,7 @@ func TestImage_RoutesCachingImage(t *testing.T) {\n }\n \n func TestImage_RoutesUsingCachedImage(t *testing.T) {\n-\t// In order to validate that cached data used cache \"will return\" some other data from what http server would\n+\t// in order to validate that cached data used cache \"will return\" some other data from what http server would\n \ttestImage := []byte(fmt.Sprintf(\"%256s\", \"X\"))\n \timageStore := image.StoreMock{LoadFunc: func(string) ([]byte, error) {\n \t\treturn testImage, nil\n@@ -246,6 +250,7 @@ func TestImage_RoutesTimedOut(t *testing.T) {\n \t\tRoutePath:    \"/api/v1/proxy\",\n \t\tTimeout:      50 * time.Millisecond,\n \t\tImageService: image.NewService(&imageStore, image.ServiceParams{}),\n+\t\tTransport:    http.DefaultTransport,\n \t}\n \n \tts := httptest.NewServer(http.HandlerFunc(img.Handler))\n@@ -262,7 +267,8 @@ func TestImage_RoutesTimedOut(t *testing.T) {\n \tassert.NoError(t, resp.Body.Close())\n \trequire.NoError(t, err)\n \tt.Log(string(b))\n-\tassert.Contains(t, string(b), \"deadline exceeded\")\n+\tassert.Contains(t, string(b), \"failed to fetch\")\n+\tassert.NotContains(t, string(b), \"deadline exceeded\", \"should not leak transport details\")\n \tassert.Equal(t, 1, len(imageStore.LoadCalls()))\n }\n \n@@ -304,6 +310,152 @@ func TestImage_ConvertCachingMode(t *testing.T) {\n \tassert.Equal(t, `<img src=\"https://remark42.com/img?src=aHR0cDovL3JhZGlvLXQuY29tL2ltZzMucG5n\"/> xyz <img src=\"https://remark42.com/img?src=aHR0cDovL2ltYWdlcy5wZXhlbHMuY29tLzY3NjM2L2ltZzQuanBlZw==\">`, r)\n }\n \n+func TestImage_PrivateIPBlocking(t *testing.T) {\n+\timageStore := image.StoreMock{LoadFunc: func(string) ([]byte, error) { return nil, nil }}\n+\timg := Image{\n+\t\tHTTP2HTTPS:   true,\n+\t\tRemarkURL:    \"https://demo.remark42.com\",\n+\t\tRoutePath:    \"/api/v1/proxy\",\n+\t\tTimeout:      100 * time.Millisecond,\n+\t\tImageService: image.NewService(&imageStore, image.ServiceParams{}),\n+\t\t// no Transport override — uses SSRF-safe transport\n+\t}\n+\n+\tts := httptest.NewServer(http.HandlerFunc(img.Handler))\n+\tdefer ts.Close()\n+\n+\ttbl := []struct {\n+\t\tname string\n+\t\turl  string\n+\t}{\n+\t\t{\"loopback\", \"http://127.0.0.1/image.png\"},\n+\t\t{\"rfc1918 10.x\", \"http://10.0.0.1/image.png\"},\n+\t\t{\"rfc1918 172.16.x\", \"http://172.16.0.1/image.png\"},\n+\t\t{\"rfc1918 192.168.x\", \"http://192.168.1.1/image.png\"},\n+\t\t{\"link-local\", \"http://169.254.1.1/image.png\"},\n+\t\t{\"ipv6 loopback\", \"http://[::1]/image.png\"},\n+\t}\n+\n+\tfor _, tt := range tbl {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tencodedImgURL := base64.URLEncoding.EncodeToString([]byte(tt.url))\n+\t\t\tresp, err := http.Get(ts.URL + \"/?src=\" + encodedImgURL)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tb, err := io.ReadAll(resp.Body)\n+\t\t\tassert.NoError(t, resp.Body.Close())\n+\t\t\trequire.NoError(t, err)\n+\t\t\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n+\t\t\tassert.NotContains(t, string(b), \"private address\", \"should not leak private IP check details\")\n+\t\t\tassert.Contains(t, string(b), \"failed to fetch\")\n+\t\t})\n+\t}\n+}\n+\n+func TestImage_ErrorSanitization(t *testing.T) {\n+\t// server that immediately closes connections to simulate transport errors\n+\thttpSrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n+\t\thj, ok := w.(http.Hijacker)\n+\t\tif !ok {\n+\t\t\tw.WriteHeader(http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tconn, _, _ := hj.Hijack()\n+\t\tconn.Close() // forcefully close to trigger transport error\n+\t}))\n+\tdefer httpSrv.Close()\n+\n+\timageStore := image.StoreMock{LoadFunc: func(string) ([]byte, error) { return nil, nil }}\n+\timg := Image{\n+\t\tRemarkURL:    \"https://demo.remark42.com\",\n+\t\tRoutePath:    \"/api/v1/proxy\",\n+\t\tTimeout:      2 * time.Second,\n+\t\tImageService: image.NewService(&imageStore, image.ServiceParams{}),\n+\t\tTransport:    http.DefaultTransport,\n+\t}\n+\n+\tts := httptest.NewServer(http.HandlerFunc(img.Handler))\n+\tdefer ts.Close()\n+\n+\tencodedImgURL := base64.URLEncoding.EncodeToString([]byte(httpSrv.URL + \"/image.png\"))\n+\tresp, err := http.Get(ts.URL + \"/?src=\" + encodedImgURL)\n+\trequire.NoError(t, err)\n+\tb, err := io.ReadAll(resp.Body)\n+\tassert.NoError(t, resp.Body.Close())\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n+\tassert.Contains(t, string(b), \"failed to fetch\")\n+\tassert.NotContains(t, string(b), \"EOF\", \"should not leak transport details\")\n+\tassert.NotContains(t, string(b), \"connection\", \"should not leak transport details\")\n+}\n+\n+func TestImage_ResponseSizeLimit(t *testing.T) {\n+\t// create a test server that returns a large image\n+\tlargeImg := make([]byte, 2000)\n+\tfor i := range largeImg {\n+\t\tlargeImg[i] = 0xFF\n+\t}\n+\thttpSrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"image/png\")\n+\t\t_, _ = w.Write(largeImg)\n+\t}))\n+\tdefer httpSrv.Close()\n+\n+\timageStore := image.StoreMock{LoadFunc: func(string) ([]byte, error) { return nil, nil }}\n+\timg := Image{\n+\t\tRemarkURL:    \"https://demo.remark42.com\",\n+\t\tRoutePath:    \"/api/v1/proxy\",\n+\t\tImageService: image.NewService(&imageStore, image.ServiceParams{MaxSize: 1000}),\n+\t\tTransport:    http.DefaultTransport,\n+\t}\n+\n+\tts := httptest.NewServer(http.HandlerFunc(img.Handler))\n+\tdefer ts.Close()\n+\n+\tencodedImgURL := base64.URLEncoding.EncodeToString([]byte(httpSrv.URL + \"/big-image.png\"))\n+\tresp, err := http.Get(ts.URL + \"/?src=\" + encodedImgURL)\n+\trequire.NoError(t, err)\n+\tb, err := io.ReadAll(resp.Body)\n+\tassert.NoError(t, resp.Body.Close())\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n+\tassert.Contains(t, string(b), \"failed to fetch\")\n+}\n+\n+func TestIsPrivateIP(t *testing.T) {\n+\ttbl := []struct {\n+\t\tip      string\n+\t\tprivate bool\n+\t}{\n+\t\t{\"127.0.0.1\", true},\n+\t\t{\"10.0.0.1\", true},\n+\t\t{\"10.255.255.255\", true},\n+\t\t{\"172.16.0.1\", true},\n+\t\t{\"172.31.255.255\", true},\n+\t\t{\"192.168.0.1\", true},\n+\t\t{\"192.168.255.255\", true},\n+\t\t{\"169.254.1.1\", true},\n+\t\t{\"100.64.0.1\", true},\n+\t\t{\"100.127.255.255\", true},\n+\t\t{\"::1\", true},\n+\t\t{\"fc00::1\", true},\n+\t\t{\"fe80::1\", true},\n+\t\t{\"0.0.0.0\", true},\n+\t\t{\"::\", true},\n+\t\t{\"8.8.8.8\", false},\n+\t\t{\"203.0.113.1\", false},\n+\t\t{\"1.1.1.1\", false},\n+\t\t{\"2001:db8::1\", false},\n+\t}\n+\n+\tfor _, tt := range tbl {\n+\t\tt.Run(tt.ip, func(t *testing.T) {\n+\t\t\tip := net.ParseIP(tt.ip)\n+\t\t\trequire.NotNil(t, ip)\n+\t\t\tassert.Equal(t, tt.private, isPrivateIP(ip))\n+\t\t})\n+\t}\n+}\n+\n func imgHTTPTestsServer(t *testing.T) *httptest.Server {\n \tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n \t\tif r.URL.Path == \"/image/img1.png\" {"
    },
    {
      "sha": "8a5b89fdfe71678b3e1acb06ccba423161350c8a",
      "filename": "backend/app/store/comment.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fcomment.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fcomment.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fcomment.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -157,7 +157,7 @@ func (c *Comment) Snippet(limit int) string {\n \t\t\tbreak\n \t\t}\n \t}\n-\t// Don't add a space if comment is just a one single word which has been truncated.\n+\t// don't add a space if comment is just a one single word which has been truncated.\n \tif len(snippet) == limit {\n \t\treturn string(snippet) + \"...\"\n \t}"
    },
    {
      "sha": "ea049b549fee32a83a6332dbbcc50d86d948f7b3",
      "filename": "backend/app/store/engine/engine_mock.go",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fengine%2Fengine_mock.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fengine%2Fengine_mock.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fengine%2Fengine_mock.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -4,8 +4,9 @@\n package engine\n \n import (\n-\tstore \"github.com/umputun/remark42/backend/app/store\"\n \t\"sync\"\n+\n+\tstore \"github.com/umputun/remark42/backend/app/store\"\n )\n \n // Ensure, that InterfaceMock does implement Interface."
    },
    {
      "sha": "c307be0d7f4aeaeeeb5fbc7989e0d0aca6c0cacf",
      "filename": "backend/app/store/image/image.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fimage%2Fimage.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fimage%2Fimage.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fimage%2Fimage.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -13,6 +13,7 @@ import (\n \t\"encoding/base64\"\n \t\"fmt\"\n \t\"image\"\n+\n \t// support gif and jpeg images decoding\n \t_ \"image/gif\"\n \t_ \"image/jpeg\""
    },
    {
      "sha": "30b995d8c9f47ad7fb8f8fcd6ecefe1fa23fb69f",
      "filename": "backend/app/store/image/image_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fimage%2Fimage_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fimage%2Fimage_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fimage%2Fimage_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -56,10 +56,10 @@ func TestService_ResizeJpeg(t *testing.T) {\n \n \timg, err := readAndValidateImage(fh, 32000)\n \tassert.NoError(t, err)\n-\tassert.Equal(t, 16756, len(img))\n+\tassert.InDelta(t, 16756, len(img), 100)\n \n \timg = resize(img, 400, 300)\n-\tassert.Equal(t, 10918, len(img))\n+\tassert.InDelta(t, 10913, len(img), 100)\n }\n \n func TestService_SaveTooLarge(t *testing.T) {"
    },
    {
      "sha": "c3f0b09e329084f11705ac5b21407510ae688544",
      "filename": "backend/app/store/service/service.go",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fservice%2Fservice.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fservice%2Fservice.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Fservice.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -552,9 +552,9 @@ func (s *DataStore) HasReplies(comment store.Comment) bool {\n \tfor _, c := range comments {\n \t\tif c.ParentID != \"\" && !c.Deleted {\n \t\t\tif c.ParentID == comment.ID {\n-\t\t\t\t// When this code is reached, key \"comment.ID\" is not in cache.\n-\t\t\t\t// Calling cache.Get on it will put it in cache with 5 minutes TTL.\n-\t\t\t\t// We call it with empty struct as value as we care about keys and not values.\n+\t\t\t\t// when this code is reached, key \"comment.ID\" is not in cache.\n+\t\t\t\t// calling cache.Get on it will put it in cache with 5 minutes TTL.\n+\t\t\t\t// we call it with empty struct as value as we care about keys and not values.\n \t\t\t\t_, _ = s.repliesCache.Get(comment.ID, func() (struct{}, error) { return struct{}{}, nil })\n \t\t\t\treturn true\n \t\t\t}\n@@ -611,7 +611,7 @@ func (s *DataStore) SetTitle(locator store.Locator, commentID string) (comment s\n \t// set title, overwrite the current one\n \ttitle, e := s.TitleExtractor.Get(comment.Locator.URL)\n \tif e != nil {\n-\t\treturn comment, err\n+\t\treturn comment, e\n \t}\n \tcomment.PostTitle = title\n \tcomment.Locator = locator\n@@ -743,7 +743,7 @@ func (s *DataStore) SetBlock(siteID, userID string, status bool, ttl time.Durati\n func (s *DataStore) BlockedUsers(siteID string) (res []store.BlockedUser, err error) {\n \tblocked, e := s.Engine.ListFlags(engine.FlagRequest{Locator: store.Locator{SiteID: siteID}, Flag: engine.Blocked})\n \tif e != nil {\n-\t\treturn nil, fmt.Errorf(\"can't get list of blocked users for %s: %w\", siteID, err)\n+\t\treturn nil, fmt.Errorf(\"can't get list of blocked users for %s: %w\", siteID, e)\n \t}\n \tfor _, v := range blocked {\n \t\tres = append(res, v.(store.BlockedUser))\n@@ -801,7 +801,7 @@ func (s *DataStore) Delete(locator store.Locator, commentID string, mode store.D\n \tidsFn := func() []string { // get IDs of all images from the same URL to verify if image from deleted comment was reused\n \t\tcomments, e := s.Engine.Find(engine.FindRequest{Locator: locator})\n \t\tif e != nil {\n-\t\t\tlog.Printf(\"[WARN] can't get comments %s text for deleted comment image check, %v\", comment.ID, err)\n+\t\t\tlog.Printf(\"[WARN] can't get comments %s text for deleted comment image check, %v\", comment.ID, e)\n \t\t\treturn nil\n \t\t}\n \t\tvar imgIDs = []string{}\n@@ -822,7 +822,7 @@ func (s *DataStore) Delete(locator store.Locator, commentID string, mode store.D\n \t\t\t}\n \t\t}\n \t}\n-\tlog.Printf(\"[ERROR] commentImgIDs: %v, pageImgIDs: %v\", commentImgIDs, pageImgIDs)\n+\tlog.Printf(\"[DEBUG] commentImgIDs: %v, pageImgIDs: %v\", commentImgIDs, pageImgIDs)\n \n \treq := engine.DeleteRequest{Locator: locator, CommentID: commentID, DeleteMode: mode}\n \treturn s.Engine.Delete(req)"
    },
    {
      "sha": "1b9faa89a3f74918f9630eb69ad443057f92577d",
      "filename": "backend/app/store/service/service_test.go",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fservice%2Fservice_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fservice%2Fservice_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Fservice_test.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -642,15 +642,15 @@ func TestDataStore_AdminStoreErrors(t *testing.T) {\n \t\tUser:      store.User{ID: \"user2\", Name: \"user name 2\"},\n \t}\n \n-\t// Key call error\n+\t// key call error\n \tid, err := b.Create(comment)\n \tassert.ErrorContainsf(t, err, \"mock key err\", \"should fail with mock error\")\n \tassert.Empty(t, id)\n \tassert.Equal(t, len(as.KeyCalls()), 1)\n \tassert.Equal(t, len(as.EnabledCalls()), 0)\n \tassert.Equal(t, len(as.OnEventCalls()), 0)\n \n-\t// Enabled call error\n+\t// enabled call error\n \tbadKey = false\n \tid, err = b.Create(comment)\n \tassert.ErrorContains(t, err, \"mock enabled err\", \"should fail with mock error\")\n@@ -676,7 +676,7 @@ func TestDataStore_AdminStoreErrors(t *testing.T) {\n \tassert.Equal(t, len(as.EnabledCalls()), 3)\n \tassert.Equal(t, len(as.OnEventCalls()), 2)\n \n-\t// Admins error\n+\t// admins error\n \tisAdmin := b.IsAdmin(\"radio-t\", \"user2\")\n \tassert.False(t, isAdmin)\n \tassert.Equal(t, len(as.AdminsCalls()), 1)\n@@ -1808,7 +1808,7 @@ func TestService_ResubmitStagingImages_EngineError(t *testing.T) {\n \tsite2Req := engine.FindRequest{Locator: store.Locator{SiteID: \"site2\", URL: \"\"}, Sort: \"time\", Since: time.Time{}.Add(time.Second)}\n \tb := DataStore{Engine: &engineMock, EditDuration: 10 * time.Millisecond, ImageService: imgSvc}\n \n-\t// One call without error and one with error\n+\t// one call without error and one with error\n \terr := b.ResubmitStagingImages([]string{\"site1\", \"site2\"})\n \tassert.Error(t, err)\n \tassert.Contains(t, err.Error(), \"problem finding comments for site site2: mockError\")"
    },
    {
      "sha": "18dff8402915b680534cd3315ed2df8b4ae9dcb2",
      "filename": "backend/app/store/service/tree.go",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fservice%2Ftree.go",
      "raw_url": "https://github.com/umputun/remark42/raw/aca0cff39925ae520d8b949b995724aff1a4e00b/backend%2Fapp%2Fstore%2Fservice%2Ftree.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Ftree.go?ref=aca0cff39925ae520d8b949b995724aff1a4e00b",
      "patch": "@@ -185,7 +185,7 @@ func (t *Tree) limit(limit int, offsetID string) {\n \t\t}\n \t}\n \n-\tif start == len(t.Nodes) { // If the start index is beyond the available nodes, clear the nodes\n+\tif start == len(t.Nodes) { // if the start index is beyond the available nodes, clear the nodes\n \t\tt.Nodes = []*Node{}\n \t\treturn\n \t}\n@@ -198,28 +198,28 @@ func (t *Tree) limit(limit int, offsetID string) {\n \t\treturn\n \t}\n \n-\t// Traverse and limit the number of top-level nodes, including their replies\n+\t// traverse and limit the number of top-level nodes, including their replies\n \tlimitedNodes := []*Node{}\n \tcommentsCount := 0\n \n \tfor _, node := range t.Nodes {\n-\t\trepliesCount := countReplies(node) + 1 // Count this node and its replies\n+\t\trepliesCount := countReplies(node) + 1 // count this node and its replies\n \n-\t\t// If the limit is already reached or exceeded, calculate countLeft and move to the next node\n+\t\t// if the limit is already reached or exceeded, calculate countLeft and move to the next node\n \t\tif commentsCount >= limit {\n \t\t\tt.countLeft += repliesCount\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Check if we just exceeded the limit and there are already some nodes in the list,\n+\t\t// check if we just exceeded the limit and there are already some nodes in the list,\n \t\t// as otherwise we would have to return the first node with all its replies even if it exceeds the limit.\n \t\tif commentsCount+repliesCount >= limit && len(limitedNodes) > 0 {\n \t\t\tt.countLeft += repliesCount\n-\t\t\tcommentsCount = limit // Adjust commentsCount to stop checking limit for the next nodes\n+\t\t\tcommentsCount = limit // adjust commentsCount to stop checking limit for the next nodes\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Add the node and its replies to the list\n+\t\t// add the node and its replies to the list\n \t\tlimitedNodes = append(limitedNodes, node)\n \t\tcommentsCount += repliesCount\n \t}\n@@ -232,8 +232,8 @@ func (t *Tree) limit(limit int, offsetID string) {\n func countReplies(node *Node) int {\n \tcount := 0\n \tfor _, reply := range node.Replies {\n-\t\tcount++                      // Count the reply itself\n-\t\tcount += countReplies(reply) // Recursively count its replies\n+\t\tcount++                      // count the reply itself\n+\t\tcount += countReplies(reply) // recursively count its replies\n \t}\n \treturn count\n }"
    }
  ]
}
