{
  "sha": "ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
  "node_id": "C_kwDOCQOkhNoAKGVjMGVmMTJiMGVlNmExMTlhZWE3OGE2ZDA5MzBlMGQ5ODYzYmZkMTQ",
  "commit": {
    "author": {
      "name": "qwqcode",
      "email": "22412567+qwqcode@users.noreply.github.com",
      "date": "2023-09-21T13:48:56Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2023-09-21T13:48:56Z"
    },
    "message": "refactor(anti_spam): refactor anti_spam pkg and add unit test (#589)\n\n* refactor(anti_spam): refactor anti_spam pkg and add unit test\r\n\r\n* add more test",
    "tree": {
      "sha": "a9533e940e4952c6232ecb998c2c3d312669bfbb",
      "url": "https://api.github.com/repos/ArtalkJS/Artalk/git/trees/a9533e940e4952c6232ecb998c2c3d312669bfbb"
    },
    "url": "https://api.github.com/repos/ArtalkJS/Artalk/git/commits/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJlDEnICRBK7hj4Ov3rIwAA4V4IAKNsLtKWVJCatJ41FsXFn4N9\nYG3BG3v8+jVbOPKcqGwOtri1ErZGT70aR/E50MTrniEgUKlZygyPFxIaEtieShaY\nQdvTxipuZ+fMxXqpalWsNBXU7SBLf1pQkDQ+wF5G2Fb6Hfj4HZB3ZWpUWrYHNab+\ntGPUTo5hjPjjfVzMMouLVj5XvLlF4eS/baJKJxToCaBuAI4aj7HJgEJphnxsWTVO\nf94G4MTsdl5AC9PnQrli1Z5AdoHrQhl3Sg+g+LMOPzRsvKJpP1w2Kw0oolWiIWmD\n3xKLPnLlP24X8GQ0c6bGK4K2Aha4M4/PaT1HkImAqQcDz5Df9Rm2FKPGMgtaUsU=\n=E7iM\n-----END PGP SIGNATURE-----\n",
      "payload": "tree a9533e940e4952c6232ecb998c2c3d312669bfbb\nparent 5d2950f842dd3f00b6866ff6128fa57274cac4a8\nauthor qwqcode <22412567+qwqcode@users.noreply.github.com> 1695304136 +0800\ncommitter GitHub <noreply@github.com> 1695304136 +0800\n\nrefactor(anti_spam): refactor anti_spam pkg and add unit test (#589)\n\n* refactor(anti_spam): refactor anti_spam pkg and add unit test\r\n\r\n* add more test"
    }
  },
  "url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
  "html_url": "https://github.com/ArtalkJS/Artalk/commit/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
  "comments_url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/comments",
  "author": {
    "login": "qwqcode",
    "id": 22412567,
    "node_id": "MDQ6VXNlcjIyNDEyNTY3",
    "avatar_url": "https://avatars.githubusercontent.com/u/22412567?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/qwqcode",
    "html_url": "https://github.com/qwqcode",
    "followers_url": "https://api.github.com/users/qwqcode/followers",
    "following_url": "https://api.github.com/users/qwqcode/following{/other_user}",
    "gists_url": "https://api.github.com/users/qwqcode/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/qwqcode/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/qwqcode/subscriptions",
    "organizations_url": "https://api.github.com/users/qwqcode/orgs",
    "repos_url": "https://api.github.com/users/qwqcode/repos",
    "events_url": "https://api.github.com/users/qwqcode/events{/privacy}",
    "received_events_url": "https://api.github.com/users/qwqcode/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5d2950f842dd3f00b6866ff6128fa57274cac4a8",
      "url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/5d2950f842dd3f00b6866ff6128fa57274cac4a8",
      "html_url": "https://github.com/ArtalkJS/Artalk/commit/5d2950f842dd3f00b6866ff6128fa57274cac4a8"
    }
  ],
  "stats": {
    "total": 657,
    "additions": 485,
    "deletions": 172
  },
  "files": [
    {
      "sha": "4050f87aa3071d56a8053a60a70efd1bbb57922a",
      "filename": "internal/anti_spam/base.go",
      "status": "modified",
      "additions": 123,
      "deletions": 16,
      "changes": 139,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fbase.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fbase.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fanti_spam%2Fbase.go?ref=ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
      "patch": "@@ -1,42 +1,149 @@\n package anti_spam\n \n import (\n+\t\"fmt\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n \t\"github.com/ArtalkJS/Artalk/internal/config\"\n-\t\"github.com/ArtalkJS/Artalk/internal/dao\"\n-\t\"github.com/ArtalkJS/Artalk/internal/entity\"\n+\t\"github.com/ArtalkJS/Artalk/internal/log\"\n+\t\"github.com/samber/lo\"\n )\n \n-const LOG_TAG = \"[Spam Interception]\"\n+const LOG_TAG = \"[AntiSpam]\"\n+\n+// -------------------------------------------------------------------\n+//  AntiSpam\n+// -------------------------------------------------------------------\n \n type AntiSpamConf struct {\n \tconfig.ModeratorConf\n-\tDao *dao.Dao\n+\n+\tOnBlockComment  func(commentID uint)\n+\tOnUpdateComment func(commentID uint, content string)\n }\n \n type AntiSpam struct {\n \tconf *AntiSpamConf\n-\tdao  *dao.Dao\n }\n \n+// Create new AntiSpam instance\n func NewAntiSpam(conf *AntiSpamConf) *AntiSpam {\n \treturn &AntiSpam{\n \t\tconf: conf,\n-\t\tdao:  conf.Dao,\n \t}\n }\n \n-type CheckData struct {\n-\tComment      *entity.Comment\n-\tReqReferer   string\n-\tReqIP        string\n-\tReqUserAgent string\n-}\n-\n-func (as AntiSpam) CheckAndBlock(data *CheckData) {\n+// Check and block comment if it is spam,\n+// the function is exposed and can be called by other modules\n+func (as AntiSpam) CheckAndBlock(params *CheckerParams) {\n \tcheckers := as.getEnabledCheckers()\n \n-\t// 执行检查\n+\t// Execute check one by one\n+\t// Multiple checkers can be enabled at the same time\n+\t// If one of the checkers returns false, the comment will be blocked\n \tfor _, checker := range checkers {\n-\t\tas.checkerTrigger(checker, data)\n+\t\tpass := as.checkerTrigger(checker, params)\n+\n+\t\tif !pass {\n+\t\t\treturn // if blocked, stop checking\n+\t\t}\n+\t}\n+}\n+\n+// Checker trigger function\n+func (as AntiSpam) checkerTrigger(checker Checker, params *CheckerParams) bool {\n+\tpass, err := checker.Check(params)\n+\n+\tif err != nil {\n+\t\tlog.Error(LOG_TAG, fmt.Sprintf(\"%s checker comment=%d error:\",\n+\t\t\tchecker.Name(), params.CommentID), err)\n+\n+\t\tpass = lo.If(as.conf.ApiFailBlock, false).Else(true) // block if api fail\n+\t}\n+\n+\tif !pass {\n+\t\tif as.conf.OnBlockComment != nil {\n+\t\t\tas.conf.OnBlockComment(params.CommentID)\n+\t\t}\n+\n+\t\tlog.Debug(LOG_TAG, fmt.Sprintf(\"[%s] Successful blocking of comments ID=%d CONT=%s\",\n+\t\t\tchecker.Name(), params.CommentID, strconv.Quote(params.Content)))\n+\t}\n+\n+\treturn pass\n+}\n+\n+// Get enabled checkers by config\n+func (as AntiSpam) getEnabledCheckers() []Checker {\n+\tcheckers := []Checker{}\n+\n+\t// Akismet\n+\takismetKey := strings.TrimSpace(as.conf.AkismetKey)\n+\tif akismetKey != \"\" {\n+\t\tcheckers = append(checkers, NewAkismetChecker(akismetKey))\n+\t}\n+\n+\t// Tencent Cloud\n+\ttencentConf := as.conf.Tencent\n+\tif tencentConf.Enabled {\n+\t\tcheckers = append(checkers, NewTencentChecker(\n+\t\t\ttencentConf.SecretID, tencentConf.SecretKey, tencentConf.Region))\n+\t}\n+\n+\t// Aliyun\n+\taliyunConf := as.conf.Aliyun\n+\tif aliyunConf.Enabled {\n+\t\tcheckers = append(checkers, NewAliyunChecker(\n+\t\t\taliyunConf.AccessKeyID, aliyunConf.AccessKeySecret, aliyunConf.Region))\n+\t}\n+\n+\t// Keywords Checker\n+\tkeywordsConf := as.conf.Keywords\n+\tif keywordsConf.Enabled {\n+\n+\t\tvar kwCheckerMode KwCheckerMode\n+\t\tif as.conf.Keywords.Pending {\n+\t\t\tkwCheckerMode = KwCheckerModeBlock\n+\t\t} else {\n+\t\t\tkwCheckerMode = KwCheckerModeReplace\n+\t\t}\n+\n+\t\tcheckers = append(checkers, NewKeywordsChecker(&KeywordsCheckerConf{\n+\t\t\tFiles:     as.conf.Keywords.Files,\n+\t\t\tFileSep:   as.conf.Keywords.FileSep,\n+\t\t\tReplaceTo: as.conf.Keywords.ReplacTo,\n+\t\t\tMode:      kwCheckerMode,\n+\t\t\tOnUpdateComment: func(commentID uint, content string) {\n+\t\t\t\tif as.conf.OnUpdateComment != nil {\n+\t\t\t\t\tas.conf.OnUpdateComment(commentID, content)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t}))\n+\n \t}\n+\n+\treturn checkers\n+}\n+\n+// -------------------------------------------------------------------\n+//  Checker\n+// -------------------------------------------------------------------\n+\n+type CheckerParams struct {\n+\tBlogURL string\n+\n+\tContent   string\n+\tCommentID uint\n+\n+\tUserName  string\n+\tUserEmail string\n+\tUserID    uint\n+\tUserIP    string\n+\tUserAgent string\n+}\n+\n+type Checker interface {\n+\tName() string\n+\tCheck(p *CheckerParams) (bool, error)\n }"
    },
    {
      "sha": "6e505dc811b0cf5f107076e333176d8479516a75",
      "filename": "internal/anti_spam/base_test.go",
      "status": "added",
      "additions": 169,
      "deletions": 0,
      "changes": 169,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fbase_test.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fbase_test.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fanti_spam%2Fbase_test.go?ref=ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
      "patch": "@@ -0,0 +1,169 @@\n+package anti_spam\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+\n+\t\"github.com/ArtalkJS/Artalk/internal/config\"\n+\t\"github.com/samber/lo\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestAntiSpam(t *testing.T) {\n+\tt.Run(\"NewAntiSpam\", func(t *testing.T) {\n+\t\tantiSpam := NewAntiSpam(&AntiSpamConf{\n+\t\t\tModeratorConf: config.ModeratorConf{\n+\t\t\t\tAkismetKey: \"test\",\n+\t\t\t\tTencent: config.TencentAntispamConf{\n+\t\t\t\t\tEnabled: true,\n+\t\t\t\t},\n+\t\t\t\tAliyun: config.AliyunAntispamConf{\n+\t\t\t\t\tEnabled: true,\n+\t\t\t\t},\n+\t\t\t\tKeywords: config.KeyWordsAntispamConf{\n+\t\t\t\t\tEnabled: true,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\n+\t\tcheckers := antiSpam.getEnabledCheckers()\n+\n+\t\tcheckerNames := lo.Map[Checker, string](checkers, func(item Checker, index int) string {\n+\t\t\treturn item.Name()\n+\t\t})\n+\t\texpectedCheckers := []string{\"akismet\", \"tencent\", \"aliyun\", \"keywords\"}\n+\n+\t\tfor _, expect := range expectedCheckers {\n+\t\t\tassert.Contains(t, checkerNames, expect, \"expected %s in %v\", expect, checkerNames)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"CheckAndBlock by KeywordsChecker\", func(t *testing.T) {\n+\t\tkwFile1 := fmt.Sprintf(\"%s/keywords_1.txt\", t.TempDir())\n+\t\t_ = os.WriteFile(kwFile1, []byte(\"关键词A\\n关键词B\"), 0644)\n+\t\tdefer os.Remove(kwFile1)\n+\n+\t\tgetAntiSpamConf := func() *AntiSpamConf {\n+\t\t\treturn &AntiSpamConf{\n+\t\t\t\tModeratorConf: config.ModeratorConf{\n+\t\t\t\t\tKeywords: config.KeyWordsAntispamConf{\n+\t\t\t\t\t\tEnabled:  true,\n+\t\t\t\t\t\tPending:  false,\n+\t\t\t\t\t\tFiles:    []string{kwFile1},\n+\t\t\t\t\t\tFileSep:  \"\\n\",\n+\t\t\t\t\t\tReplacTo: \"*\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\n+\t\t\t\tOnUpdateComment: func(commentID uint, content string) {\n+\t\t\t\t\tassert.Equal(t, \"---\\n****\\n---\", content)\n+\t\t\t\t},\n+\t\t\t}\n+\t\t}\n+\n+\t\tt.Run(\"OnBlockComment\", func(t *testing.T) {\n+\t\t\tblockedID := 0\n+\t\t\tupdatedID := 0\n+\n+\t\t\tconf := getAntiSpamConf()\n+\t\t\tconf.ModeratorConf.Keywords.Pending = true\n+\n+\t\t\tconf.OnBlockComment = func(commentID uint) {\n+\t\t\t\tblockedID = int(commentID)\n+\t\t\t}\n+\t\t\tconf.OnUpdateComment = func(commentID uint, content string) {\n+\t\t\t\tupdatedID = int(commentID)\n+\t\t\t}\n+\n+\t\t\tantiSpam := NewAntiSpam(conf)\n+\n+\t\t\tantiSpam.CheckAndBlock(&CheckerParams{\n+\t\t\t\tCommentID: 1000,\n+\t\t\t\tContent:   \"---\\n关键词B\\n---\",\n+\t\t\t})\n+\n+\t\t\tassert.Equal(t, 1000, blockedID)\n+\t\t\tassert.Equal(t, 0, updatedID, \"should not update\")\n+\t\t})\n+\n+\t\tt.Run(\"OnUpdateComment\", func(t *testing.T) {\n+\t\t\tblockedID := 0\n+\t\t\tupdatedID := 0\n+\t\t\tupdatedContent := \"\"\n+\n+\t\t\tconf := getAntiSpamConf()\n+\t\t\tconf.ModeratorConf.Keywords.Pending = false\n+\n+\t\t\tconf.OnBlockComment = func(commentID uint) {\n+\t\t\t\tblockedID = int(commentID)\n+\t\t\t}\n+\t\t\tconf.OnUpdateComment = func(commentID uint, content string) {\n+\t\t\t\tupdatedID = int(commentID)\n+\t\t\t\tupdatedContent = content\n+\t\t\t}\n+\n+\t\t\tantiSpam := NewAntiSpam(conf)\n+\n+\t\t\tantiSpam.CheckAndBlock(&CheckerParams{\n+\t\t\t\tCommentID: 1000,\n+\t\t\t\tContent:   \"---\\n关键词B\\n---\",\n+\t\t\t})\n+\n+\t\t\tassert.Equal(t, 0, blockedID, \"should not block\")\n+\t\t\tassert.Equal(t, 1000, updatedID)\n+\t\t\tassert.Equal(t, \"---\\n****\\n---\", updatedContent)\n+\t\t})\n+\t})\n+\n+\tt.Run(\"MockChecker Error Return\", func(t *testing.T) {\n+\t\tt.Run(\"ApiFailBlock=true\", func(t *testing.T) {\n+\t\t\tchecker := &mockChecker{}\n+\t\t\tantiSpam := NewAntiSpam(&AntiSpamConf{\n+\t\t\t\tModeratorConf: config.ModeratorConf{\n+\t\t\t\t\tApiFailBlock: true,\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tmockCheckerErr = true // pretend api fail\n+\t\t\tpass := antiSpam.checkerTrigger(checker, &CheckerParams{})\n+\t\t\tassert.False(t, pass, \"should be blocked when api fail\")\n+\t\t})\n+\n+\t\tt.Run(\"ApiFailBlock=false\", func(t *testing.T) {\n+\t\t\tchecker := &mockChecker{}\n+\t\t\tantiSpam := NewAntiSpam(&AntiSpamConf{\n+\t\t\t\tModeratorConf: config.ModeratorConf{\n+\t\t\t\t\tApiFailBlock: false,\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tmockCheckerErr = true // pretend api fail\n+\t\t\tpass := antiSpam.checkerTrigger(checker, &CheckerParams{})\n+\t\t\tassert.True(t, pass, \"should not be blocked when api fail\")\n+\t\t})\n+\t})\n+}\n+\n+// -------------------------------------------------------------------\n+//  Mock Checker\n+// -------------------------------------------------------------------\n+\n+var mockCheckerErr = false\n+\n+var _ Checker = (*mockChecker)(nil)\n+\n+type mockChecker struct {\n+}\n+\n+func (c *mockChecker) Name() string {\n+\treturn \"test\"\n+}\n+\n+func (c *mockChecker) Check(params *CheckerParams) (bool, error) {\n+\tif mockCheckerErr {\n+\t\treturn false, fmt.Errorf(\"test error\")\n+\t}\n+\n+\treturn true, nil\n+}"
    },
    {
      "sha": "3d9ffd58762734e3c7b843b84fb92b8259dbb6b2",
      "filename": "internal/anti_spam/checker.go",
      "status": "removed",
      "additions": 0,
      "deletions": 21,
      "changes": 21,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/5d2950f842dd3f00b6866ff6128fa57274cac4a8/internal%2Fanti_spam%2Fchecker.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/5d2950f842dd3f00b6866ff6128fa57274cac4a8/internal%2Fanti_spam%2Fchecker.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fanti_spam%2Fchecker.go?ref=5d2950f842dd3f00b6866ff6128fa57274cac4a8",
      "patch": "@@ -1,21 +0,0 @@\n-package anti_spam\n-\n-type CheckerName string\n-\n-type CheckerParams struct {\n-\tBlogURL string\n-\n-\tContent   string\n-\tCommentID uint\n-\n-\tUserName  string\n-\tUserEmail string\n-\tUserID    uint\n-\tUserIP    string\n-\tUserAgent string\n-}\n-\n-type Checker interface {\n-\tName() string\n-\tCheck(p *CheckerParams) (bool, error)\n-}"
    },
    {
      "sha": "f751c4c69d5ab799dd8eee8e53f997375014227a",
      "filename": "internal/anti_spam/keywords.go",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fkeywords.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fkeywords.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fanti_spam%2Fkeywords.go?ref=ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
      "patch": "@@ -25,7 +25,7 @@ type KeywordsCheckerConf struct {\n \tFileSep         string\n \tReplaceTo       string\n \tMode            KwCheckerMode\n-\tOnUpdateComment func(commentID uint, content string) error\n+\tOnUpdateComment func(commentID uint, content string)\n }\n \n type KeywordsChecker struct {\n@@ -45,7 +45,9 @@ func (*KeywordsChecker) Name() string {\n }\n \n func (c *KeywordsChecker) Check(p *CheckerParams) (bool, error) {\n-\tc.loadKeywords()\n+\tif err := c.loadKeywords(); err != nil {\n+\t\treturn false, err\n+\t}\n \n \tisContains := false\n \tcontent := p.Content\n@@ -61,7 +63,8 @@ func (c *KeywordsChecker) Check(p *CheckerParams) (bool, error) {\n \t\t}\n \t}\n \n-\tif c.conf.Mode == KwCheckerModeReplace {\n+\tswitch c.conf.Mode {\n+\tcase KwCheckerModeReplace:\n \t\tif isContains {\n \t\t\tlog.Info(LOG_TAG, fmt.Sprintf(\"keyword replace comment id=%d original=%s processed=%s\",\n \t\t\t\tp.CommentID, strconv.Quote(p.Content), strconv.Quote(content)))\n@@ -73,13 +76,12 @@ func (c *KeywordsChecker) Check(p *CheckerParams) (bool, error) {\n \t\t}\n \n \t\treturn true, nil\n-\t}\n \n-\tif c.conf.Mode == KwCheckerModeBlock {\n+\tcase KwCheckerModeBlock:\n \t\treturn !isContains, nil\n \t}\n \n-\treturn true, nil\n+\treturn false, fmt.Errorf(\"unknown mode: %d\", c.conf.Mode)\n }\n \n func (c *KeywordsChecker) loadKeywords() error {"
    },
    {
      "sha": "939a4cffb8e8816d234d5025e6a673b2cf1e12d6",
      "filename": "internal/anti_spam/keywords_test.go",
      "status": "added",
      "additions": 119,
      "deletions": 0,
      "changes": 119,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fkeywords_test.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fanti_spam%2Fkeywords_test.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fanti_spam%2Fkeywords_test.go?ref=ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
      "patch": "@@ -0,0 +1,119 @@\n+package anti_spam\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestNewKeywordsChecker(t *testing.T) {\n+\tkwFile1 := fmt.Sprintf(\"%s/keywords_1.txt\", t.TempDir())\n+\t_ = os.WriteFile(kwFile1, []byte(\"关键词A\\n关键词B\"), 0644)\n+\tdefer os.Remove(kwFile1)\n+\n+\tkwFile2 := fmt.Sprintf(\"%s/keywords_2.txt\", t.TempDir())\n+\t_ = os.WriteFile(kwFile2, []byte(\"关键词C\\n关键词D\"), 0644)\n+\tdefer os.Remove(kwFile2)\n+\n+\tkwFile3 := fmt.Sprintf(\"%s/keywords_3.txt\", t.TempDir())\n+\t_ = os.WriteFile(kwFile3, []byte(\"关键词E\\n关键词F\"), 0644)\n+\tdefer os.Remove(kwFile3)\n+\n+\tassert.Equal(t, \"keywords\", NewKeywordsChecker(&KeywordsCheckerConf{}).Name())\n+\n+\tt.Run(\"BlockMode\", func(t *testing.T) {\n+\t\tchecker := NewKeywordsChecker(&KeywordsCheckerConf{\n+\t\t\tFiles:     []string{kwFile1, kwFile2},\n+\t\t\tFileSep:   \"\\n\",\n+\t\t\tReplaceTo: \"*\",\n+\t\t\tMode:      KwCheckerModeBlock,\n+\t\t})\n+\n+\t\tt.Run(\"Exist\", func(t *testing.T) {\n+\t\t\tok, err := checker.Check(&CheckerParams{\n+\t\t\t\tContent:   \"dWQDQOIJWO\\nABC关键词CEF\\nABDIWHDUWH\\n\\n\",\n+\t\t\t\tCommentID: 1000,\n+\t\t\t})\n+\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.False(t, ok)\n+\t\t})\n+\n+\t\tt.Run(\"NotExist\", func(t *testing.T) {\n+\t\t\tok, err := checker.Check(&CheckerParams{\n+\t\t\t\tContent:   \"ABCDEFG\\nEWFWEOI\\nWIEEWOIE\\nWDIQJDW\",\n+\t\t\t\tCommentID: 1000,\n+\t\t\t})\n+\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.True(t, ok)\n+\t\t})\n+\t})\n+\n+\tt.Run(\"ReplaceMode\", func(t *testing.T) {\n+\n+\t\tchecker := NewKeywordsChecker(&KeywordsCheckerConf{\n+\t\t\tFiles:     []string{kwFile3},\n+\t\t\tFileSep:   \"\\n\",\n+\t\t\tReplaceTo: \"*\",\n+\t\t\tMode:      KwCheckerModeReplace,\n+\t\t})\n+\n+\t\tt.Run(\"Exist\", func(t *testing.T) {\n+\t\t\tupdated := false\n+\t\t\tupdatedContent := \"\"\n+\t\t\tchecker.conf.OnUpdateComment = func(commentID uint, content string) {\n+\t\t\t\tupdated = true\n+\t\t\t\tupdatedContent = content\n+\t\t\t}\n+\n+\t\t\tok, err := checker.Check(&CheckerParams{\n+\t\t\t\tContent:   \"ABCDEF\\nEWFWEOI\\nWIE关键词EWOIE\\nWDIQJDW\",\n+\t\t\t\tCommentID: 1000,\n+\t\t\t})\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.True(t, ok)\n+\t\t\tassert.True(t, updated)\n+\t\t\tassert.Equal(t, \"ABCDEF\\nEWFWEOI\\nWIE****WOIE\\nWDIQJDW\", updatedContent)\n+\t\t})\n+\n+\t\tt.Run(\"NotExist\", func(t *testing.T) {\n+\t\t\tupdated := false\n+\t\t\tchecker.conf.OnUpdateComment = func(commentID uint, content string) {\n+\t\t\t\tupdated = true\n+\t\t\t}\n+\n+\t\t\tok, err := checker.Check(&CheckerParams{\n+\t\t\t\tContent:   \"ABCDEFG\\nEWFWEOI\\nWIEEWOIE\\nWDIQJDW\",\n+\t\t\t\tCommentID: 1000,\n+\t\t\t})\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.True(t, ok)\n+\t\t\tassert.False(t, updated)\n+\t\t})\n+\t})\n+\n+\tt.Run(\"ErrorLoad\", func(t *testing.T) {\n+\t\tchecker := NewKeywordsChecker(&KeywordsCheckerConf{\n+\t\t\tFiles:   []string{\"not_exist_file\"},\n+\t\t\tFileSep: \"\\n\",\n+\t\t\tMode:    KwCheckerModeBlock,\n+\t\t})\n+\t\tok, err := checker.Check(&CheckerParams{\n+\t\t\tContent: \"ABCDEFG\\nEWFWEOI\\nWIEEWOIE\\nWDIQJDW\",\n+\t\t})\n+\t\tassert.ErrorContains(t, err, \"failed to load\")\n+\t\tassert.False(t, ok)\n+\t})\n+\n+\tt.Run(\"ErrorUnknownMode\", func(t *testing.T) {\n+\t\tchecker := NewKeywordsChecker(&KeywordsCheckerConf{\n+\t\t\tMode: 999,\n+\t\t})\n+\t\tok, err := checker.Check(&CheckerParams{})\n+\t\tassert.ErrorContains(t, err, \"unknown mode\")\n+\t\tassert.False(t, ok)\n+\t})\n+}"
    },
    {
      "sha": "c6cbf98d6862ce6329c77cfaa5ca4eecb5a485dc",
      "filename": "internal/anti_spam/operate.go",
      "status": "removed",
      "additions": 0,
      "deletions": 123,
      "changes": 123,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/5d2950f842dd3f00b6866ff6128fa57274cac4a8/internal%2Fanti_spam%2Foperate.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/5d2950f842dd3f00b6866ff6128fa57274cac4a8/internal%2Fanti_spam%2Foperate.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fanti_spam%2Foperate.go?ref=5d2950f842dd3f00b6866ff6128fa57274cac4a8",
      "patch": "@@ -1,123 +0,0 @@\n-package anti_spam\n-\n-import (\n-\t\"fmt\"\n-\t\"net/url\"\n-\t\"strconv\"\n-\t\"strings\"\n-\n-\t\"github.com/ArtalkJS/Artalk/internal/entity\"\n-\t\"github.com/ArtalkJS/Artalk/internal/log\"\n-)\n-\n-func (as AntiSpam) getEnabledCheckers() []Checker {\n-\tcheckers := []Checker{}\n-\n-\takismetKey := strings.TrimSpace(as.conf.AkismetKey)\n-\tif akismetKey != \"\" {\n-\t\tcheckers = append(checkers, NewAkismetChecker(akismetKey))\n-\t}\n-\n-\t// 腾讯云\n-\ttencentConf := as.conf.Tencent\n-\tif tencentConf.Enabled {\n-\t\tcheckers = append(checkers, NewTencentChecker(\n-\t\t\ttencentConf.SecretID, tencentConf.SecretKey, tencentConf.Region))\n-\t}\n-\n-\t// 阿里云\n-\taliyunConf := as.conf.Aliyun\n-\tif aliyunConf.Enabled {\n-\t\tcheckers = append(checkers, NewAliyunChecker(\n-\t\t\taliyunConf.AccessKeyID, aliyunConf.AccessKeySecret, aliyunConf.Region))\n-\t}\n-\n-\t// 关键字过滤\n-\tkeywordsConf := as.conf.Keywords\n-\tif keywordsConf.Enabled {\n-\n-\t\tvar kwCheckerMode KwCheckerMode\n-\t\tif as.conf.Keywords.Pending {\n-\t\t\tkwCheckerMode = KwCheckerModeBlock\n-\t\t} else {\n-\t\t\tkwCheckerMode = KwCheckerModeReplace\n-\t\t}\n-\n-\t\tcheckers = append(checkers, NewKeywordsChecker(&KeywordsCheckerConf{\n-\t\t\tFiles:     as.conf.Keywords.Files,\n-\t\t\tFileSep:   as.conf.Keywords.FileSep,\n-\t\t\tReplaceTo: as.conf.Keywords.ReplacTo,\n-\t\t\tMode:      kwCheckerMode,\n-\t\t\tOnUpdateComment: func(commentID uint, content string) error {\n-\t\t\t\tcomment := as.dao.FindComment(commentID)\n-\t\t\t\tcomment.Content = content\n-\t\t\t\tas.dao.UpdateComment(&comment)\n-\t\t\t\treturn nil\n-\t\t\t},\n-\t\t}))\n-\n-\t}\n-\n-\treturn checkers\n-}\n-\n-// 拦截评论\n-func (as AntiSpam) blockComment(checker Checker, comment *entity.Comment) {\n-\tlog.Info(LOG_TAG, fmt.Sprintf(\"[%s] Successful blocking of comments ID=%d CONT=%s\",\n-\t\tchecker.Name(), comment.ID, strconv.Quote(comment.Content)))\n-\n-\tif comment.IsPending {\n-\t\treturn\n-\t}\n-\n-\tcomment.IsPending = true // 改为待审状态\n-\tas.dao.UpdateComment(comment)\n-}\n-\n-func (as AntiSpam) getCheckerParams(data *CheckData) *CheckerParams {\n-\tuser := as.dao.FetchUserForComment(data.Comment)\n-\tsiteURL := \"\"\n-\n-\tif data.Comment.SiteName != \"\" {\n-\t\tsite := as.dao.FindSite(data.Comment.SiteName)\n-\t\tsiteURL = as.dao.CookSite(&site).FirstUrl\n-\t}\n-\tif siteURL == \"\" { // 从 referer 中提取网站\n-\t\tif pr, err := url.Parse(data.ReqReferer); err == nil && pr.Scheme != \"\" && pr.Host != \"\" {\n-\t\t\tsiteURL = fmt.Sprintf(\"%s://%s\", pr.Scheme, pr.Host)\n-\t\t}\n-\t}\n-\n-\treturn &CheckerParams{\n-\t\tBlogURL: siteURL,\n-\n-\t\tContent:   data.Comment.Content,\n-\t\tCommentID: data.Comment.ID,\n-\n-\t\tUserName:  user.Name,\n-\t\tUserEmail: user.Email,\n-\t\tUserID:    user.ID,\n-\t\tUserIP:    data.ReqIP,\n-\t\tUserAgent: data.ReqUserAgent,\n-\t}\n-}\n-\n-func (as AntiSpam) checkerTrigger(checker Checker, data *CheckData) {\n-\tparams := as.getCheckerParams(data)\n-\tisPass, err := checker.Check(params)\n-\n-\tif err != nil { // Api 发生错误\n-\t\tlog.Error(LOG_TAG, fmt.Sprintf(\n-\t\t\t\"%s Interception error occurred ID=%d Err:\", checker.Name(), data.Comment.ID), err)\n-\n-\t\tif as.conf.ApiFailBlock {\n-\t\t\tas.blockComment(checker, data.Comment) // 仍然拦截\n-\t\t}\n-\n-\t\treturn\n-\t}\n-\n-\tif !isPass { // not Pass 且 Api 未发生错误\n-\t\tas.blockComment(checker, data.Comment) // 拦截评论\n-\t}\n-}"
    },
    {
      "sha": "b280c6d4f17eea08965ad82e502209e35618bf8d",
      "filename": "internal/core/service_anti_spam.go",
      "status": "modified",
      "additions": 65,
      "deletions": 4,
      "changes": 69,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fcore%2Fservice_anti_spam.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/internal%2Fcore%2Fservice_anti_spam.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fcore%2Fservice_anti_spam.go?ref=ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
      "patch": "@@ -1,6 +1,12 @@\n package core\n \n-import \"github.com/ArtalkJS/Artalk/internal/anti_spam\"\n+import (\n+\t\"fmt\"\n+\t\"net/url\"\n+\n+\t\"github.com/ArtalkJS/Artalk/internal/anti_spam\"\n+\t\"github.com/ArtalkJS/Artalk/internal/entity\"\n+)\n \n var _ Service = (*AntiSpamService)(nil)\n \n@@ -16,7 +22,21 @@ func NewAntiSpamService(app *App) *AntiSpamService {\n func (s *AntiSpamService) Init() error {\n \ts.client = anti_spam.NewAntiSpam(&anti_spam.AntiSpamConf{\n \t\tModeratorConf: s.app.Conf().Moderator,\n-\t\tDao:           s.app.Dao(),\n+\t\tOnBlockComment: func(commentID uint) {\n+\t\t\tcomment := s.app.dao.FindComment(commentID)\n+\t\t\tif comment.IsPending {\n+\t\t\t\treturn // no need to block again\n+\t\t\t}\n+\n+\t\t\t// update comment status\n+\t\t\tcomment.IsPending = true\n+\t\t\ts.app.dao.UpdateComment(&comment)\n+\t\t},\n+\t\tOnUpdateComment: func(commentID uint, content string) {\n+\t\t\tcomment := s.app.dao.FindComment(commentID)\n+\t\t\tcomment.Content = content\n+\t\t\ts.app.dao.UpdateComment(&comment)\n+\t\t},\n \t})\n \n \treturn nil\n@@ -28,6 +48,47 @@ func (s *AntiSpamService) Dispose() error {\n \treturn nil\n }\n \n-func (s *AntiSpamService) CheckAndBlock(data *anti_spam.CheckData) {\n-\ts.client.CheckAndBlock(data)\n+func (s *AntiSpamService) CheckAndBlock(data *AntiSpamCheckPayload) {\n+\ts.client.CheckAndBlock(s.payload2CheckerParams(data))\n+}\n+\n+// Payload for CheckAndBlock function\n+type AntiSpamCheckPayload struct {\n+\tComment      *entity.Comment\n+\tReqReferer   string\n+\tReqIP        string\n+\tReqUserAgent string\n+}\n+\n+// Transform `AntiSpamCheckPayload` to `CheckerParams` for `anti_spam.CheckAndBlock` func call\n+//\n+//\tThe `AntiSpamCheckPayload` struct is exposed and can be used by other modules\n+//\tThe `CheckerParams` struct is used by `anti_spam.CheckAndBlock` in anti_spam module\n+func (s *AntiSpamService) payload2CheckerParams(payload *AntiSpamCheckPayload) *anti_spam.CheckerParams {\n+\tuser := s.app.dao.FetchUserForComment(payload.Comment)\n+\tsiteURL := \"\"\n+\n+\tif payload.Comment.SiteName != \"\" {\n+\t\tsite := s.app.dao.FindSite(payload.Comment.SiteName)\n+\t\tsiteURL = s.app.dao.CookSite(&site).FirstUrl\n+\t}\n+\tif siteURL == \"\" {\n+\t\t// extract site url from referer\n+\t\tif pr, err := url.Parse(payload.ReqReferer); err == nil && pr.Scheme != \"\" && pr.Host != \"\" {\n+\t\t\tsiteURL = fmt.Sprintf(\"%s://%s\", pr.Scheme, pr.Host)\n+\t\t}\n+\t}\n+\n+\treturn &anti_spam.CheckerParams{\n+\t\tBlogURL: siteURL,\n+\n+\t\tContent:   payload.Comment.Content,\n+\t\tCommentID: payload.Comment.ID,\n+\n+\t\tUserName:  user.Name,\n+\t\tUserEmail: user.Email,\n+\t\tUserID:    user.ID,\n+\t\tUserIP:    payload.ReqIP,\n+\t\tUserAgent: payload.ReqUserAgent,\n+\t}\n }"
    },
    {
      "sha": "ab1d7a8735458918cba7f5e2284d7732ab42b30e",
      "filename": "server/handler/comment_add.go",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/server%2Fhandler%2Fcomment_add.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14/server%2Fhandler%2Fcomment_add.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/server%2Fhandler%2Fcomment_add.go?ref=ec0ef12b0ee6a119aea78a6d0930e0d9863bfd14",
      "patch": "@@ -3,7 +3,6 @@ package handler\n import (\n \t\"strings\"\n \n-\t\"github.com/ArtalkJS/Artalk/internal/anti_spam\"\n \t\"github.com/ArtalkJS/Artalk/internal/core\"\n \t\"github.com/ArtalkJS/Artalk/internal/entity\"\n \t\"github.com/ArtalkJS/Artalk/internal/i18n\"\n@@ -161,7 +160,7 @@ func CommentAdd(app *core.App, router fiber.Router) {\n \t\t\tif !isAdmin { // 忽略检查管理员\n \t\t\t\t// 同步执行\n \t\t\t\tif antiSpamService, err := core.AppService[*core.AntiSpamService](app); err == nil {\n-\t\t\t\t\tantiSpamService.CheckAndBlock(&anti_spam.CheckData{\n+\t\t\t\t\tantiSpamService.CheckAndBlock(&core.AntiSpamCheckPayload{\n \t\t\t\t\t\tComment:      &comment,\n \t\t\t\t\t\tReqReferer:   referer,\n \t\t\t\t\t\tReqIP:        ip,"
    }
  ]
}
