{
  "sha": "e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOmUwMThmYWM2YzRjMjRlYTMxM2UxMzM5ZDI1YzFmZmM4ZmEzMmE5M2Y=",
  "commit": {
    "author": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-09-05T23:56:43Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-09-05T23:56:43Z"
    },
    "message": "revendor",
    "tree": {
      "sha": "2cd32f1232f27a5878ca17e7094833d5137e514a",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/2cd32f1232f27a5878ca17e7094833d5137e514a"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
  "html_url": "https://github.com/umputun/remark/commit/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/comments",
  "author": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "url": "https://api.github.com/repos/umputun/remark/commits/7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "html_url": "https://github.com/umputun/remark/commit/7971ebe6f49e5a9a944407ef2f380d0fb405572b"
    }
  ],
  "stats": {
    "total": 8367,
    "additions": 50,
    "deletions": 8317
  },
  "files": [
    {
      "sha": "6aae1eed6c5ce6e8a6c58b74f81904d5ab4b3494",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.mod?ref=e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
      "patch": "@@ -17,7 +17,7 @@ require (\n \tgithub.com/go-chi/chi v4.0.2+incompatible\n \tgithub.com/go-chi/cors v1.0.0\n \tgithub.com/go-chi/render v1.0.1\n-\tgithub.com/go-pkgz/auth v0.8.2\n+\tgithub.com/go-pkgz/auth v0.8.3\n \tgithub.com/go-pkgz/jrpc v0.1.0\n \tgithub.com/go-pkgz/lcw v0.3.1\n \tgithub.com/go-pkgz/lgr v0.6.3\n@@ -33,7 +33,6 @@ require (\n \tgithub.com/jessevdk/go-flags v0.0.0-20180331124232-1c38ed7ad0cc\n \tgithub.com/klauspost/compress v1.7.6 // indirect\n \tgithub.com/klauspost/cpuid v1.2.1 // indirect\n-\tgithub.com/kr/pretty v0.1.0 // indirect\n \tgithub.com/kyokomi/emoji v2.1.0+incompatible\n \tgithub.com/mattn/go-colorable v0.1.2 // indirect\n \tgithub.com/mattn/go-isatty v0.0.9 // indirect\n@@ -57,6 +56,5 @@ require (\n \tgolang.org/x/crypto v0.0.0-20190820162420-60c769a6c586\n \tgolang.org/x/image v0.0.0-20190823064033-3a9bac650e44\n \tgolang.org/x/net v0.0.0-20190813141303-74dc4d7220e7\n-\tgopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect\n \tgopkg.in/russross/blackfriday.v2 v2.0.1\n )"
    },
    {
      "sha": "7759ef9ccb85ba1618177ba22d4088c60baba712",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.sum?ref=e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
      "patch": "@@ -53,8 +53,8 @@ github.com/go-chi/cors v1.0.0/go.mod h1:K2Yje0VW/SJzxiyMYu6iPQYa7hMjQX2i/F491VCh\n github.com/go-chi/render v1.0.1 h1:4/5tis2cKaNdnv9zFLfXzcquC9HbeZgCnxGnKrltBS8=\n github.com/go-chi/render v1.0.1/go.mod h1:pq4Rr7HbnsdaeHagklXub+p6Wd16Af5l9koip1OvJns=\n github.com/go-pkgz/auth v0.4.1/go.mod h1:CWtB8dHmOv+TfF3MUzKwk/YwTLepC2TaDL05A+pFVBM=\n-github.com/go-pkgz/auth v0.8.2 h1:cMpLwoIeVAP1QwwRRDRlgQcsDvBS+yT/gL0m8p4gmcI=\n-github.com/go-pkgz/auth v0.8.2/go.mod h1:MBNrhig13KG0iXz/0d+30lnFUgzTxncUlaQ8suH/2p8=\n+github.com/go-pkgz/auth v0.8.3 h1:Ll6n2IYN67KFxyI0qdTuk4hXjtUbVdUW4TiR+X36Svc=\n+github.com/go-pkgz/auth v0.8.3/go.mod h1:Ij9y6oBzfsvutSGWSGwh9C4WyU4hOfxB6rTlj4xBwGE=\n github.com/go-pkgz/auth/_example v0.0.0-20190722170031-705d3f732438/go.mod h1:rvZtFFkmm3p+E0CHmfUqTGKweCVg2ddsRUrEEPB1iaE=\n github.com/go-pkgz/jrpc v0.1.0 h1:hNg/IyfEqJcSWOKkuHw0ZwcuGc9TDp7QZREsD2ycmiM=\n github.com/go-pkgz/jrpc v0.1.0/go.mod h1:JxZsvoBklA50DNhELVJnJ567Rt+KrMH9rR3u515wvE8="
    },
    {
      "sha": "3525a004b6c8d636aa84423900c0f886c28dedfb",
      "filename": "backend/vendor/github.com/globalsign/mgo/bson/bson_corpus_spec_test_generator.go",
      "status": "removed",
      "additions": 0,
      "deletions": 294,
      "changes": 294,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/github.com/globalsign/mgo/bson/bson_corpus_spec_test_generator.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/github.com/globalsign/mgo/bson/bson_corpus_spec_test_generator.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/globalsign/mgo/bson/bson_corpus_spec_test_generator.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,294 +0,0 @@\n-// +build ignore\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"go/format\"\n-\t\"html/template\"\n-\t\"io/ioutil\"\n-\t\"log\"\n-\t\"path/filepath\"\n-\t\"strings\"\n-\n-\t\"github.com/globalsign/mgo/internal/json\"\n-)\n-\n-func main() {\n-\tlog.SetFlags(0)\n-\tlog.SetPrefix(name + \": \")\n-\n-\tvar g Generator\n-\n-\tfmt.Fprintf(&g, \"// Code generated by \\\"%s.go\\\"; DO NOT EDIT\\n\\n\", name)\n-\n-\tsrc := g.generate()\n-\n-\terr := ioutil.WriteFile(fmt.Sprintf(\"%s.go\", strings.TrimSuffix(name, \"_generator\")), src, 0644)\n-\tif err != nil {\n-\t\tlog.Fatalf(\"writing output: %s\", err)\n-\t}\n-}\n-\n-// Generator holds the state of the analysis. Primarily used to buffer\n-// the output for format.Source.\n-type Generator struct {\n-\tbytes.Buffer // Accumulated output.\n-}\n-\n-// format returns the gofmt-ed contents of the Generator's buffer.\n-func (g *Generator) format() []byte {\n-\tsrc, err := format.Source(g.Bytes())\n-\tif err != nil {\n-\t\t// Should never happen, but can arise when developing this code.\n-\t\t// The user can compile the output to see the error.\n-\t\tlog.Printf(\"warning: internal error: invalid Go generated: %s\", err)\n-\t\tlog.Printf(\"warning: compile the package to analyze the error\")\n-\t\treturn g.Bytes()\n-\t}\n-\treturn src\n-}\n-\n-// EVERYTHING ABOVE IS CONSTANT BETWEEN THE GENERATORS\n-\n-const name = \"bson_corpus_spec_test_generator\"\n-\n-func (g *Generator) generate() []byte {\n-\n-\ttestFiles, err := filepath.Glob(\"./specdata/specifications/source/bson-corpus/tests/*.json\")\n-\tif err != nil {\n-\t\tlog.Fatalf(\"error reading bson-corpus files: %s\", err)\n-\t}\n-\n-\ttests, err := g.loadTests(testFiles)\n-\tif err != nil {\n-\t\tlog.Fatalf(\"error loading tests: %s\", err)\n-\t}\n-\n-\ttmpl, err := g.getTemplate()\n-\tif err != nil {\n-\t\tlog.Fatalf(\"error loading template: %s\", err)\n-\t}\n-\n-\ttmpl.Execute(&g.Buffer, tests)\n-\n-\treturn g.format()\n-}\n-\n-func (g *Generator) loadTests(filenames []string) ([]*testDef, error) {\n-\tvar tests []*testDef\n-\tfor _, filename := range filenames {\n-\t\ttest, err := g.loadTest(filename)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\ttests = append(tests, test)\n-\t}\n-\n-\treturn tests, nil\n-}\n-\n-func (g *Generator) loadTest(filename string) (*testDef, error) {\n-\tcontent, err := ioutil.ReadFile(filename)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar testDef testDef\n-\terr = json.Unmarshal(content, &testDef)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tnames := make(map[string]struct{})\n-\n-\tfor i := len(testDef.Valid) - 1; i >= 0; i-- {\n-\t\tif testDef.BsonType == \"0x05\" && testDef.Valid[i].Description == \"subtype 0x02\" {\n-\t\t\ttestDef.Valid = append(testDef.Valid[:i], testDef.Valid[i+1:]...)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tname := cleanupFuncName(testDef.Description + \"_\" + testDef.Valid[i].Description)\n-\t\tnameIdx := name\n-\t\tj := 1\n-\t\tfor {\n-\t\t\tif _, ok := names[nameIdx]; !ok {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tnameIdx = fmt.Sprintf(\"%s_%d\", name, j)\n-\t\t}\n-\n-\t\tnames[nameIdx] = struct{}{}\n-\n-\t\ttestDef.Valid[i].TestDef = &testDef\n-\t\ttestDef.Valid[i].Name = nameIdx\n-\t\ttestDef.Valid[i].StructTest = testDef.TestKey != \"\" &&\n-\t\t\t(testDef.BsonType != \"0x05\" || strings.Contains(testDef.Valid[i].Description, \"0x00\")) &&\n-\t\t\t!testDef.Deprecated\n-\t}\n-\n-\tfor i := len(testDef.DecodeErrors) - 1; i >= 0; i-- {\n-\t\tif strings.Contains(testDef.DecodeErrors[i].Description, \"UTF-8\") {\n-\t\t\ttestDef.DecodeErrors = append(testDef.DecodeErrors[:i], testDef.DecodeErrors[i+1:]...)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tname := cleanupFuncName(testDef.Description + \"_\" + testDef.DecodeErrors[i].Description)\n-\t\tnameIdx := name\n-\t\tj := 1\n-\t\tfor {\n-\t\t\tif _, ok := names[nameIdx]; !ok {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tnameIdx = fmt.Sprintf(\"%s_%d\", name, j)\n-\t\t}\n-\t\tnames[nameIdx] = struct{}{}\n-\n-\t\ttestDef.DecodeErrors[i].Name = nameIdx\n-\t}\n-\n-\treturn &testDef, nil\n-}\n-\n-func (g *Generator) getTemplate() (*template.Template, error) {\n-\tcontent := `package bson_test\n-\n-import (\n-    \"encoding/hex\"\n-\t\"time\"\n-\n-\t. \"gopkg.in/check.v1\"\n-    \"github.com/globalsign/mgo/bson\"\n-)\n-\n-func testValid(c *C, in []byte, expected []byte, result interface{}) {\n-\terr := bson.Unmarshal(in, result)\n-\tc.Assert(err, IsNil)\n-\n-\tout, err := bson.Marshal(result)\n-\tc.Assert(err, IsNil)\n-\n-\tc.Assert(string(expected), Equals, string(out), Commentf(\"roundtrip failed for %T, expected '%x' but got '%x'\", result, expected, out))\n-}\n-\n-func testDecodeSkip(c *C, in []byte) {\n-\terr := bson.Unmarshal(in, &struct{}{})\n-\tc.Assert(err, IsNil)\n-}\n-\n-func testDecodeError(c *C, in []byte, result interface{}) {\n-\terr := bson.Unmarshal(in, result)\n-\tc.Assert(err, Not(IsNil))\n-}\n-\n-{{range .}}\n-{{range .Valid}}\n-func (s *S) Test{{.Name}}(c *C) {\n-    b, err := hex.DecodeString(\"{{.Bson}}\")\n-\tc.Assert(err, IsNil)\n-\n-    {{if .CanonicalBson}}\n-    cb, err := hex.DecodeString(\"{{.CanonicalBson}}\")\n-\tc.Assert(err, IsNil)\n-\t{{else}}\n-    cb := b\n-    {{end}}\n-\n-    var resultD bson.D\n-\ttestValid(c, b, cb, &resultD)\n-\t{{if .StructTest}}var resultS struct {\n-\t\tElement {{.TestDef.GoType}} ` + \"`bson:\\\"{{.TestDef.TestKey}}\\\"`\" + `\n-\t}\n-\ttestValid(c, b, cb, &resultS){{end}}\n-\n-\ttestDecodeSkip(c, b)\n-}\n-{{end}}\n-\n-{{range .DecodeErrors}}\n-func (s *S) Test{{.Name}}(c *C) {\n-\tb, err := hex.DecodeString(\"{{.Bson}}\")\n-\tc.Assert(err, IsNil)\n-\n-\tvar resultD bson.D\n-\ttestDecodeError(c, b, &resultD)\n-}\n-{{end}}\n-{{end}}\n-`\n-\ttmpl, err := template.New(\"\").Parse(content)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn tmpl, nil\n-}\n-\n-func cleanupFuncName(name string) string {\n-\treturn strings.Map(func(r rune) rune {\n-\t\tif (r >= 48 && r <= 57) || (r >= 65 && r <= 90) || (r >= 97 && r <= 122) {\n-\t\t\treturn r\n-\t\t}\n-\t\treturn '_'\n-\t}, name)\n-}\n-\n-type testDef struct {\n-\tDescription  string         `json:\"description\"`\n-\tBsonType     string         `json:\"bson_type\"`\n-\tTestKey      string         `json:\"test_key\"`\n-\tValid        []*valid       `json:\"valid\"`\n-\tDecodeErrors []*decodeError `json:\"decodeErrors\"`\n-\tDeprecated   bool           `json:\"deprecated\"`\n-}\n-\n-func (t *testDef) GoType() string {\n-\tswitch t.BsonType {\n-\tcase \"0x01\":\n-\t\treturn \"float64\"\n-\tcase \"0x02\":\n-\t\treturn \"string\"\n-\tcase \"0x03\":\n-\t\treturn \"bson.D\"\n-\tcase \"0x04\":\n-\t\treturn \"[]interface{}\"\n-\tcase \"0x05\":\n-\t\treturn \"[]byte\"\n-\tcase \"0x07\":\n-\t\treturn \"bson.ObjectId\"\n-\tcase \"0x08\":\n-\t\treturn \"bool\"\n-\tcase \"0x09\":\n-\t\treturn \"time.Time\"\n-\tcase \"0x0E\":\n-\t\treturn \"string\"\n-\tcase \"0x10\":\n-\t\treturn \"int32\"\n-\tcase \"0x12\":\n-\t\treturn \"int64\"\n-\tcase \"0x13\":\n-\t\treturn \"bson.Decimal\"\n-\tdefault:\n-\t\treturn \"interface{}\"\n-\t}\n-}\n-\n-type valid struct {\n-\tDescription   string `json:\"description\"`\n-\tBson          string `json:\"bson\"`\n-\tCanonicalBson string `json:\"canonical_bson\"`\n-\n-\tName       string\n-\tStructTest bool\n-\tTestDef    *testDef\n-}\n-\n-type decodeError struct {\n-\tDescription string `json:\"description\"`\n-\tBson        string `json:\"bson\"`\n-\n-\tName string\n-}"
    },
    {
      "sha": "cf57f871d7d46689a473b1dd5023164a10830cef",
      "filename": "backend/vendor/github.com/go-pkgz/auth/go.mod",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/vendor/github.com/go-pkgz/auth/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/vendor/github.com/go-pkgz/auth/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/auth/go.mod?ref=e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
      "patch": "@@ -22,3 +22,5 @@ require (\n \tgoogle.golang.org/appengine v1.6.1 // indirect\n \tgopkg.in/oauth2.v3 v3.10.1\n )\n+\n+go 1.13"
    },
    {
      "sha": "5a0f9ab4a29efdee8f981a6a3b32944ab7fda406",
      "filename": "backend/vendor/github.com/go-pkgz/auth/provider/sender/email.go",
      "status": "modified",
      "additions": 29,
      "deletions": 8,
      "changes": 37,
      "blob_url": "https://github.com/umputun/remark/blob/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/vendor/github.com/go-pkgz/auth/provider/sender/email.go",
      "raw_url": "https://github.com/umputun/remark/raw/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/vendor/github.com/go-pkgz/auth/provider/sender/email.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/auth/provider/sender/email.go?ref=e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
      "patch": "@@ -5,6 +5,7 @@ import (\n \t\"crypto/tls\"\n \t\"fmt\"\n \t\"io\"\n+\t\"mime/quotedprintable\"\n \t\"net\"\n \t\"net/smtp\"\n \t\"time\"\n@@ -94,7 +95,11 @@ func (em *Email) Send(to, text string) error {\n \t\treturn errors.Wrap(err, \"can't make email writer\")\n \t}\n \n-\tbuf := bytes.NewBufferString(em.buildMessage(text, to))\n+\tmsg, err := em.buildMessage(text, to)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"can't make email message\")\n+\t}\n+\tbuf := bytes.NewBufferString(msg)\n \tif _, err = buf.WriteTo(writer); err != nil {\n \t\treturn errors.Wrapf(err, \"failed to send email body to %q\", to)\n \t}\n@@ -139,13 +144,29 @@ func (em *Email) client() (c *smtp.Client, err error) {\n \treturn c, nil\n }\n \n-func (em *Email) buildMessage(msg, to string) (message string) {\n-\tmessage += fmt.Sprintf(\"From: %s\\n\", em.From)\n-\tmessage += fmt.Sprintf(\"To: %s\\n\", to)\n-\tmessage += fmt.Sprintf(\"Subject: %s\\n\", em.Subject)\n+func (em *Email) buildMessage(msg, to string) (message string, err error) {\n+\taddHeader := func(msg, h, v string) string {\n+\t\tmsg += fmt.Sprintf(\"%s: %s\\n\", h, v)\n+\t\treturn msg\n+\t}\n+\tmessage = addHeader(message, \"From\", em.From)\n+\tmessage = addHeader(message, \"To\", to)\n+\tmessage = addHeader(message, \"Subject\", em.Subject)\n+\tmessage = addHeader(message, \"Content-Transfer-Encoding\", \"quoted-printable\")\n+\n \tif em.ContentType != \"\" {\n-\t\tmessage += fmt.Sprintf(\"MIME-version: 1.0;\\nContent-Type: %s; charset=\\\"UTF-8\\\";\\n\", em.ContentType)\n+\t\tmessage = addHeader(message, \"MIME-version\", \"1.0\")\n+\t\tmessage = addHeader(message, \"Content-Type\", em.ContentType+`; charset=\"UTF-8\"`)\n+\t}\n+\tmessage = addHeader(message, \"Date\", time.Now().Format(time.RFC1123Z))\n+\n+\tbuff := &bytes.Buffer{}\n+\tqp := quotedprintable.NewWriter(buff)\n+\tif _, err := qp.Write([]byte(msg)); err != nil {\n+\t\treturn \"\", err\n \t}\n-\tmessage += \"\\n\" + msg\n-\treturn message\n+\tdefer qp.Close()\n+\tm := buff.String()\n+\tmessage += \"\\n\" + m\n+\treturn message, nil\n }"
    },
    {
      "sha": "822bb6a5028e05e707dc596c8d80fbdeb41e9bc2",
      "filename": "backend/vendor/golang.org/x/image/draw/gen.go",
      "status": "removed",
      "additions": 0,
      "deletions": 1404,
      "changes": 1404,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/image/draw/gen.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/image/draw/gen.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/image/draw/gen.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,1404 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"go/format\"\n-\t\"io/ioutil\"\n-\t\"log\"\n-\t\"os\"\n-\t\"strings\"\n-)\n-\n-var debug = flag.Bool(\"debug\", false, \"\")\n-\n-func main() {\n-\tflag.Parse()\n-\n-\tw := new(bytes.Buffer)\n-\tw.WriteString(\"// generated by \\\"go run gen.go\\\". DO NOT EDIT.\\n\\n\" +\n-\t\t\"package draw\\n\\nimport (\\n\" +\n-\t\t\"\\\"image\\\"\\n\" +\n-\t\t\"\\\"image/color\\\"\\n\" +\n-\t\t\"\\\"math\\\"\\n\" +\n-\t\t\"\\n\" +\n-\t\t\"\\\"golang.org/x/image/math/f64\\\"\\n\" +\n-\t\t\")\\n\")\n-\n-\tgen(w, \"nnInterpolator\", codeNNScaleLeaf, codeNNTransformLeaf)\n-\tgen(w, \"ablInterpolator\", codeABLScaleLeaf, codeABLTransformLeaf)\n-\tgenKernel(w)\n-\n-\tif *debug {\n-\t\tos.Stdout.Write(w.Bytes())\n-\t\treturn\n-\t}\n-\tout, err := format.Source(w.Bytes())\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\tif err := ioutil.WriteFile(\"impl.go\", out, 0660); err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-var (\n-\t// dsTypes are the (dst image type, src image type) pairs to generate\n-\t// scale_DType_SType implementations for. The last element in the slice\n-\t// should be the fallback pair (\"Image\", \"image.Image\").\n-\t//\n-\t// TODO: add *image.CMYK src type after Go 1.5 is released.\n-\t// An *image.CMYK is also alwaysOpaque.\n-\tdsTypes = []struct{ dType, sType string }{\n-\t\t{\"*image.RGBA\", \"*image.Gray\"},\n-\t\t{\"*image.RGBA\", \"*image.NRGBA\"},\n-\t\t{\"*image.RGBA\", \"*image.RGBA\"},\n-\t\t{\"*image.RGBA\", \"*image.YCbCr\"},\n-\t\t{\"*image.RGBA\", \"image.Image\"},\n-\t\t{\"Image\", \"image.Image\"},\n-\t}\n-\tdTypes, sTypes  []string\n-\tsTypesForDType  = map[string][]string{}\n-\tsubsampleRatios = []string{\n-\t\t\"444\",\n-\t\t\"422\",\n-\t\t\"420\",\n-\t\t\"440\",\n-\t}\n-\tops = []string{\"Over\", \"Src\"}\n-\t// alwaysOpaque are those image.Image implementations that are always\n-\t// opaque. For these types, Over is equivalent to the faster Src, in the\n-\t// absence of a source mask.\n-\talwaysOpaque = map[string]bool{\n-\t\t\"*image.Gray\":  true,\n-\t\t\"*image.YCbCr\": true,\n-\t}\n-)\n-\n-func init() {\n-\tdTypesSeen := map[string]bool{}\n-\tsTypesSeen := map[string]bool{}\n-\tfor _, t := range dsTypes {\n-\t\tif !sTypesSeen[t.sType] {\n-\t\t\tsTypesSeen[t.sType] = true\n-\t\t\tsTypes = append(sTypes, t.sType)\n-\t\t}\n-\t\tif !dTypesSeen[t.dType] {\n-\t\t\tdTypesSeen[t.dType] = true\n-\t\t\tdTypes = append(dTypes, t.dType)\n-\t\t}\n-\t\tsTypesForDType[t.dType] = append(sTypesForDType[t.dType], t.sType)\n-\t}\n-\tsTypesForDType[\"anyDType\"] = sTypes\n-}\n-\n-type data struct {\n-\tdType    string\n-\tsType    string\n-\tsratio   string\n-\treceiver string\n-\top       string\n-}\n-\n-func gen(w *bytes.Buffer, receiver string, codes ...string) {\n-\texpn(w, codeRoot, &data{receiver: receiver})\n-\tfor _, code := range codes {\n-\t\tfor _, t := range dsTypes {\n-\t\t\tfor _, op := range ops {\n-\t\t\t\tif op == \"Over\" && alwaysOpaque[t.sType] {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\texpn(w, code, &data{\n-\t\t\t\t\tdType:    t.dType,\n-\t\t\t\t\tsType:    t.sType,\n-\t\t\t\t\treceiver: receiver,\n-\t\t\t\t\top:       op,\n-\t\t\t\t})\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func genKernel(w *bytes.Buffer) {\n-\texpn(w, codeKernelRoot, &data{})\n-\tfor _, sType := range sTypes {\n-\t\texpn(w, codeKernelScaleLeafX, &data{\n-\t\t\tsType: sType,\n-\t\t})\n-\t}\n-\tfor _, dType := range dTypes {\n-\t\tfor _, op := range ops {\n-\t\t\texpn(w, codeKernelScaleLeafY, &data{\n-\t\t\t\tdType: dType,\n-\t\t\t\top:    op,\n-\t\t\t})\n-\t\t}\n-\t}\n-\tfor _, t := range dsTypes {\n-\t\tfor _, op := range ops {\n-\t\t\tif op == \"Over\" && alwaysOpaque[t.sType] {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\texpn(w, codeKernelTransformLeaf, &data{\n-\t\t\t\tdType: t.dType,\n-\t\t\t\tsType: t.sType,\n-\t\t\t\top:    op,\n-\t\t\t})\n-\t\t}\n-\t}\n-}\n-\n-func expn(w *bytes.Buffer, code string, d *data) {\n-\tif d.sType == \"*image.YCbCr\" && d.sratio == \"\" {\n-\t\tfor _, sratio := range subsampleRatios {\n-\t\t\te := *d\n-\t\t\te.sratio = sratio\n-\t\t\texpn(w, code, &e)\n-\t\t}\n-\t\treturn\n-\t}\n-\n-\tfor _, line := range strings.Split(code, \"\\n\") {\n-\t\tline = expnLine(line, d)\n-\t\tif line == \";\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tfmt.Fprintln(w, line)\n-\t}\n-}\n-\n-func expnLine(line string, d *data) string {\n-\tfor {\n-\t\ti := strings.IndexByte(line, '$')\n-\t\tif i < 0 {\n-\t\t\tbreak\n-\t\t}\n-\t\tprefix, s := line[:i], line[i+1:]\n-\n-\t\ti = len(s)\n-\t\tfor j, c := range s {\n-\t\t\tif !('A' <= c && c <= 'Z' || 'a' <= c && c <= 'z') {\n-\t\t\t\ti = j\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tdollar, suffix := s[:i], s[i:]\n-\n-\t\te := expnDollar(prefix, dollar, suffix, d)\n-\t\tif e == \"\" {\n-\t\t\tlog.Fatalf(\"couldn't expand %q\", line)\n-\t\t}\n-\t\tline = e\n-\t}\n-\treturn line\n-}\n-\n-// expnDollar expands a \"$foo\" fragment in a line of generated code. It returns\n-// the empty string if there was a problem. It returns \";\" if the generated\n-// code is a no-op.\n-func expnDollar(prefix, dollar, suffix string, d *data) string {\n-\tswitch dollar {\n-\tcase \"dType\":\n-\t\treturn prefix + d.dType + suffix\n-\tcase \"dTypeRN\":\n-\t\treturn prefix + relName(d.dType) + suffix\n-\tcase \"sratio\":\n-\t\treturn prefix + d.sratio + suffix\n-\tcase \"sType\":\n-\t\treturn prefix + d.sType + suffix\n-\tcase \"sTypeRN\":\n-\t\treturn prefix + relName(d.sType) + suffix\n-\tcase \"receiver\":\n-\t\treturn prefix + d.receiver + suffix\n-\tcase \"op\":\n-\t\treturn prefix + d.op + suffix\n-\n-\tcase \"switch\":\n-\t\treturn expnSwitch(\"\", \"\", true, suffix)\n-\tcase \"switchD\":\n-\t\treturn expnSwitch(\"\", \"\", false, suffix)\n-\tcase \"switchS\":\n-\t\treturn expnSwitch(\"\", \"anyDType\", false, suffix)\n-\n-\tcase \"preOuter\":\n-\t\tswitch d.dType {\n-\t\tdefault:\n-\t\t\treturn \";\"\n-\t\tcase \"Image\":\n-\t\t\ts := \"\"\n-\t\t\tif d.sType == \"image.Image\" {\n-\t\t\t\ts = \"srcMask, smp := opts.SrcMask, opts.SrcMaskP\\n\"\n-\t\t\t}\n-\t\t\treturn s +\n-\t\t\t\t\"dstMask, dmp := opts.DstMask, opts.DstMaskP\\n\" +\n-\t\t\t\t\"dstColorRGBA64 := &color.RGBA64{}\\n\" +\n-\t\t\t\t\"dstColor := color.Color(dstColorRGBA64)\"\n-\t\t}\n-\n-\tcase \"preInner\":\n-\t\tswitch d.dType {\n-\t\tdefault:\n-\t\t\treturn \";\"\n-\t\tcase \"*image.RGBA\":\n-\t\t\treturn \"d := \" + pixOffset(\"dst\", \"dr.Min.X+adr.Min.X\", \"dr.Min.Y+int(dy)\", \"*4\", \"*dst.Stride\")\n-\t\t}\n-\n-\tcase \"preKernelOuter\":\n-\t\tswitch d.sType {\n-\t\tdefault:\n-\t\t\treturn \";\"\n-\t\tcase \"image.Image\":\n-\t\t\treturn \"srcMask, smp := opts.SrcMask, opts.SrcMaskP\"\n-\t\t}\n-\n-\tcase \"preKernelInner\":\n-\t\tswitch d.dType {\n-\t\tdefault:\n-\t\t\treturn \";\"\n-\t\tcase \"*image.RGBA\":\n-\t\t\treturn \"d := \" + pixOffset(\"dst\", \"dr.Min.X+int(dx)\", \"dr.Min.Y+adr.Min.Y\", \"*4\", \"*dst.Stride\")\n-\t\t}\n-\n-\tcase \"blend\":\n-\t\targs, _ := splitArgs(suffix)\n-\t\tif len(args) != 4 {\n-\t\t\treturn \"\"\n-\t\t}\n-\t\tswitch d.sType {\n-\t\tdefault:\n-\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\"$3r = $0*$1r + $2*$3r\\n\"+\n-\t\t\t\t\"$3g = $0*$1g + $2*$3g\\n\"+\n-\t\t\t\t\"$3b = $0*$1b + $2*$3b\\n\"+\n-\t\t\t\t\"$3a = $0*$1a + $2*$3a\",\n-\t\t\t)\n-\t\tcase \"*image.Gray\":\n-\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\"$3r = $0*$1r + $2*$3r\",\n-\t\t\t)\n-\t\tcase \"*image.YCbCr\":\n-\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\"$3r = $0*$1r + $2*$3r\\n\"+\n-\t\t\t\t\"$3g = $0*$1g + $2*$3g\\n\"+\n-\t\t\t\t\"$3b = $0*$1b + $2*$3b\",\n-\t\t\t)\n-\t\t}\n-\n-\tcase \"clampToAlpha\":\n-\t\tif alwaysOpaque[d.sType] {\n-\t\t\treturn \";\"\n-\t\t}\n-\t\t// Go uses alpha-premultiplied color. The naive computation can lead to\n-\t\t// invalid colors, e.g. red > alpha, when some weights are negative.\n-\t\treturn `\n-\t\t\tif pr > pa {\n-\t\t\t\tpr = pa\n-\t\t\t}\n-\t\t\tif pg > pa {\n-\t\t\t\tpg = pa\n-\t\t\t}\n-\t\t\tif pb > pa {\n-\t\t\t\tpb = pa\n-\t\t\t}\n-\t\t`\n-\n-\tcase \"convFtou\":\n-\t\targs, _ := splitArgs(suffix)\n-\t\tif len(args) != 2 {\n-\t\t\treturn \"\"\n-\t\t}\n-\n-\t\tswitch d.sType {\n-\t\tdefault:\n-\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\"$0r := uint32($1r)\\n\"+\n-\t\t\t\t\"$0g := uint32($1g)\\n\"+\n-\t\t\t\t\"$0b := uint32($1b)\\n\"+\n-\t\t\t\t\"$0a := uint32($1a)\",\n-\t\t\t)\n-\t\tcase \"*image.Gray\":\n-\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\"$0r := uint32($1r)\",\n-\t\t\t)\n-\t\tcase \"*image.YCbCr\":\n-\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\"$0r := uint32($1r)\\n\"+\n-\t\t\t\t\"$0g := uint32($1g)\\n\"+\n-\t\t\t\t\"$0b := uint32($1b)\",\n-\t\t\t)\n-\t\t}\n-\n-\tcase \"outputu\":\n-\t\targs, _ := splitArgs(suffix)\n-\t\tif len(args) != 3 {\n-\t\t\treturn \"\"\n-\t\t}\n-\n-\t\tswitch d.op {\n-\t\tcase \"Over\":\n-\t\t\tswitch d.dType {\n-\t\t\tdefault:\n-\t\t\t\tlog.Fatalf(\"bad dType %q\", d.dType)\n-\t\t\tcase \"Image\":\n-\t\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\t\"qr, qg, qb, qa := dst.At($0, $1).RGBA()\\n\"+\n-\t\t\t\t\t\"if dstMask != nil {\\n\"+\n-\t\t\t\t\t\"\t_, _, _, ma := dstMask.At(dmp.X + $0, dmp.Y + $1).RGBA()\\n\"+\n-\t\t\t\t\t\"\t$2r = $2r * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t$2g = $2g * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t$2b = $2b * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t$2a = $2a * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"}\\n\"+\n-\t\t\t\t\t\"$2a1 := 0xffff - $2a\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.R = uint16(qr*$2a1/0xffff + $2r)\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.G = uint16(qg*$2a1/0xffff + $2g)\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.B = uint16(qb*$2a1/0xffff + $2b)\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.A = uint16(qa*$2a1/0xffff + $2a)\\n\"+\n-\t\t\t\t\t\"dst.Set($0, $1, dstColor)\",\n-\t\t\t\t)\n-\t\t\tcase \"*image.RGBA\":\n-\t\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\t\"$2a1 := (0xffff - $2a) * 0x101\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+0] = uint8((uint32(dst.Pix[d+0])*$2a1/0xffff + $2r) >> 8)\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+1] = uint8((uint32(dst.Pix[d+1])*$2a1/0xffff + $2g) >> 8)\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+2] = uint8((uint32(dst.Pix[d+2])*$2a1/0xffff + $2b) >> 8)\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+3] = uint8((uint32(dst.Pix[d+3])*$2a1/0xffff + $2a) >> 8)\",\n-\t\t\t\t)\n-\t\t\t}\n-\n-\t\tcase \"Src\":\n-\t\t\tswitch d.dType {\n-\t\t\tdefault:\n-\t\t\t\tlog.Fatalf(\"bad dType %q\", d.dType)\n-\t\t\tcase \"Image\":\n-\t\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\t\"if dstMask != nil {\\n\"+\n-\t\t\t\t\t\"\tqr, qg, qb, qa := dst.At($0, $1).RGBA()\\n\"+\n-\t\t\t\t\t\"\t_, _, _, ma := dstMask.At(dmp.X + $0, dmp.Y + $1).RGBA()\\n\"+\n-\t\t\t\t\t\"\tpr = pr * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\tpg = pg * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\tpb = pb * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\tpa = pa * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t$2a1 := 0xffff - ma\\n\"+ // Note that this is ma, not $2a.\n-\t\t\t\t\t\"\tdstColorRGBA64.R = uint16(qr*$2a1/0xffff + $2r)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.G = uint16(qg*$2a1/0xffff + $2g)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.B = uint16(qb*$2a1/0xffff + $2b)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.A = uint16(qa*$2a1/0xffff + $2a)\\n\"+\n-\t\t\t\t\t\"\tdst.Set($0, $1, dstColor)\\n\"+\n-\t\t\t\t\t\"} else {\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.R = uint16($2r)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.G = uint16($2g)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.B = uint16($2b)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.A = uint16($2a)\\n\"+\n-\t\t\t\t\t\"\tdst.Set($0, $1, dstColor)\\n\"+\n-\t\t\t\t\t\"}\",\n-\t\t\t\t)\n-\t\t\tcase \"*image.RGBA\":\n-\t\t\t\tswitch d.sType {\n-\t\t\t\tdefault:\n-\t\t\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\t\t\"dst.Pix[d+0] = uint8($2r >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+1] = uint8($2g >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+2] = uint8($2b >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+3] = uint8($2a >> 8)\",\n-\t\t\t\t\t)\n-\t\t\t\tcase \"*image.Gray\":\n-\t\t\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\t\t\"out := uint8($2r >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+0] = out\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+1] = out\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+2] = out\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+3] = 0xff\",\n-\t\t\t\t\t)\n-\t\t\t\tcase \"*image.YCbCr\":\n-\t\t\t\t\treturn argf(args, \"\"+\n-\t\t\t\t\t\t\"dst.Pix[d+0] = uint8($2r >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+1] = uint8($2g >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+2] = uint8($2b >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+3] = 0xff\",\n-\t\t\t\t\t)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\tcase \"outputf\":\n-\t\targs, _ := splitArgs(suffix)\n-\t\tif len(args) != 5 {\n-\t\t\treturn \"\"\n-\t\t}\n-\t\tret := \"\"\n-\n-\t\tswitch d.op {\n-\t\tcase \"Over\":\n-\t\t\tswitch d.dType {\n-\t\t\tdefault:\n-\t\t\t\tlog.Fatalf(\"bad dType %q\", d.dType)\n-\t\t\tcase \"Image\":\n-\t\t\t\tret = argf(args, \"\"+\n-\t\t\t\t\t\"qr, qg, qb, qa := dst.At($0, $1).RGBA()\\n\"+\n-\t\t\t\t\t\"$3r0 := uint32($2($3r * $4))\\n\"+\n-\t\t\t\t\t\"$3g0 := uint32($2($3g * $4))\\n\"+\n-\t\t\t\t\t\"$3b0 := uint32($2($3b * $4))\\n\"+\n-\t\t\t\t\t\"$3a0 := uint32($2($3a * $4))\\n\"+\n-\t\t\t\t\t\"if dstMask != nil {\\n\"+\n-\t\t\t\t\t\"\t_, _, _, ma := dstMask.At(dmp.X + $0, dmp.Y + $1).RGBA()\\n\"+\n-\t\t\t\t\t\"\t$3r0 = $3r0 * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t$3g0 = $3g0 * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t$3b0 = $3b0 * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t$3a0 = $3a0 * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"}\\n\"+\n-\t\t\t\t\t\"$3a1 := 0xffff - $3a0\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.R = uint16(qr*$3a1/0xffff + $3r0)\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.G = uint16(qg*$3a1/0xffff + $3g0)\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.B = uint16(qb*$3a1/0xffff + $3b0)\\n\"+\n-\t\t\t\t\t\"dstColorRGBA64.A = uint16(qa*$3a1/0xffff + $3a0)\\n\"+\n-\t\t\t\t\t\"dst.Set($0, $1, dstColor)\",\n-\t\t\t\t)\n-\t\t\tcase \"*image.RGBA\":\n-\t\t\t\tret = argf(args, \"\"+\n-\t\t\t\t\t\"$3r0 := uint32($2($3r * $4))\\n\"+\n-\t\t\t\t\t\"$3g0 := uint32($2($3g * $4))\\n\"+\n-\t\t\t\t\t\"$3b0 := uint32($2($3b * $4))\\n\"+\n-\t\t\t\t\t\"$3a0 := uint32($2($3a * $4))\\n\"+\n-\t\t\t\t\t\"$3a1 := (0xffff - uint32($3a0)) * 0x101\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+0] = uint8((uint32(dst.Pix[d+0])*$3a1/0xffff + $3r0) >> 8)\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+1] = uint8((uint32(dst.Pix[d+1])*$3a1/0xffff + $3g0) >> 8)\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+2] = uint8((uint32(dst.Pix[d+2])*$3a1/0xffff + $3b0) >> 8)\\n\"+\n-\t\t\t\t\t\"dst.Pix[d+3] = uint8((uint32(dst.Pix[d+3])*$3a1/0xffff + $3a0) >> 8)\",\n-\t\t\t\t)\n-\t\t\t}\n-\n-\t\tcase \"Src\":\n-\t\t\tswitch d.dType {\n-\t\t\tdefault:\n-\t\t\t\tlog.Fatalf(\"bad dType %q\", d.dType)\n-\t\t\tcase \"Image\":\n-\t\t\t\tret = argf(args, \"\"+\n-\t\t\t\t\t\"if dstMask != nil {\\n\"+\n-\t\t\t\t\t\"\tqr, qg, qb, qa := dst.At($0, $1).RGBA()\\n\"+\n-\t\t\t\t\t\"\t_, _, _, ma := dstMask.At(dmp.X + $0, dmp.Y + $1).RGBA()\\n\"+\n-\t\t\t\t\t\"\tpr := uint32($2($3r * $4)) * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\tpg := uint32($2($3g * $4)) * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\tpb := uint32($2($3b * $4)) * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\tpa := uint32($2($3a * $4)) * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\tpa1 := 0xffff - ma\\n\"+ // Note that this is ma, not pa.\n-\t\t\t\t\t\"\tdstColorRGBA64.R = uint16(qr*pa1/0xffff + pr)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.G = uint16(qg*pa1/0xffff + pg)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.B = uint16(qb*pa1/0xffff + pb)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.A = uint16(qa*pa1/0xffff + pa)\\n\"+\n-\t\t\t\t\t\"\tdst.Set($0, $1, dstColor)\\n\"+\n-\t\t\t\t\t\"} else {\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.R = $2($3r * $4)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.G = $2($3g * $4)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.B = $2($3b * $4)\\n\"+\n-\t\t\t\t\t\"\tdstColorRGBA64.A = $2($3a * $4)\\n\"+\n-\t\t\t\t\t\"\tdst.Set($0, $1, dstColor)\\n\"+\n-\t\t\t\t\t\"}\",\n-\t\t\t\t)\n-\t\t\tcase \"*image.RGBA\":\n-\t\t\t\tswitch d.sType {\n-\t\t\t\tdefault:\n-\t\t\t\t\tret = argf(args, \"\"+\n-\t\t\t\t\t\t\"dst.Pix[d+0] = uint8($2($3r * $4) >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+1] = uint8($2($3g * $4) >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+2] = uint8($2($3b * $4) >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+3] = uint8($2($3a * $4) >> 8)\",\n-\t\t\t\t\t)\n-\t\t\t\tcase \"*image.Gray\":\n-\t\t\t\t\tret = argf(args, \"\"+\n-\t\t\t\t\t\t\"out := uint8($2($3r * $4) >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+0] = out\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+1] = out\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+2] = out\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+3] = 0xff\",\n-\t\t\t\t\t)\n-\t\t\t\tcase \"*image.YCbCr\":\n-\t\t\t\t\tret = argf(args, \"\"+\n-\t\t\t\t\t\t\"dst.Pix[d+0] = uint8($2($3r * $4) >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+1] = uint8($2($3g * $4) >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+2] = uint8($2($3b * $4) >> 8)\\n\"+\n-\t\t\t\t\t\t\"dst.Pix[d+3] = 0xff\",\n-\t\t\t\t\t)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn strings.Replace(ret, \" * 1)\", \")\", -1)\n-\n-\tcase \"srcf\", \"srcu\":\n-\t\tlhs, eqOp := splitEq(prefix)\n-\t\tif lhs == \"\" {\n-\t\t\treturn \"\"\n-\t\t}\n-\t\targs, extra := splitArgs(suffix)\n-\t\tif len(args) != 2 {\n-\t\t\treturn \"\"\n-\t\t}\n-\n-\t\ttmp := \"\"\n-\t\tif dollar == \"srcf\" {\n-\t\t\ttmp = \"u\"\n-\t\t}\n-\n-\t\t// TODO: there's no need to multiply by 0x101 in the switch below if\n-\t\t// the next thing we're going to do is shift right by 8.\n-\n-\t\tbuf := new(bytes.Buffer)\n-\t\tswitch d.sType {\n-\t\tdefault:\n-\t\t\tlog.Fatalf(\"bad sType %q\", d.sType)\n-\t\tcase \"image.Image\":\n-\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\"%sr%s, %sg%s, %sb%s, %sa%s := src.At(%s, %s).RGBA()\\n\",\n-\t\t\t\tlhs, tmp, lhs, tmp, lhs, tmp, lhs, tmp, args[0], args[1],\n-\t\t\t)\n-\t\t\tif d.dType == \"\" || d.dType == \"Image\" {\n-\t\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\t\"if srcMask != nil {\\n\"+\n-\t\t\t\t\t\"\t_, _, _, ma := srcMask.At(smp.X+%s, smp.Y+%s).RGBA()\\n\"+\n-\t\t\t\t\t\"\t%sr%s = %sr%s * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t%sg%s = %sg%s * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t%sb%s = %sb%s * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"\t%sa%s = %sa%s * ma / 0xffff\\n\"+\n-\t\t\t\t\t\"}\\n\",\n-\t\t\t\t\targs[0], args[1],\n-\t\t\t\t\tlhs, tmp, lhs, tmp,\n-\t\t\t\t\tlhs, tmp, lhs, tmp,\n-\t\t\t\t\tlhs, tmp, lhs, tmp,\n-\t\t\t\t\tlhs, tmp, lhs, tmp,\n-\t\t\t\t)\n-\t\t\t}\n-\t\tcase \"*image.Gray\":\n-\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\"%si := %s\\n\"+\n-\t\t\t\t\"%sr%s := uint32(src.Pix[%si]) * 0x101\\n\",\n-\t\t\t\tlhs, pixOffset(\"src\", args[0], args[1], \"\", \"*src.Stride\"),\n-\t\t\t\tlhs, tmp, lhs,\n-\t\t\t)\n-\t\tcase \"*image.NRGBA\":\n-\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\"%si := %s\\n\"+\n-\t\t\t\t\"%sa%s := uint32(src.Pix[%si+3]) * 0x101\\n\"+\n-\t\t\t\t\"%sr%s := uint32(src.Pix[%si+0]) * %sa%s / 0xff\\n\"+\n-\t\t\t\t\"%sg%s := uint32(src.Pix[%si+1]) * %sa%s / 0xff\\n\"+\n-\t\t\t\t\"%sb%s := uint32(src.Pix[%si+2]) * %sa%s / 0xff\\n\",\n-\t\t\t\tlhs, pixOffset(\"src\", args[0], args[1], \"*4\", \"*src.Stride\"),\n-\t\t\t\tlhs, tmp, lhs,\n-\t\t\t\tlhs, tmp, lhs, lhs, tmp,\n-\t\t\t\tlhs, tmp, lhs, lhs, tmp,\n-\t\t\t\tlhs, tmp, lhs, lhs, tmp,\n-\t\t\t)\n-\t\tcase \"*image.RGBA\":\n-\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\"%si := %s\\n\"+\n-\t\t\t\t\"%sr%s := uint32(src.Pix[%si+0]) * 0x101\\n\"+\n-\t\t\t\t\"%sg%s := uint32(src.Pix[%si+1]) * 0x101\\n\"+\n-\t\t\t\t\"%sb%s := uint32(src.Pix[%si+2]) * 0x101\\n\"+\n-\t\t\t\t\"%sa%s := uint32(src.Pix[%si+3]) * 0x101\\n\",\n-\t\t\t\tlhs, pixOffset(\"src\", args[0], args[1], \"*4\", \"*src.Stride\"),\n-\t\t\t\tlhs, tmp, lhs,\n-\t\t\t\tlhs, tmp, lhs,\n-\t\t\t\tlhs, tmp, lhs,\n-\t\t\t\tlhs, tmp, lhs,\n-\t\t\t)\n-\t\tcase \"*image.YCbCr\":\n-\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\"%si := %s\\n\"+\n-\t\t\t\t\"%sj := %s\\n\"+\n-\t\t\t\t\"%s\\n\",\n-\t\t\t\tlhs, pixOffset(\"src\", args[0], args[1], \"\", \"*src.YStride\"),\n-\t\t\t\tlhs, cOffset(args[0], args[1], d.sratio),\n-\t\t\t\tycbcrToRGB(lhs, tmp),\n-\t\t\t)\n-\t\t}\n-\n-\t\tif dollar == \"srcf\" {\n-\t\t\tswitch d.sType {\n-\t\t\tdefault:\n-\t\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\t\"%sr %s float64(%sru)%s\\n\"+\n-\t\t\t\t\t\"%sg %s float64(%sgu)%s\\n\"+\n-\t\t\t\t\t\"%sb %s float64(%sbu)%s\\n\"+\n-\t\t\t\t\t\"%sa %s float64(%sau)%s\\n\",\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t)\n-\t\t\tcase \"*image.Gray\":\n-\t\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\t\"%sr %s float64(%sru)%s\\n\",\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t)\n-\t\t\tcase \"*image.YCbCr\":\n-\t\t\t\tfmt.Fprintf(buf, \"\"+\n-\t\t\t\t\t\"%sr %s float64(%sru)%s\\n\"+\n-\t\t\t\t\t\"%sg %s float64(%sgu)%s\\n\"+\n-\t\t\t\t\t\"%sb %s float64(%sbu)%s\\n\",\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t\tlhs, eqOp, lhs, extra,\n-\t\t\t\t)\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn strings.TrimSpace(buf.String())\n-\n-\tcase \"tweakD\":\n-\t\tif d.dType == \"*image.RGBA\" {\n-\t\t\treturn \"d += dst.Stride\"\n-\t\t}\n-\t\treturn \";\"\n-\n-\tcase \"tweakDx\":\n-\t\tif d.dType == \"*image.RGBA\" {\n-\t\t\treturn strings.Replace(prefix, \"dx++\", \"dx, d = dx+1, d+4\", 1)\n-\t\t}\n-\t\treturn prefix\n-\n-\tcase \"tweakDy\":\n-\t\tif d.dType == \"*image.RGBA\" {\n-\t\t\treturn strings.Replace(prefix, \"for dy, s\", \"for _, s\", 1)\n-\t\t}\n-\t\treturn prefix\n-\n-\tcase \"tweakP\":\n-\t\tswitch d.sType {\n-\t\tcase \"*image.Gray\":\n-\t\t\tif strings.HasPrefix(strings.TrimSpace(prefix), \"pa * \") {\n-\t\t\t\treturn \"1,\"\n-\t\t\t}\n-\t\t\treturn \"pr,\"\n-\t\tcase \"*image.YCbCr\":\n-\t\t\tif strings.HasPrefix(strings.TrimSpace(prefix), \"pa * \") {\n-\t\t\t\treturn \"1,\"\n-\t\t\t}\n-\t\t}\n-\t\treturn prefix\n-\n-\tcase \"tweakPr\":\n-\t\tif d.sType == \"*image.Gray\" {\n-\t\t\treturn \"pr *= s.invTotalWeightFFFF\"\n-\t\t}\n-\t\treturn \";\"\n-\n-\tcase \"tweakVarP\":\n-\t\tswitch d.sType {\n-\t\tcase \"*image.Gray\":\n-\t\t\treturn strings.Replace(prefix, \"var pr, pg, pb, pa\", \"var pr\", 1)\n-\t\tcase \"*image.YCbCr\":\n-\t\t\treturn strings.Replace(prefix, \"var pr, pg, pb, pa\", \"var pr, pg, pb\", 1)\n-\t\t}\n-\t\treturn prefix\n-\t}\n-\treturn \"\"\n-}\n-\n-func expnSwitch(op, dType string, expandBoth bool, template string) string {\n-\tif op == \"\" && dType != \"anyDType\" {\n-\t\tlines := []string{\"switch op {\"}\n-\t\tfor _, op = range ops {\n-\t\t\tlines = append(lines,\n-\t\t\t\tfmt.Sprintf(\"case %s:\", op),\n-\t\t\t\texpnSwitch(op, dType, expandBoth, template),\n-\t\t\t)\n-\t\t}\n-\t\tlines = append(lines, \"}\")\n-\t\treturn strings.Join(lines, \"\\n\")\n-\t}\n-\n-\tswitchVar := \"dst\"\n-\tif dType != \"\" {\n-\t\tswitchVar = \"src\"\n-\t}\n-\tlines := []string{fmt.Sprintf(\"switch %s := %s.(type) {\", switchVar, switchVar)}\n-\n-\tfallback, values := \"Image\", dTypes\n-\tif dType != \"\" {\n-\t\tfallback, values = \"image.Image\", sTypesForDType[dType]\n-\t}\n-\tfor _, v := range values {\n-\t\tif dType != \"\" {\n-\t\t\t// v is the sType. Skip those always-opaque sTypes, where Over is\n-\t\t\t// equivalent to Src.\n-\t\t\tif op == \"Over\" && alwaysOpaque[v] {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n-\n-\t\tif v == fallback {\n-\t\t\tlines = append(lines, \"default:\")\n-\t\t} else {\n-\t\t\tlines = append(lines, fmt.Sprintf(\"case %s:\", v))\n-\t\t}\n-\n-\t\tif dType != \"\" {\n-\t\t\tif v == \"*image.YCbCr\" {\n-\t\t\t\tlines = append(lines, expnSwitchYCbCr(op, dType, template))\n-\t\t\t} else {\n-\t\t\t\tlines = append(lines, expnLine(template, &data{dType: dType, sType: v, op: op}))\n-\t\t\t}\n-\t\t} else if !expandBoth {\n-\t\t\tlines = append(lines, expnLine(template, &data{dType: v, op: op}))\n-\t\t} else {\n-\t\t\tlines = append(lines, expnSwitch(op, v, false, template))\n-\t\t}\n-\t}\n-\n-\tlines = append(lines, \"}\")\n-\treturn strings.Join(lines, \"\\n\")\n-}\n-\n-func expnSwitchYCbCr(op, dType, template string) string {\n-\tlines := []string{\n-\t\t\"switch src.SubsampleRatio {\",\n-\t\t\"default:\",\n-\t\texpnLine(template, &data{dType: dType, sType: \"image.Image\", op: op}),\n-\t}\n-\tfor _, sratio := range subsampleRatios {\n-\t\tlines = append(lines,\n-\t\t\tfmt.Sprintf(\"case image.YCbCrSubsampleRatio%s:\", sratio),\n-\t\t\texpnLine(template, &data{dType: dType, sType: \"*image.YCbCr\", sratio: sratio, op: op}),\n-\t\t)\n-\t}\n-\tlines = append(lines, \"}\")\n-\treturn strings.Join(lines, \"\\n\")\n-}\n-\n-func argf(args []string, s string) string {\n-\tif len(args) > 9 {\n-\t\tpanic(\"too many args\")\n-\t}\n-\tfor i, a := range args {\n-\t\told := fmt.Sprintf(\"$%d\", i)\n-\t\ts = strings.Replace(s, old, a, -1)\n-\t}\n-\treturn s\n-}\n-\n-func pixOffset(m, x, y, xstride, ystride string) string {\n-\treturn fmt.Sprintf(\"(%s-%s.Rect.Min.Y)%s + (%s-%s.Rect.Min.X)%s\", y, m, ystride, x, m, xstride)\n-}\n-\n-func cOffset(x, y, sratio string) string {\n-\tswitch sratio {\n-\tcase \"444\":\n-\t\treturn fmt.Sprintf(\"( %s    - src.Rect.Min.Y  )*src.CStride + ( %s    - src.Rect.Min.X  )\", y, x)\n-\tcase \"422\":\n-\t\treturn fmt.Sprintf(\"( %s    - src.Rect.Min.Y  )*src.CStride + ((%s)/2 - src.Rect.Min.X/2)\", y, x)\n-\tcase \"420\":\n-\t\treturn fmt.Sprintf(\"((%s)/2 - src.Rect.Min.Y/2)*src.CStride + ((%s)/2 - src.Rect.Min.X/2)\", y, x)\n-\tcase \"440\":\n-\t\treturn fmt.Sprintf(\"((%s)/2 - src.Rect.Min.Y/2)*src.CStride + ( %s    - src.Rect.Min.X  )\", y, x)\n-\t}\n-\treturn fmt.Sprintf(\"unsupported sratio %q\", sratio)\n-}\n-\n-func ycbcrToRGB(lhs, tmp string) string {\n-\ts := `\n-\t\t// This is an inline version of image/color/ycbcr.go's YCbCr.RGBA method.\n-\t\t$yy1 := int(src.Y[$i]) * 0x10101\n-\t\t$cb1 := int(src.Cb[$j]) - 128\n-\t\t$cr1 := int(src.Cr[$j]) - 128\n-\t\t$r@ := ($yy1 + 91881*$cr1) >> 8\n-\t\t$g@ := ($yy1 - 22554*$cb1 - 46802*$cr1) >> 8\n-\t\t$b@ := ($yy1 + 116130*$cb1) >> 8\n-\t\tif $r@ < 0 {\n-\t\t\t$r@ = 0\n-\t\t} else if $r@ > 0xffff {\n-\t\t\t$r@ = 0xffff\n-\t\t}\n-\t\tif $g@ < 0 {\n-\t\t\t$g@ = 0\n-\t\t} else if $g@ > 0xffff {\n-\t\t\t$g@ = 0xffff\n-\t\t}\n-\t\tif $b@ < 0 {\n-\t\t\t$b@ = 0\n-\t\t} else if $b@ > 0xffff {\n-\t\t\t$b@ = 0xffff\n-\t\t}\n-\t`\n-\ts = strings.Replace(s, \"$\", lhs, -1)\n-\ts = strings.Replace(s, \"@\", tmp, -1)\n-\treturn s\n-}\n-\n-func split(s, sep string) (string, string) {\n-\tif i := strings.Index(s, sep); i >= 0 {\n-\t\treturn strings.TrimSpace(s[:i]), strings.TrimSpace(s[i+len(sep):])\n-\t}\n-\treturn \"\", \"\"\n-}\n-\n-func splitEq(s string) (lhs, eqOp string) {\n-\ts = strings.TrimSpace(s)\n-\tif lhs, _ = split(s, \":=\"); lhs != \"\" {\n-\t\treturn lhs, \":=\"\n-\t}\n-\tif lhs, _ = split(s, \"+=\"); lhs != \"\" {\n-\t\treturn lhs, \"+=\"\n-\t}\n-\treturn \"\", \"\"\n-}\n-\n-func splitArgs(s string) (args []string, extra string) {\n-\ts = strings.TrimSpace(s)\n-\tif s == \"\" || s[0] != '[' {\n-\t\treturn nil, \"\"\n-\t}\n-\ts = s[1:]\n-\n-\ti := strings.IndexByte(s, ']')\n-\tif i < 0 {\n-\t\treturn nil, \"\"\n-\t}\n-\targs, extra = strings.Split(s[:i], \",\"), s[i+1:]\n-\tfor i := range args {\n-\t\targs[i] = strings.TrimSpace(args[i])\n-\t}\n-\treturn args, extra\n-}\n-\n-func relName(s string) string {\n-\tif i := strings.LastIndex(s, \".\"); i >= 0 {\n-\t\treturn s[i+1:]\n-\t}\n-\treturn s\n-}\n-\n-const (\n-\tcodeRoot = `\n-\t\tfunc (z $receiver) Scale(dst Image, dr image.Rectangle, src image.Image, sr image.Rectangle, op Op, opts *Options) {\n-\t\t\t// Try to simplify a Scale to a Copy when DstMask is not specified.\n-\t\t\t// If DstMask is not nil, Copy will call Scale back with same dr and sr, and cause stack overflow.\n-\t\t\tif dr.Size() == sr.Size() && (opts == nil || opts.DstMask == nil) {\n-\t\t\t\tCopy(dst, dr.Min, src, sr, op, opts)\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\tvar o Options\n-\t\t\tif opts != nil {\n-\t\t\t\to = *opts\n-\t\t\t}\n-\n-\t\t\t// adr is the affected destination pixels.\n-\t\t\tadr := dst.Bounds().Intersect(dr)\n-\t\t\tadr, o.DstMask = clipAffectedDestRect(adr, o.DstMask, o.DstMaskP)\n-\t\t\tif adr.Empty() || sr.Empty() {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\t// Make adr relative to dr.Min.\n-\t\t\tadr = adr.Sub(dr.Min)\n-\t\t\tif op == Over && o.SrcMask == nil && opaque(src) {\n-\t\t\t\top = Src\n-\t\t\t}\n-\n-\t\t\t// sr is the source pixels. If it extends beyond the src bounds,\n-\t\t\t// we cannot use the type-specific fast paths, as they access\n-\t\t\t// the Pix fields directly without bounds checking.\n-\t\t\t//\n-\t\t\t// Similarly, the fast paths assume that the masks are nil.\n-\t\t\tif o.DstMask != nil || o.SrcMask != nil || !sr.In(src.Bounds()) {\n-\t\t\t\tswitch op {\n-\t\t\t\tcase Over:\n-\t\t\t\t\tz.scale_Image_Image_Over(dst, dr, adr, src, sr, &o)\n-\t\t\t\tcase Src:\n-\t\t\t\t\tz.scale_Image_Image_Src(dst, dr, adr, src, sr, &o)\n-\t\t\t\t}\n-\t\t\t} else if _, ok := src.(*image.Uniform); ok {\n-\t\t\t\tDraw(dst, dr, src, src.Bounds().Min, op)\n-\t\t\t} else {\n-\t\t\t\t$switch z.scale_$dTypeRN_$sTypeRN$sratio_$op(dst, dr, adr, src, sr, &o)\n-\t\t\t}\n-\t\t}\n-\n-\t\tfunc (z $receiver) Transform(dst Image, s2d f64.Aff3, src image.Image, sr image.Rectangle, op Op, opts *Options) {\n-\t\t\t// Try to simplify a Transform to a Copy.\n-\t\t\tif s2d[0] == 1 && s2d[1] == 0 && s2d[3] == 0 && s2d[4] == 1 {\n-\t\t\t\tdx := int(s2d[2])\n-\t\t\t\tdy := int(s2d[5])\n-\t\t\t\tif float64(dx) == s2d[2] && float64(dy) == s2d[5] {\n-\t\t\t\t\tCopy(dst, image.Point{X: sr.Min.X + dx, Y: sr.Min.X + dy}, src, sr, op, opts)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tvar o Options\n-\t\t\tif opts != nil {\n-\t\t\t\to = *opts\n-\t\t\t}\n-\n-\t\t\tdr := transformRect(&s2d, &sr)\n-\t\t\t// adr is the affected destination pixels.\n-\t\t\tadr := dst.Bounds().Intersect(dr)\n-\t\t\tadr, o.DstMask = clipAffectedDestRect(adr, o.DstMask, o.DstMaskP)\n-\t\t\tif adr.Empty() || sr.Empty() {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif op == Over && o.SrcMask == nil && opaque(src) {\n-\t\t\t\top = Src\n-\t\t\t}\n-\n-\t\t\td2s := invert(&s2d)\n-\t\t\t// bias is a translation of the mapping from dst coordinates to src\n-\t\t\t// coordinates such that the latter temporarily have non-negative X\n-\t\t\t// and Y coordinates. This allows us to write int(f) instead of\n-\t\t\t// int(math.Floor(f)), since \"round to zero\" and \"round down\" are\n-\t\t\t// equivalent when f >= 0, but the former is much cheaper. The X--\n-\t\t\t// and Y-- are because the TransformLeaf methods have a \"sx -= 0.5\"\n-\t\t\t// adjustment.\n-\t\t\tbias := transformRect(&d2s, &adr).Min\n-\t\t\tbias.X--\n-\t\t\tbias.Y--\n-\t\t\td2s[2] -= float64(bias.X)\n-\t\t\td2s[5] -= float64(bias.Y)\n-\t\t\t// Make adr relative to dr.Min.\n-\t\t\tadr = adr.Sub(dr.Min)\n-\t\t\t// sr is the source pixels. If it extends beyond the src bounds,\n-\t\t\t// we cannot use the type-specific fast paths, as they access\n-\t\t\t// the Pix fields directly without bounds checking.\n-\t\t\t//\n-\t\t\t// Similarly, the fast paths assume that the masks are nil.\n-\t\t\tif o.DstMask != nil || o.SrcMask != nil || !sr.In(src.Bounds()) {\n-\t\t\t\tswitch op {\n-\t\t\t\tcase Over:\n-\t\t\t\t\tz.transform_Image_Image_Over(dst, dr, adr, &d2s, src, sr, bias, &o)\n-\t\t\t\tcase Src:\n-\t\t\t\t\tz.transform_Image_Image_Src(dst, dr, adr, &d2s, src, sr, bias, &o)\n-\t\t\t\t}\n-\t\t\t} else if u, ok := src.(*image.Uniform); ok {\n-\t\t\t\ttransform_Uniform(dst, dr, adr, &d2s, u, sr, bias, op)\n-\t\t\t} else {\n-\t\t\t\t$switch z.transform_$dTypeRN_$sTypeRN$sratio_$op(dst, dr, adr, &d2s, src, sr, bias, &o)\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeNNScaleLeaf = `\n-\t\tfunc (nnInterpolator) scale_$dTypeRN_$sTypeRN$sratio_$op(dst $dType, dr, adr image.Rectangle, src $sType, sr image.Rectangle, opts *Options) {\n-\t\t\tdw2 := uint64(dr.Dx()) * 2\n-\t\t\tdh2 := uint64(dr.Dy()) * 2\n-\t\t\tsw := uint64(sr.Dx())\n-\t\t\tsh := uint64(sr.Dy())\n-\t\t\t$preOuter\n-\t\t\tfor dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {\n-\t\t\t\tsy := (2*uint64(dy) + 1) * sh / dh2\n-\t\t\t\t$preInner\n-\t\t\t\tfor dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ { $tweakDx\n-\t\t\t\t\tsx := (2*uint64(dx) + 1) * sw / dw2\n-\t\t\t\t\tp := $srcu[sr.Min.X + int(sx), sr.Min.Y + int(sy)]\n-\t\t\t\t\t$outputu[dr.Min.X + int(dx), dr.Min.Y + int(dy), p]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeNNTransformLeaf = `\n-\t\tfunc (nnInterpolator) transform_$dTypeRN_$sTypeRN$sratio_$op(dst $dType, dr, adr image.Rectangle, d2s *f64.Aff3, src $sType, sr image.Rectangle, bias image.Point, opts *Options) {\n-\t\t\t$preOuter\n-\t\t\tfor dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {\n-\t\t\t\tdyf := float64(dr.Min.Y + int(dy)) + 0.5\n-\t\t\t\t$preInner\n-\t\t\t\tfor dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ { $tweakDx\n-\t\t\t\t\tdxf := float64(dr.Min.X + int(dx)) + 0.5\n-\t\t\t\t\tsx0 := int(d2s[0]*dxf + d2s[1]*dyf + d2s[2]) + bias.X\n-\t\t\t\t\tsy0 := int(d2s[3]*dxf + d2s[4]*dyf + d2s[5]) + bias.Y\n-\t\t\t\t\tif !(image.Point{sx0, sy0}).In(sr) {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\tp := $srcu[sx0, sy0]\n-\t\t\t\t\t$outputu[dr.Min.X + int(dx), dr.Min.Y + int(dy), p]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeABLScaleLeaf = `\n-\t\tfunc (ablInterpolator) scale_$dTypeRN_$sTypeRN$sratio_$op(dst $dType, dr, adr image.Rectangle, src $sType, sr image.Rectangle, opts *Options) {\n-\t\t\tsw := int32(sr.Dx())\n-\t\t\tsh := int32(sr.Dy())\n-\t\t\tyscale := float64(sh) / float64(dr.Dy())\n-\t\t\txscale := float64(sw) / float64(dr.Dx())\n-\t\t\tswMinus1, shMinus1 := sw - 1, sh - 1\n-\t\t\t$preOuter\n-\n-\t\t\tfor dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {\n-\t\t\t\tsy := (float64(dy)+0.5)*yscale - 0.5\n-\t\t\t\t// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if\n-\t\t\t\t// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for\n-\t\t\t\t// sx, below.\n-\t\t\t\tsy0 := int32(sy)\n-\t\t\t\tyFrac0 := sy - float64(sy0)\n-\t\t\t\tyFrac1 := 1 - yFrac0\n-\t\t\t\tsy1 := sy0 + 1\n-\t\t\t\tif sy < 0 {\n-\t\t\t\t\tsy0, sy1 = 0, 0\n-\t\t\t\t\tyFrac0, yFrac1 = 0, 1\n-\t\t\t\t} else if sy1 > shMinus1 {\n-\t\t\t\t\tsy0, sy1 = shMinus1, shMinus1\n-\t\t\t\t\tyFrac0, yFrac1 = 1, 0\n-\t\t\t\t}\n-\t\t\t\t$preInner\n-\n-\t\t\t\tfor dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ { $tweakDx\n-\t\t\t\t\tsx := (float64(dx)+0.5)*xscale - 0.5\n-\t\t\t\t\tsx0 := int32(sx)\n-\t\t\t\t\txFrac0 := sx - float64(sx0)\n-\t\t\t\t\txFrac1 := 1 - xFrac0\n-\t\t\t\t\tsx1 := sx0 + 1\n-\t\t\t\t\tif sx < 0 {\n-\t\t\t\t\t\tsx0, sx1 = 0, 0\n-\t\t\t\t\t\txFrac0, xFrac1 = 0, 1\n-\t\t\t\t\t} else if sx1 > swMinus1 {\n-\t\t\t\t\t\tsx0, sx1 = swMinus1, swMinus1\n-\t\t\t\t\t\txFrac0, xFrac1 = 1, 0\n-\t\t\t\t\t}\n-\n-\t\t\t\t\ts00 := $srcf[sr.Min.X + int(sx0), sr.Min.Y + int(sy0)]\n-\t\t\t\t\ts10 := $srcf[sr.Min.X + int(sx1), sr.Min.Y + int(sy0)]\n-\t\t\t\t\t$blend[xFrac1, s00, xFrac0, s10]\n-\t\t\t\t\ts01 := $srcf[sr.Min.X + int(sx0), sr.Min.Y + int(sy1)]\n-\t\t\t\t\ts11 := $srcf[sr.Min.X + int(sx1), sr.Min.Y + int(sy1)]\n-\t\t\t\t\t$blend[xFrac1, s01, xFrac0, s11]\n-\t\t\t\t\t$blend[yFrac1, s10, yFrac0, s11]\n-\t\t\t\t\t$convFtou[p, s11]\n-\t\t\t\t\t$outputu[dr.Min.X + int(dx), dr.Min.Y + int(dy), p]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeABLTransformLeaf = `\n-\t\tfunc (ablInterpolator) transform_$dTypeRN_$sTypeRN$sratio_$op(dst $dType, dr, adr image.Rectangle, d2s *f64.Aff3, src $sType, sr image.Rectangle, bias image.Point, opts *Options) {\n-\t\t\t$preOuter\n-\t\t\tfor dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {\n-\t\t\t\tdyf := float64(dr.Min.Y + int(dy)) + 0.5\n-\t\t\t\t$preInner\n-\t\t\t\tfor dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ { $tweakDx\n-\t\t\t\t\tdxf := float64(dr.Min.X + int(dx)) + 0.5\n-\t\t\t\t\tsx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]\n-\t\t\t\t\tsy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]\n-\t\t\t\t\tif !(image.Point{int(sx) + bias.X, int(sy) + bias.Y}).In(sr) {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tsx -= 0.5\n-\t\t\t\t\tsx0 := int(sx)\n-\t\t\t\t\txFrac0 := sx - float64(sx0)\n-\t\t\t\t\txFrac1 := 1 - xFrac0\n-\t\t\t\t\tsx0 += bias.X\n-\t\t\t\t\tsx1 := sx0 + 1\n-\t\t\t\t\tif sx0 < sr.Min.X {\n-\t\t\t\t\t\tsx0, sx1 = sr.Min.X, sr.Min.X\n-\t\t\t\t\t\txFrac0, xFrac1 = 0, 1\n-\t\t\t\t\t} else if sx1 >= sr.Max.X {\n-\t\t\t\t\t\tsx0, sx1 = sr.Max.X-1, sr.Max.X-1\n-\t\t\t\t\t\txFrac0, xFrac1 = 1, 0\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tsy -= 0.5\n-\t\t\t\t\tsy0 := int(sy)\n-\t\t\t\t\tyFrac0 := sy - float64(sy0)\n-\t\t\t\t\tyFrac1 := 1 - yFrac0\n-\t\t\t\t\tsy0 += bias.Y\n-\t\t\t\t\tsy1 := sy0 + 1\n-\t\t\t\t\tif sy0 < sr.Min.Y {\n-\t\t\t\t\t\tsy0, sy1 = sr.Min.Y, sr.Min.Y\n-\t\t\t\t\t\tyFrac0, yFrac1 = 0, 1\n-\t\t\t\t\t} else if sy1 >= sr.Max.Y {\n-\t\t\t\t\t\tsy0, sy1 = sr.Max.Y-1, sr.Max.Y-1\n-\t\t\t\t\t\tyFrac0, yFrac1 = 1, 0\n-\t\t\t\t\t}\n-\n-\t\t\t\t\ts00 := $srcf[sx0, sy0]\n-\t\t\t\t\ts10 := $srcf[sx1, sy0]\n-\t\t\t\t\t$blend[xFrac1, s00, xFrac0, s10]\n-\t\t\t\t\ts01 := $srcf[sx0, sy1]\n-\t\t\t\t\ts11 := $srcf[sx1, sy1]\n-\t\t\t\t\t$blend[xFrac1, s01, xFrac0, s11]\n-\t\t\t\t\t$blend[yFrac1, s10, yFrac0, s11]\n-\t\t\t\t\t$convFtou[p, s11]\n-\t\t\t\t\t$outputu[dr.Min.X + int(dx), dr.Min.Y + int(dy), p]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeKernelRoot = `\n-\t\tfunc (z *kernelScaler) Scale(dst Image, dr image.Rectangle, src image.Image, sr image.Rectangle, op Op, opts *Options) {\n-\t\t\tif z.dw != int32(dr.Dx()) || z.dh != int32(dr.Dy()) || z.sw != int32(sr.Dx()) || z.sh != int32(sr.Dy()) {\n-\t\t\t\tz.kernel.Scale(dst, dr, src, sr, op, opts)\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\tvar o Options\n-\t\t\tif opts != nil {\n-\t\t\t\to = *opts\n-\t\t\t}\n-\n-\t\t\t// adr is the affected destination pixels.\n-\t\t\tadr := dst.Bounds().Intersect(dr)\n-\t\t\tadr, o.DstMask = clipAffectedDestRect(adr, o.DstMask, o.DstMaskP)\n-\t\t\tif adr.Empty() || sr.Empty() {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\t// Make adr relative to dr.Min.\n-\t\t\tadr = adr.Sub(dr.Min)\n-\t\t\tif op == Over && o.SrcMask == nil && opaque(src) {\n-\t\t\t\top = Src\n-\t\t\t}\n-\n-\t\t\tif _, ok := src.(*image.Uniform); ok && o.DstMask == nil && o.SrcMask == nil && sr.In(src.Bounds()) {\n-\t\t\t\tDraw(dst, dr, src, src.Bounds().Min, op)\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\t// Create a temporary buffer:\n-\t\t\t// scaleX distributes the source image's columns over the temporary image.\n-\t\t\t// scaleY distributes the temporary image's rows over the destination image.\n-\t\t\tvar tmp [][4]float64\n-\t\t\tif z.pool.New != nil {\n-\t\t\t\ttmpp := z.pool.Get().(*[][4]float64)\n-\t\t\t\tdefer z.pool.Put(tmpp)\n-\t\t\t\ttmp = *tmpp\n-\t\t\t} else {\n-\t\t\t\ttmp = z.makeTmpBuf()\n-\t\t\t}\n-\n-\t\t\t// sr is the source pixels. If it extends beyond the src bounds,\n-\t\t\t// we cannot use the type-specific fast paths, as they access\n-\t\t\t// the Pix fields directly without bounds checking.\n-\t\t\t//\n-\t\t\t// Similarly, the fast paths assume that the masks are nil.\n-\t\t\tif o.SrcMask != nil || !sr.In(src.Bounds()) {\n-\t\t\t\tz.scaleX_Image(tmp, src, sr, &o)\n-\t\t\t} else {\n-\t\t\t\t$switchS z.scaleX_$sTypeRN$sratio(tmp, src, sr, &o)\n-\t\t\t}\n-\n-\t\t\tif o.DstMask != nil {\n-\t\t\t\tswitch op {\n-\t\t\t\tcase Over:\n-\t\t\t\t\tz.scaleY_Image_Over(dst, dr, adr, tmp, &o)\n-\t\t\t\tcase Src:\n-\t\t\t\t\tz.scaleY_Image_Src(dst, dr, adr, tmp, &o)\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t$switchD z.scaleY_$dTypeRN_$op(dst, dr, adr, tmp, &o)\n-\t\t\t}\n-\t\t}\n-\n-\t\tfunc (q *Kernel) Transform(dst Image, s2d f64.Aff3, src image.Image, sr image.Rectangle, op Op, opts *Options) {\n-\t\t\tvar o Options\n-\t\t\tif opts != nil {\n-\t\t\t\to = *opts\n-\t\t\t}\n-\n-\t\t\tdr := transformRect(&s2d, &sr)\n-\t\t\t// adr is the affected destination pixels.\n-\t\t\tadr := dst.Bounds().Intersect(dr)\n-\t\t\tadr, o.DstMask = clipAffectedDestRect(adr, o.DstMask, o.DstMaskP)\n-\t\t\tif adr.Empty() || sr.Empty() {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif op == Over && o.SrcMask == nil && opaque(src) {\n-\t\t\t\top = Src\n-\t\t\t}\n-\t\t\td2s := invert(&s2d)\n-\t\t\t// bias is a translation of the mapping from dst coordinates to src\n-\t\t\t// coordinates such that the latter temporarily have non-negative X\n-\t\t\t// and Y coordinates. This allows us to write int(f) instead of\n-\t\t\t// int(math.Floor(f)), since \"round to zero\" and \"round down\" are\n-\t\t\t// equivalent when f >= 0, but the former is much cheaper. The X--\n-\t\t\t// and Y-- are because the TransformLeaf methods have a \"sx -= 0.5\"\n-\t\t\t// adjustment.\n-\t\t\tbias := transformRect(&d2s, &adr).Min\n-\t\t\tbias.X--\n-\t\t\tbias.Y--\n-\t\t\td2s[2] -= float64(bias.X)\n-\t\t\td2s[5] -= float64(bias.Y)\n-\t\t\t// Make adr relative to dr.Min.\n-\t\t\tadr = adr.Sub(dr.Min)\n-\n-\t\t\tif u, ok := src.(*image.Uniform); ok && o.DstMask != nil && o.SrcMask != nil && sr.In(src.Bounds()) {\n-\t\t\t\ttransform_Uniform(dst, dr, adr, &d2s, u, sr, bias, op)\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\txscale := abs(d2s[0])\n-\t\t\tif s := abs(d2s[1]); xscale < s {\n-\t\t\t\txscale = s\n-\t\t\t}\n-\t\t\tyscale := abs(d2s[3])\n-\t\t\tif s := abs(d2s[4]); yscale < s {\n-\t\t\t\tyscale = s\n-\t\t\t}\n-\n-\t\t\t// sr is the source pixels. If it extends beyond the src bounds,\n-\t\t\t// we cannot use the type-specific fast paths, as they access\n-\t\t\t// the Pix fields directly without bounds checking.\n-\t\t\t//\n-\t\t\t// Similarly, the fast paths assume that the masks are nil.\n-\t\t\tif o.DstMask != nil || o.SrcMask != nil || !sr.In(src.Bounds()) {\n-\t\t\t\tswitch op {\n-\t\t\t\tcase Over:\n-\t\t\t\t\tq.transform_Image_Image_Over(dst, dr, adr, &d2s, src, sr, bias, xscale, yscale, &o)\n-\t\t\t\tcase Src:\n-\t\t\t\t\tq.transform_Image_Image_Src(dst, dr, adr, &d2s, src, sr, bias, xscale, yscale, &o)\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t$switch q.transform_$dTypeRN_$sTypeRN$sratio_$op(dst, dr, adr, &d2s, src, sr, bias, xscale, yscale, &o)\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeKernelScaleLeafX = `\n-\t\tfunc (z *kernelScaler) scaleX_$sTypeRN$sratio(tmp [][4]float64, src $sType, sr image.Rectangle, opts *Options) {\n-\t\t\tt := 0\n-\t\t\t$preKernelOuter\n-\t\t\tfor y := int32(0); y < z.sh; y++ {\n-\t\t\t\tfor _, s := range z.horizontal.sources {\n-\t\t\t\t\tvar pr, pg, pb, pa float64 $tweakVarP\n-\t\t\t\t\tfor _, c := range z.horizontal.contribs[s.i:s.j] {\n-\t\t\t\t\t\tp += $srcf[sr.Min.X + int(c.coord), sr.Min.Y + int(y)] * c.weight\n-\t\t\t\t\t}\n-\t\t\t\t\t$tweakPr\n-\t\t\t\t\ttmp[t] = [4]float64{\n-\t\t\t\t\t\tpr * s.invTotalWeightFFFF, $tweakP\n-\t\t\t\t\t\tpg * s.invTotalWeightFFFF, $tweakP\n-\t\t\t\t\t\tpb * s.invTotalWeightFFFF, $tweakP\n-\t\t\t\t\t\tpa * s.invTotalWeightFFFF, $tweakP\n-\t\t\t\t\t}\n-\t\t\t\t\tt++\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeKernelScaleLeafY = `\n-\t\tfunc (z *kernelScaler) scaleY_$dTypeRN_$op(dst $dType, dr, adr image.Rectangle, tmp [][4]float64, opts *Options) {\n-\t\t\t$preOuter\n-\t\t\tfor dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {\n-\t\t\t\t$preKernelInner\n-\t\t\t\tfor dy, s := range z.vertical.sources[adr.Min.Y:adr.Max.Y] { $tweakDy\n-\t\t\t\t\tvar pr, pg, pb, pa float64\n-\t\t\t\t\tfor _, c := range z.vertical.contribs[s.i:s.j] {\n-\t\t\t\t\t\tp := &tmp[c.coord*z.dw+dx]\n-\t\t\t\t\t\tpr += p[0] * c.weight\n-\t\t\t\t\t\tpg += p[1] * c.weight\n-\t\t\t\t\t\tpb += p[2] * c.weight\n-\t\t\t\t\t\tpa += p[3] * c.weight\n-\t\t\t\t\t}\n-\t\t\t\t\t$clampToAlpha\n-\t\t\t\t\t$outputf[dr.Min.X + int(dx), dr.Min.Y + int(adr.Min.Y + dy), ftou, p, s.invTotalWeight]\n-\t\t\t\t\t$tweakD\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t`\n-\n-\tcodeKernelTransformLeaf = `\n-\t\tfunc (q *Kernel) transform_$dTypeRN_$sTypeRN$sratio_$op(dst $dType, dr, adr image.Rectangle, d2s *f64.Aff3, src $sType, sr image.Rectangle, bias image.Point, xscale, yscale float64, opts *Options) {\n-\t\t\t// When shrinking, broaden the effective kernel support so that we still\n-\t\t\t// visit every source pixel.\n-\t\t\txHalfWidth, xKernelArgScale := q.Support, 1.0\n-\t\t\tif xscale > 1 {\n-\t\t\t\txHalfWidth *= xscale\n-\t\t\t\txKernelArgScale = 1 / xscale\n-\t\t\t}\n-\t\t\tyHalfWidth, yKernelArgScale := q.Support, 1.0\n-\t\t\tif yscale > 1 {\n-\t\t\t\tyHalfWidth *= yscale\n-\t\t\t\tyKernelArgScale = 1 / yscale\n-\t\t\t}\n-\n-\t\t\txWeights := make([]float64, 1 + 2*int(math.Ceil(xHalfWidth)))\n-\t\t\tyWeights := make([]float64, 1 + 2*int(math.Ceil(yHalfWidth)))\n-\n-\t\t\t$preOuter\n-\t\t\tfor dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {\n-\t\t\t\tdyf := float64(dr.Min.Y + int(dy)) + 0.5\n-\t\t\t\t$preInner\n-\t\t\t\tfor dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ { $tweakDx\n-\t\t\t\t\tdxf := float64(dr.Min.X + int(dx)) + 0.5\n-\t\t\t\t\tsx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]\n-\t\t\t\t\tsy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]\n-\t\t\t\t\tif !(image.Point{int(sx) + bias.X, int(sy) + bias.Y}).In(sr) {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// TODO: adjust the bias so that we can use int(f) instead\n-\t\t\t\t\t// of math.Floor(f) and math.Ceil(f).\n-\t\t\t\t\tsx += float64(bias.X)\n-\t\t\t\t\tsx -= 0.5\n-\t\t\t\t\tix := int(math.Floor(sx - xHalfWidth))\n-\t\t\t\t\tif ix < sr.Min.X {\n-\t\t\t\t\t\tix = sr.Min.X\n-\t\t\t\t\t}\n-\t\t\t\t\tjx := int(math.Ceil(sx + xHalfWidth))\n-\t\t\t\t\tif jx > sr.Max.X {\n-\t\t\t\t\t\tjx = sr.Max.X\n-\t\t\t\t\t}\n-\n-\t\t\t\t\ttotalXWeight := 0.0\n-\t\t\t\t\tfor kx := ix; kx < jx; kx++ {\n-\t\t\t\t\t\txWeight := 0.0\n-\t\t\t\t\t\tif t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {\n-\t\t\t\t\t\t\txWeight = q.At(t)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\txWeights[kx - ix] = xWeight\n-\t\t\t\t\t\ttotalXWeight += xWeight\n-\t\t\t\t\t}\n-\t\t\t\t\tfor x := range xWeights[:jx-ix] {\n-\t\t\t\t\t\txWeights[x] /= totalXWeight\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tsy += float64(bias.Y)\n-\t\t\t\t\tsy -= 0.5\n-\t\t\t\t\tiy := int(math.Floor(sy - yHalfWidth))\n-\t\t\t\t\tif iy < sr.Min.Y {\n-\t\t\t\t\t\tiy = sr.Min.Y\n-\t\t\t\t\t}\n-\t\t\t\t\tjy := int(math.Ceil(sy + yHalfWidth))\n-\t\t\t\t\tif jy > sr.Max.Y {\n-\t\t\t\t\t\tjy = sr.Max.Y\n-\t\t\t\t\t}\n-\n-\t\t\t\t\ttotalYWeight := 0.0\n-\t\t\t\t\tfor ky := iy; ky < jy; ky++ {\n-\t\t\t\t\t\tyWeight := 0.0\n-\t\t\t\t\t\tif t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {\n-\t\t\t\t\t\t\tyWeight = q.At(t)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tyWeights[ky - iy] = yWeight\n-\t\t\t\t\t\ttotalYWeight += yWeight\n-\t\t\t\t\t}\n-\t\t\t\t\tfor y := range yWeights[:jy-iy] {\n-\t\t\t\t\t\tyWeights[y] /= totalYWeight\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tvar pr, pg, pb, pa float64 $tweakVarP\n-\t\t\t\t\tfor ky := iy; ky < jy; ky++ {\n-\t\t\t\t\t\tif yWeight := yWeights[ky - iy]; yWeight != 0 {\n-\t\t\t\t\t\t\tfor kx := ix; kx < jx; kx++ {\n-\t\t\t\t\t\t\t\tif w := xWeights[kx - ix] * yWeight; w != 0 {\n-\t\t\t\t\t\t\t\t\tp += $srcf[kx, ky] * w\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t$clampToAlpha\n-\t\t\t\t\t$outputf[dr.Min.X + int(dx), dr.Min.Y + int(dy), fffftou, p, 1]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t`\n-)"
    },
    {
      "sha": "5d052781bceaf8504923cff6da7d4a5f22044169",
      "filename": "backend/vendor/golang.org/x/net/html/atom/gen.go",
      "status": "removed",
      "additions": 0,
      "deletions": 712,
      "changes": 712,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/net/html/atom/gen.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/net/html/atom/gen.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/atom/gen.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,712 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-//go:generate go run gen.go\n-//go:generate go run gen.go -test\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"go/format\"\n-\t\"io/ioutil\"\n-\t\"math/rand\"\n-\t\"os\"\n-\t\"sort\"\n-\t\"strings\"\n-)\n-\n-// identifier converts s to a Go exported identifier.\n-// It converts \"div\" to \"Div\" and \"accept-charset\" to \"AcceptCharset\".\n-func identifier(s string) string {\n-\tb := make([]byte, 0, len(s))\n-\tcap := true\n-\tfor _, c := range s {\n-\t\tif c == '-' {\n-\t\t\tcap = true\n-\t\t\tcontinue\n-\t\t}\n-\t\tif cap && 'a' <= c && c <= 'z' {\n-\t\t\tc -= 'a' - 'A'\n-\t\t}\n-\t\tcap = false\n-\t\tb = append(b, byte(c))\n-\t}\n-\treturn string(b)\n-}\n-\n-var test = flag.Bool(\"test\", false, \"generate table_test.go\")\n-\n-func genFile(name string, buf *bytes.Buffer) {\n-\tb, err := format.Source(buf.Bytes())\n-\tif err != nil {\n-\t\tfmt.Fprintln(os.Stderr, err)\n-\t\tos.Exit(1)\n-\t}\n-\tif err := ioutil.WriteFile(name, b, 0644); err != nil {\n-\t\tfmt.Fprintln(os.Stderr, err)\n-\t\tos.Exit(1)\n-\t}\n-}\n-\n-func main() {\n-\tflag.Parse()\n-\n-\tvar all []string\n-\tall = append(all, elements...)\n-\tall = append(all, attributes...)\n-\tall = append(all, eventHandlers...)\n-\tall = append(all, extra...)\n-\tsort.Strings(all)\n-\n-\t// uniq - lists have dups\n-\tw := 0\n-\tfor _, s := range all {\n-\t\tif w == 0 || all[w-1] != s {\n-\t\t\tall[w] = s\n-\t\t\tw++\n-\t\t}\n-\t}\n-\tall = all[:w]\n-\n-\tif *test {\n-\t\tvar buf bytes.Buffer\n-\t\tfmt.Fprintln(&buf, \"// Code generated by go generate gen.go; DO NOT EDIT.\\n\")\n-\t\tfmt.Fprintln(&buf, \"//go:generate go run gen.go -test\\n\")\n-\t\tfmt.Fprintln(&buf, \"package atom\\n\")\n-\t\tfmt.Fprintln(&buf, \"var testAtomList = []string{\")\n-\t\tfor _, s := range all {\n-\t\t\tfmt.Fprintf(&buf, \"\\t%q,\\n\", s)\n-\t\t}\n-\t\tfmt.Fprintln(&buf, \"}\")\n-\n-\t\tgenFile(\"table_test.go\", &buf)\n-\t\treturn\n-\t}\n-\n-\t// Find hash that minimizes table size.\n-\tvar best *table\n-\tfor i := 0; i < 1000000; i++ {\n-\t\tif best != nil && 1<<(best.k-1) < len(all) {\n-\t\t\tbreak\n-\t\t}\n-\t\th := rand.Uint32()\n-\t\tfor k := uint(0); k <= 16; k++ {\n-\t\t\tif best != nil && k >= best.k {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tvar t table\n-\t\t\tif t.init(h, k, all) {\n-\t\t\t\tbest = &t\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif best == nil {\n-\t\tfmt.Fprintf(os.Stderr, \"failed to construct string table\\n\")\n-\t\tos.Exit(1)\n-\t}\n-\n-\t// Lay out strings, using overlaps when possible.\n-\tlayout := append([]string{}, all...)\n-\n-\t// Remove strings that are substrings of other strings\n-\tfor changed := true; changed; {\n-\t\tchanged = false\n-\t\tfor i, s := range layout {\n-\t\t\tif s == \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tfor j, t := range layout {\n-\t\t\t\tif i != j && t != \"\" && strings.Contains(s, t) {\n-\t\t\t\t\tchanged = true\n-\t\t\t\t\tlayout[j] = \"\"\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Join strings where one suffix matches another prefix.\n-\tfor {\n-\t\t// Find best i, j, k such that layout[i][len-k:] == layout[j][:k],\n-\t\t// maximizing overlap length k.\n-\t\tbesti := -1\n-\t\tbestj := -1\n-\t\tbestk := 0\n-\t\tfor i, s := range layout {\n-\t\t\tif s == \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tfor j, t := range layout {\n-\t\t\t\tif i == j {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tfor k := bestk + 1; k <= len(s) && k <= len(t); k++ {\n-\t\t\t\t\tif s[len(s)-k:] == t[:k] {\n-\t\t\t\t\t\tbesti = i\n-\t\t\t\t\t\tbestj = j\n-\t\t\t\t\t\tbestk = k\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif bestk > 0 {\n-\t\t\tlayout[besti] += layout[bestj][bestk:]\n-\t\t\tlayout[bestj] = \"\"\n-\t\t\tcontinue\n-\t\t}\n-\t\tbreak\n-\t}\n-\n-\ttext := strings.Join(layout, \"\")\n-\n-\tatom := map[string]uint32{}\n-\tfor _, s := range all {\n-\t\toff := strings.Index(text, s)\n-\t\tif off < 0 {\n-\t\t\tpanic(\"lost string \" + s)\n-\t\t}\n-\t\tatom[s] = uint32(off<<8 | len(s))\n-\t}\n-\n-\tvar buf bytes.Buffer\n-\t// Generate the Go code.\n-\tfmt.Fprintln(&buf, \"// Code generated by go generate gen.go; DO NOT EDIT.\\n\")\n-\tfmt.Fprintln(&buf, \"//go:generate go run gen.go\\n\")\n-\tfmt.Fprintln(&buf, \"package atom\\n\\nconst (\")\n-\n-\t// compute max len\n-\tmaxLen := 0\n-\tfor _, s := range all {\n-\t\tif maxLen < len(s) {\n-\t\t\tmaxLen = len(s)\n-\t\t}\n-\t\tfmt.Fprintf(&buf, \"\\t%s Atom = %#x\\n\", identifier(s), atom[s])\n-\t}\n-\tfmt.Fprintln(&buf, \")\\n\")\n-\n-\tfmt.Fprintf(&buf, \"const hash0 = %#x\\n\\n\", best.h0)\n-\tfmt.Fprintf(&buf, \"const maxAtomLen = %d\\n\\n\", maxLen)\n-\n-\tfmt.Fprintf(&buf, \"var table = [1<<%d]Atom{\\n\", best.k)\n-\tfor i, s := range best.tab {\n-\t\tif s == \"\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tfmt.Fprintf(&buf, \"\\t%#x: %#x, // %s\\n\", i, atom[s], s)\n-\t}\n-\tfmt.Fprintf(&buf, \"}\\n\")\n-\tdatasize := (1 << best.k) * 4\n-\n-\tfmt.Fprintln(&buf, \"const atomText =\")\n-\ttextsize := len(text)\n-\tfor len(text) > 60 {\n-\t\tfmt.Fprintf(&buf, \"\\t%q +\\n\", text[:60])\n-\t\ttext = text[60:]\n-\t}\n-\tfmt.Fprintf(&buf, \"\\t%q\\n\\n\", text)\n-\n-\tgenFile(\"table.go\", &buf)\n-\n-\tfmt.Fprintf(os.Stdout, \"%d atoms; %d string bytes + %d tables = %d total data\\n\", len(all), textsize, datasize, textsize+datasize)\n-}\n-\n-type byLen []string\n-\n-func (x byLen) Less(i, j int) bool { return len(x[i]) > len(x[j]) }\n-func (x byLen) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n-func (x byLen) Len() int           { return len(x) }\n-\n-// fnv computes the FNV hash with an arbitrary starting value h.\n-func fnv(h uint32, s string) uint32 {\n-\tfor i := 0; i < len(s); i++ {\n-\t\th ^= uint32(s[i])\n-\t\th *= 16777619\n-\t}\n-\treturn h\n-}\n-\n-// A table represents an attempt at constructing the lookup table.\n-// The lookup table uses cuckoo hashing, meaning that each string\n-// can be found in one of two positions.\n-type table struct {\n-\th0   uint32\n-\tk    uint\n-\tmask uint32\n-\ttab  []string\n-}\n-\n-// hash returns the two hashes for s.\n-func (t *table) hash(s string) (h1, h2 uint32) {\n-\th := fnv(t.h0, s)\n-\th1 = h & t.mask\n-\th2 = (h >> 16) & t.mask\n-\treturn\n-}\n-\n-// init initializes the table with the given parameters.\n-// h0 is the initial hash value,\n-// k is the number of bits of hash value to use, and\n-// x is the list of strings to store in the table.\n-// init returns false if the table cannot be constructed.\n-func (t *table) init(h0 uint32, k uint, x []string) bool {\n-\tt.h0 = h0\n-\tt.k = k\n-\tt.tab = make([]string, 1<<k)\n-\tt.mask = 1<<k - 1\n-\tfor _, s := range x {\n-\t\tif !t.insert(s) {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-// insert inserts s in the table.\n-func (t *table) insert(s string) bool {\n-\th1, h2 := t.hash(s)\n-\tif t.tab[h1] == \"\" {\n-\t\tt.tab[h1] = s\n-\t\treturn true\n-\t}\n-\tif t.tab[h2] == \"\" {\n-\t\tt.tab[h2] = s\n-\t\treturn true\n-\t}\n-\tif t.push(h1, 0) {\n-\t\tt.tab[h1] = s\n-\t\treturn true\n-\t}\n-\tif t.push(h2, 0) {\n-\t\tt.tab[h2] = s\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-// push attempts to push aside the entry in slot i.\n-func (t *table) push(i uint32, depth int) bool {\n-\tif depth > len(t.tab) {\n-\t\treturn false\n-\t}\n-\ts := t.tab[i]\n-\th1, h2 := t.hash(s)\n-\tj := h1 + h2 - i\n-\tif t.tab[j] != \"\" && !t.push(j, depth+1) {\n-\t\treturn false\n-\t}\n-\tt.tab[j] = s\n-\treturn true\n-}\n-\n-// The lists of element names and attribute keys were taken from\n-// https://html.spec.whatwg.org/multipage/indices.html#index\n-// as of the \"HTML Living Standard - Last Updated 16 April 2018\" version.\n-\n-// \"command\", \"keygen\" and \"menuitem\" have been removed from the spec,\n-// but are kept here for backwards compatibility.\n-var elements = []string{\n-\t\"a\",\n-\t\"abbr\",\n-\t\"address\",\n-\t\"area\",\n-\t\"article\",\n-\t\"aside\",\n-\t\"audio\",\n-\t\"b\",\n-\t\"base\",\n-\t\"bdi\",\n-\t\"bdo\",\n-\t\"blockquote\",\n-\t\"body\",\n-\t\"br\",\n-\t\"button\",\n-\t\"canvas\",\n-\t\"caption\",\n-\t\"cite\",\n-\t\"code\",\n-\t\"col\",\n-\t\"colgroup\",\n-\t\"command\",\n-\t\"data\",\n-\t\"datalist\",\n-\t\"dd\",\n-\t\"del\",\n-\t\"details\",\n-\t\"dfn\",\n-\t\"dialog\",\n-\t\"div\",\n-\t\"dl\",\n-\t\"dt\",\n-\t\"em\",\n-\t\"embed\",\n-\t\"fieldset\",\n-\t\"figcaption\",\n-\t\"figure\",\n-\t\"footer\",\n-\t\"form\",\n-\t\"h1\",\n-\t\"h2\",\n-\t\"h3\",\n-\t\"h4\",\n-\t\"h5\",\n-\t\"h6\",\n-\t\"head\",\n-\t\"header\",\n-\t\"hgroup\",\n-\t\"hr\",\n-\t\"html\",\n-\t\"i\",\n-\t\"iframe\",\n-\t\"img\",\n-\t\"input\",\n-\t\"ins\",\n-\t\"kbd\",\n-\t\"keygen\",\n-\t\"label\",\n-\t\"legend\",\n-\t\"li\",\n-\t\"link\",\n-\t\"main\",\n-\t\"map\",\n-\t\"mark\",\n-\t\"menu\",\n-\t\"menuitem\",\n-\t\"meta\",\n-\t\"meter\",\n-\t\"nav\",\n-\t\"noscript\",\n-\t\"object\",\n-\t\"ol\",\n-\t\"optgroup\",\n-\t\"option\",\n-\t\"output\",\n-\t\"p\",\n-\t\"param\",\n-\t\"picture\",\n-\t\"pre\",\n-\t\"progress\",\n-\t\"q\",\n-\t\"rp\",\n-\t\"rt\",\n-\t\"ruby\",\n-\t\"s\",\n-\t\"samp\",\n-\t\"script\",\n-\t\"section\",\n-\t\"select\",\n-\t\"slot\",\n-\t\"small\",\n-\t\"source\",\n-\t\"span\",\n-\t\"strong\",\n-\t\"style\",\n-\t\"sub\",\n-\t\"summary\",\n-\t\"sup\",\n-\t\"table\",\n-\t\"tbody\",\n-\t\"td\",\n-\t\"template\",\n-\t\"textarea\",\n-\t\"tfoot\",\n-\t\"th\",\n-\t\"thead\",\n-\t\"time\",\n-\t\"title\",\n-\t\"tr\",\n-\t\"track\",\n-\t\"u\",\n-\t\"ul\",\n-\t\"var\",\n-\t\"video\",\n-\t\"wbr\",\n-}\n-\n-// https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n-//\n-// \"challenge\", \"command\", \"contextmenu\", \"dropzone\", \"icon\", \"keytype\", \"mediagroup\",\n-// \"radiogroup\", \"spellcheck\", \"scoped\", \"seamless\", \"sortable\" and \"sorted\" have been removed from the spec,\n-// but are kept here for backwards compatibility.\n-var attributes = []string{\n-\t\"abbr\",\n-\t\"accept\",\n-\t\"accept-charset\",\n-\t\"accesskey\",\n-\t\"action\",\n-\t\"allowfullscreen\",\n-\t\"allowpaymentrequest\",\n-\t\"allowusermedia\",\n-\t\"alt\",\n-\t\"as\",\n-\t\"async\",\n-\t\"autocomplete\",\n-\t\"autofocus\",\n-\t\"autoplay\",\n-\t\"challenge\",\n-\t\"charset\",\n-\t\"checked\",\n-\t\"cite\",\n-\t\"class\",\n-\t\"color\",\n-\t\"cols\",\n-\t\"colspan\",\n-\t\"command\",\n-\t\"content\",\n-\t\"contenteditable\",\n-\t\"contextmenu\",\n-\t\"controls\",\n-\t\"coords\",\n-\t\"crossorigin\",\n-\t\"data\",\n-\t\"datetime\",\n-\t\"default\",\n-\t\"defer\",\n-\t\"dir\",\n-\t\"dirname\",\n-\t\"disabled\",\n-\t\"download\",\n-\t\"draggable\",\n-\t\"dropzone\",\n-\t\"enctype\",\n-\t\"for\",\n-\t\"form\",\n-\t\"formaction\",\n-\t\"formenctype\",\n-\t\"formmethod\",\n-\t\"formnovalidate\",\n-\t\"formtarget\",\n-\t\"headers\",\n-\t\"height\",\n-\t\"hidden\",\n-\t\"high\",\n-\t\"href\",\n-\t\"hreflang\",\n-\t\"http-equiv\",\n-\t\"icon\",\n-\t\"id\",\n-\t\"inputmode\",\n-\t\"integrity\",\n-\t\"is\",\n-\t\"ismap\",\n-\t\"itemid\",\n-\t\"itemprop\",\n-\t\"itemref\",\n-\t\"itemscope\",\n-\t\"itemtype\",\n-\t\"keytype\",\n-\t\"kind\",\n-\t\"label\",\n-\t\"lang\",\n-\t\"list\",\n-\t\"loop\",\n-\t\"low\",\n-\t\"manifest\",\n-\t\"max\",\n-\t\"maxlength\",\n-\t\"media\",\n-\t\"mediagroup\",\n-\t\"method\",\n-\t\"min\",\n-\t\"minlength\",\n-\t\"multiple\",\n-\t\"muted\",\n-\t\"name\",\n-\t\"nomodule\",\n-\t\"nonce\",\n-\t\"novalidate\",\n-\t\"open\",\n-\t\"optimum\",\n-\t\"pattern\",\n-\t\"ping\",\n-\t\"placeholder\",\n-\t\"playsinline\",\n-\t\"poster\",\n-\t\"preload\",\n-\t\"radiogroup\",\n-\t\"readonly\",\n-\t\"referrerpolicy\",\n-\t\"rel\",\n-\t\"required\",\n-\t\"reversed\",\n-\t\"rows\",\n-\t\"rowspan\",\n-\t\"sandbox\",\n-\t\"spellcheck\",\n-\t\"scope\",\n-\t\"scoped\",\n-\t\"seamless\",\n-\t\"selected\",\n-\t\"shape\",\n-\t\"size\",\n-\t\"sizes\",\n-\t\"sortable\",\n-\t\"sorted\",\n-\t\"slot\",\n-\t\"span\",\n-\t\"spellcheck\",\n-\t\"src\",\n-\t\"srcdoc\",\n-\t\"srclang\",\n-\t\"srcset\",\n-\t\"start\",\n-\t\"step\",\n-\t\"style\",\n-\t\"tabindex\",\n-\t\"target\",\n-\t\"title\",\n-\t\"translate\",\n-\t\"type\",\n-\t\"typemustmatch\",\n-\t\"updateviacache\",\n-\t\"usemap\",\n-\t\"value\",\n-\t\"width\",\n-\t\"workertype\",\n-\t\"wrap\",\n-}\n-\n-// \"onautocomplete\", \"onautocompleteerror\", \"onmousewheel\",\n-// \"onshow\" and \"onsort\" have been removed from the spec,\n-// but are kept here for backwards compatibility.\n-var eventHandlers = []string{\n-\t\"onabort\",\n-\t\"onautocomplete\",\n-\t\"onautocompleteerror\",\n-\t\"onauxclick\",\n-\t\"onafterprint\",\n-\t\"onbeforeprint\",\n-\t\"onbeforeunload\",\n-\t\"onblur\",\n-\t\"oncancel\",\n-\t\"oncanplay\",\n-\t\"oncanplaythrough\",\n-\t\"onchange\",\n-\t\"onclick\",\n-\t\"onclose\",\n-\t\"oncontextmenu\",\n-\t\"oncopy\",\n-\t\"oncuechange\",\n-\t\"oncut\",\n-\t\"ondblclick\",\n-\t\"ondrag\",\n-\t\"ondragend\",\n-\t\"ondragenter\",\n-\t\"ondragexit\",\n-\t\"ondragleave\",\n-\t\"ondragover\",\n-\t\"ondragstart\",\n-\t\"ondrop\",\n-\t\"ondurationchange\",\n-\t\"onemptied\",\n-\t\"onended\",\n-\t\"onerror\",\n-\t\"onfocus\",\n-\t\"onhashchange\",\n-\t\"oninput\",\n-\t\"oninvalid\",\n-\t\"onkeydown\",\n-\t\"onkeypress\",\n-\t\"onkeyup\",\n-\t\"onlanguagechange\",\n-\t\"onload\",\n-\t\"onloadeddata\",\n-\t\"onloadedmetadata\",\n-\t\"onloadend\",\n-\t\"onloadstart\",\n-\t\"onmessage\",\n-\t\"onmessageerror\",\n-\t\"onmousedown\",\n-\t\"onmouseenter\",\n-\t\"onmouseleave\",\n-\t\"onmousemove\",\n-\t\"onmouseout\",\n-\t\"onmouseover\",\n-\t\"onmouseup\",\n-\t\"onmousewheel\",\n-\t\"onwheel\",\n-\t\"onoffline\",\n-\t\"ononline\",\n-\t\"onpagehide\",\n-\t\"onpageshow\",\n-\t\"onpaste\",\n-\t\"onpause\",\n-\t\"onplay\",\n-\t\"onplaying\",\n-\t\"onpopstate\",\n-\t\"onprogress\",\n-\t\"onratechange\",\n-\t\"onreset\",\n-\t\"onresize\",\n-\t\"onrejectionhandled\",\n-\t\"onscroll\",\n-\t\"onsecuritypolicyviolation\",\n-\t\"onseeked\",\n-\t\"onseeking\",\n-\t\"onselect\",\n-\t\"onshow\",\n-\t\"onsort\",\n-\t\"onstalled\",\n-\t\"onstorage\",\n-\t\"onsubmit\",\n-\t\"onsuspend\",\n-\t\"ontimeupdate\",\n-\t\"ontoggle\",\n-\t\"onunhandledrejection\",\n-\t\"onunload\",\n-\t\"onvolumechange\",\n-\t\"onwaiting\",\n-}\n-\n-// extra are ad-hoc values not covered by any of the lists above.\n-var extra = []string{\n-\t\"acronym\",\n-\t\"align\",\n-\t\"annotation\",\n-\t\"annotation-xml\",\n-\t\"applet\",\n-\t\"basefont\",\n-\t\"bgsound\",\n-\t\"big\",\n-\t\"blink\",\n-\t\"center\",\n-\t\"color\",\n-\t\"desc\",\n-\t\"face\",\n-\t\"font\",\n-\t\"foreignObject\", // HTML is case-insensitive, but SVG-embedded-in-HTML is case-sensitive.\n-\t\"foreignobject\",\n-\t\"frame\",\n-\t\"frameset\",\n-\t\"image\",\n-\t\"isindex\",\n-\t\"listing\",\n-\t\"malignmark\",\n-\t\"marquee\",\n-\t\"math\",\n-\t\"mglyph\",\n-\t\"mi\",\n-\t\"mn\",\n-\t\"mo\",\n-\t\"ms\",\n-\t\"mtext\",\n-\t\"nobr\",\n-\t\"noembed\",\n-\t\"noframes\",\n-\t\"plaintext\",\n-\t\"prompt\",\n-\t\"public\",\n-\t\"rb\",\n-\t\"rtc\",\n-\t\"spacer\",\n-\t\"strike\",\n-\t\"svg\",\n-\t\"system\",\n-\t\"tt\",\n-\t\"xmp\",\n-}"
    },
    {
      "sha": "4548b993dbcc52a83ba7e944a6d7d8dd9de3b049",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go",
      "status": "removed",
      "additions": 0,
      "deletions": 61,
      "changes": 61,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// mkasm_darwin.go generates assembly trampolines to call libSystem routines from Go.\n-//This program must be run after mksyscall.go.\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"log\"\n-\t\"os\"\n-\t\"strings\"\n-)\n-\n-func main() {\n-\tin1, err := ioutil.ReadFile(\"syscall_darwin.go\")\n-\tif err != nil {\n-\t\tlog.Fatalf(\"can't open syscall_darwin.go: %s\", err)\n-\t}\n-\tarch := os.Args[1]\n-\tin2, err := ioutil.ReadFile(fmt.Sprintf(\"syscall_darwin_%s.go\", arch))\n-\tif err != nil {\n-\t\tlog.Fatalf(\"can't open syscall_darwin_%s.go: %s\", arch, err)\n-\t}\n-\tin3, err := ioutil.ReadFile(fmt.Sprintf(\"zsyscall_darwin_%s.go\", arch))\n-\tif err != nil {\n-\t\tlog.Fatalf(\"can't open zsyscall_darwin_%s.go: %s\", arch, err)\n-\t}\n-\tin := string(in1) + string(in2) + string(in3)\n-\n-\ttrampolines := map[string]bool{}\n-\n-\tvar out bytes.Buffer\n-\n-\tfmt.Fprintf(&out, \"// go run mkasm_darwin.go %s\\n\", strings.Join(os.Args[1:], \" \"))\n-\tfmt.Fprintf(&out, \"// Code generated by the command above; DO NOT EDIT.\\n\")\n-\tfmt.Fprintf(&out, \"\\n\")\n-\tfmt.Fprintf(&out, \"// +build go1.12\\n\")\n-\tfmt.Fprintf(&out, \"\\n\")\n-\tfmt.Fprintf(&out, \"#include \\\"textflag.h\\\"\\n\")\n-\tfor _, line := range strings.Split(in, \"\\n\") {\n-\t\tif !strings.HasPrefix(line, \"func \") || !strings.HasSuffix(line, \"_trampoline()\") {\n-\t\t\tcontinue\n-\t\t}\n-\t\tfn := line[5 : len(line)-13]\n-\t\tif !trampolines[fn] {\n-\t\t\ttrampolines[fn] = true\n-\t\t\tfmt.Fprintf(&out, \"TEXT %s_trampoline(SB),NOSPLIT,$0-0\\n\", fn)\n-\t\t\tfmt.Fprintf(&out, \"\\tJMP\\t%s(SB)\\n\", fn)\n-\t\t}\n-\t}\n-\terr = ioutil.WriteFile(fmt.Sprintf(\"zsyscall_darwin_%s.s\", arch), out.Bytes(), 0644)\n-\tif err != nil {\n-\t\tlog.Fatalf(\"can't write zsyscall_darwin_%s.s: %s\", arch, err)\n-\t}\n-}"
    },
    {
      "sha": "eb4332059aefda2ccc029a8a8115fe307d690c71",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkpost.go",
      "status": "removed",
      "additions": 0,
      "deletions": 122,
      "changes": 122,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mkpost.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mkpost.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkpost.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,122 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// mkpost processes the output of cgo -godefs to\n-// modify the generated types. It is used to clean up\n-// the sys API in an architecture specific manner.\n-//\n-// mkpost is run after cgo -godefs; see README.md.\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"go/format\"\n-\t\"io/ioutil\"\n-\t\"log\"\n-\t\"os\"\n-\t\"regexp\"\n-)\n-\n-func main() {\n-\t// Get the OS and architecture (using GOARCH_TARGET if it exists)\n-\tgoos := os.Getenv(\"GOOS\")\n-\tgoarch := os.Getenv(\"GOARCH_TARGET\")\n-\tif goarch == \"\" {\n-\t\tgoarch = os.Getenv(\"GOARCH\")\n-\t}\n-\t// Check that we are using the Docker-based build system if we should be.\n-\tif goos == \"linux\" {\n-\t\tif os.Getenv(\"GOLANG_SYS_BUILD\") != \"docker\" {\n-\t\t\tos.Stderr.WriteString(\"In the Docker-based build system, mkpost should not be called directly.\\n\")\n-\t\t\tos.Stderr.WriteString(\"See README.md\\n\")\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t}\n-\n-\tb, err := ioutil.ReadAll(os.Stdin)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\tif goos == \"aix\" {\n-\t\t// Replace type of Atim, Mtim and Ctim by Timespec in Stat_t\n-\t\t// to avoid having both StTimespec and Timespec.\n-\t\tsttimespec := regexp.MustCompile(`_Ctype_struct_st_timespec`)\n-\t\tb = sttimespec.ReplaceAll(b, []byte(\"Timespec\"))\n-\t}\n-\n-\t// Intentionally export __val fields in Fsid and Sigset_t\n-\tvalRegex := regexp.MustCompile(`type (Fsid|Sigset_t) struct {(\\s+)X__(bits|val)(\\s+\\S+\\s+)}`)\n-\tb = valRegex.ReplaceAll(b, []byte(\"type $1 struct {${2}Val$4}\"))\n-\n-\t// Intentionally export __fds_bits field in FdSet\n-\tfdSetRegex := regexp.MustCompile(`type (FdSet) struct {(\\s+)X__fds_bits(\\s+\\S+\\s+)}`)\n-\tb = fdSetRegex.ReplaceAll(b, []byte(\"type $1 struct {${2}Bits$3}\"))\n-\n-\t// If we have empty Ptrace structs, we should delete them. Only s390x emits\n-\t// nonempty Ptrace structs.\n-\tptraceRexexp := regexp.MustCompile(`type Ptrace((Psw|Fpregs|Per) struct {\\s*})`)\n-\tb = ptraceRexexp.ReplaceAll(b, nil)\n-\n-\t// Replace the control_regs union with a blank identifier for now.\n-\tcontrolRegsRegex := regexp.MustCompile(`(Control_regs)\\s+\\[0\\]uint64`)\n-\tb = controlRegsRegex.ReplaceAll(b, []byte(\"_ [0]uint64\"))\n-\n-\t// Remove fields that are added by glibc\n-\t// Note that this is unstable as the identifers are private.\n-\tremoveFieldsRegex := regexp.MustCompile(`X__glibc\\S*`)\n-\tb = removeFieldsRegex.ReplaceAll(b, []byte(\"_\"))\n-\n-\t// Convert [65]int8 to [65]byte in Utsname members to simplify\n-\t// conversion to string; see golang.org/issue/20753\n-\tconvertUtsnameRegex := regexp.MustCompile(`((Sys|Node|Domain)name|Release|Version|Machine)(\\s+)\\[(\\d+)\\]u?int8`)\n-\tb = convertUtsnameRegex.ReplaceAll(b, []byte(\"$1$3[$4]byte\"))\n-\n-\t// Convert [1024]int8 to [1024]byte in Ptmget members\n-\tconvertPtmget := regexp.MustCompile(`([SC]n)(\\s+)\\[(\\d+)\\]u?int8`)\n-\tb = convertPtmget.ReplaceAll(b, []byte(\"$1[$3]byte\"))\n-\n-\t// Remove spare fields (e.g. in Statx_t)\n-\tspareFieldsRegex := regexp.MustCompile(`X__spare\\S*`)\n-\tb = spareFieldsRegex.ReplaceAll(b, []byte(\"_\"))\n-\n-\t// Remove cgo padding fields\n-\tremovePaddingFieldsRegex := regexp.MustCompile(`Pad_cgo_\\d+`)\n-\tb = removePaddingFieldsRegex.ReplaceAll(b, []byte(\"_\"))\n-\n-\t// Remove padding, hidden, or unused fields\n-\tremoveFieldsRegex = regexp.MustCompile(`\\b(X_\\S+|Padding)`)\n-\tb = removeFieldsRegex.ReplaceAll(b, []byte(\"_\"))\n-\n-\t// Remove the first line of warning from cgo\n-\tb = b[bytes.IndexByte(b, '\\n')+1:]\n-\t// Modify the command in the header to include:\n-\t//  mkpost, our own warning, and a build tag.\n-\treplacement := fmt.Sprintf(`$1 | go run mkpost.go\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s,%s`, goarch, goos)\n-\tcgoCommandRegex := regexp.MustCompile(`(cgo -godefs .*)`)\n-\tb = cgoCommandRegex.ReplaceAll(b, []byte(replacement))\n-\n-\t// Rename Stat_t time fields\n-\tif goos == \"freebsd\" && goarch == \"386\" {\n-\t\t// Hide Stat_t.[AMCB]tim_ext fields\n-\t\trenameStatTimeExtFieldsRegex := regexp.MustCompile(`[AMCB]tim_ext`)\n-\t\tb = renameStatTimeExtFieldsRegex.ReplaceAll(b, []byte(\"_\"))\n-\t}\n-\trenameStatTimeFieldsRegex := regexp.MustCompile(`([AMCB])(?:irth)?time?(?:spec)?\\s+(Timespec|StTimespec)`)\n-\tb = renameStatTimeFieldsRegex.ReplaceAll(b, []byte(\"${1}tim ${2}\"))\n-\n-\t// gofmt\n-\tb, err = format.Source(b)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\n-\tos.Stdout.Write(b)\n-}"
    },
    {
      "sha": "e4af9424e97886239f52a5035fbe64c3402c4792",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "status": "removed",
      "additions": 0,
      "deletions": 407,
      "changes": 407,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,407 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-This program reads a file containing function prototypes\n-(like syscall_darwin.go) and generates system call bodies.\n-The prototypes are marked by lines beginning with \"//sys\"\n-and read like func declarations if //sys is replaced by func, but:\n-\t* The parameter lists must give a name for each argument.\n-\t  This includes return parameters.\n-\t* The parameter lists must give a type for each argument:\n-\t  the (x, y, z int) shorthand is not allowed.\n-\t* If the return parameter is an error number, it must be named errno.\n-\n-A line beginning with //sysnb is like //sys, except that the\n-goroutine will not be suspended during the execution of the system\n-call.  This must only be used for system calls which can never\n-block, as otherwise the system call could cause all goroutines to\n-hang.\n-*/\n-package main\n-\n-import (\n-\t\"bufio\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"regexp\"\n-\t\"strings\"\n-)\n-\n-var (\n-\tb32       = flag.Bool(\"b32\", false, \"32bit big-endian\")\n-\tl32       = flag.Bool(\"l32\", false, \"32bit little-endian\")\n-\tplan9     = flag.Bool(\"plan9\", false, \"plan9\")\n-\topenbsd   = flag.Bool(\"openbsd\", false, \"openbsd\")\n-\tnetbsd    = flag.Bool(\"netbsd\", false, \"netbsd\")\n-\tdragonfly = flag.Bool(\"dragonfly\", false, \"dragonfly\")\n-\tarm       = flag.Bool(\"arm\", false, \"arm\") // 64-bit value should use (even, odd)-pair\n-\ttags      = flag.String(\"tags\", \"\", \"build tags\")\n-\tfilename  = flag.String(\"output\", \"\", \"output file name (standard output if omitted)\")\n-)\n-\n-// cmdLine returns this programs's commandline arguments\n-func cmdLine() string {\n-\treturn \"go run mksyscall.go \" + strings.Join(os.Args[1:], \" \")\n-}\n-\n-// buildTags returns build tags\n-func buildTags() string {\n-\treturn *tags\n-}\n-\n-// Param is function parameter\n-type Param struct {\n-\tName string\n-\tType string\n-}\n-\n-// usage prints the program usage\n-func usage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: go run mksyscall.go [-b32 | -l32] [-tags x,y] [file ...]\\n\")\n-\tos.Exit(1)\n-}\n-\n-// parseParamList parses parameter list and returns a slice of parameters\n-func parseParamList(list string) []string {\n-\tlist = strings.TrimSpace(list)\n-\tif list == \"\" {\n-\t\treturn []string{}\n-\t}\n-\treturn regexp.MustCompile(`\\s*,\\s*`).Split(list, -1)\n-}\n-\n-// parseParam splits a parameter into name and type\n-func parseParam(p string) Param {\n-\tps := regexp.MustCompile(`^(\\S*) (\\S*)$`).FindStringSubmatch(p)\n-\tif ps == nil {\n-\t\tfmt.Fprintf(os.Stderr, \"malformed parameter: %s\\n\", p)\n-\t\tos.Exit(1)\n-\t}\n-\treturn Param{ps[1], ps[2]}\n-}\n-\n-func main() {\n-\t// Get the OS and architecture (using GOARCH_TARGET if it exists)\n-\tgoos := os.Getenv(\"GOOS\")\n-\tif goos == \"\" {\n-\t\tfmt.Fprintln(os.Stderr, \"GOOS not defined in environment\")\n-\t\tos.Exit(1)\n-\t}\n-\tgoarch := os.Getenv(\"GOARCH_TARGET\")\n-\tif goarch == \"\" {\n-\t\tgoarch = os.Getenv(\"GOARCH\")\n-\t}\n-\n-\t// Check that we are using the Docker-based build system if we should\n-\tif goos == \"linux\" {\n-\t\tif os.Getenv(\"GOLANG_SYS_BUILD\") != \"docker\" {\n-\t\t\tfmt.Fprintf(os.Stderr, \"In the Docker-based build system, mksyscall should not be called directly.\\n\")\n-\t\t\tfmt.Fprintf(os.Stderr, \"See README.md\\n\")\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t}\n-\n-\tflag.Usage = usage\n-\tflag.Parse()\n-\tif len(flag.Args()) <= 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"no files to parse provided\\n\")\n-\t\tusage()\n-\t}\n-\n-\tendianness := \"\"\n-\tif *b32 {\n-\t\tendianness = \"big-endian\"\n-\t} else if *l32 {\n-\t\tendianness = \"little-endian\"\n-\t}\n-\n-\tlibc := false\n-\tif goos == \"darwin\" && strings.Contains(buildTags(), \",go1.12\") {\n-\t\tlibc = true\n-\t}\n-\ttrampolines := map[string]bool{}\n-\n-\ttext := \"\"\n-\tfor _, path := range flag.Args() {\n-\t\tfile, err := os.Open(path)\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\ts := bufio.NewScanner(file)\n-\t\tfor s.Scan() {\n-\t\t\tt := s.Text()\n-\t\t\tt = strings.TrimSpace(t)\n-\t\t\tt = regexp.MustCompile(`\\s+`).ReplaceAllString(t, ` `)\n-\t\t\tnonblock := regexp.MustCompile(`^\\/\\/sysnb `).FindStringSubmatch(t)\n-\t\t\tif regexp.MustCompile(`^\\/\\/sys `).FindStringSubmatch(t) == nil && nonblock == nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// Line must be of the form\n-\t\t\t//\tfunc Open(path string, mode int, perm int) (fd int, errno error)\n-\t\t\t// Split into name, in params, out params.\n-\t\t\tf := regexp.MustCompile(`^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*((?i)SYS_[A-Z0-9_]+))?$`).FindStringSubmatch(t)\n-\t\t\tif f == nil {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s\\nmalformed //sys declaration\\n\", path, t)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\t\t\tfunct, inps, outps, sysname := f[2], f[3], f[4], f[5]\n-\n-\t\t\t// ClockGettime doesn't have a syscall number on Darwin, only generate libc wrappers.\n-\t\t\tif goos == \"darwin\" && !libc && funct == \"ClockGettime\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// Split argument lists on comma.\n-\t\t\tin := parseParamList(inps)\n-\t\t\tout := parseParamList(outps)\n-\n-\t\t\t// Try in vain to keep people from editing this file.\n-\t\t\t// The theory is that they jump into the middle of the file\n-\t\t\t// without reading the header.\n-\t\t\ttext += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n-\n-\t\t\t// Go function header.\n-\t\t\toutDecl := \"\"\n-\t\t\tif len(out) > 0 {\n-\t\t\t\toutDecl = fmt.Sprintf(\" (%s)\", strings.Join(out, \", \"))\n-\t\t\t}\n-\t\t\ttext += fmt.Sprintf(\"func %s(%s)%s {\\n\", funct, strings.Join(in, \", \"), outDecl)\n-\n-\t\t\t// Check if err return available\n-\t\t\terrvar := \"\"\n-\t\t\tfor _, param := range out {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif p.Type == \"error\" {\n-\t\t\t\t\terrvar = p.Name\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Prepare arguments to Syscall.\n-\t\t\tvar args []string\n-\t\t\tn := 0\n-\t\t\tfor _, param := range in {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\targs = append(args, \"uintptr(unsafe.Pointer(\"+p.Name+\"))\")\n-\t\t\t\t} else if p.Type == \"string\" && errvar != \"\" {\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d *byte\\n\", n)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d, %s = BytePtrFromString(%s)\\n\", n, errvar, p.Name)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tif %s != nil {\\n\\t\\treturn\\n\\t}\\n\", errvar)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"string\" {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses string arguments, but has no error return\\n\")\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d *byte\\n\", n)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d, _ = BytePtrFromString(%s)\\n\", n, p.Name)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\t// Convert slice into pointer, length.\n-\t\t\t\t\t// Have to be careful not to take address of &a[0] if len == 0:\n-\t\t\t\t\t// pass dummy pointer in that case.\n-\t\t\t\t\t// Used to pass nil, but some OSes or simulators reject write(fd, nil, 0).\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d unsafe.Pointer\\n\", n)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tif len(%s) > 0 {\\n\\t\\t_p%d = unsafe.Pointer(&%s[0])\\n\\t}\", p.Name, n, p.Name)\n-\t\t\t\t\ttext += fmt.Sprintf(\" else {\\n\\t\\t_p%d = unsafe.Pointer(&_zero)\\n\\t}\\n\", n)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(_p%d)\", n), fmt.Sprintf(\"uintptr(len(%s))\", p.Name))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"int64\" && (*openbsd || *netbsd) {\n-\t\t\t\t\targs = append(args, \"0\")\n-\t\t\t\t\tif endianness == \"big-endian\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s>>32)\", p.Name), fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t} else if endianness == \"little-endian\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name), fmt.Sprintf(\"uintptr(%s>>32)\", p.Name))\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t}\n-\t\t\t\t} else if p.Type == \"int64\" && *dragonfly {\n-\t\t\t\t\tif regexp.MustCompile(`^(?i)extp(read|write)`).FindStringSubmatch(funct) == nil {\n-\t\t\t\t\t\targs = append(args, \"0\")\n-\t\t\t\t\t}\n-\t\t\t\t\tif endianness == \"big-endian\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s>>32)\", p.Name), fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t} else if endianness == \"little-endian\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name), fmt.Sprintf(\"uintptr(%s>>32)\", p.Name))\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t}\n-\t\t\t\t} else if (p.Type == \"int64\" || p.Type == \"uint64\") && endianness != \"\" {\n-\t\t\t\t\tif len(args)%2 == 1 && *arm {\n-\t\t\t\t\t\t// arm abi specifies 64-bit argument uses\n-\t\t\t\t\t\t// (even, odd) pair\n-\t\t\t\t\t\targs = append(args, \"0\")\n-\t\t\t\t\t}\n-\t\t\t\t\tif endianness == \"big-endian\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s>>32)\", p.Name), fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name), fmt.Sprintf(\"uintptr(%s>>32)\", p.Name))\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Determine which form to use; pad args with zeros.\n-\t\t\tasm := \"Syscall\"\n-\t\t\tif nonblock != nil {\n-\t\t\t\tif errvar == \"\" && goos == \"linux\" {\n-\t\t\t\t\tasm = \"RawSyscallNoError\"\n-\t\t\t\t} else {\n-\t\t\t\t\tasm = \"RawSyscall\"\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif errvar == \"\" && goos == \"linux\" {\n-\t\t\t\t\tasm = \"SyscallNoError\"\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif len(args) <= 3 {\n-\t\t\t\tfor len(args) < 3 {\n-\t\t\t\t\targs = append(args, \"0\")\n-\t\t\t\t}\n-\t\t\t} else if len(args) <= 6 {\n-\t\t\t\tasm += \"6\"\n-\t\t\t\tfor len(args) < 6 {\n-\t\t\t\t\targs = append(args, \"0\")\n-\t\t\t\t}\n-\t\t\t} else if len(args) <= 9 {\n-\t\t\t\tasm += \"9\"\n-\t\t\t\tfor len(args) < 9 {\n-\t\t\t\t\targs = append(args, \"0\")\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s too many arguments to system call\\n\", path, funct)\n-\t\t\t}\n-\n-\t\t\t// System call number.\n-\t\t\tif sysname == \"\" {\n-\t\t\t\tsysname = \"SYS_\" + funct\n-\t\t\t\tsysname = regexp.MustCompile(`([a-z])([A-Z])`).ReplaceAllString(sysname, `${1}_$2`)\n-\t\t\t\tsysname = strings.ToUpper(sysname)\n-\t\t\t}\n-\n-\t\t\tvar libcFn string\n-\t\t\tif libc {\n-\t\t\t\tasm = \"syscall_\" + strings.ToLower(asm[:1]) + asm[1:] // internal syscall call\n-\t\t\t\tsysname = strings.TrimPrefix(sysname, \"SYS_\")         // remove SYS_\n-\t\t\t\tsysname = strings.ToLower(sysname)                    // lowercase\n-\t\t\t\tif sysname == \"getdirentries64\" {\n-\t\t\t\t\t// Special case - libSystem name and\n-\t\t\t\t\t// raw syscall name don't match.\n-\t\t\t\t\tsysname = \"__getdirentries64\"\n-\t\t\t\t}\n-\t\t\t\tlibcFn = sysname\n-\t\t\t\tsysname = \"funcPC(libc_\" + sysname + \"_trampoline)\"\n-\t\t\t}\n-\n-\t\t\t// Actual call.\n-\t\t\targlist := strings.Join(args, \", \")\n-\t\t\tcall := fmt.Sprintf(\"%s(%s, %s)\", asm, sysname, arglist)\n-\n-\t\t\t// Assign return values.\n-\t\t\tbody := \"\"\n-\t\t\tret := []string{\"_\", \"_\", \"_\"}\n-\t\t\tdoErrno := false\n-\t\t\tfor i := 0; i < len(out); i++ {\n-\t\t\t\tp := parseParam(out[i])\n-\t\t\t\treg := \"\"\n-\t\t\t\tif p.Name == \"err\" && !*plan9 {\n-\t\t\t\t\treg = \"e1\"\n-\t\t\t\t\tret[2] = reg\n-\t\t\t\t\tdoErrno = true\n-\t\t\t\t} else if p.Name == \"err\" && *plan9 {\n-\t\t\t\t\tret[0] = \"r0\"\n-\t\t\t\t\tret[2] = \"e1\"\n-\t\t\t\t\tbreak\n-\t\t\t\t} else {\n-\t\t\t\t\treg = fmt.Sprintf(\"r%d\", i)\n-\t\t\t\t\tret[i] = reg\n-\t\t\t\t}\n-\t\t\t\tif p.Type == \"bool\" {\n-\t\t\t\t\treg = fmt.Sprintf(\"%s != 0\", reg)\n-\t\t\t\t}\n-\t\t\t\tif p.Type == \"int64\" && endianness != \"\" {\n-\t\t\t\t\t// 64-bit number in r1:r0 or r0:r1.\n-\t\t\t\t\tif i+2 > len(out) {\n-\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s not enough registers for int64 return\\n\", path, funct)\n-\t\t\t\t\t}\n-\t\t\t\t\tif endianness == \"big-endian\" {\n-\t\t\t\t\t\treg = fmt.Sprintf(\"int64(r%d)<<32 | int64(r%d)\", i, i+1)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treg = fmt.Sprintf(\"int64(r%d)<<32 | int64(r%d)\", i+1, i)\n-\t\t\t\t\t}\n-\t\t\t\t\tret[i] = fmt.Sprintf(\"r%d\", i)\n-\t\t\t\t\tret[i+1] = fmt.Sprintf(\"r%d\", i+1)\n-\t\t\t\t}\n-\t\t\t\tif reg != \"e1\" || *plan9 {\n-\t\t\t\t\tbody += fmt.Sprintf(\"\\t%s = %s(%s)\\n\", p.Name, p.Type, reg)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif ret[0] == \"_\" && ret[1] == \"_\" && ret[2] == \"_\" {\n-\t\t\t\ttext += fmt.Sprintf(\"\\t%s\\n\", call)\n-\t\t\t} else {\n-\t\t\t\tif errvar == \"\" && goos == \"linux\" {\n-\t\t\t\t\t// raw syscall without error on Linux, see golang.org/issue/22924\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t%s, %s := %s\\n\", ret[0], ret[1], call)\n-\t\t\t\t} else {\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t%s, %s, %s := %s\\n\", ret[0], ret[1], ret[2], call)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\ttext += body\n-\n-\t\t\tif *plan9 && ret[2] == \"e1\" {\n-\t\t\t\ttext += \"\\tif int32(r0) == -1 {\\n\"\n-\t\t\t\ttext += \"\\t\\terr = e1\\n\"\n-\t\t\t\ttext += \"\\t}\\n\"\n-\t\t\t} else if doErrno {\n-\t\t\t\ttext += \"\\tif e1 != 0 {\\n\"\n-\t\t\t\ttext += \"\\t\\terr = errnoErr(e1)\\n\"\n-\t\t\t\ttext += \"\\t}\\n\"\n-\t\t\t}\n-\t\t\ttext += \"\\treturn\\n\"\n-\t\t\ttext += \"}\\n\\n\"\n-\n-\t\t\tif libc && !trampolines[libcFn] {\n-\t\t\t\t// some system calls share a trampoline, like read and readlen.\n-\t\t\t\ttrampolines[libcFn] = true\n-\t\t\t\t// Declare assembly trampoline.\n-\t\t\t\ttext += fmt.Sprintf(\"func libc_%s_trampoline()\\n\", libcFn)\n-\t\t\t\t// Assembly trampoline calls the libc_* function, which this magic\n-\t\t\t\t// redirects to use the function from libSystem.\n-\t\t\t\ttext += fmt.Sprintf(\"//go:linkname libc_%s libc_%s\\n\", libcFn, libcFn)\n-\t\t\t\ttext += fmt.Sprintf(\"//go:cgo_import_dynamic libc_%s %s \\\"/usr/lib/libSystem.B.dylib\\\"\\n\", libcFn, libcFn)\n-\t\t\t\ttext += \"\\n\"\n-\t\t\t}\n-\t\t}\n-\t\tif err := s.Err(); err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\tfile.Close()\n-\t}\n-\tfmt.Printf(srcTemplate, cmdLine(), buildTags(), text)\n-}\n-\n-const srcTemplate = `// %s\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s\n-\n-package unix\n-\n-import (\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-var _ syscall.Errno\n-\n-%s\n-`"
    },
    {
      "sha": "3be3cdfc3b6ee5f6273d4458cdc01f49cd6913d5",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go",
      "status": "removed",
      "additions": 0,
      "deletions": 415,
      "changes": 415,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,415 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-This program reads a file containing function prototypes\n-(like syscall_aix.go) and generates system call bodies.\n-The prototypes are marked by lines beginning with \"//sys\"\n-and read like func declarations if //sys is replaced by func, but:\n-\t* The parameter lists must give a name for each argument.\n-\t  This includes return parameters.\n-\t* The parameter lists must give a type for each argument:\n-\t  the (x, y, z int) shorthand is not allowed.\n-\t* If the return parameter is an error number, it must be named err.\n-\t* If go func name needs to be different than its libc name,\n-\t* or the function is not in libc, name could be specified\n-\t* at the end, after \"=\" sign, like\n-\t  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt\n-*/\n-package main\n-\n-import (\n-\t\"bufio\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"regexp\"\n-\t\"strings\"\n-)\n-\n-var (\n-\tb32  = flag.Bool(\"b32\", false, \"32bit big-endian\")\n-\tl32  = flag.Bool(\"l32\", false, \"32bit little-endian\")\n-\taix  = flag.Bool(\"aix\", false, \"aix\")\n-\ttags = flag.String(\"tags\", \"\", \"build tags\")\n-)\n-\n-// cmdLine returns this programs's commandline arguments\n-func cmdLine() string {\n-\treturn \"go run mksyscall_aix_ppc.go \" + strings.Join(os.Args[1:], \" \")\n-}\n-\n-// buildTags returns build tags\n-func buildTags() string {\n-\treturn *tags\n-}\n-\n-// Param is function parameter\n-type Param struct {\n-\tName string\n-\tType string\n-}\n-\n-// usage prints the program usage\n-func usage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: go run mksyscall_aix_ppc.go [-b32 | -l32] [-tags x,y] [file ...]\\n\")\n-\tos.Exit(1)\n-}\n-\n-// parseParamList parses parameter list and returns a slice of parameters\n-func parseParamList(list string) []string {\n-\tlist = strings.TrimSpace(list)\n-\tif list == \"\" {\n-\t\treturn []string{}\n-\t}\n-\treturn regexp.MustCompile(`\\s*,\\s*`).Split(list, -1)\n-}\n-\n-// parseParam splits a parameter into name and type\n-func parseParam(p string) Param {\n-\tps := regexp.MustCompile(`^(\\S*) (\\S*)$`).FindStringSubmatch(p)\n-\tif ps == nil {\n-\t\tfmt.Fprintf(os.Stderr, \"malformed parameter: %s\\n\", p)\n-\t\tos.Exit(1)\n-\t}\n-\treturn Param{ps[1], ps[2]}\n-}\n-\n-func main() {\n-\tflag.Usage = usage\n-\tflag.Parse()\n-\tif len(flag.Args()) <= 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"no files to parse provided\\n\")\n-\t\tusage()\n-\t}\n-\n-\tendianness := \"\"\n-\tif *b32 {\n-\t\tendianness = \"big-endian\"\n-\t} else if *l32 {\n-\t\tendianness = \"little-endian\"\n-\t}\n-\n-\tpack := \"\"\n-\ttext := \"\"\n-\tcExtern := \"/*\\n#include <stdint.h>\\n#include <stddef.h>\\n\"\n-\tfor _, path := range flag.Args() {\n-\t\tfile, err := os.Open(path)\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\ts := bufio.NewScanner(file)\n-\t\tfor s.Scan() {\n-\t\t\tt := s.Text()\n-\t\t\tt = strings.TrimSpace(t)\n-\t\t\tt = regexp.MustCompile(`\\s+`).ReplaceAllString(t, ` `)\n-\t\t\tif p := regexp.MustCompile(`^package (\\S+)$`).FindStringSubmatch(t); p != nil && pack == \"\" {\n-\t\t\t\tpack = p[1]\n-\t\t\t}\n-\t\t\tnonblock := regexp.MustCompile(`^\\/\\/sysnb `).FindStringSubmatch(t)\n-\t\t\tif regexp.MustCompile(`^\\/\\/sys `).FindStringSubmatch(t) == nil && nonblock == nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// Line must be of the form\n-\t\t\t//\tfunc Open(path string, mode int, perm int) (fd int, err error)\n-\t\t\t// Split into name, in params, out params.\n-\t\t\tf := regexp.MustCompile(`^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*(?:(\\w*)\\.)?(\\w*))?$`).FindStringSubmatch(t)\n-\t\t\tif f == nil {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s\\nmalformed //sys declaration\\n\", path, t)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\t\t\tfunct, inps, outps, modname, sysname := f[2], f[3], f[4], f[5], f[6]\n-\n-\t\t\t// Split argument lists on comma.\n-\t\t\tin := parseParamList(inps)\n-\t\t\tout := parseParamList(outps)\n-\n-\t\t\tinps = strings.Join(in, \", \")\n-\t\t\toutps = strings.Join(out, \", \")\n-\n-\t\t\t// Try in vain to keep people from editing this file.\n-\t\t\t// The theory is that they jump into the middle of the file\n-\t\t\t// without reading the header.\n-\t\t\ttext += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n-\n-\t\t\t// Check if value return, err return available\n-\t\t\terrvar := \"\"\n-\t\t\tretvar := \"\"\n-\t\t\trettype := \"\"\n-\t\t\tfor _, param := range out {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif p.Type == \"error\" {\n-\t\t\t\t\terrvar = p.Name\n-\t\t\t\t} else {\n-\t\t\t\t\tretvar = p.Name\n-\t\t\t\t\trettype = p.Type\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// System call name.\n-\t\t\tif sysname == \"\" {\n-\t\t\t\tsysname = funct\n-\t\t\t}\n-\t\t\tsysname = regexp.MustCompile(`([a-z])([A-Z])`).ReplaceAllString(sysname, `${1}_$2`)\n-\t\t\tsysname = strings.ToLower(sysname) // All libc functions are lowercase.\n-\n-\t\t\tcRettype := \"\"\n-\t\t\tif rettype == \"unsafe.Pointer\" {\n-\t\t\t\tcRettype = \"uintptr_t\"\n-\t\t\t} else if rettype == \"uintptr\" {\n-\t\t\t\tcRettype = \"uintptr_t\"\n-\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(rettype) != nil {\n-\t\t\t\tcRettype = \"uintptr_t\"\n-\t\t\t} else if rettype == \"int\" {\n-\t\t\t\tcRettype = \"int\"\n-\t\t\t} else if rettype == \"int32\" {\n-\t\t\t\tcRettype = \"int\"\n-\t\t\t} else if rettype == \"int64\" {\n-\t\t\t\tcRettype = \"long long\"\n-\t\t\t} else if rettype == \"uint32\" {\n-\t\t\t\tcRettype = \"unsigned int\"\n-\t\t\t} else if rettype == \"uint64\" {\n-\t\t\t\tcRettype = \"unsigned long long\"\n-\t\t\t} else {\n-\t\t\t\tcRettype = \"int\"\n-\t\t\t}\n-\t\t\tif sysname == \"exit\" {\n-\t\t\t\tcRettype = \"void\"\n-\t\t\t}\n-\n-\t\t\t// Change p.Types to c\n-\t\t\tvar cIn []string\n-\t\t\tfor _, param := range in {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if p.Type == \"string\" {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\", \"size_t\")\n-\t\t\t\t} else if p.Type == \"unsafe.Pointer\" {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if p.Type == \"uintptr\" {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if p.Type == \"int\" {\n-\t\t\t\t\tcIn = append(cIn, \"int\")\n-\t\t\t\t} else if p.Type == \"int32\" {\n-\t\t\t\t\tcIn = append(cIn, \"int\")\n-\t\t\t\t} else if p.Type == \"int64\" {\n-\t\t\t\t\tcIn = append(cIn, \"long long\")\n-\t\t\t\t} else if p.Type == \"uint32\" {\n-\t\t\t\t\tcIn = append(cIn, \"unsigned int\")\n-\t\t\t\t} else if p.Type == \"uint64\" {\n-\t\t\t\t\tcIn = append(cIn, \"unsigned long long\")\n-\t\t\t\t} else {\n-\t\t\t\t\tcIn = append(cIn, \"int\")\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif funct != \"fcntl\" && funct != \"FcntlInt\" && funct != \"readlen\" && funct != \"writelen\" {\n-\t\t\t\tif sysname == \"select\" {\n-\t\t\t\t\t// select is a keyword of Go. Its name is\n-\t\t\t\t\t// changed to c_select.\n-\t\t\t\t\tcExtern += \"#define c_select select\\n\"\n-\t\t\t\t}\n-\t\t\t\t// Imports of system calls from libc\n-\t\t\t\tcExtern += fmt.Sprintf(\"%s %s\", cRettype, sysname)\n-\t\t\t\tcIn := strings.Join(cIn, \", \")\n-\t\t\t\tcExtern += fmt.Sprintf(\"(%s);\\n\", cIn)\n-\t\t\t}\n-\n-\t\t\t// So file name.\n-\t\t\tif *aix {\n-\t\t\t\tif modname == \"\" {\n-\t\t\t\t\tmodname = \"libc.a/shr_64.o\"\n-\t\t\t\t} else {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: only syscall using libc are available\\n\", funct)\n-\t\t\t\t\tos.Exit(1)\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tstrconvfunc := \"C.CString\"\n-\n-\t\t\t// Go function header.\n-\t\t\tif outps != \"\" {\n-\t\t\t\toutps = fmt.Sprintf(\" (%s)\", outps)\n-\t\t\t}\n-\t\t\tif text != \"\" {\n-\t\t\t\ttext += \"\\n\"\n-\t\t\t}\n-\n-\t\t\ttext += fmt.Sprintf(\"func %s(%s)%s {\\n\", funct, strings.Join(in, \", \"), outps)\n-\n-\t\t\t// Prepare arguments to Syscall.\n-\t\t\tvar args []string\n-\t\t\tn := 0\n-\t\t\targN := 0\n-\t\t\tfor _, param := range in {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\targs = append(args, \"C.uintptr_t(uintptr(unsafe.Pointer(\"+p.Name+\")))\")\n-\t\t\t\t} else if p.Type == \"string\" && errvar != \"\" {\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d := uintptr(unsafe.Pointer(%s(%s)))\\n\", n, strconvfunc, p.Name)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"string\" {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses string arguments, but has no error return\\n\")\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d := uintptr(unsafe.Pointer(%s(%s)))\\n\", n, strconvfunc, p.Name)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if m := regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type); m != nil {\n-\t\t\t\t\t// Convert slice into pointer, length.\n-\t\t\t\t\t// Have to be careful not to take address of &a[0] if len == 0:\n-\t\t\t\t\t// pass nil in that case.\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d *%s\\n\", n, m[1])\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tif len(%s) > 0 {\\n\\t\\t_p%d = &%s[0]\\n\\t}\\n\", p.Name, n, p.Name)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(uintptr(unsafe.Pointer(_p%d)))\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d int\\n\", n)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d = len(%s)\\n\", n, p.Name)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.size_t(_p%d)\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"int64\" && endianness != \"\" {\n-\t\t\t\t\tif endianness == \"big-endian\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s>>32)\", p.Name), fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name), fmt.Sprintf(\"uintptr(%s>>32)\", p.Name))\n-\t\t\t\t\t}\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"bool\" {\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d uint32\\n\", n)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tif %s {\\n\\t\\t_p%d = 1\\n\\t} else {\\n\\t\\t_p%d = 0\\n\\t}\\n\", p.Name, n, n)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"_p%d\", n))\n-\t\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(uintptr(%s))\", p.Name))\n-\t\t\t\t} else if p.Type == \"unsafe.Pointer\" {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(uintptr(%s))\", p.Name))\n-\t\t\t\t} else if p.Type == \"int\" {\n-\t\t\t\t\tif (argN == 2) && ((funct == \"readlen\") || (funct == \"writelen\")) {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.size_t(%s)\", p.Name))\n-\t\t\t\t\t} else if argN == 0 && funct == \"fcntl\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n-\t\t\t\t\t} else if (argN == 2) && ((funct == \"fcntl\") || (funct == \"FcntlInt\")) {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.int(%s)\", p.Name))\n-\t\t\t\t\t}\n-\t\t\t\t} else if p.Type == \"int32\" {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.int(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"int64\" {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.longlong(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"uint32\" {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uint(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"uint64\" {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.ulonglong(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"uintptr\" {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n-\t\t\t\t} else {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"C.int(%s)\", p.Name))\n-\t\t\t\t}\n-\t\t\t\targN++\n-\t\t\t}\n-\n-\t\t\t// Actual call.\n-\t\t\targlist := strings.Join(args, \", \")\n-\t\t\tcall := \"\"\n-\t\t\tif sysname == \"exit\" {\n-\t\t\t\tif errvar != \"\" {\n-\t\t\t\t\tcall += \"er :=\"\n-\t\t\t\t} else {\n-\t\t\t\t\tcall += \"\"\n-\t\t\t\t}\n-\t\t\t} else if errvar != \"\" {\n-\t\t\t\tcall += \"r0,er :=\"\n-\t\t\t} else if retvar != \"\" {\n-\t\t\t\tcall += \"r0,_ :=\"\n-\t\t\t} else {\n-\t\t\t\tcall += \"\"\n-\t\t\t}\n-\t\t\tif sysname == \"select\" {\n-\t\t\t\t// select is a keyword of Go. Its name is\n-\t\t\t\t// changed to c_select.\n-\t\t\t\tcall += fmt.Sprintf(\"C.c_%s(%s)\", sysname, arglist)\n-\t\t\t} else {\n-\t\t\t\tcall += fmt.Sprintf(\"C.%s(%s)\", sysname, arglist)\n-\t\t\t}\n-\n-\t\t\t// Assign return values.\n-\t\t\tbody := \"\"\n-\t\t\tfor i := 0; i < len(out); i++ {\n-\t\t\t\tp := parseParam(out[i])\n-\t\t\t\treg := \"\"\n-\t\t\t\tif p.Name == \"err\" {\n-\t\t\t\t\treg = \"e1\"\n-\t\t\t\t} else {\n-\t\t\t\t\treg = \"r0\"\n-\t\t\t\t}\n-\t\t\t\tif reg != \"e1\" {\n-\t\t\t\t\tbody += fmt.Sprintf(\"\\t%s = %s(%s)\\n\", p.Name, p.Type, reg)\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// verify return\n-\t\t\tif sysname != \"exit\" && errvar != \"\" {\n-\t\t\t\tif regexp.MustCompile(`^uintptr`).FindStringSubmatch(cRettype) != nil {\n-\t\t\t\t\tbody += \"\\tif (uintptr(r0) ==^uintptr(0) && er != nil) {\\n\"\n-\t\t\t\t\tbody += fmt.Sprintf(\"\\t\\t%s = er\\n\", errvar)\n-\t\t\t\t\tbody += \"\\t}\\n\"\n-\t\t\t\t} else {\n-\t\t\t\t\tbody += \"\\tif (r0 ==-1 && er != nil) {\\n\"\n-\t\t\t\t\tbody += fmt.Sprintf(\"\\t\\t%s = er\\n\", errvar)\n-\t\t\t\t\tbody += \"\\t}\\n\"\n-\t\t\t\t}\n-\t\t\t} else if errvar != \"\" {\n-\t\t\t\tbody += \"\\tif (er != nil) {\\n\"\n-\t\t\t\tbody += fmt.Sprintf(\"\\t\\t%s = er\\n\", errvar)\n-\t\t\t\tbody += \"\\t}\\n\"\n-\t\t\t}\n-\n-\t\t\ttext += fmt.Sprintf(\"\\t%s\\n\", call)\n-\t\t\ttext += body\n-\n-\t\t\ttext += \"\\treturn\\n\"\n-\t\t\ttext += \"}\\n\"\n-\t\t}\n-\t\tif err := s.Err(); err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\tfile.Close()\n-\t}\n-\timp := \"\"\n-\tif pack != \"unix\" {\n-\t\timp = \"import \\\"golang.org/x/sys/unix\\\"\\n\"\n-\n-\t}\n-\tfmt.Printf(srcTemplate, cmdLine(), buildTags(), pack, cExtern, imp, text)\n-}\n-\n-const srcTemplate = `// %s\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s\n-\n-package %s\n-\n-\n-%s\n-*/\n-import \"C\"\n-import (\n-\t\"unsafe\"\n-)\n-\n-\n-%s\n-\n-%s\n-`"
    },
    {
      "sha": "c960099517af00196e77b62b8c029c1be765c9e0",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go",
      "status": "removed",
      "additions": 0,
      "deletions": 614,
      "changes": 614,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,614 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-This program reads a file containing function prototypes\n-(like syscall_aix.go) and generates system call bodies.\n-The prototypes are marked by lines beginning with \"//sys\"\n-and read like func declarations if //sys is replaced by func, but:\n-\t* The parameter lists must give a name for each argument.\n-\t  This includes return parameters.\n-\t* The parameter lists must give a type for each argument:\n-\t  the (x, y, z int) shorthand is not allowed.\n-\t* If the return parameter is an error number, it must be named err.\n-\t* If go func name needs to be different than its libc name,\n-\t* or the function is not in libc, name could be specified\n-\t* at the end, after \"=\" sign, like\n-\t  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt\n-\n-\n-This program will generate three files and handle both gc and gccgo implementation:\n-  - zsyscall_aix_ppc64.go: the common part of each implementation (error handler, pointer creation)\n-  - zsyscall_aix_ppc64_gc.go: gc part with //go_cgo_import_dynamic and a call to syscall6\n-  - zsyscall_aix_ppc64_gccgo.go: gccgo part with C function and conversion to C type.\n-\n- The generated code looks like this\n-\n-zsyscall_aix_ppc64.go\n-func asyscall(...) (n int, err error) {\n-\t // Pointer Creation\n-\t r1, e1 := callasyscall(...)\n-\t // Type Conversion\n-\t // Error Handler\n-\t return\n-}\n-\n-zsyscall_aix_ppc64_gc.go\n-//go:cgo_import_dynamic libc_asyscall asyscall \"libc.a/shr_64.o\"\n-//go:linkname libc_asyscall libc_asyscall\n-var asyscall syscallFunc\n-\n-func callasyscall(...) (r1 uintptr, e1 Errno) {\n-\t r1, _, e1 = syscall6(uintptr(unsafe.Pointer(&libc_asyscall)), \"nb_args\", ... )\n-\t return\n-}\n-\n-zsyscall_aix_ppc64_ggcgo.go\n-\n-// int asyscall(...)\n-\n-import \"C\"\n-\n-func callasyscall(...) (r1 uintptr, e1 Errno) {\n-\t r1 = uintptr(C.asyscall(...))\n-\t e1 = syscall.GetErrno()\n-\t return\n-}\n-*/\n-\n-package main\n-\n-import (\n-\t\"bufio\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"regexp\"\n-\t\"strings\"\n-)\n-\n-var (\n-\tb32  = flag.Bool(\"b32\", false, \"32bit big-endian\")\n-\tl32  = flag.Bool(\"l32\", false, \"32bit little-endian\")\n-\taix  = flag.Bool(\"aix\", false, \"aix\")\n-\ttags = flag.String(\"tags\", \"\", \"build tags\")\n-)\n-\n-// cmdLine returns this programs's commandline arguments\n-func cmdLine() string {\n-\treturn \"go run mksyscall_aix_ppc64.go \" + strings.Join(os.Args[1:], \" \")\n-}\n-\n-// buildTags returns build tags\n-func buildTags() string {\n-\treturn *tags\n-}\n-\n-// Param is function parameter\n-type Param struct {\n-\tName string\n-\tType string\n-}\n-\n-// usage prints the program usage\n-func usage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: go run mksyscall_aix_ppc64.go [-b32 | -l32] [-tags x,y] [file ...]\\n\")\n-\tos.Exit(1)\n-}\n-\n-// parseParamList parses parameter list and returns a slice of parameters\n-func parseParamList(list string) []string {\n-\tlist = strings.TrimSpace(list)\n-\tif list == \"\" {\n-\t\treturn []string{}\n-\t}\n-\treturn regexp.MustCompile(`\\s*,\\s*`).Split(list, -1)\n-}\n-\n-// parseParam splits a parameter into name and type\n-func parseParam(p string) Param {\n-\tps := regexp.MustCompile(`^(\\S*) (\\S*)$`).FindStringSubmatch(p)\n-\tif ps == nil {\n-\t\tfmt.Fprintf(os.Stderr, \"malformed parameter: %s\\n\", p)\n-\t\tos.Exit(1)\n-\t}\n-\treturn Param{ps[1], ps[2]}\n-}\n-\n-func main() {\n-\tflag.Usage = usage\n-\tflag.Parse()\n-\tif len(flag.Args()) <= 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"no files to parse provided\\n\")\n-\t\tusage()\n-\t}\n-\n-\tendianness := \"\"\n-\tif *b32 {\n-\t\tendianness = \"big-endian\"\n-\t} else if *l32 {\n-\t\tendianness = \"little-endian\"\n-\t}\n-\n-\tpack := \"\"\n-\t// GCCGO\n-\ttextgccgo := \"\"\n-\tcExtern := \"/*\\n#include <stdint.h>\\n\"\n-\t// GC\n-\ttextgc := \"\"\n-\tdynimports := \"\"\n-\tlinknames := \"\"\n-\tvar vars []string\n-\t// COMMON\n-\ttextcommon := \"\"\n-\tfor _, path := range flag.Args() {\n-\t\tfile, err := os.Open(path)\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\ts := bufio.NewScanner(file)\n-\t\tfor s.Scan() {\n-\t\t\tt := s.Text()\n-\t\t\tt = strings.TrimSpace(t)\n-\t\t\tt = regexp.MustCompile(`\\s+`).ReplaceAllString(t, ` `)\n-\t\t\tif p := regexp.MustCompile(`^package (\\S+)$`).FindStringSubmatch(t); p != nil && pack == \"\" {\n-\t\t\t\tpack = p[1]\n-\t\t\t}\n-\t\t\tnonblock := regexp.MustCompile(`^\\/\\/sysnb `).FindStringSubmatch(t)\n-\t\t\tif regexp.MustCompile(`^\\/\\/sys `).FindStringSubmatch(t) == nil && nonblock == nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// Line must be of the form\n-\t\t\t//\tfunc Open(path string, mode int, perm int) (fd int, err error)\n-\t\t\t// Split into name, in params, out params.\n-\t\t\tf := regexp.MustCompile(`^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*(?:(\\w*)\\.)?(\\w*))?$`).FindStringSubmatch(t)\n-\t\t\tif f == nil {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s\\nmalformed //sys declaration\\n\", path, t)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\t\t\tfunct, inps, outps, modname, sysname := f[2], f[3], f[4], f[5], f[6]\n-\n-\t\t\t// Split argument lists on comma.\n-\t\t\tin := parseParamList(inps)\n-\t\t\tout := parseParamList(outps)\n-\n-\t\t\tinps = strings.Join(in, \", \")\n-\t\t\toutps = strings.Join(out, \", \")\n-\n-\t\t\tif sysname == \"\" {\n-\t\t\t\tsysname = funct\n-\t\t\t}\n-\n-\t\t\tonlyCommon := false\n-\t\t\tif funct == \"readlen\" || funct == \"writelen\" || funct == \"FcntlInt\" || funct == \"FcntlFlock\" {\n-\t\t\t\t// This function call another syscall which is already implemented.\n-\t\t\t\t// Therefore, the gc and gccgo part must not be generated.\n-\t\t\t\tonlyCommon = true\n-\t\t\t}\n-\n-\t\t\t// Try in vain to keep people from editing this file.\n-\t\t\t// The theory is that they jump into the middle of the file\n-\t\t\t// without reading the header.\n-\n-\t\t\ttextcommon += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n-\t\t\tif !onlyCommon {\n-\t\t\t\ttextgccgo += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n-\t\t\t\ttextgc += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n-\t\t\t}\n-\n-\t\t\t// Check if value return, err return available\n-\t\t\terrvar := \"\"\n-\t\t\trettype := \"\"\n-\t\t\tfor _, param := range out {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif p.Type == \"error\" {\n-\t\t\t\t\terrvar = p.Name\n-\t\t\t\t} else {\n-\t\t\t\t\trettype = p.Type\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tsysname = regexp.MustCompile(`([a-z])([A-Z])`).ReplaceAllString(sysname, `${1}_$2`)\n-\t\t\tsysname = strings.ToLower(sysname) // All libc functions are lowercase.\n-\n-\t\t\t// GCCGO Prototype return type\n-\t\t\tcRettype := \"\"\n-\t\t\tif rettype == \"unsafe.Pointer\" {\n-\t\t\t\tcRettype = \"uintptr_t\"\n-\t\t\t} else if rettype == \"uintptr\" {\n-\t\t\t\tcRettype = \"uintptr_t\"\n-\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(rettype) != nil {\n-\t\t\t\tcRettype = \"uintptr_t\"\n-\t\t\t} else if rettype == \"int\" {\n-\t\t\t\tcRettype = \"int\"\n-\t\t\t} else if rettype == \"int32\" {\n-\t\t\t\tcRettype = \"int\"\n-\t\t\t} else if rettype == \"int64\" {\n-\t\t\t\tcRettype = \"long long\"\n-\t\t\t} else if rettype == \"uint32\" {\n-\t\t\t\tcRettype = \"unsigned int\"\n-\t\t\t} else if rettype == \"uint64\" {\n-\t\t\t\tcRettype = \"unsigned long long\"\n-\t\t\t} else {\n-\t\t\t\tcRettype = \"int\"\n-\t\t\t}\n-\t\t\tif sysname == \"exit\" {\n-\t\t\t\tcRettype = \"void\"\n-\t\t\t}\n-\n-\t\t\t// GCCGO Prototype arguments type\n-\t\t\tvar cIn []string\n-\t\t\tfor i, param := range in {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if p.Type == \"string\" {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\", \"size_t\")\n-\t\t\t\t} else if p.Type == \"unsafe.Pointer\" {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if p.Type == \"uintptr\" {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t} else if p.Type == \"int\" {\n-\t\t\t\t\tif (i == 0 || i == 2) && funct == \"fcntl\" {\n-\t\t\t\t\t\t// These fcntl arguments needs to be uintptr to be able to call FcntlInt and FcntlFlock\n-\t\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tcIn = append(cIn, \"int\")\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if p.Type == \"int32\" {\n-\t\t\t\t\tcIn = append(cIn, \"int\")\n-\t\t\t\t} else if p.Type == \"int64\" {\n-\t\t\t\t\tcIn = append(cIn, \"long long\")\n-\t\t\t\t} else if p.Type == \"uint32\" {\n-\t\t\t\t\tcIn = append(cIn, \"unsigned int\")\n-\t\t\t\t} else if p.Type == \"uint64\" {\n-\t\t\t\t\tcIn = append(cIn, \"unsigned long long\")\n-\t\t\t\t} else {\n-\t\t\t\t\tcIn = append(cIn, \"int\")\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif !onlyCommon {\n-\t\t\t\t// GCCGO Prototype Generation\n-\t\t\t\t// Imports of system calls from libc\n-\t\t\t\tif sysname == \"select\" {\n-\t\t\t\t\t// select is a keyword of Go. Its name is\n-\t\t\t\t\t// changed to c_select.\n-\t\t\t\t\tcExtern += \"#define c_select select\\n\"\n-\t\t\t\t}\n-\t\t\t\tcExtern += fmt.Sprintf(\"%s %s\", cRettype, sysname)\n-\t\t\t\tcIn := strings.Join(cIn, \", \")\n-\t\t\t\tcExtern += fmt.Sprintf(\"(%s);\\n\", cIn)\n-\t\t\t}\n-\t\t\t// GC Library name\n-\t\t\tif modname == \"\" {\n-\t\t\t\tmodname = \"libc.a/shr_64.o\"\n-\t\t\t} else {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: only syscall using libc are available\\n\", funct)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\t\t\tsysvarname := fmt.Sprintf(\"libc_%s\", sysname)\n-\n-\t\t\tif !onlyCommon {\n-\t\t\t\t// GC Runtime import of function to allow cross-platform builds.\n-\t\t\t\tdynimports += fmt.Sprintf(\"//go:cgo_import_dynamic %s %s \\\"%s\\\"\\n\", sysvarname, sysname, modname)\n-\t\t\t\t// GC Link symbol to proc address variable.\n-\t\t\t\tlinknames += fmt.Sprintf(\"//go:linkname %s %s\\n\", sysvarname, sysvarname)\n-\t\t\t\t// GC Library proc address variable.\n-\t\t\t\tvars = append(vars, sysvarname)\n-\t\t\t}\n-\n-\t\t\tstrconvfunc := \"BytePtrFromString\"\n-\t\t\tstrconvtype := \"*byte\"\n-\n-\t\t\t// Go function header.\n-\t\t\tif outps != \"\" {\n-\t\t\t\toutps = fmt.Sprintf(\" (%s)\", outps)\n-\t\t\t}\n-\t\t\tif textcommon != \"\" {\n-\t\t\t\ttextcommon += \"\\n\"\n-\t\t\t}\n-\n-\t\t\ttextcommon += fmt.Sprintf(\"func %s(%s)%s {\\n\", funct, strings.Join(in, \", \"), outps)\n-\n-\t\t\t// Prepare arguments tocall.\n-\t\t\tvar argscommon []string // Arguments in the common part\n-\t\t\tvar argscall []string   // Arguments for call prototype\n-\t\t\tvar argsgc []string     // Arguments for gc call (with syscall6)\n-\t\t\tvar argsgccgo []string  // Arguments for gccgo call (with C.name_of_syscall)\n-\t\t\tn := 0\n-\t\t\targN := 0\n-\t\t\tfor _, param := range in {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(%s))\", p.Name))\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, p.Name)\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"string\" && errvar != \"\" {\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\t_p%d, %s = %s(%s)\\n\", n, errvar, strconvfunc, p.Name)\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tif %s != nil {\\n\\t\\treturn\\n\\t}\\n\", errvar)\n-\n-\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"_p%d uintptr \", n))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"_p%d\", n))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"string\" {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses string arguments, but has no error return\\n\")\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\t_p%d, %s = %s(%s)\\n\", n, errvar, strconvfunc, p.Name)\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tif %s != nil {\\n\\t\\treturn\\n\\t}\\n\", errvar)\n-\n-\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"_p%d uintptr\", n))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"_p%d\", n))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if m := regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type); m != nil {\n-\t\t\t\t\t// Convert slice into pointer, length.\n-\t\t\t\t\t// Have to be careful not to take address of &a[0] if len == 0:\n-\t\t\t\t\t// pass nil in that case.\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tvar _p%d *%s\\n\", n, m[1])\n-\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tif len(%s) > 0 {\\n\\t\\t_p%d = &%s[0]\\n\\t}\\n\", p.Name, n, p.Name)\n-\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n), fmt.Sprintf(\"len(%s)\", p.Name))\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"_p%d uintptr\", n), fmt.Sprintf(\"_lenp%d int\", n))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"_p%d\", n), fmt.Sprintf(\"uintptr(_lenp%d)\", n))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n), fmt.Sprintf(\"C.size_t(_lenp%d)\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"int64\" && endianness != \"\" {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses int64 with 32 bits mode. Case not yet implemented\\n\")\n-\t\t\t\t} else if p.Type == \"bool\" {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses bool. Case not yet implemented\\n\")\n-\t\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(p.Type) != nil || p.Type == \"unsafe.Pointer\" {\n-\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, p.Name)\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"int\" {\n-\t\t\t\t\tif (argN == 0 || argN == 2) && ((funct == \"fcntl\") || (funct == \"FcntlInt\") || (funct == \"FcntlFlock\")) {\n-\t\t\t\t\t\t// These fcntl arguments need to be uintptr to be able to call FcntlInt and FcntlFlock\n-\t\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n-\t\t\t\t\t\targsgc = append(argsgc, p.Name)\n-\t\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n-\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targscommon = append(argscommon, p.Name)\n-\t\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int\", p.Name))\n-\t\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.int(%s)\", p.Name))\n-\t\t\t\t\t}\n-\t\t\t\t} else if p.Type == \"int32\" {\n-\t\t\t\t\targscommon = append(argscommon, p.Name)\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int32\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.int(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"int64\" {\n-\t\t\t\t\targscommon = append(argscommon, p.Name)\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int64\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.longlong(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"uint32\" {\n-\t\t\t\t\targscommon = append(argscommon, p.Name)\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uint32\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uint(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"uint64\" {\n-\t\t\t\t\targscommon = append(argscommon, p.Name)\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uint64\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.ulonglong(%s)\", p.Name))\n-\t\t\t\t} else if p.Type == \"uintptr\" {\n-\t\t\t\t\targscommon = append(argscommon, p.Name)\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, p.Name)\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n-\t\t\t\t} else {\n-\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"int(%s)\", p.Name))\n-\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int\", p.Name))\n-\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.int(%s)\", p.Name))\n-\t\t\t\t}\n-\t\t\t\targN++\n-\t\t\t}\n-\t\t\tnargs := len(argsgc)\n-\n-\t\t\t// COMMON function generation\n-\t\t\targscommonlist := strings.Join(argscommon, \", \")\n-\t\t\tcallcommon := fmt.Sprintf(\"call%s(%s)\", sysname, argscommonlist)\n-\t\t\tret := []string{\"_\", \"_\"}\n-\t\t\tbody := \"\"\n-\t\t\tdoErrno := false\n-\t\t\tfor i := 0; i < len(out); i++ {\n-\t\t\t\tp := parseParam(out[i])\n-\t\t\t\treg := \"\"\n-\t\t\t\tif p.Name == \"err\" {\n-\t\t\t\t\treg = \"e1\"\n-\t\t\t\t\tret[1] = reg\n-\t\t\t\t\tdoErrno = true\n-\t\t\t\t} else {\n-\t\t\t\t\treg = \"r0\"\n-\t\t\t\t\tret[0] = reg\n-\t\t\t\t}\n-\t\t\t\tif p.Type == \"bool\" {\n-\t\t\t\t\treg = fmt.Sprintf(\"%s != 0\", reg)\n-\t\t\t\t}\n-\t\t\t\tif reg != \"e1\" {\n-\t\t\t\t\tbody += fmt.Sprintf(\"\\t%s = %s(%s)\\n\", p.Name, p.Type, reg)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif ret[0] == \"_\" && ret[1] == \"_\" {\n-\t\t\t\ttextcommon += fmt.Sprintf(\"\\t%s\\n\", callcommon)\n-\t\t\t} else {\n-\t\t\t\ttextcommon += fmt.Sprintf(\"\\t%s, %s := %s\\n\", ret[0], ret[1], callcommon)\n-\t\t\t}\n-\t\t\ttextcommon += body\n-\n-\t\t\tif doErrno {\n-\t\t\t\ttextcommon += \"\\tif e1 != 0 {\\n\"\n-\t\t\t\ttextcommon += \"\\t\\terr = errnoErr(e1)\\n\"\n-\t\t\t\ttextcommon += \"\\t}\\n\"\n-\t\t\t}\n-\t\t\ttextcommon += \"\\treturn\\n\"\n-\t\t\ttextcommon += \"}\\n\"\n-\n-\t\t\tif onlyCommon {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// CALL Prototype\n-\t\t\tcallProto := fmt.Sprintf(\"func call%s(%s) (r1 uintptr, e1 Errno) {\\n\", sysname, strings.Join(argscall, \", \"))\n-\n-\t\t\t// GC function generation\n-\t\t\tasm := \"syscall6\"\n-\t\t\tif nonblock != nil {\n-\t\t\t\tasm = \"rawSyscall6\"\n-\t\t\t}\n-\n-\t\t\tif len(argsgc) <= 6 {\n-\t\t\t\tfor len(argsgc) < 6 {\n-\t\t\t\t\targsgc = append(argsgc, \"0\")\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: too many arguments to system call\", funct)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\t\t\targsgclist := strings.Join(argsgc, \", \")\n-\t\t\tcallgc := fmt.Sprintf(\"%s(uintptr(unsafe.Pointer(&%s)), %d, %s)\", asm, sysvarname, nargs, argsgclist)\n-\n-\t\t\ttextgc += callProto\n-\t\t\ttextgc += fmt.Sprintf(\"\\tr1, _, e1 = %s\\n\", callgc)\n-\t\t\ttextgc += \"\\treturn\\n}\\n\"\n-\n-\t\t\t// GCCGO function generation\n-\t\t\targsgccgolist := strings.Join(argsgccgo, \", \")\n-\t\t\tvar callgccgo string\n-\t\t\tif sysname == \"select\" {\n-\t\t\t\t// select is a keyword of Go. Its name is\n-\t\t\t\t// changed to c_select.\n-\t\t\t\tcallgccgo = fmt.Sprintf(\"C.c_%s(%s)\", sysname, argsgccgolist)\n-\t\t\t} else {\n-\t\t\t\tcallgccgo = fmt.Sprintf(\"C.%s(%s)\", sysname, argsgccgolist)\n-\t\t\t}\n-\t\t\ttextgccgo += callProto\n-\t\t\ttextgccgo += fmt.Sprintf(\"\\tr1 = uintptr(%s)\\n\", callgccgo)\n-\t\t\ttextgccgo += \"\\te1 = syscall.GetErrno()\\n\"\n-\t\t\ttextgccgo += \"\\treturn\\n}\\n\"\n-\t\t}\n-\t\tif err := s.Err(); err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\tfile.Close()\n-\t}\n-\timp := \"\"\n-\tif pack != \"unix\" {\n-\t\timp = \"import \\\"golang.org/x/sys/unix\\\"\\n\"\n-\n-\t}\n-\n-\t// Print zsyscall_aix_ppc64.go\n-\terr := ioutil.WriteFile(\"zsyscall_aix_ppc64.go\",\n-\t\t[]byte(fmt.Sprintf(srcTemplate1, cmdLine(), buildTags(), pack, imp, textcommon)),\n-\t\t0644)\n-\tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\tos.Exit(1)\n-\t}\n-\n-\t// Print zsyscall_aix_ppc64_gc.go\n-\tvardecls := \"\\t\" + strings.Join(vars, \",\\n\\t\")\n-\tvardecls += \" syscallFunc\"\n-\terr = ioutil.WriteFile(\"zsyscall_aix_ppc64_gc.go\",\n-\t\t[]byte(fmt.Sprintf(srcTemplate2, cmdLine(), buildTags(), pack, imp, dynimports, linknames, vardecls, textgc)),\n-\t\t0644)\n-\tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\tos.Exit(1)\n-\t}\n-\n-\t// Print zsyscall_aix_ppc64_gccgo.go\n-\terr = ioutil.WriteFile(\"zsyscall_aix_ppc64_gccgo.go\",\n-\t\t[]byte(fmt.Sprintf(srcTemplate3, cmdLine(), buildTags(), pack, cExtern, imp, textgccgo)),\n-\t\t0644)\n-\tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\tos.Exit(1)\n-\t}\n-}\n-\n-const srcTemplate1 = `// %s\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s\n-\n-package %s\n-\n-import (\n-\t\"unsafe\"\n-)\n-\n-\n-%s\n-\n-%s\n-`\n-const srcTemplate2 = `// %s\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s\n-// +build !gccgo\n-\n-package %s\n-\n-import (\n-\t\"unsafe\"\n-)\n-%s\n-%s\n-%s\n-type syscallFunc uintptr\n-\n-var (\n-%s\n-)\n-\n-// Implemented in runtime/syscall_aix.go.\n-func rawSyscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n-func syscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n-\n-%s\n-`\n-const srcTemplate3 = `// %s\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s\n-// +build gccgo\n-\n-package %s\n-\n-%s\n-*/\n-import \"C\"\n-import (\n-\t\"syscall\"\n-)\n-\n-\n-%s\n-\n-%s\n-`"
    },
    {
      "sha": "3d864738b69594aaf1b7e60e6c191ac9168039b2",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go",
      "status": "removed",
      "additions": 0,
      "deletions": 335,
      "changes": 335,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,335 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n- This program reads a file containing function prototypes\n- (like syscall_solaris.go) and generates system call bodies.\n- The prototypes are marked by lines beginning with \"//sys\"\n- and read like func declarations if //sys is replaced by func, but:\n-\t* The parameter lists must give a name for each argument.\n-\t  This includes return parameters.\n-\t* The parameter lists must give a type for each argument:\n-\t  the (x, y, z int) shorthand is not allowed.\n-\t* If the return parameter is an error number, it must be named err.\n-\t* If go func name needs to be different than its libc name,\n-\t* or the function is not in libc, name could be specified\n-\t* at the end, after \"=\" sign, like\n-\t  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt\n-*/\n-\n-package main\n-\n-import (\n-\t\"bufio\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"regexp\"\n-\t\"strings\"\n-)\n-\n-var (\n-\tb32  = flag.Bool(\"b32\", false, \"32bit big-endian\")\n-\tl32  = flag.Bool(\"l32\", false, \"32bit little-endian\")\n-\ttags = flag.String(\"tags\", \"\", \"build tags\")\n-)\n-\n-// cmdLine returns this programs's commandline arguments\n-func cmdLine() string {\n-\treturn \"go run mksyscall_solaris.go \" + strings.Join(os.Args[1:], \" \")\n-}\n-\n-// buildTags returns build tags\n-func buildTags() string {\n-\treturn *tags\n-}\n-\n-// Param is function parameter\n-type Param struct {\n-\tName string\n-\tType string\n-}\n-\n-// usage prints the program usage\n-func usage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: go run mksyscall_solaris.go [-b32 | -l32] [-tags x,y] [file ...]\\n\")\n-\tos.Exit(1)\n-}\n-\n-// parseParamList parses parameter list and returns a slice of parameters\n-func parseParamList(list string) []string {\n-\tlist = strings.TrimSpace(list)\n-\tif list == \"\" {\n-\t\treturn []string{}\n-\t}\n-\treturn regexp.MustCompile(`\\s*,\\s*`).Split(list, -1)\n-}\n-\n-// parseParam splits a parameter into name and type\n-func parseParam(p string) Param {\n-\tps := regexp.MustCompile(`^(\\S*) (\\S*)$`).FindStringSubmatch(p)\n-\tif ps == nil {\n-\t\tfmt.Fprintf(os.Stderr, \"malformed parameter: %s\\n\", p)\n-\t\tos.Exit(1)\n-\t}\n-\treturn Param{ps[1], ps[2]}\n-}\n-\n-func main() {\n-\tflag.Usage = usage\n-\tflag.Parse()\n-\tif len(flag.Args()) <= 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"no files to parse provided\\n\")\n-\t\tusage()\n-\t}\n-\n-\tendianness := \"\"\n-\tif *b32 {\n-\t\tendianness = \"big-endian\"\n-\t} else if *l32 {\n-\t\tendianness = \"little-endian\"\n-\t}\n-\n-\tpack := \"\"\n-\ttext := \"\"\n-\tdynimports := \"\"\n-\tlinknames := \"\"\n-\tvar vars []string\n-\tfor _, path := range flag.Args() {\n-\t\tfile, err := os.Open(path)\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\ts := bufio.NewScanner(file)\n-\t\tfor s.Scan() {\n-\t\t\tt := s.Text()\n-\t\t\tt = strings.TrimSpace(t)\n-\t\t\tt = regexp.MustCompile(`\\s+`).ReplaceAllString(t, ` `)\n-\t\t\tif p := regexp.MustCompile(`^package (\\S+)$`).FindStringSubmatch(t); p != nil && pack == \"\" {\n-\t\t\t\tpack = p[1]\n-\t\t\t}\n-\t\t\tnonblock := regexp.MustCompile(`^\\/\\/sysnb `).FindStringSubmatch(t)\n-\t\t\tif regexp.MustCompile(`^\\/\\/sys `).FindStringSubmatch(t) == nil && nonblock == nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\t// Line must be of the form\n-\t\t\t//\tfunc Open(path string, mode int, perm int) (fd int, err error)\n-\t\t\t// Split into name, in params, out params.\n-\t\t\tf := regexp.MustCompile(`^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*(?:(\\w*)\\.)?(\\w*))?$`).FindStringSubmatch(t)\n-\t\t\tif f == nil {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s\\nmalformed //sys declaration\\n\", path, t)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\t\t\tfunct, inps, outps, modname, sysname := f[2], f[3], f[4], f[5], f[6]\n-\n-\t\t\t// Split argument lists on comma.\n-\t\t\tin := parseParamList(inps)\n-\t\t\tout := parseParamList(outps)\n-\n-\t\t\tinps = strings.Join(in, \", \")\n-\t\t\toutps = strings.Join(out, \", \")\n-\n-\t\t\t// Try in vain to keep people from editing this file.\n-\t\t\t// The theory is that they jump into the middle of the file\n-\t\t\t// without reading the header.\n-\t\t\ttext += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n-\n-\t\t\t// So file name.\n-\t\t\tif modname == \"\" {\n-\t\t\t\tmodname = \"libc\"\n-\t\t\t}\n-\n-\t\t\t// System call name.\n-\t\t\tif sysname == \"\" {\n-\t\t\t\tsysname = funct\n-\t\t\t}\n-\n-\t\t\t// System call pointer variable name.\n-\t\t\tsysvarname := fmt.Sprintf(\"proc%s\", sysname)\n-\n-\t\t\tstrconvfunc := \"BytePtrFromString\"\n-\t\t\tstrconvtype := \"*byte\"\n-\n-\t\t\tsysname = strings.ToLower(sysname) // All libc functions are lowercase.\n-\n-\t\t\t// Runtime import of function to allow cross-platform builds.\n-\t\t\tdynimports += fmt.Sprintf(\"//go:cgo_import_dynamic libc_%s %s \\\"%s.so\\\"\\n\", sysname, sysname, modname)\n-\t\t\t// Link symbol to proc address variable.\n-\t\t\tlinknames += fmt.Sprintf(\"//go:linkname %s libc_%s\\n\", sysvarname, sysname)\n-\t\t\t// Library proc address variable.\n-\t\t\tvars = append(vars, sysvarname)\n-\n-\t\t\t// Go function header.\n-\t\t\toutlist := strings.Join(out, \", \")\n-\t\t\tif outlist != \"\" {\n-\t\t\t\toutlist = fmt.Sprintf(\" (%s)\", outlist)\n-\t\t\t}\n-\t\t\tif text != \"\" {\n-\t\t\t\ttext += \"\\n\"\n-\t\t\t}\n-\t\t\ttext += fmt.Sprintf(\"func %s(%s)%s {\\n\", funct, strings.Join(in, \", \"), outlist)\n-\n-\t\t\t// Check if err return available\n-\t\t\terrvar := \"\"\n-\t\t\tfor _, param := range out {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif p.Type == \"error\" {\n-\t\t\t\t\terrvar = p.Name\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Prepare arguments to Syscall.\n-\t\t\tvar args []string\n-\t\t\tn := 0\n-\t\t\tfor _, param := range in {\n-\t\t\t\tp := parseParam(param)\n-\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n-\t\t\t\t\targs = append(args, \"uintptr(unsafe.Pointer(\"+p.Name+\"))\")\n-\t\t\t\t} else if p.Type == \"string\" && errvar != \"\" {\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d, %s = %s(%s)\\n\", n, errvar, strconvfunc, p.Name)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tif %s != nil {\\n\\t\\treturn\\n\\t}\\n\", errvar)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"string\" {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses string arguments, but has no error return\\n\")\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d, _ = %s(%s)\\n\", n, strconvfunc, p.Name)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if s := regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type); s != nil {\n-\t\t\t\t\t// Convert slice into pointer, length.\n-\t\t\t\t\t// Have to be careful not to take address of &a[0] if len == 0:\n-\t\t\t\t\t// pass nil in that case.\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d *%s\\n\", n, s[1])\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tif len(%s) > 0 {\\n\\t\\t_p%d = &%s[0]\\n\\t}\\n\", p.Name, n, p.Name)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n), fmt.Sprintf(\"uintptr(len(%s))\", p.Name))\n-\t\t\t\t\tn++\n-\t\t\t\t} else if p.Type == \"int64\" && endianness != \"\" {\n-\t\t\t\t\tif endianness == \"big-endian\" {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s>>32)\", p.Name), fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name), fmt.Sprintf(\"uintptr(%s>>32)\", p.Name))\n-\t\t\t\t\t}\n-\t\t\t\t} else if p.Type == \"bool\" {\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d uint32\\n\", n)\n-\t\t\t\t\ttext += fmt.Sprintf(\"\\tif %s {\\n\\t\\t_p%d = 1\\n\\t} else {\\n\\t\\t_p%d = 0\\n\\t}\\n\", p.Name, n, n)\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(_p%d)\", n))\n-\t\t\t\t\tn++\n-\t\t\t\t} else {\n-\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnargs := len(args)\n-\n-\t\t\t// Determine which form to use; pad args with zeros.\n-\t\t\tasm := \"sysvicall6\"\n-\t\t\tif nonblock != nil {\n-\t\t\t\tasm = \"rawSysvicall6\"\n-\t\t\t}\n-\t\t\tif len(args) <= 6 {\n-\t\t\t\tfor len(args) < 6 {\n-\t\t\t\t\targs = append(args, \"0\")\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: too many arguments to system call\\n\", path)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\n-\t\t\t// Actual call.\n-\t\t\targlist := strings.Join(args, \", \")\n-\t\t\tcall := fmt.Sprintf(\"%s(uintptr(unsafe.Pointer(&%s)), %d, %s)\", asm, sysvarname, nargs, arglist)\n-\n-\t\t\t// Assign return values.\n-\t\t\tbody := \"\"\n-\t\t\tret := []string{\"_\", \"_\", \"_\"}\n-\t\t\tdoErrno := false\n-\t\t\tfor i := 0; i < len(out); i++ {\n-\t\t\t\tp := parseParam(out[i])\n-\t\t\t\treg := \"\"\n-\t\t\t\tif p.Name == \"err\" {\n-\t\t\t\t\treg = \"e1\"\n-\t\t\t\t\tret[2] = reg\n-\t\t\t\t\tdoErrno = true\n-\t\t\t\t} else {\n-\t\t\t\t\treg = fmt.Sprintf(\"r%d\", i)\n-\t\t\t\t\tret[i] = reg\n-\t\t\t\t}\n-\t\t\t\tif p.Type == \"bool\" {\n-\t\t\t\t\treg = fmt.Sprintf(\"%d != 0\", reg)\n-\t\t\t\t}\n-\t\t\t\tif p.Type == \"int64\" && endianness != \"\" {\n-\t\t\t\t\t// 64-bit number in r1:r0 or r0:r1.\n-\t\t\t\t\tif i+2 > len(out) {\n-\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: not enough registers for int64 return\\n\", path)\n-\t\t\t\t\t\tos.Exit(1)\n-\t\t\t\t\t}\n-\t\t\t\t\tif endianness == \"big-endian\" {\n-\t\t\t\t\t\treg = fmt.Sprintf(\"int64(r%d)<<32 | int64(r%d)\", i, i+1)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treg = fmt.Sprintf(\"int64(r%d)<<32 | int64(r%d)\", i+1, i)\n-\t\t\t\t\t}\n-\t\t\t\t\tret[i] = fmt.Sprintf(\"r%d\", i)\n-\t\t\t\t\tret[i+1] = fmt.Sprintf(\"r%d\", i+1)\n-\t\t\t\t}\n-\t\t\t\tif reg != \"e1\" {\n-\t\t\t\t\tbody += fmt.Sprintf(\"\\t%s = %s(%s)\\n\", p.Name, p.Type, reg)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif ret[0] == \"_\" && ret[1] == \"_\" && ret[2] == \"_\" {\n-\t\t\t\ttext += fmt.Sprintf(\"\\t%s\\n\", call)\n-\t\t\t} else {\n-\t\t\t\ttext += fmt.Sprintf(\"\\t%s, %s, %s := %s\\n\", ret[0], ret[1], ret[2], call)\n-\t\t\t}\n-\t\t\ttext += body\n-\n-\t\t\tif doErrno {\n-\t\t\t\ttext += \"\\tif e1 != 0 {\\n\"\n-\t\t\t\ttext += \"\\t\\terr = e1\\n\"\n-\t\t\t\ttext += \"\\t}\\n\"\n-\t\t\t}\n-\t\t\ttext += \"\\treturn\\n\"\n-\t\t\ttext += \"}\\n\"\n-\t\t}\n-\t\tif err := s.Err(); err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\tfile.Close()\n-\t}\n-\timp := \"\"\n-\tif pack != \"unix\" {\n-\t\timp = \"import \\\"golang.org/x/sys/unix\\\"\\n\"\n-\n-\t}\n-\tvardecls := \"\\t\" + strings.Join(vars, \",\\n\\t\")\n-\tvardecls += \" syscallFunc\"\n-\tfmt.Printf(srcTemplate, cmdLine(), buildTags(), pack, imp, dynimports, linknames, vardecls, text)\n-}\n-\n-const srcTemplate = `// %s\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s\n-\n-package %s\n-\n-import (\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-%s\n-%s\n-%s\n-var (\n-%s\t\n-)\n-\n-%s\n-`"
    },
    {
      "sha": "b6b409909cc3c93d86deb351f5699cf672aa4e76",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.go",
      "status": "removed",
      "additions": 0,
      "deletions": 355,
      "changes": 355,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,355 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// Parse the header files for OpenBSD and generate a Go usable sysctl MIB.\n-//\n-// Build a MIB with each entry being an array containing the level, type and\n-// a hash that will contain additional entries if the current entry is a node.\n-// We then walk this MIB and create a flattened sysctl name to OID hash.\n-\n-package main\n-\n-import (\n-\t\"bufio\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"regexp\"\n-\t\"sort\"\n-\t\"strings\"\n-)\n-\n-var (\n-\tgoos, goarch string\n-)\n-\n-// cmdLine returns this programs's commandline arguments.\n-func cmdLine() string {\n-\treturn \"go run mksysctl_openbsd.go \" + strings.Join(os.Args[1:], \" \")\n-}\n-\n-// buildTags returns build tags.\n-func buildTags() string {\n-\treturn fmt.Sprintf(\"%s,%s\", goarch, goos)\n-}\n-\n-// reMatch performs regular expression match and stores the substring slice to value pointed by m.\n-func reMatch(re *regexp.Regexp, str string, m *[]string) bool {\n-\t*m = re.FindStringSubmatch(str)\n-\tif *m != nil {\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-type nodeElement struct {\n-\tn  int\n-\tt  string\n-\tpE *map[string]nodeElement\n-}\n-\n-var (\n-\tdebugEnabled bool\n-\tmib          map[string]nodeElement\n-\tnode         *map[string]nodeElement\n-\tnodeMap      map[string]string\n-\tsysCtl       []string\n-)\n-\n-var (\n-\tctlNames1RE = regexp.MustCompile(`^#define\\s+(CTL_NAMES)\\s+{`)\n-\tctlNames2RE = regexp.MustCompile(`^#define\\s+(CTL_(.*)_NAMES)\\s+{`)\n-\tctlNames3RE = regexp.MustCompile(`^#define\\s+((.*)CTL_NAMES)\\s+{`)\n-\tnetInetRE   = regexp.MustCompile(`^netinet/`)\n-\tnetInet6RE  = regexp.MustCompile(`^netinet6/`)\n-\tnetRE       = regexp.MustCompile(`^net/`)\n-\tbracesRE    = regexp.MustCompile(`{.*}`)\n-\tctlTypeRE   = regexp.MustCompile(`{\\s+\"(\\w+)\",\\s+(CTLTYPE_[A-Z]+)\\s+}`)\n-\tfsNetKernRE = regexp.MustCompile(`^(fs|net|kern)_`)\n-)\n-\n-func debug(s string) {\n-\tif debugEnabled {\n-\t\tfmt.Fprintln(os.Stderr, s)\n-\t}\n-}\n-\n-// Walk the MIB and build a sysctl name to OID mapping.\n-func buildSysctl(pNode *map[string]nodeElement, name string, oid []int) {\n-\tlNode := pNode // local copy of pointer to node\n-\tvar keys []string\n-\tfor k := range *lNode {\n-\t\tkeys = append(keys, k)\n-\t}\n-\tsort.Strings(keys)\n-\n-\tfor _, key := range keys {\n-\t\tnodename := name\n-\t\tif name != \"\" {\n-\t\t\tnodename += \".\"\n-\t\t}\n-\t\tnodename += key\n-\n-\t\tnodeoid := append(oid, (*pNode)[key].n)\n-\n-\t\tif (*pNode)[key].t == `CTLTYPE_NODE` {\n-\t\t\tif _, ok := nodeMap[nodename]; ok {\n-\t\t\t\tlNode = &mib\n-\t\t\t\tctlName := nodeMap[nodename]\n-\t\t\t\tfor _, part := range strings.Split(ctlName, \".\") {\n-\t\t\t\t\tlNode = ((*lNode)[part]).pE\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tlNode = (*pNode)[key].pE\n-\t\t\t}\n-\t\t\tbuildSysctl(lNode, nodename, nodeoid)\n-\t\t} else if (*pNode)[key].t != \"\" {\n-\t\t\toidStr := []string{}\n-\t\t\tfor j := range nodeoid {\n-\t\t\t\toidStr = append(oidStr, fmt.Sprintf(\"%d\", nodeoid[j]))\n-\t\t\t}\n-\t\t\ttext := \"\\t{ \\\"\" + nodename + \"\\\", []_C_int{ \" + strings.Join(oidStr, \", \") + \" } }, \\n\"\n-\t\t\tsysCtl = append(sysCtl, text)\n-\t\t}\n-\t}\n-}\n-\n-func main() {\n-\t// Get the OS (using GOOS_TARGET if it exist)\n-\tgoos = os.Getenv(\"GOOS_TARGET\")\n-\tif goos == \"\" {\n-\t\tgoos = os.Getenv(\"GOOS\")\n-\t}\n-\t// Get the architecture (using GOARCH_TARGET if it exists)\n-\tgoarch = os.Getenv(\"GOARCH_TARGET\")\n-\tif goarch == \"\" {\n-\t\tgoarch = os.Getenv(\"GOARCH\")\n-\t}\n-\t// Check if GOOS and GOARCH environment variables are defined\n-\tif goarch == \"\" || goos == \"\" {\n-\t\tfmt.Fprintf(os.Stderr, \"GOARCH or GOOS not defined in environment\\n\")\n-\t\tos.Exit(1)\n-\t}\n-\n-\tmib = make(map[string]nodeElement)\n-\theaders := [...]string{\n-\t\t`sys/sysctl.h`,\n-\t\t`sys/socket.h`,\n-\t\t`sys/tty.h`,\n-\t\t`sys/malloc.h`,\n-\t\t`sys/mount.h`,\n-\t\t`sys/namei.h`,\n-\t\t`sys/sem.h`,\n-\t\t`sys/shm.h`,\n-\t\t`sys/vmmeter.h`,\n-\t\t`uvm/uvmexp.h`,\n-\t\t`uvm/uvm_param.h`,\n-\t\t`uvm/uvm_swap_encrypt.h`,\n-\t\t`ddb/db_var.h`,\n-\t\t`net/if.h`,\n-\t\t`net/if_pfsync.h`,\n-\t\t`net/pipex.h`,\n-\t\t`netinet/in.h`,\n-\t\t`netinet/icmp_var.h`,\n-\t\t`netinet/igmp_var.h`,\n-\t\t`netinet/ip_ah.h`,\n-\t\t`netinet/ip_carp.h`,\n-\t\t`netinet/ip_divert.h`,\n-\t\t`netinet/ip_esp.h`,\n-\t\t`netinet/ip_ether.h`,\n-\t\t`netinet/ip_gre.h`,\n-\t\t`netinet/ip_ipcomp.h`,\n-\t\t`netinet/ip_ipip.h`,\n-\t\t`netinet/pim_var.h`,\n-\t\t`netinet/tcp_var.h`,\n-\t\t`netinet/udp_var.h`,\n-\t\t`netinet6/in6.h`,\n-\t\t`netinet6/ip6_divert.h`,\n-\t\t`netinet6/pim6_var.h`,\n-\t\t`netinet/icmp6.h`,\n-\t\t`netmpls/mpls.h`,\n-\t}\n-\n-\tctls := [...]string{\n-\t\t`kern`,\n-\t\t`vm`,\n-\t\t`fs`,\n-\t\t`net`,\n-\t\t//debug\t\t\t/* Special handling required */\n-\t\t`hw`,\n-\t\t//machdep\t\t/* Arch specific */\n-\t\t`user`,\n-\t\t`ddb`,\n-\t\t//vfs\t\t\t/* Special handling required */\n-\t\t`fs.posix`,\n-\t\t`kern.forkstat`,\n-\t\t`kern.intrcnt`,\n-\t\t`kern.malloc`,\n-\t\t`kern.nchstats`,\n-\t\t`kern.seminfo`,\n-\t\t`kern.shminfo`,\n-\t\t`kern.timecounter`,\n-\t\t`kern.tty`,\n-\t\t`kern.watchdog`,\n-\t\t`net.bpf`,\n-\t\t`net.ifq`,\n-\t\t`net.inet`,\n-\t\t`net.inet.ah`,\n-\t\t`net.inet.carp`,\n-\t\t`net.inet.divert`,\n-\t\t`net.inet.esp`,\n-\t\t`net.inet.etherip`,\n-\t\t`net.inet.gre`,\n-\t\t`net.inet.icmp`,\n-\t\t`net.inet.igmp`,\n-\t\t`net.inet.ip`,\n-\t\t`net.inet.ip.ifq`,\n-\t\t`net.inet.ipcomp`,\n-\t\t`net.inet.ipip`,\n-\t\t`net.inet.mobileip`,\n-\t\t`net.inet.pfsync`,\n-\t\t`net.inet.pim`,\n-\t\t`net.inet.tcp`,\n-\t\t`net.inet.udp`,\n-\t\t`net.inet6`,\n-\t\t`net.inet6.divert`,\n-\t\t`net.inet6.ip6`,\n-\t\t`net.inet6.icmp6`,\n-\t\t`net.inet6.pim6`,\n-\t\t`net.inet6.tcp6`,\n-\t\t`net.inet6.udp6`,\n-\t\t`net.mpls`,\n-\t\t`net.mpls.ifq`,\n-\t\t`net.key`,\n-\t\t`net.pflow`,\n-\t\t`net.pfsync`,\n-\t\t`net.pipex`,\n-\t\t`net.rt`,\n-\t\t`vm.swapencrypt`,\n-\t\t//vfsgenctl\t\t/* Special handling required */\n-\t}\n-\n-\t// Node name \"fixups\"\n-\tctlMap := map[string]string{\n-\t\t\"ipproto\":             \"net.inet\",\n-\t\t\"net.inet.ipproto\":    \"net.inet\",\n-\t\t\"net.inet6.ipv6proto\": \"net.inet6\",\n-\t\t\"net.inet6.ipv6\":      \"net.inet6.ip6\",\n-\t\t\"net.inet.icmpv6\":     \"net.inet6.icmp6\",\n-\t\t\"net.inet6.divert6\":   \"net.inet6.divert\",\n-\t\t\"net.inet6.tcp6\":      \"net.inet.tcp\",\n-\t\t\"net.inet6.udp6\":      \"net.inet.udp\",\n-\t\t\"mpls\":                \"net.mpls\",\n-\t\t\"swpenc\":              \"vm.swapencrypt\",\n-\t}\n-\n-\t// Node mappings\n-\tnodeMap = map[string]string{\n-\t\t\"net.inet.ip.ifq\": \"net.ifq\",\n-\t\t\"net.inet.pfsync\": \"net.pfsync\",\n-\t\t\"net.mpls.ifq\":    \"net.ifq\",\n-\t}\n-\n-\tmCtls := make(map[string]bool)\n-\tfor _, ctl := range ctls {\n-\t\tmCtls[ctl] = true\n-\t}\n-\n-\tfor _, header := range headers {\n-\t\tdebug(\"Processing \" + header)\n-\t\tfile, err := os.Open(filepath.Join(\"/usr/include\", header))\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\ts := bufio.NewScanner(file)\n-\t\tfor s.Scan() {\n-\t\t\tvar sub []string\n-\t\t\tif reMatch(ctlNames1RE, s.Text(), &sub) ||\n-\t\t\t\treMatch(ctlNames2RE, s.Text(), &sub) ||\n-\t\t\t\treMatch(ctlNames3RE, s.Text(), &sub) {\n-\t\t\t\tif sub[1] == `CTL_NAMES` {\n-\t\t\t\t\t// Top level.\n-\t\t\t\t\tnode = &mib\n-\t\t\t\t} else {\n-\t\t\t\t\t// Node.\n-\t\t\t\t\tnodename := strings.ToLower(sub[2])\n-\t\t\t\t\tctlName := \"\"\n-\t\t\t\t\tif reMatch(netInetRE, header, &sub) {\n-\t\t\t\t\t\tctlName = \"net.inet.\" + nodename\n-\t\t\t\t\t} else if reMatch(netInet6RE, header, &sub) {\n-\t\t\t\t\t\tctlName = \"net.inet6.\" + nodename\n-\t\t\t\t\t} else if reMatch(netRE, header, &sub) {\n-\t\t\t\t\t\tctlName = \"net.\" + nodename\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tctlName = nodename\n-\t\t\t\t\t\tctlName = fsNetKernRE.ReplaceAllString(ctlName, `$1.`)\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif val, ok := ctlMap[ctlName]; ok {\n-\t\t\t\t\t\tctlName = val\n-\t\t\t\t\t}\n-\t\t\t\t\tif _, ok := mCtls[ctlName]; !ok {\n-\t\t\t\t\t\tdebug(\"Ignoring \" + ctlName + \"...\")\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Walk down from the top of the MIB.\n-\t\t\t\t\tnode = &mib\n-\t\t\t\t\tfor _, part := range strings.Split(ctlName, \".\") {\n-\t\t\t\t\t\tif _, ok := (*node)[part]; !ok {\n-\t\t\t\t\t\t\tdebug(\"Missing node \" + part)\n-\t\t\t\t\t\t\t(*node)[part] = nodeElement{n: 0, t: \"\", pE: &map[string]nodeElement{}}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tnode = (*node)[part].pE\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Populate current node with entries.\n-\t\t\t\ti := -1\n-\t\t\t\tfor !strings.HasPrefix(s.Text(), \"}\") {\n-\t\t\t\t\ts.Scan()\n-\t\t\t\t\tif reMatch(bracesRE, s.Text(), &sub) {\n-\t\t\t\t\t\ti++\n-\t\t\t\t\t}\n-\t\t\t\t\tif !reMatch(ctlTypeRE, s.Text(), &sub) {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\t(*node)[sub[1]] = nodeElement{n: i, t: sub[2], pE: &map[string]nodeElement{}}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\terr = s.Err()\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\tfile.Close()\n-\t}\n-\tbuildSysctl(&mib, \"\", []int{})\n-\n-\tsort.Strings(sysCtl)\n-\ttext := strings.Join(sysCtl, \"\")\n-\n-\tfmt.Printf(srcTemplate, cmdLine(), buildTags(), text)\n-}\n-\n-const srcTemplate = `// %s\n-// Code generated by the command above; DO NOT EDIT.\n-\n-// +build %s\n-\n-package unix\n-\n-type mibentry struct {\n-\tctlname string\n-\tctloid []_C_int\n-}\n-\n-var sysctlMib = []mibentry {\n-%s\n-}\n-`"
    },
    {
      "sha": "baa6ecd85065d3c008958a73c0483427b3966dfe",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysnum.go",
      "status": "removed",
      "additions": 0,
      "deletions": 190,
      "changes": 190,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksysnum.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/mksysnum.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysnum.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,190 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// Generate system call table for DragonFly, NetBSD,\n-// FreeBSD, OpenBSD or Darwin from master list\n-// (for example, /usr/src/sys/kern/syscalls.master or\n-// sys/syscall.h).\n-package main\n-\n-import (\n-\t\"bufio\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"net/http\"\n-\t\"os\"\n-\t\"regexp\"\n-\t\"strings\"\n-)\n-\n-var (\n-\tgoos, goarch string\n-)\n-\n-// cmdLine returns this programs's commandline arguments\n-func cmdLine() string {\n-\treturn \"go run mksysnum.go \" + strings.Join(os.Args[1:], \" \")\n-}\n-\n-// buildTags returns build tags\n-func buildTags() string {\n-\treturn fmt.Sprintf(\"%s,%s\", goarch, goos)\n-}\n-\n-func checkErr(err error) {\n-\tif err != nil {\n-\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n-\t\tos.Exit(1)\n-\t}\n-}\n-\n-// source string and substring slice for regexp\n-type re struct {\n-\tstr string   // source string\n-\tsub []string // matched sub-string\n-}\n-\n-// Match performs regular expression match\n-func (r *re) Match(exp string) bool {\n-\tr.sub = regexp.MustCompile(exp).FindStringSubmatch(r.str)\n-\tif r.sub != nil {\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-// fetchFile fetches a text file from URL\n-func fetchFile(URL string) io.Reader {\n-\tresp, err := http.Get(URL)\n-\tcheckErr(err)\n-\tdefer resp.Body.Close()\n-\tbody, err := ioutil.ReadAll(resp.Body)\n-\tcheckErr(err)\n-\treturn strings.NewReader(string(body))\n-}\n-\n-// readFile reads a text file from path\n-func readFile(path string) io.Reader {\n-\tfile, err := os.Open(os.Args[1])\n-\tcheckErr(err)\n-\treturn file\n-}\n-\n-func format(name, num, proto string) string {\n-\tname = strings.ToUpper(name)\n-\t// There are multiple entries for enosys and nosys, so comment them out.\n-\tnm := re{str: name}\n-\tif nm.Match(`^SYS_E?NOSYS$`) {\n-\t\tname = fmt.Sprintf(\"// %s\", name)\n-\t}\n-\tif name == `SYS_SYS_EXIT` {\n-\t\tname = `SYS_EXIT`\n-\t}\n-\treturn fmt.Sprintf(\"\t%s = %s;  // %s\\n\", name, num, proto)\n-}\n-\n-func main() {\n-\t// Get the OS (using GOOS_TARGET if it exist)\n-\tgoos = os.Getenv(\"GOOS_TARGET\")\n-\tif goos == \"\" {\n-\t\tgoos = os.Getenv(\"GOOS\")\n-\t}\n-\t// Get the architecture (using GOARCH_TARGET if it exists)\n-\tgoarch = os.Getenv(\"GOARCH_TARGET\")\n-\tif goarch == \"\" {\n-\t\tgoarch = os.Getenv(\"GOARCH\")\n-\t}\n-\t// Check if GOOS and GOARCH environment variables are defined\n-\tif goarch == \"\" || goos == \"\" {\n-\t\tfmt.Fprintf(os.Stderr, \"GOARCH or GOOS not defined in environment\\n\")\n-\t\tos.Exit(1)\n-\t}\n-\n-\tfile := strings.TrimSpace(os.Args[1])\n-\tvar syscalls io.Reader\n-\tif strings.HasPrefix(file, \"https://\") || strings.HasPrefix(file, \"http://\") {\n-\t\t// Download syscalls.master file\n-\t\tsyscalls = fetchFile(file)\n-\t} else {\n-\t\tsyscalls = readFile(file)\n-\t}\n-\n-\tvar text, line string\n-\ts := bufio.NewScanner(syscalls)\n-\tfor s.Scan() {\n-\t\tt := re{str: line}\n-\t\tif t.Match(`^(.*)\\\\$`) {\n-\t\t\t// Handle continuation\n-\t\t\tline = t.sub[1]\n-\t\t\tline += strings.TrimLeft(s.Text(), \" \\t\")\n-\t\t} else {\n-\t\t\t// New line\n-\t\t\tline = s.Text()\n-\t\t}\n-\t\tt = re{str: line}\n-\t\tif t.Match(`\\\\$`) {\n-\t\t\tcontinue\n-\t\t}\n-\t\tt = re{str: line}\n-\n-\t\tswitch goos {\n-\t\tcase \"dragonfly\":\n-\t\t\tif t.Match(`^([0-9]+)\\s+STD\\s+({ \\S+\\s+(\\w+).*)$`) {\n-\t\t\t\tnum, proto := t.sub[1], t.sub[2]\n-\t\t\t\tname := fmt.Sprintf(\"SYS_%s\", t.sub[3])\n-\t\t\t\ttext += format(name, num, proto)\n-\t\t\t}\n-\t\tcase \"freebsd\":\n-\t\t\tif t.Match(`^([0-9]+)\\s+\\S+\\s+(?:(?:NO)?STD|COMPAT10)\\s+({ \\S+\\s+(\\w+).*)$`) {\n-\t\t\t\tnum, proto := t.sub[1], t.sub[2]\n-\t\t\t\tname := fmt.Sprintf(\"SYS_%s\", t.sub[3])\n-\t\t\t\ttext += format(name, num, proto)\n-\t\t\t}\n-\t\tcase \"openbsd\":\n-\t\t\tif t.Match(`^([0-9]+)\\s+STD\\s+(NOLOCK\\s+)?({ \\S+\\s+\\*?(\\w+).*)$`) {\n-\t\t\t\tnum, proto, name := t.sub[1], t.sub[3], t.sub[4]\n-\t\t\t\ttext += format(name, num, proto)\n-\t\t\t}\n-\t\tcase \"netbsd\":\n-\t\t\tif t.Match(`^([0-9]+)\\s+((STD)|(NOERR))\\s+(RUMP\\s+)?({\\s+\\S+\\s*\\*?\\s*\\|(\\S+)\\|(\\S*)\\|(\\w+).*\\s+})(\\s+(\\S+))?$`) {\n-\t\t\t\tnum, proto, compat := t.sub[1], t.sub[6], t.sub[8]\n-\t\t\t\tname := t.sub[7] + \"_\" + t.sub[9]\n-\t\t\t\tif t.sub[11] != \"\" {\n-\t\t\t\t\tname = t.sub[7] + \"_\" + t.sub[11]\n-\t\t\t\t}\n-\t\t\t\tname = strings.ToUpper(name)\n-\t\t\t\tif compat == \"\" || compat == \"13\" || compat == \"30\" || compat == \"50\" {\n-\t\t\t\t\ttext += fmt.Sprintf(\"\t%s = %s;  // %s\\n\", name, num, proto)\n-\t\t\t\t}\n-\t\t\t}\n-\t\tcase \"darwin\":\n-\t\t\tif t.Match(`^#define\\s+SYS_(\\w+)\\s+([0-9]+)`) {\n-\t\t\t\tname, num := t.sub[1], t.sub[2]\n-\t\t\t\tname = strings.ToUpper(name)\n-\t\t\t\ttext += fmt.Sprintf(\"\tSYS_%s = %s;\\n\", name, num)\n-\t\t\t}\n-\t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"unrecognized GOOS=%s\\n\", goos)\n-\t\t\tos.Exit(1)\n-\n-\t\t}\n-\t}\n-\terr := s.Err()\n-\tcheckErr(err)\n-\n-\tfmt.Printf(template, cmdLine(), buildTags(), text)\n-}\n-\n-const template = `// %s\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build %s\n-\n-package unix\n-\n-const(\n-%s)`"
    },
    {
      "sha": "40d2beede556524b8d03d73a2bb41f14b8ae70b9",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_aix.go",
      "status": "removed",
      "additions": 0,
      "deletions": 237,
      "changes": 237,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_aix.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_aix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_aix.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,237 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-// +build aix\n-\n-/*\n-Input to cgo -godefs.  See also mkerrors.sh and mkall.sh\n-*/\n-\n-// +godefs map struct_in_addr [4]byte /* in_addr */\n-// +godefs map struct_in6_addr [16]byte /* in6_addr */\n-\n-package unix\n-\n-/*\n-#include <sys/types.h>\n-#include <sys/time.h>\n-#include <sys/limits.h>\n-#include <sys/un.h>\n-#include <utime.h>\n-#include <sys/utsname.h>\n-#include <sys/poll.h>\n-#include <sys/resource.h>\n-#include <sys/stat.h>\n-#include <sys/statfs.h>\n-#include <sys/termio.h>\n-#include <sys/ioctl.h>\n-\n-#include <termios.h>\n-\n-#include <net/if.h>\n-#include <net/if_dl.h>\n-#include <netinet/in.h>\n-#include <netinet/icmp6.h>\n-\n-\n-#include <dirent.h>\n-#include <fcntl.h>\n-\n-enum {\n-\tsizeofPtr = sizeof(void*),\n-};\n-\n-union sockaddr_all {\n-\tstruct sockaddr s1;     // this one gets used for fields\n-\tstruct sockaddr_in s2;  // these pad it out\n-\tstruct sockaddr_in6 s3;\n-\tstruct sockaddr_un s4;\n-\tstruct sockaddr_dl s5;\n-};\n-\n-struct sockaddr_any {\n-\tstruct sockaddr addr;\n-\tchar pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];\n-};\n-\n-*/\n-import \"C\"\n-\n-// Machine characteristics\n-\n-const (\n-\tSizeofPtr      = C.sizeofPtr\n-\tSizeofShort    = C.sizeof_short\n-\tSizeofInt      = C.sizeof_int\n-\tSizeofLong     = C.sizeof_long\n-\tSizeofLongLong = C.sizeof_longlong\n-\tPathMax        = C.PATH_MAX\n-)\n-\n-// Basic types\n-\n-type (\n-\t_C_short     C.short\n-\t_C_int       C.int\n-\t_C_long      C.long\n-\t_C_long_long C.longlong\n-)\n-\n-type off64 C.off64_t\n-type off C.off_t\n-type Mode_t C.mode_t\n-\n-// Time\n-\n-type Timespec C.struct_timespec\n-\n-type Timeval C.struct_timeval\n-\n-type Timeval32 C.struct_timeval32\n-\n-type Timex C.struct_timex\n-\n-type Time_t C.time_t\n-\n-type Tms C.struct_tms\n-\n-type Utimbuf C.struct_utimbuf\n-\n-type Timezone C.struct_timezone\n-\n-// Processes\n-\n-type Rusage C.struct_rusage\n-\n-type Rlimit C.struct_rlimit64\n-\n-type Pid_t C.pid_t\n-\n-type _Gid_t C.gid_t\n-\n-type dev_t C.dev_t\n-\n-// Files\n-\n-type Stat_t C.struct_stat\n-\n-type StatxTimestamp C.struct_statx_timestamp\n-\n-type Statx_t C.struct_statx\n-\n-type Dirent C.struct_dirent\n-\n-// Sockets\n-\n-type RawSockaddrInet4 C.struct_sockaddr_in\n-\n-type RawSockaddrInet6 C.struct_sockaddr_in6\n-\n-type RawSockaddrUnix C.struct_sockaddr_un\n-\n-type RawSockaddrDatalink C.struct_sockaddr_dl\n-\n-type RawSockaddr C.struct_sockaddr\n-\n-type RawSockaddrAny C.struct_sockaddr_any\n-\n-type _Socklen C.socklen_t\n-\n-type Cmsghdr C.struct_cmsghdr\n-\n-type ICMPv6Filter C.struct_icmp6_filter\n-\n-type Iovec C.struct_iovec\n-\n-type IPMreq C.struct_ip_mreq\n-\n-type IPv6Mreq C.struct_ipv6_mreq\n-\n-type IPv6MTUInfo C.struct_ip6_mtuinfo\n-\n-type Linger C.struct_linger\n-\n-type Msghdr C.struct_msghdr\n-\n-const (\n-\tSizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in\n-\tSizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6\n-\tSizeofSockaddrAny      = C.sizeof_struct_sockaddr_any\n-\tSizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un\n-\tSizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl\n-\tSizeofLinger           = C.sizeof_struct_linger\n-\tSizeofIPMreq           = C.sizeof_struct_ip_mreq\n-\tSizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq\n-\tSizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo\n-\tSizeofMsghdr           = C.sizeof_struct_msghdr\n-\tSizeofCmsghdr          = C.sizeof_struct_cmsghdr\n-\tSizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter\n-)\n-\n-// Routing and interface messages\n-\n-const (\n-\tSizeofIfMsghdr = C.sizeof_struct_if_msghdr\n-)\n-\n-type IfMsgHdr C.struct_if_msghdr\n-\n-// Misc\n-\n-type FdSet C.fd_set\n-\n-type Utsname C.struct_utsname\n-\n-type Ustat_t C.struct_ustat\n-\n-type Sigset_t C.sigset_t\n-\n-const (\n-\tAT_FDCWD            = C.AT_FDCWD\n-\tAT_REMOVEDIR        = C.AT_REMOVEDIR\n-\tAT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW\n-)\n-\n-// Terminal handling\n-\n-type Termios C.struct_termios\n-\n-type Termio C.struct_termio\n-\n-type Winsize C.struct_winsize\n-\n-//poll\n-\n-type PollFd struct {\n-\tFd      int32\n-\tEvents  uint16\n-\tRevents uint16\n-}\n-\n-const (\n-\tPOLLERR    = C.POLLERR\n-\tPOLLHUP    = C.POLLHUP\n-\tPOLLIN     = C.POLLIN\n-\tPOLLNVAL   = C.POLLNVAL\n-\tPOLLOUT    = C.POLLOUT\n-\tPOLLPRI    = C.POLLPRI\n-\tPOLLRDBAND = C.POLLRDBAND\n-\tPOLLRDNORM = C.POLLRDNORM\n-\tPOLLWRBAND = C.POLLWRBAND\n-\tPOLLWRNORM = C.POLLWRNORM\n-)\n-\n-//flock_t\n-\n-type Flock_t C.struct_flock64\n-\n-// Statfs\n-\n-type Fsid_t C.struct_fsid_t\n-type Fsid64_t C.struct_fsid64_t\n-\n-type Statfs_t C.struct_statfs\n-\n-const RNDGETENTCNT = 0x80045200"
    },
    {
      "sha": "155c2e692b45eb9f4416eaa6fe5ad50c4ea655a1",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_darwin.go",
      "status": "removed",
      "additions": 0,
      "deletions": 283,
      "changes": 283,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_darwin.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_darwin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_darwin.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,283 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-Input to cgo -godefs.  See README.md\n-*/\n-\n-// +godefs map struct_in_addr [4]byte /* in_addr */\n-// +godefs map struct_in6_addr [16]byte /* in6_addr */\n-\n-package unix\n-\n-/*\n-#define __DARWIN_UNIX03 0\n-#define KERNEL\n-#define _DARWIN_USE_64_BIT_INODE\n-#include <dirent.h>\n-#include <fcntl.h>\n-#include <poll.h>\n-#include <signal.h>\n-#include <termios.h>\n-#include <unistd.h>\n-#include <mach/mach.h>\n-#include <mach/message.h>\n-#include <sys/event.h>\n-#include <sys/mman.h>\n-#include <sys/mount.h>\n-#include <sys/param.h>\n-#include <sys/ptrace.h>\n-#include <sys/resource.h>\n-#include <sys/select.h>\n-#include <sys/signal.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/types.h>\n-#include <sys/uio.h>\n-#include <sys/un.h>\n-#include <sys/utsname.h>\n-#include <sys/wait.h>\n-#include <net/bpf.h>\n-#include <net/if.h>\n-#include <net/if_dl.h>\n-#include <net/if_var.h>\n-#include <net/route.h>\n-#include <netinet/in.h>\n-#include <netinet/icmp6.h>\n-#include <netinet/tcp.h>\n-\n-enum {\n-\tsizeofPtr = sizeof(void*),\n-};\n-\n-union sockaddr_all {\n-\tstruct sockaddr s1;\t// this one gets used for fields\n-\tstruct sockaddr_in s2;\t// these pad it out\n-\tstruct sockaddr_in6 s3;\n-\tstruct sockaddr_un s4;\n-\tstruct sockaddr_dl s5;\n-};\n-\n-struct sockaddr_any {\n-\tstruct sockaddr addr;\n-\tchar pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];\n-};\n-\n-*/\n-import \"C\"\n-\n-// Machine characteristics\n-\n-const (\n-\tSizeofPtr      = C.sizeofPtr\n-\tSizeofShort    = C.sizeof_short\n-\tSizeofInt      = C.sizeof_int\n-\tSizeofLong     = C.sizeof_long\n-\tSizeofLongLong = C.sizeof_longlong\n-)\n-\n-// Basic types\n-\n-type (\n-\t_C_short     C.short\n-\t_C_int       C.int\n-\t_C_long      C.long\n-\t_C_long_long C.longlong\n-)\n-\n-// Time\n-\n-type Timespec C.struct_timespec\n-\n-type Timeval C.struct_timeval\n-\n-type Timeval32 C.struct_timeval32\n-\n-// Processes\n-\n-type Rusage C.struct_rusage\n-\n-type Rlimit C.struct_rlimit\n-\n-type _Gid_t C.gid_t\n-\n-// Files\n-\n-type Stat_t C.struct_stat64\n-\n-type Statfs_t C.struct_statfs64\n-\n-type Flock_t C.struct_flock\n-\n-type Fstore_t C.struct_fstore\n-\n-type Radvisory_t C.struct_radvisory\n-\n-type Fbootstraptransfer_t C.struct_fbootstraptransfer\n-\n-type Log2phys_t C.struct_log2phys\n-\n-type Fsid C.struct_fsid\n-\n-type Dirent C.struct_dirent\n-\n-// Sockets\n-\n-type RawSockaddrInet4 C.struct_sockaddr_in\n-\n-type RawSockaddrInet6 C.struct_sockaddr_in6\n-\n-type RawSockaddrUnix C.struct_sockaddr_un\n-\n-type RawSockaddrDatalink C.struct_sockaddr_dl\n-\n-type RawSockaddr C.struct_sockaddr\n-\n-type RawSockaddrAny C.struct_sockaddr_any\n-\n-type _Socklen C.socklen_t\n-\n-type Linger C.struct_linger\n-\n-type Iovec C.struct_iovec\n-\n-type IPMreq C.struct_ip_mreq\n-\n-type IPv6Mreq C.struct_ipv6_mreq\n-\n-type Msghdr C.struct_msghdr\n-\n-type Cmsghdr C.struct_cmsghdr\n-\n-type Inet4Pktinfo C.struct_in_pktinfo\n-\n-type Inet6Pktinfo C.struct_in6_pktinfo\n-\n-type IPv6MTUInfo C.struct_ip6_mtuinfo\n-\n-type ICMPv6Filter C.struct_icmp6_filter\n-\n-const (\n-\tSizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in\n-\tSizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6\n-\tSizeofSockaddrAny      = C.sizeof_struct_sockaddr_any\n-\tSizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un\n-\tSizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl\n-\tSizeofLinger           = C.sizeof_struct_linger\n-\tSizeofIPMreq           = C.sizeof_struct_ip_mreq\n-\tSizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq\n-\tSizeofMsghdr           = C.sizeof_struct_msghdr\n-\tSizeofCmsghdr          = C.sizeof_struct_cmsghdr\n-\tSizeofInet4Pktinfo     = C.sizeof_struct_in_pktinfo\n-\tSizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo\n-\tSizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo\n-\tSizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter\n-)\n-\n-// Ptrace requests\n-\n-const (\n-\tPTRACE_TRACEME = C.PT_TRACE_ME\n-\tPTRACE_CONT    = C.PT_CONTINUE\n-\tPTRACE_KILL    = C.PT_KILL\n-)\n-\n-// Events (kqueue, kevent)\n-\n-type Kevent_t C.struct_kevent\n-\n-// Select\n-\n-type FdSet C.fd_set\n-\n-// Routing and interface messages\n-\n-const (\n-\tSizeofIfMsghdr    = C.sizeof_struct_if_msghdr\n-\tSizeofIfData      = C.sizeof_struct_if_data\n-\tSizeofIfaMsghdr   = C.sizeof_struct_ifa_msghdr\n-\tSizeofIfmaMsghdr  = C.sizeof_struct_ifma_msghdr\n-\tSizeofIfmaMsghdr2 = C.sizeof_struct_ifma_msghdr2\n-\tSizeofRtMsghdr    = C.sizeof_struct_rt_msghdr\n-\tSizeofRtMetrics   = C.sizeof_struct_rt_metrics\n-)\n-\n-type IfMsghdr C.struct_if_msghdr\n-\n-type IfData C.struct_if_data\n-\n-type IfaMsghdr C.struct_ifa_msghdr\n-\n-type IfmaMsghdr C.struct_ifma_msghdr\n-\n-type IfmaMsghdr2 C.struct_ifma_msghdr2\n-\n-type RtMsghdr C.struct_rt_msghdr\n-\n-type RtMetrics C.struct_rt_metrics\n-\n-// Berkeley packet filter\n-\n-const (\n-\tSizeofBpfVersion = C.sizeof_struct_bpf_version\n-\tSizeofBpfStat    = C.sizeof_struct_bpf_stat\n-\tSizeofBpfProgram = C.sizeof_struct_bpf_program\n-\tSizeofBpfInsn    = C.sizeof_struct_bpf_insn\n-\tSizeofBpfHdr     = C.sizeof_struct_bpf_hdr\n-)\n-\n-type BpfVersion C.struct_bpf_version\n-\n-type BpfStat C.struct_bpf_stat\n-\n-type BpfProgram C.struct_bpf_program\n-\n-type BpfInsn C.struct_bpf_insn\n-\n-type BpfHdr C.struct_bpf_hdr\n-\n-// Terminal handling\n-\n-type Termios C.struct_termios\n-\n-type Winsize C.struct_winsize\n-\n-// fchmodat-like syscalls.\n-\n-const (\n-\tAT_FDCWD            = C.AT_FDCWD\n-\tAT_REMOVEDIR        = C.AT_REMOVEDIR\n-\tAT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW\n-\tAT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW\n-)\n-\n-// poll\n-\n-type PollFd C.struct_pollfd\n-\n-const (\n-\tPOLLERR    = C.POLLERR\n-\tPOLLHUP    = C.POLLHUP\n-\tPOLLIN     = C.POLLIN\n-\tPOLLNVAL   = C.POLLNVAL\n-\tPOLLOUT    = C.POLLOUT\n-\tPOLLPRI    = C.POLLPRI\n-\tPOLLRDBAND = C.POLLRDBAND\n-\tPOLLRDNORM = C.POLLRDNORM\n-\tPOLLWRBAND = C.POLLWRBAND\n-\tPOLLWRNORM = C.POLLWRNORM\n-)\n-\n-// uname\n-\n-type Utsname C.struct_utsname\n-\n-// Clockinfo\n-\n-const SizeofClockinfo = C.sizeof_struct_clockinfo\n-\n-type Clockinfo C.struct_clockinfo"
    },
    {
      "sha": "3365dd79d082c232ec189b6d1dbcf0eb21ea8364",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_dragonfly.go",
      "status": "removed",
      "additions": 0,
      "deletions": 263,
      "changes": 263,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_dragonfly.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_dragonfly.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_dragonfly.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,263 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-Input to cgo -godefs.  See README.md\n-*/\n-\n-// +godefs map struct_in_addr [4]byte /* in_addr */\n-// +godefs map struct_in6_addr [16]byte /* in6_addr */\n-\n-package unix\n-\n-/*\n-#define KERNEL\n-#include <dirent.h>\n-#include <fcntl.h>\n-#include <poll.h>\n-#include <signal.h>\n-#include <termios.h>\n-#include <stdio.h>\n-#include <unistd.h>\n-#include <sys/event.h>\n-#include <sys/mman.h>\n-#include <sys/mount.h>\n-#include <sys/param.h>\n-#include <sys/ptrace.h>\n-#include <sys/resource.h>\n-#include <sys/select.h>\n-#include <sys/signal.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/types.h>\n-#include <sys/un.h>\n-#include <sys/utsname.h>\n-#include <sys/wait.h>\n-#include <net/bpf.h>\n-#include <net/if.h>\n-#include <net/if_dl.h>\n-#include <net/route.h>\n-#include <netinet/in.h>\n-#include <netinet/icmp6.h>\n-#include <netinet/tcp.h>\n-\n-enum {\n-\tsizeofPtr = sizeof(void*),\n-};\n-\n-union sockaddr_all {\n-\tstruct sockaddr s1;\t// this one gets used for fields\n-\tstruct sockaddr_in s2;\t// these pad it out\n-\tstruct sockaddr_in6 s3;\n-\tstruct sockaddr_un s4;\n-\tstruct sockaddr_dl s5;\n-};\n-\n-struct sockaddr_any {\n-\tstruct sockaddr addr;\n-\tchar pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];\n-};\n-\n-*/\n-import \"C\"\n-\n-// Machine characteristics\n-\n-const (\n-\tSizeofPtr      = C.sizeofPtr\n-\tSizeofShort    = C.sizeof_short\n-\tSizeofInt      = C.sizeof_int\n-\tSizeofLong     = C.sizeof_long\n-\tSizeofLongLong = C.sizeof_longlong\n-)\n-\n-// Basic types\n-\n-type (\n-\t_C_short     C.short\n-\t_C_int       C.int\n-\t_C_long      C.long\n-\t_C_long_long C.longlong\n-)\n-\n-// Time\n-\n-type Timespec C.struct_timespec\n-\n-type Timeval C.struct_timeval\n-\n-// Processes\n-\n-type Rusage C.struct_rusage\n-\n-type Rlimit C.struct_rlimit\n-\n-type _Gid_t C.gid_t\n-\n-// Files\n-\n-type Stat_t C.struct_stat\n-\n-type Statfs_t C.struct_statfs\n-\n-type Flock_t C.struct_flock\n-\n-type Dirent C.struct_dirent\n-\n-type Fsid C.struct_fsid\n-\n-// File system limits\n-\n-const (\n-\tPathMax = C.PATH_MAX\n-)\n-\n-// Sockets\n-\n-type RawSockaddrInet4 C.struct_sockaddr_in\n-\n-type RawSockaddrInet6 C.struct_sockaddr_in6\n-\n-type RawSockaddrUnix C.struct_sockaddr_un\n-\n-type RawSockaddrDatalink C.struct_sockaddr_dl\n-\n-type RawSockaddr C.struct_sockaddr\n-\n-type RawSockaddrAny C.struct_sockaddr_any\n-\n-type _Socklen C.socklen_t\n-\n-type Linger C.struct_linger\n-\n-type Iovec C.struct_iovec\n-\n-type IPMreq C.struct_ip_mreq\n-\n-type IPv6Mreq C.struct_ipv6_mreq\n-\n-type Msghdr C.struct_msghdr\n-\n-type Cmsghdr C.struct_cmsghdr\n-\n-type Inet6Pktinfo C.struct_in6_pktinfo\n-\n-type IPv6MTUInfo C.struct_ip6_mtuinfo\n-\n-type ICMPv6Filter C.struct_icmp6_filter\n-\n-const (\n-\tSizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in\n-\tSizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6\n-\tSizeofSockaddrAny      = C.sizeof_struct_sockaddr_any\n-\tSizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un\n-\tSizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl\n-\tSizeofLinger           = C.sizeof_struct_linger\n-\tSizeofIPMreq           = C.sizeof_struct_ip_mreq\n-\tSizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq\n-\tSizeofMsghdr           = C.sizeof_struct_msghdr\n-\tSizeofCmsghdr          = C.sizeof_struct_cmsghdr\n-\tSizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo\n-\tSizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo\n-\tSizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter\n-)\n-\n-// Ptrace requests\n-\n-const (\n-\tPTRACE_TRACEME = C.PT_TRACE_ME\n-\tPTRACE_CONT    = C.PT_CONTINUE\n-\tPTRACE_KILL    = C.PT_KILL\n-)\n-\n-// Events (kqueue, kevent)\n-\n-type Kevent_t C.struct_kevent\n-\n-// Select\n-\n-type FdSet C.fd_set\n-\n-// Routing and interface messages\n-\n-const (\n-\tSizeofIfMsghdr         = C.sizeof_struct_if_msghdr\n-\tSizeofIfData           = C.sizeof_struct_if_data\n-\tSizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr\n-\tSizeofIfmaMsghdr       = C.sizeof_struct_ifma_msghdr\n-\tSizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr\n-\tSizeofRtMsghdr         = C.sizeof_struct_rt_msghdr\n-\tSizeofRtMetrics        = C.sizeof_struct_rt_metrics\n-)\n-\n-type IfMsghdr C.struct_if_msghdr\n-\n-type IfData C.struct_if_data\n-\n-type IfaMsghdr C.struct_ifa_msghdr\n-\n-type IfmaMsghdr C.struct_ifma_msghdr\n-\n-type IfAnnounceMsghdr C.struct_if_announcemsghdr\n-\n-type RtMsghdr C.struct_rt_msghdr\n-\n-type RtMetrics C.struct_rt_metrics\n-\n-// Berkeley packet filter\n-\n-const (\n-\tSizeofBpfVersion = C.sizeof_struct_bpf_version\n-\tSizeofBpfStat    = C.sizeof_struct_bpf_stat\n-\tSizeofBpfProgram = C.sizeof_struct_bpf_program\n-\tSizeofBpfInsn    = C.sizeof_struct_bpf_insn\n-\tSizeofBpfHdr     = C.sizeof_struct_bpf_hdr\n-)\n-\n-type BpfVersion C.struct_bpf_version\n-\n-type BpfStat C.struct_bpf_stat\n-\n-type BpfProgram C.struct_bpf_program\n-\n-type BpfInsn C.struct_bpf_insn\n-\n-type BpfHdr C.struct_bpf_hdr\n-\n-// Terminal handling\n-\n-type Termios C.struct_termios\n-\n-type Winsize C.struct_winsize\n-\n-// fchmodat-like syscalls.\n-\n-const (\n-\tAT_FDCWD            = C.AT_FDCWD\n-\tAT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW\n-)\n-\n-// poll\n-\n-type PollFd C.struct_pollfd\n-\n-const (\n-\tPOLLERR    = C.POLLERR\n-\tPOLLHUP    = C.POLLHUP\n-\tPOLLIN     = C.POLLIN\n-\tPOLLNVAL   = C.POLLNVAL\n-\tPOLLOUT    = C.POLLOUT\n-\tPOLLPRI    = C.POLLPRI\n-\tPOLLRDBAND = C.POLLRDBAND\n-\tPOLLRDNORM = C.POLLRDNORM\n-\tPOLLWRBAND = C.POLLWRBAND\n-\tPOLLWRNORM = C.POLLWRNORM\n-)\n-\n-// Uname\n-\n-type Utsname C.struct_utsname"
    },
    {
      "sha": "a121dc3368f92e624671b1211437c181b5883226",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_freebsd.go",
      "status": "removed",
      "additions": 0,
      "deletions": 400,
      "changes": 400,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_freebsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_freebsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_freebsd.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,400 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-Input to cgo -godefs.  See README.md\n-*/\n-\n-// +godefs map struct_in_addr [4]byte /* in_addr */\n-// +godefs map struct_in6_addr [16]byte /* in6_addr */\n-\n-package unix\n-\n-/*\n-#define\t_WANT_FREEBSD11_STAT\t1\n-#define\t_WANT_FREEBSD11_STATFS\t1\n-#define\t_WANT_FREEBSD11_DIRENT\t1\n-#define\t_WANT_FREEBSD11_KEVENT  1\n-\n-#include <dirent.h>\n-#include <fcntl.h>\n-#include <poll.h>\n-#include <signal.h>\n-#include <termios.h>\n-#include <stdio.h>\n-#include <unistd.h>\n-#include <sys/capsicum.h>\n-#include <sys/event.h>\n-#include <sys/mman.h>\n-#include <sys/mount.h>\n-#include <sys/param.h>\n-#include <sys/ptrace.h>\n-#include <sys/resource.h>\n-#include <sys/select.h>\n-#include <sys/signal.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/types.h>\n-#include <sys/un.h>\n-#include <sys/utsname.h>\n-#include <sys/wait.h>\n-#include <net/bpf.h>\n-#include <net/if.h>\n-#include <net/if_dl.h>\n-#include <net/route.h>\n-#include <netinet/in.h>\n-#include <netinet/icmp6.h>\n-#include <netinet/tcp.h>\n-\n-enum {\n-\tsizeofPtr = sizeof(void*),\n-};\n-\n-union sockaddr_all {\n-\tstruct sockaddr s1;\t// this one gets used for fields\n-\tstruct sockaddr_in s2;\t// these pad it out\n-\tstruct sockaddr_in6 s3;\n-\tstruct sockaddr_un s4;\n-\tstruct sockaddr_dl s5;\n-};\n-\n-struct sockaddr_any {\n-\tstruct sockaddr addr;\n-\tchar pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];\n-};\n-\n-// This structure is a duplicate of if_data on FreeBSD 8-STABLE.\n-// See /usr/include/net/if.h.\n-struct if_data8 {\n-\tu_char  ifi_type;\n-\tu_char  ifi_physical;\n-\tu_char  ifi_addrlen;\n-\tu_char  ifi_hdrlen;\n-\tu_char  ifi_link_state;\n-\tu_char  ifi_spare_char1;\n-\tu_char  ifi_spare_char2;\n-\tu_char  ifi_datalen;\n-\tu_long  ifi_mtu;\n-\tu_long  ifi_metric;\n-\tu_long  ifi_baudrate;\n-\tu_long  ifi_ipackets;\n-\tu_long  ifi_ierrors;\n-\tu_long  ifi_opackets;\n-\tu_long  ifi_oerrors;\n-\tu_long  ifi_collisions;\n-\tu_long  ifi_ibytes;\n-\tu_long  ifi_obytes;\n-\tu_long  ifi_imcasts;\n-\tu_long  ifi_omcasts;\n-\tu_long  ifi_iqdrops;\n-\tu_long  ifi_noproto;\n-\tu_long  ifi_hwassist;\n-// FIXME: these are now unions, so maybe need to change definitions?\n-#undef ifi_epoch\n-\ttime_t  ifi_epoch;\n-#undef ifi_lastchange\n-\tstruct  timeval ifi_lastchange;\n-};\n-\n-// This structure is a duplicate of if_msghdr on FreeBSD 8-STABLE.\n-// See /usr/include/net/if.h.\n-struct if_msghdr8 {\n-\tu_short ifm_msglen;\n-\tu_char  ifm_version;\n-\tu_char  ifm_type;\n-\tint     ifm_addrs;\n-\tint     ifm_flags;\n-\tu_short ifm_index;\n-\tstruct  if_data8 ifm_data;\n-};\n-*/\n-import \"C\"\n-\n-// Machine characteristics\n-\n-const (\n-\tSizeofPtr      = C.sizeofPtr\n-\tSizeofShort    = C.sizeof_short\n-\tSizeofInt      = C.sizeof_int\n-\tSizeofLong     = C.sizeof_long\n-\tSizeofLongLong = C.sizeof_longlong\n-)\n-\n-// Basic types\n-\n-type (\n-\t_C_short     C.short\n-\t_C_int       C.int\n-\t_C_long      C.long\n-\t_C_long_long C.longlong\n-)\n-\n-// Time\n-\n-type Timespec C.struct_timespec\n-\n-type Timeval C.struct_timeval\n-\n-// Processes\n-\n-type Rusage C.struct_rusage\n-\n-type Rlimit C.struct_rlimit\n-\n-type _Gid_t C.gid_t\n-\n-// Files\n-\n-const (\n-\t_statfsVersion = C.STATFS_VERSION\n-\t_dirblksiz     = C.DIRBLKSIZ\n-)\n-\n-type Stat_t C.struct_stat\n-\n-type stat_freebsd11_t C.struct_freebsd11_stat\n-\n-type Statfs_t C.struct_statfs\n-\n-type statfs_freebsd11_t C.struct_freebsd11_statfs\n-\n-type Flock_t C.struct_flock\n-\n-type Dirent C.struct_dirent\n-\n-type dirent_freebsd11 C.struct_freebsd11_dirent\n-\n-type Fsid C.struct_fsid\n-\n-// File system limits\n-\n-const (\n-\tPathMax = C.PATH_MAX\n-)\n-\n-// Advice to Fadvise\n-\n-const (\n-\tFADV_NORMAL     = C.POSIX_FADV_NORMAL\n-\tFADV_RANDOM     = C.POSIX_FADV_RANDOM\n-\tFADV_SEQUENTIAL = C.POSIX_FADV_SEQUENTIAL\n-\tFADV_WILLNEED   = C.POSIX_FADV_WILLNEED\n-\tFADV_DONTNEED   = C.POSIX_FADV_DONTNEED\n-\tFADV_NOREUSE    = C.POSIX_FADV_NOREUSE\n-)\n-\n-// Sockets\n-\n-type RawSockaddrInet4 C.struct_sockaddr_in\n-\n-type RawSockaddrInet6 C.struct_sockaddr_in6\n-\n-type RawSockaddrUnix C.struct_sockaddr_un\n-\n-type RawSockaddrDatalink C.struct_sockaddr_dl\n-\n-type RawSockaddr C.struct_sockaddr\n-\n-type RawSockaddrAny C.struct_sockaddr_any\n-\n-type _Socklen C.socklen_t\n-\n-type Linger C.struct_linger\n-\n-type Iovec C.struct_iovec\n-\n-type IPMreq C.struct_ip_mreq\n-\n-type IPMreqn C.struct_ip_mreqn\n-\n-type IPv6Mreq C.struct_ipv6_mreq\n-\n-type Msghdr C.struct_msghdr\n-\n-type Cmsghdr C.struct_cmsghdr\n-\n-type Inet6Pktinfo C.struct_in6_pktinfo\n-\n-type IPv6MTUInfo C.struct_ip6_mtuinfo\n-\n-type ICMPv6Filter C.struct_icmp6_filter\n-\n-const (\n-\tSizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in\n-\tSizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6\n-\tSizeofSockaddrAny      = C.sizeof_struct_sockaddr_any\n-\tSizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un\n-\tSizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl\n-\tSizeofLinger           = C.sizeof_struct_linger\n-\tSizeofIPMreq           = C.sizeof_struct_ip_mreq\n-\tSizeofIPMreqn          = C.sizeof_struct_ip_mreqn\n-\tSizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq\n-\tSizeofMsghdr           = C.sizeof_struct_msghdr\n-\tSizeofCmsghdr          = C.sizeof_struct_cmsghdr\n-\tSizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo\n-\tSizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo\n-\tSizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter\n-)\n-\n-// Ptrace requests\n-\n-const (\n-\tPTRACE_ATTACH     = C.PT_ATTACH\n-\tPTRACE_CONT       = C.PT_CONTINUE\n-\tPTRACE_DETACH     = C.PT_DETACH\n-\tPTRACE_GETFPREGS  = C.PT_GETFPREGS\n-\tPTRACE_GETFSBASE  = C.PT_GETFSBASE\n-\tPTRACE_GETLWPLIST = C.PT_GETLWPLIST\n-\tPTRACE_GETNUMLWPS = C.PT_GETNUMLWPS\n-\tPTRACE_GETREGS    = C.PT_GETREGS\n-\tPTRACE_GETXSTATE  = C.PT_GETXSTATE\n-\tPTRACE_IO         = C.PT_IO\n-\tPTRACE_KILL       = C.PT_KILL\n-\tPTRACE_LWPEVENTS  = C.PT_LWP_EVENTS\n-\tPTRACE_LWPINFO    = C.PT_LWPINFO\n-\tPTRACE_SETFPREGS  = C.PT_SETFPREGS\n-\tPTRACE_SETREGS    = C.PT_SETREGS\n-\tPTRACE_SINGLESTEP = C.PT_STEP\n-\tPTRACE_TRACEME    = C.PT_TRACE_ME\n-)\n-\n-const (\n-\tPIOD_READ_D  = C.PIOD_READ_D\n-\tPIOD_WRITE_D = C.PIOD_WRITE_D\n-\tPIOD_READ_I  = C.PIOD_READ_I\n-\tPIOD_WRITE_I = C.PIOD_WRITE_I\n-)\n-\n-const (\n-\tPL_FLAG_BORN   = C.PL_FLAG_BORN\n-\tPL_FLAG_EXITED = C.PL_FLAG_EXITED\n-\tPL_FLAG_SI     = C.PL_FLAG_SI\n-)\n-\n-const (\n-\tTRAP_BRKPT = C.TRAP_BRKPT\n-\tTRAP_TRACE = C.TRAP_TRACE\n-)\n-\n-type PtraceLwpInfoStruct C.struct_ptrace_lwpinfo\n-\n-type __Siginfo C.struct___siginfo\n-\n-type Sigset_t C.sigset_t\n-\n-type Reg C.struct_reg\n-\n-type FpReg C.struct_fpreg\n-\n-type PtraceIoDesc C.struct_ptrace_io_desc\n-\n-// Events (kqueue, kevent)\n-\n-type Kevent_t C.struct_kevent_freebsd11\n-\n-// Select\n-\n-type FdSet C.fd_set\n-\n-// Routing and interface messages\n-\n-const (\n-\tsizeofIfMsghdr         = C.sizeof_struct_if_msghdr\n-\tSizeofIfMsghdr         = C.sizeof_struct_if_msghdr8\n-\tsizeofIfData           = C.sizeof_struct_if_data\n-\tSizeofIfData           = C.sizeof_struct_if_data8\n-\tSizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr\n-\tSizeofIfmaMsghdr       = C.sizeof_struct_ifma_msghdr\n-\tSizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr\n-\tSizeofRtMsghdr         = C.sizeof_struct_rt_msghdr\n-\tSizeofRtMetrics        = C.sizeof_struct_rt_metrics\n-)\n-\n-type ifMsghdr C.struct_if_msghdr\n-\n-type IfMsghdr C.struct_if_msghdr8\n-\n-type ifData C.struct_if_data\n-\n-type IfData C.struct_if_data8\n-\n-type IfaMsghdr C.struct_ifa_msghdr\n-\n-type IfmaMsghdr C.struct_ifma_msghdr\n-\n-type IfAnnounceMsghdr C.struct_if_announcemsghdr\n-\n-type RtMsghdr C.struct_rt_msghdr\n-\n-type RtMetrics C.struct_rt_metrics\n-\n-// Berkeley packet filter\n-\n-const (\n-\tSizeofBpfVersion    = C.sizeof_struct_bpf_version\n-\tSizeofBpfStat       = C.sizeof_struct_bpf_stat\n-\tSizeofBpfZbuf       = C.sizeof_struct_bpf_zbuf\n-\tSizeofBpfProgram    = C.sizeof_struct_bpf_program\n-\tSizeofBpfInsn       = C.sizeof_struct_bpf_insn\n-\tSizeofBpfHdr        = C.sizeof_struct_bpf_hdr\n-\tSizeofBpfZbufHeader = C.sizeof_struct_bpf_zbuf_header\n-)\n-\n-type BpfVersion C.struct_bpf_version\n-\n-type BpfStat C.struct_bpf_stat\n-\n-type BpfZbuf C.struct_bpf_zbuf\n-\n-type BpfProgram C.struct_bpf_program\n-\n-type BpfInsn C.struct_bpf_insn\n-\n-type BpfHdr C.struct_bpf_hdr\n-\n-type BpfZbufHeader C.struct_bpf_zbuf_header\n-\n-// Terminal handling\n-\n-type Termios C.struct_termios\n-\n-type Winsize C.struct_winsize\n-\n-// fchmodat-like syscalls.\n-\n-const (\n-\tAT_FDCWD            = C.AT_FDCWD\n-\tAT_REMOVEDIR        = C.AT_REMOVEDIR\n-\tAT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW\n-\tAT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW\n-)\n-\n-// poll\n-\n-type PollFd C.struct_pollfd\n-\n-const (\n-\tPOLLERR      = C.POLLERR\n-\tPOLLHUP      = C.POLLHUP\n-\tPOLLIN       = C.POLLIN\n-\tPOLLINIGNEOF = C.POLLINIGNEOF\n-\tPOLLNVAL     = C.POLLNVAL\n-\tPOLLOUT      = C.POLLOUT\n-\tPOLLPRI      = C.POLLPRI\n-\tPOLLRDBAND   = C.POLLRDBAND\n-\tPOLLRDNORM   = C.POLLRDNORM\n-\tPOLLWRBAND   = C.POLLWRBAND\n-\tPOLLWRNORM   = C.POLLWRNORM\n-)\n-\n-// Capabilities\n-\n-type CapRights C.struct_cap_rights\n-\n-// Uname\n-\n-type Utsname C.struct_utsname"
    },
    {
      "sha": "4a96d72c37d185dea1b319b17a5d6420ebf0eb70",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_netbsd.go",
      "status": "removed",
      "additions": 0,
      "deletions": 290,
      "changes": 290,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_netbsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_netbsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_netbsd.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,290 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-Input to cgo -godefs.  See README.md\n-*/\n-\n-// +godefs map struct_in_addr [4]byte /* in_addr */\n-// +godefs map struct_in6_addr [16]byte /* in6_addr */\n-\n-package unix\n-\n-/*\n-#define KERNEL\n-#include <dirent.h>\n-#include <fcntl.h>\n-#include <poll.h>\n-#include <signal.h>\n-#include <termios.h>\n-#include <stdio.h>\n-#include <unistd.h>\n-#include <sys/param.h>\n-#include <sys/types.h>\n-#include <sys/event.h>\n-#include <sys/mman.h>\n-#include <sys/mount.h>\n-#include <sys/ptrace.h>\n-#include <sys/resource.h>\n-#include <sys/select.h>\n-#include <sys/signal.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <sys/sysctl.h>\n-#include <sys/time.h>\n-#include <sys/uio.h>\n-#include <sys/un.h>\n-#include <sys/utsname.h>\n-#include <sys/wait.h>\n-#include <net/bpf.h>\n-#include <net/if.h>\n-#include <net/if_dl.h>\n-#include <net/route.h>\n-#include <netinet/in.h>\n-#include <netinet/icmp6.h>\n-#include <netinet/tcp.h>\n-\n-enum {\n-\tsizeofPtr = sizeof(void*),\n-};\n-\n-union sockaddr_all {\n-\tstruct sockaddr s1;\t// this one gets used for fields\n-\tstruct sockaddr_in s2;\t// these pad it out\n-\tstruct sockaddr_in6 s3;\n-\tstruct sockaddr_un s4;\n-\tstruct sockaddr_dl s5;\n-};\n-\n-struct sockaddr_any {\n-\tstruct sockaddr addr;\n-\tchar pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];\n-};\n-\n-*/\n-import \"C\"\n-\n-// Machine characteristics\n-\n-const (\n-\tSizeofPtr      = C.sizeofPtr\n-\tSizeofShort    = C.sizeof_short\n-\tSizeofInt      = C.sizeof_int\n-\tSizeofLong     = C.sizeof_long\n-\tSizeofLongLong = C.sizeof_longlong\n-)\n-\n-// Basic types\n-\n-type (\n-\t_C_short     C.short\n-\t_C_int       C.int\n-\t_C_long      C.long\n-\t_C_long_long C.longlong\n-)\n-\n-// Time\n-\n-type Timespec C.struct_timespec\n-\n-type Timeval C.struct_timeval\n-\n-// Processes\n-\n-type Rusage C.struct_rusage\n-\n-type Rlimit C.struct_rlimit\n-\n-type _Gid_t C.gid_t\n-\n-// Files\n-\n-type Stat_t C.struct_stat\n-\n-type Statfs_t C.struct_statfs\n-\n-type Flock_t C.struct_flock\n-\n-type Dirent C.struct_dirent\n-\n-type Fsid C.fsid_t\n-\n-// File system limits\n-\n-const (\n-\tPathMax = C.PATH_MAX\n-)\n-\n-// Advice to Fadvise\n-\n-const (\n-\tFADV_NORMAL     = C.POSIX_FADV_NORMAL\n-\tFADV_RANDOM     = C.POSIX_FADV_RANDOM\n-\tFADV_SEQUENTIAL = C.POSIX_FADV_SEQUENTIAL\n-\tFADV_WILLNEED   = C.POSIX_FADV_WILLNEED\n-\tFADV_DONTNEED   = C.POSIX_FADV_DONTNEED\n-\tFADV_NOREUSE    = C.POSIX_FADV_NOREUSE\n-)\n-\n-// Sockets\n-\n-type RawSockaddrInet4 C.struct_sockaddr_in\n-\n-type RawSockaddrInet6 C.struct_sockaddr_in6\n-\n-type RawSockaddrUnix C.struct_sockaddr_un\n-\n-type RawSockaddrDatalink C.struct_sockaddr_dl\n-\n-type RawSockaddr C.struct_sockaddr\n-\n-type RawSockaddrAny C.struct_sockaddr_any\n-\n-type _Socklen C.socklen_t\n-\n-type Linger C.struct_linger\n-\n-type Iovec C.struct_iovec\n-\n-type IPMreq C.struct_ip_mreq\n-\n-type IPv6Mreq C.struct_ipv6_mreq\n-\n-type Msghdr C.struct_msghdr\n-\n-type Cmsghdr C.struct_cmsghdr\n-\n-type Inet6Pktinfo C.struct_in6_pktinfo\n-\n-type IPv6MTUInfo C.struct_ip6_mtuinfo\n-\n-type ICMPv6Filter C.struct_icmp6_filter\n-\n-const (\n-\tSizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in\n-\tSizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6\n-\tSizeofSockaddrAny      = C.sizeof_struct_sockaddr_any\n-\tSizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un\n-\tSizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl\n-\tSizeofLinger           = C.sizeof_struct_linger\n-\tSizeofIPMreq           = C.sizeof_struct_ip_mreq\n-\tSizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq\n-\tSizeofMsghdr           = C.sizeof_struct_msghdr\n-\tSizeofCmsghdr          = C.sizeof_struct_cmsghdr\n-\tSizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo\n-\tSizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo\n-\tSizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter\n-)\n-\n-// Ptrace requests\n-\n-const (\n-\tPTRACE_TRACEME = C.PT_TRACE_ME\n-\tPTRACE_CONT    = C.PT_CONTINUE\n-\tPTRACE_KILL    = C.PT_KILL\n-)\n-\n-// Events (kqueue, kevent)\n-\n-type Kevent_t C.struct_kevent\n-\n-// Select\n-\n-type FdSet C.fd_set\n-\n-// Routing and interface messages\n-\n-const (\n-\tSizeofIfMsghdr         = C.sizeof_struct_if_msghdr\n-\tSizeofIfData           = C.sizeof_struct_if_data\n-\tSizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr\n-\tSizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr\n-\tSizeofRtMsghdr         = C.sizeof_struct_rt_msghdr\n-\tSizeofRtMetrics        = C.sizeof_struct_rt_metrics\n-)\n-\n-type IfMsghdr C.struct_if_msghdr\n-\n-type IfData C.struct_if_data\n-\n-type IfaMsghdr C.struct_ifa_msghdr\n-\n-type IfAnnounceMsghdr C.struct_if_announcemsghdr\n-\n-type RtMsghdr C.struct_rt_msghdr\n-\n-type RtMetrics C.struct_rt_metrics\n-\n-type Mclpool C.struct_mclpool\n-\n-// Berkeley packet filter\n-\n-const (\n-\tSizeofBpfVersion = C.sizeof_struct_bpf_version\n-\tSizeofBpfStat    = C.sizeof_struct_bpf_stat\n-\tSizeofBpfProgram = C.sizeof_struct_bpf_program\n-\tSizeofBpfInsn    = C.sizeof_struct_bpf_insn\n-\tSizeofBpfHdr     = C.sizeof_struct_bpf_hdr\n-)\n-\n-type BpfVersion C.struct_bpf_version\n-\n-type BpfStat C.struct_bpf_stat\n-\n-type BpfProgram C.struct_bpf_program\n-\n-type BpfInsn C.struct_bpf_insn\n-\n-type BpfHdr C.struct_bpf_hdr\n-\n-type BpfTimeval C.struct_bpf_timeval\n-\n-// Terminal handling\n-\n-type Termios C.struct_termios\n-\n-type Winsize C.struct_winsize\n-\n-type Ptmget C.struct_ptmget\n-\n-// fchmodat-like syscalls.\n-\n-const (\n-\tAT_FDCWD            = C.AT_FDCWD\n-\tAT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW\n-\tAT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW\n-)\n-\n-// poll\n-\n-type PollFd C.struct_pollfd\n-\n-const (\n-\tPOLLERR    = C.POLLERR\n-\tPOLLHUP    = C.POLLHUP\n-\tPOLLIN     = C.POLLIN\n-\tPOLLNVAL   = C.POLLNVAL\n-\tPOLLOUT    = C.POLLOUT\n-\tPOLLPRI    = C.POLLPRI\n-\tPOLLRDBAND = C.POLLRDBAND\n-\tPOLLRDNORM = C.POLLRDNORM\n-\tPOLLWRBAND = C.POLLWRBAND\n-\tPOLLWRNORM = C.POLLWRNORM\n-)\n-\n-// Sysctl\n-\n-type Sysctlnode C.struct_sysctlnode\n-\n-// Uname\n-\n-type Utsname C.struct_utsname\n-\n-// Clockinfo\n-\n-const SizeofClockinfo = C.sizeof_struct_clockinfo\n-\n-type Clockinfo C.struct_clockinfo"
    },
    {
      "sha": "775cb57dc8a8831ee31b21f1d4bacaf1c459f3ef",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_openbsd.go",
      "status": "removed",
      "additions": 0,
      "deletions": 283,
      "changes": 283,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_openbsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_openbsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_openbsd.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,283 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-Input to cgo -godefs.  See README.md\n-*/\n-\n-// +godefs map struct_in_addr [4]byte /* in_addr */\n-// +godefs map struct_in6_addr [16]byte /* in6_addr */\n-\n-package unix\n-\n-/*\n-#define KERNEL\n-#include <dirent.h>\n-#include <fcntl.h>\n-#include <poll.h>\n-#include <signal.h>\n-#include <termios.h>\n-#include <stdio.h>\n-#include <unistd.h>\n-#include <sys/param.h>\n-#include <sys/types.h>\n-#include <sys/event.h>\n-#include <sys/mman.h>\n-#include <sys/mount.h>\n-#include <sys/ptrace.h>\n-#include <sys/resource.h>\n-#include <sys/select.h>\n-#include <sys/signal.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/uio.h>\n-#include <sys/un.h>\n-#include <sys/utsname.h>\n-#include <sys/wait.h>\n-#include <uvm/uvmexp.h>\n-#include <net/bpf.h>\n-#include <net/if.h>\n-#include <net/if_dl.h>\n-#include <net/route.h>\n-#include <netinet/in.h>\n-#include <netinet/icmp6.h>\n-#include <netinet/tcp.h>\n-\n-enum {\n-\tsizeofPtr = sizeof(void*),\n-};\n-\n-union sockaddr_all {\n-\tstruct sockaddr s1;\t// this one gets used for fields\n-\tstruct sockaddr_in s2;\t// these pad it out\n-\tstruct sockaddr_in6 s3;\n-\tstruct sockaddr_un s4;\n-\tstruct sockaddr_dl s5;\n-};\n-\n-struct sockaddr_any {\n-\tstruct sockaddr addr;\n-\tchar pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];\n-};\n-\n-*/\n-import \"C\"\n-\n-// Machine characteristics\n-\n-const (\n-\tSizeofPtr      = C.sizeofPtr\n-\tSizeofShort    = C.sizeof_short\n-\tSizeofInt      = C.sizeof_int\n-\tSizeofLong     = C.sizeof_long\n-\tSizeofLongLong = C.sizeof_longlong\n-)\n-\n-// Basic types\n-\n-type (\n-\t_C_short     C.short\n-\t_C_int       C.int\n-\t_C_long      C.long\n-\t_C_long_long C.longlong\n-)\n-\n-// Time\n-\n-type Timespec C.struct_timespec\n-\n-type Timeval C.struct_timeval\n-\n-// Processes\n-\n-type Rusage C.struct_rusage\n-\n-type Rlimit C.struct_rlimit\n-\n-type _Gid_t C.gid_t\n-\n-// Files\n-\n-type Stat_t C.struct_stat\n-\n-type Statfs_t C.struct_statfs\n-\n-type Flock_t C.struct_flock\n-\n-type Dirent C.struct_dirent\n-\n-type Fsid C.fsid_t\n-\n-// File system limits\n-\n-const (\n-\tPathMax = C.PATH_MAX\n-)\n-\n-// Sockets\n-\n-type RawSockaddrInet4 C.struct_sockaddr_in\n-\n-type RawSockaddrInet6 C.struct_sockaddr_in6\n-\n-type RawSockaddrUnix C.struct_sockaddr_un\n-\n-type RawSockaddrDatalink C.struct_sockaddr_dl\n-\n-type RawSockaddr C.struct_sockaddr\n-\n-type RawSockaddrAny C.struct_sockaddr_any\n-\n-type _Socklen C.socklen_t\n-\n-type Linger C.struct_linger\n-\n-type Iovec C.struct_iovec\n-\n-type IPMreq C.struct_ip_mreq\n-\n-type IPv6Mreq C.struct_ipv6_mreq\n-\n-type Msghdr C.struct_msghdr\n-\n-type Cmsghdr C.struct_cmsghdr\n-\n-type Inet6Pktinfo C.struct_in6_pktinfo\n-\n-type IPv6MTUInfo C.struct_ip6_mtuinfo\n-\n-type ICMPv6Filter C.struct_icmp6_filter\n-\n-const (\n-\tSizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in\n-\tSizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6\n-\tSizeofSockaddrAny      = C.sizeof_struct_sockaddr_any\n-\tSizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un\n-\tSizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl\n-\tSizeofLinger           = C.sizeof_struct_linger\n-\tSizeofIPMreq           = C.sizeof_struct_ip_mreq\n-\tSizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq\n-\tSizeofMsghdr           = C.sizeof_struct_msghdr\n-\tSizeofCmsghdr          = C.sizeof_struct_cmsghdr\n-\tSizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo\n-\tSizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo\n-\tSizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter\n-)\n-\n-// Ptrace requests\n-\n-const (\n-\tPTRACE_TRACEME = C.PT_TRACE_ME\n-\tPTRACE_CONT    = C.PT_CONTINUE\n-\tPTRACE_KILL    = C.PT_KILL\n-)\n-\n-// Events (kqueue, kevent)\n-\n-type Kevent_t C.struct_kevent\n-\n-// Select\n-\n-type FdSet C.fd_set\n-\n-// Routing and interface messages\n-\n-const (\n-\tSizeofIfMsghdr         = C.sizeof_struct_if_msghdr\n-\tSizeofIfData           = C.sizeof_struct_if_data\n-\tSizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr\n-\tSizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr\n-\tSizeofRtMsghdr         = C.sizeof_struct_rt_msghdr\n-\tSizeofRtMetrics        = C.sizeof_struct_rt_metrics\n-)\n-\n-type IfMsghdr C.struct_if_msghdr\n-\n-type IfData C.struct_if_data\n-\n-type IfaMsghdr C.struct_ifa_msghdr\n-\n-type IfAnnounceMsghdr C.struct_if_announcemsghdr\n-\n-type RtMsghdr C.struct_rt_msghdr\n-\n-type RtMetrics C.struct_rt_metrics\n-\n-type Mclpool C.struct_mclpool\n-\n-// Berkeley packet filter\n-\n-const (\n-\tSizeofBpfVersion = C.sizeof_struct_bpf_version\n-\tSizeofBpfStat    = C.sizeof_struct_bpf_stat\n-\tSizeofBpfProgram = C.sizeof_struct_bpf_program\n-\tSizeofBpfInsn    = C.sizeof_struct_bpf_insn\n-\tSizeofBpfHdr     = C.sizeof_struct_bpf_hdr\n-)\n-\n-type BpfVersion C.struct_bpf_version\n-\n-type BpfStat C.struct_bpf_stat\n-\n-type BpfProgram C.struct_bpf_program\n-\n-type BpfInsn C.struct_bpf_insn\n-\n-type BpfHdr C.struct_bpf_hdr\n-\n-type BpfTimeval C.struct_bpf_timeval\n-\n-// Terminal handling\n-\n-type Termios C.struct_termios\n-\n-type Winsize C.struct_winsize\n-\n-// fchmodat-like syscalls.\n-\n-const (\n-\tAT_FDCWD            = C.AT_FDCWD\n-\tAT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW\n-\tAT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW\n-)\n-\n-// poll\n-\n-type PollFd C.struct_pollfd\n-\n-const (\n-\tPOLLERR    = C.POLLERR\n-\tPOLLHUP    = C.POLLHUP\n-\tPOLLIN     = C.POLLIN\n-\tPOLLNVAL   = C.POLLNVAL\n-\tPOLLOUT    = C.POLLOUT\n-\tPOLLPRI    = C.POLLPRI\n-\tPOLLRDBAND = C.POLLRDBAND\n-\tPOLLRDNORM = C.POLLRDNORM\n-\tPOLLWRBAND = C.POLLWRBAND\n-\tPOLLWRNORM = C.POLLWRNORM\n-)\n-\n-// Signal Sets\n-\n-type Sigset_t C.sigset_t\n-\n-// Uname\n-\n-type Utsname C.struct_utsname\n-\n-// Uvmexp\n-\n-const SizeofUvmexp = C.sizeof_struct_uvmexp\n-\n-type Uvmexp C.struct_uvmexp\n-\n-// Clockinfo\n-\n-const SizeofClockinfo = C.sizeof_struct_clockinfo\n-\n-type Clockinfo C.struct_clockinfo"
    },
    {
      "sha": "2b716f93481d8bdb024efc7972a7d1b1de8391ba",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_solaris.go",
      "status": "removed",
      "additions": 0,
      "deletions": 266,
      "changes": 266,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_solaris.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/sys/unix/types_solaris.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_solaris.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,266 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-Input to cgo -godefs.  See README.md\n-*/\n-\n-// +godefs map struct_in_addr [4]byte /* in_addr */\n-// +godefs map struct_in6_addr [16]byte /* in6_addr */\n-\n-package unix\n-\n-/*\n-#define KERNEL\n-// These defines ensure that builds done on newer versions of Solaris are\n-// backwards-compatible with older versions of Solaris and\n-// OpenSolaris-based derivatives.\n-#define __USE_SUNOS_SOCKETS__          // msghdr\n-#define __USE_LEGACY_PROTOTYPES__      // iovec\n-#include <dirent.h>\n-#include <fcntl.h>\n-#include <netdb.h>\n-#include <limits.h>\n-#include <poll.h>\n-#include <signal.h>\n-#include <termios.h>\n-#include <termio.h>\n-#include <stdio.h>\n-#include <unistd.h>\n-#include <sys/mman.h>\n-#include <sys/mount.h>\n-#include <sys/param.h>\n-#include <sys/resource.h>\n-#include <sys/select.h>\n-#include <sys/signal.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <sys/statvfs.h>\n-#include <sys/time.h>\n-#include <sys/times.h>\n-#include <sys/types.h>\n-#include <sys/utsname.h>\n-#include <sys/un.h>\n-#include <sys/wait.h>\n-#include <net/bpf.h>\n-#include <net/if.h>\n-#include <net/if_dl.h>\n-#include <net/route.h>\n-#include <netinet/in.h>\n-#include <netinet/icmp6.h>\n-#include <netinet/tcp.h>\n-#include <ustat.h>\n-#include <utime.h>\n-\n-enum {\n-\tsizeofPtr = sizeof(void*),\n-};\n-\n-union sockaddr_all {\n-\tstruct sockaddr s1;\t// this one gets used for fields\n-\tstruct sockaddr_in s2;\t// these pad it out\n-\tstruct sockaddr_in6 s3;\n-\tstruct sockaddr_un s4;\n-\tstruct sockaddr_dl s5;\n-};\n-\n-struct sockaddr_any {\n-\tstruct sockaddr addr;\n-\tchar pad[sizeof(union sockaddr_all) - sizeof(struct sockaddr)];\n-};\n-\n-*/\n-import \"C\"\n-\n-// Machine characteristics\n-\n-const (\n-\tSizeofPtr      = C.sizeofPtr\n-\tSizeofShort    = C.sizeof_short\n-\tSizeofInt      = C.sizeof_int\n-\tSizeofLong     = C.sizeof_long\n-\tSizeofLongLong = C.sizeof_longlong\n-\tPathMax        = C.PATH_MAX\n-\tMaxHostNameLen = C.MAXHOSTNAMELEN\n-)\n-\n-// Basic types\n-\n-type (\n-\t_C_short     C.short\n-\t_C_int       C.int\n-\t_C_long      C.long\n-\t_C_long_long C.longlong\n-)\n-\n-// Time\n-\n-type Timespec C.struct_timespec\n-\n-type Timeval C.struct_timeval\n-\n-type Timeval32 C.struct_timeval32\n-\n-type Tms C.struct_tms\n-\n-type Utimbuf C.struct_utimbuf\n-\n-// Processes\n-\n-type Rusage C.struct_rusage\n-\n-type Rlimit C.struct_rlimit\n-\n-type _Gid_t C.gid_t\n-\n-// Files\n-\n-type Stat_t C.struct_stat\n-\n-type Flock_t C.struct_flock\n-\n-type Dirent C.struct_dirent\n-\n-// Filesystems\n-\n-type _Fsblkcnt_t C.fsblkcnt_t\n-\n-type Statvfs_t C.struct_statvfs\n-\n-// Sockets\n-\n-type RawSockaddrInet4 C.struct_sockaddr_in\n-\n-type RawSockaddrInet6 C.struct_sockaddr_in6\n-\n-type RawSockaddrUnix C.struct_sockaddr_un\n-\n-type RawSockaddrDatalink C.struct_sockaddr_dl\n-\n-type RawSockaddr C.struct_sockaddr\n-\n-type RawSockaddrAny C.struct_sockaddr_any\n-\n-type _Socklen C.socklen_t\n-\n-type Linger C.struct_linger\n-\n-type Iovec C.struct_iovec\n-\n-type IPMreq C.struct_ip_mreq\n-\n-type IPv6Mreq C.struct_ipv6_mreq\n-\n-type Msghdr C.struct_msghdr\n-\n-type Cmsghdr C.struct_cmsghdr\n-\n-type Inet6Pktinfo C.struct_in6_pktinfo\n-\n-type IPv6MTUInfo C.struct_ip6_mtuinfo\n-\n-type ICMPv6Filter C.struct_icmp6_filter\n-\n-const (\n-\tSizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in\n-\tSizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6\n-\tSizeofSockaddrAny      = C.sizeof_struct_sockaddr_any\n-\tSizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un\n-\tSizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl\n-\tSizeofLinger           = C.sizeof_struct_linger\n-\tSizeofIPMreq           = C.sizeof_struct_ip_mreq\n-\tSizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq\n-\tSizeofMsghdr           = C.sizeof_struct_msghdr\n-\tSizeofCmsghdr          = C.sizeof_struct_cmsghdr\n-\tSizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo\n-\tSizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo\n-\tSizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter\n-)\n-\n-// Select\n-\n-type FdSet C.fd_set\n-\n-// Misc\n-\n-type Utsname C.struct_utsname\n-\n-type Ustat_t C.struct_ustat\n-\n-const (\n-\tAT_FDCWD            = C.AT_FDCWD\n-\tAT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW\n-\tAT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW\n-\tAT_REMOVEDIR        = C.AT_REMOVEDIR\n-\tAT_EACCESS          = C.AT_EACCESS\n-)\n-\n-// Routing and interface messages\n-\n-const (\n-\tSizeofIfMsghdr  = C.sizeof_struct_if_msghdr\n-\tSizeofIfData    = C.sizeof_struct_if_data\n-\tSizeofIfaMsghdr = C.sizeof_struct_ifa_msghdr\n-\tSizeofRtMsghdr  = C.sizeof_struct_rt_msghdr\n-\tSizeofRtMetrics = C.sizeof_struct_rt_metrics\n-)\n-\n-type IfMsghdr C.struct_if_msghdr\n-\n-type IfData C.struct_if_data\n-\n-type IfaMsghdr C.struct_ifa_msghdr\n-\n-type RtMsghdr C.struct_rt_msghdr\n-\n-type RtMetrics C.struct_rt_metrics\n-\n-// Berkeley packet filter\n-\n-const (\n-\tSizeofBpfVersion = C.sizeof_struct_bpf_version\n-\tSizeofBpfStat    = C.sizeof_struct_bpf_stat\n-\tSizeofBpfProgram = C.sizeof_struct_bpf_program\n-\tSizeofBpfInsn    = C.sizeof_struct_bpf_insn\n-\tSizeofBpfHdr     = C.sizeof_struct_bpf_hdr\n-)\n-\n-type BpfVersion C.struct_bpf_version\n-\n-type BpfStat C.struct_bpf_stat\n-\n-type BpfProgram C.struct_bpf_program\n-\n-type BpfInsn C.struct_bpf_insn\n-\n-type BpfTimeval C.struct_bpf_timeval\n-\n-type BpfHdr C.struct_bpf_hdr\n-\n-// Terminal handling\n-\n-type Termios C.struct_termios\n-\n-type Termio C.struct_termio\n-\n-type Winsize C.struct_winsize\n-\n-// poll\n-\n-type PollFd C.struct_pollfd\n-\n-const (\n-\tPOLLERR    = C.POLLERR\n-\tPOLLHUP    = C.POLLHUP\n-\tPOLLIN     = C.POLLIN\n-\tPOLLNVAL   = C.POLLNVAL\n-\tPOLLOUT    = C.POLLOUT\n-\tPOLLPRI    = C.POLLPRI\n-\tPOLLRDBAND = C.POLLRDBAND\n-\tPOLLRDNORM = C.POLLRDNORM\n-\tPOLLWRBAND = C.POLLWRBAND\n-\tPOLLWRNORM = C.POLLWRNORM\n-)"
    },
    {
      "sha": "987fc169cc04a1b914770a475a619d26cbcf2c21",
      "filename": "backend/vendor/golang.org/x/text/unicode/bidi/gen.go",
      "status": "removed",
      "additions": 0,
      "deletions": 133,
      "changes": 133,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/bidi/gen.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/bidi/gen.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/text/unicode/bidi/gen.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,133 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package main\n-\n-import (\n-\t\"flag\"\n-\t\"log\"\n-\n-\t\"golang.org/x/text/internal/gen\"\n-\t\"golang.org/x/text/internal/triegen\"\n-\t\"golang.org/x/text/internal/ucd\"\n-)\n-\n-var outputFile = flag.String(\"out\", \"tables.go\", \"output file\")\n-\n-func main() {\n-\tgen.Init()\n-\tgen.Repackage(\"gen_trieval.go\", \"trieval.go\", \"bidi\")\n-\tgen.Repackage(\"gen_ranges.go\", \"ranges_test.go\", \"bidi\")\n-\n-\tgenTables()\n-}\n-\n-// bidiClass names and codes taken from class \"bc\" in\n-// https://www.unicode.org/Public/8.0.0/ucd/PropertyValueAliases.txt\n-var bidiClass = map[string]Class{\n-\t\"AL\":  AL,  // ArabicLetter\n-\t\"AN\":  AN,  // ArabicNumber\n-\t\"B\":   B,   // ParagraphSeparator\n-\t\"BN\":  BN,  // BoundaryNeutral\n-\t\"CS\":  CS,  // CommonSeparator\n-\t\"EN\":  EN,  // EuropeanNumber\n-\t\"ES\":  ES,  // EuropeanSeparator\n-\t\"ET\":  ET,  // EuropeanTerminator\n-\t\"L\":   L,   // LeftToRight\n-\t\"NSM\": NSM, // NonspacingMark\n-\t\"ON\":  ON,  // OtherNeutral\n-\t\"R\":   R,   // RightToLeft\n-\t\"S\":   S,   // SegmentSeparator\n-\t\"WS\":  WS,  // WhiteSpace\n-\n-\t\"FSI\": Control,\n-\t\"PDF\": Control,\n-\t\"PDI\": Control,\n-\t\"LRE\": Control,\n-\t\"LRI\": Control,\n-\t\"LRO\": Control,\n-\t\"RLE\": Control,\n-\t\"RLI\": Control,\n-\t\"RLO\": Control,\n-}\n-\n-func genTables() {\n-\tif numClass > 0x0F {\n-\t\tlog.Fatalf(\"Too many Class constants (%#x > 0x0F).\", numClass)\n-\t}\n-\tw := gen.NewCodeWriter()\n-\tdefer w.WriteVersionedGoFile(*outputFile, \"bidi\")\n-\n-\tgen.WriteUnicodeVersion(w)\n-\n-\tt := triegen.NewTrie(\"bidi\")\n-\n-\t// Build data about bracket mapping. These bits need to be or-ed with\n-\t// any other bits.\n-\torMask := map[rune]uint64{}\n-\n-\txorMap := map[rune]int{}\n-\txorMasks := []rune{0} // First value is no-op.\n-\n-\tucd.Parse(gen.OpenUCDFile(\"BidiBrackets.txt\"), func(p *ucd.Parser) {\n-\t\tr1 := p.Rune(0)\n-\t\tr2 := p.Rune(1)\n-\t\txor := r1 ^ r2\n-\t\tif _, ok := xorMap[xor]; !ok {\n-\t\t\txorMap[xor] = len(xorMasks)\n-\t\t\txorMasks = append(xorMasks, xor)\n-\t\t}\n-\t\tentry := uint64(xorMap[xor]) << xorMaskShift\n-\t\tswitch p.String(2) {\n-\t\tcase \"o\":\n-\t\t\tentry |= openMask\n-\t\tcase \"c\", \"n\":\n-\t\tdefault:\n-\t\t\tlog.Fatalf(\"Unknown bracket class %q.\", p.String(2))\n-\t\t}\n-\t\torMask[r1] = entry\n-\t})\n-\n-\tw.WriteComment(`\n-\txorMasks contains masks to be xor-ed with brackets to get the reverse\n-\tversion.`)\n-\tw.WriteVar(\"xorMasks\", xorMasks)\n-\n-\tdone := map[rune]bool{}\n-\n-\tinsert := func(r rune, c Class) {\n-\t\tif !done[r] {\n-\t\t\tt.Insert(r, orMask[r]|uint64(c))\n-\t\t\tdone[r] = true\n-\t\t}\n-\t}\n-\n-\t// Insert the derived BiDi properties.\n-\tucd.Parse(gen.OpenUCDFile(\"extracted/DerivedBidiClass.txt\"), func(p *ucd.Parser) {\n-\t\tr := p.Rune(0)\n-\t\tclass, ok := bidiClass[p.String(1)]\n-\t\tif !ok {\n-\t\t\tlog.Fatalf(\"%U: Unknown BiDi class %q\", r, p.String(1))\n-\t\t}\n-\t\tinsert(r, class)\n-\t})\n-\tvisitDefaults(insert)\n-\n-\t// TODO: use sparse blocks. This would reduce table size considerably\n-\t// from the looks of it.\n-\n-\tsz, err := t.Gen(w)\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\tw.Size += sz\n-}\n-\n-// dummy values to make methods in gen_common compile. The real versions\n-// will be generated by this file to tables.go.\n-var (\n-\txorMasks []rune\n-)"
    },
    {
      "sha": "02c3b505d640ec69d2a3ec9ed04401b4e4b42487",
      "filename": "backend/vendor/golang.org/x/text/unicode/bidi/gen_ranges.go",
      "status": "removed",
      "additions": 0,
      "deletions": 57,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/bidi/gen_ranges.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/bidi/gen_ranges.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/text/unicode/bidi/gen_ranges.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package main\n-\n-import (\n-\t\"unicode\"\n-\n-\t\"golang.org/x/text/internal/gen\"\n-\t\"golang.org/x/text/internal/ucd\"\n-\t\"golang.org/x/text/unicode/rangetable\"\n-)\n-\n-// These tables are hand-extracted from:\n-// https://www.unicode.org/Public/8.0.0/ucd/extracted/DerivedBidiClass.txt\n-func visitDefaults(fn func(r rune, c Class)) {\n-\t// first write default values for ranges listed above.\n-\tvisitRunes(fn, AL, []rune{\n-\t\t0x0600, 0x07BF, // Arabic\n-\t\t0x08A0, 0x08FF, // Arabic Extended-A\n-\t\t0xFB50, 0xFDCF, // Arabic Presentation Forms\n-\t\t0xFDF0, 0xFDFF,\n-\t\t0xFE70, 0xFEFF,\n-\t\t0x0001EE00, 0x0001EEFF, // Arabic Mathematical Alpha Symbols\n-\t})\n-\tvisitRunes(fn, R, []rune{\n-\t\t0x0590, 0x05FF, // Hebrew\n-\t\t0x07C0, 0x089F, // Nko et al.\n-\t\t0xFB1D, 0xFB4F,\n-\t\t0x00010800, 0x00010FFF, // Cypriot Syllabary et. al.\n-\t\t0x0001E800, 0x0001EDFF,\n-\t\t0x0001EF00, 0x0001EFFF,\n-\t})\n-\tvisitRunes(fn, ET, []rune{ // European Terminator\n-\t\t0x20A0, 0x20Cf, // Currency symbols\n-\t})\n-\trangetable.Visit(unicode.Noncharacter_Code_Point, func(r rune) {\n-\t\tfn(r, BN) // Boundary Neutral\n-\t})\n-\tucd.Parse(gen.OpenUCDFile(\"DerivedCoreProperties.txt\"), func(p *ucd.Parser) {\n-\t\tif p.String(1) == \"Default_Ignorable_Code_Point\" {\n-\t\t\tfn(p.Rune(0), BN) // Boundary Neutral\n-\t\t}\n-\t})\n-}\n-\n-func visitRunes(fn func(r rune, c Class), c Class, runes []rune) {\n-\tfor i := 0; i < len(runes); i += 2 {\n-\t\tlo, hi := runes[i], runes[i+1]\n-\t\tfor j := lo; j <= hi; j++ {\n-\t\t\tfn(j, c)\n-\t\t}\n-\t}\n-}"
    },
    {
      "sha": "9cb9942894920a5c56440b73cc356b3b67fab9e5",
      "filename": "backend/vendor/golang.org/x/text/unicode/bidi/gen_trieval.go",
      "status": "removed",
      "additions": 0,
      "deletions": 64,
      "changes": 64,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/bidi/gen_trieval.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/bidi/gen_trieval.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/text/unicode/bidi/gen_trieval.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-package main\n-\n-// Class is the Unicode BiDi class. Each rune has a single class.\n-type Class uint\n-\n-const (\n-\tL       Class = iota // LeftToRight\n-\tR                    // RightToLeft\n-\tEN                   // EuropeanNumber\n-\tES                   // EuropeanSeparator\n-\tET                   // EuropeanTerminator\n-\tAN                   // ArabicNumber\n-\tCS                   // CommonSeparator\n-\tB                    // ParagraphSeparator\n-\tS                    // SegmentSeparator\n-\tWS                   // WhiteSpace\n-\tON                   // OtherNeutral\n-\tBN                   // BoundaryNeutral\n-\tNSM                  // NonspacingMark\n-\tAL                   // ArabicLetter\n-\tControl              // Control LRO - PDI\n-\n-\tnumClass\n-\n-\tLRO // LeftToRightOverride\n-\tRLO // RightToLeftOverride\n-\tLRE // LeftToRightEmbedding\n-\tRLE // RightToLeftEmbedding\n-\tPDF // PopDirectionalFormat\n-\tLRI // LeftToRightIsolate\n-\tRLI // RightToLeftIsolate\n-\tFSI // FirstStrongIsolate\n-\tPDI // PopDirectionalIsolate\n-\n-\tunknownClass = ^Class(0)\n-)\n-\n-var controlToClass = map[rune]Class{\n-\t0x202D: LRO, // LeftToRightOverride,\n-\t0x202E: RLO, // RightToLeftOverride,\n-\t0x202A: LRE, // LeftToRightEmbedding,\n-\t0x202B: RLE, // RightToLeftEmbedding,\n-\t0x202C: PDF, // PopDirectionalFormat,\n-\t0x2066: LRI, // LeftToRightIsolate,\n-\t0x2067: RLI, // RightToLeftIsolate,\n-\t0x2068: FSI, // FirstStrongIsolate,\n-\t0x2069: PDI, // PopDirectionalIsolate,\n-}\n-\n-// A trie entry has the following bits:\n-// 7..5  XOR mask for brackets\n-// 4     1: Bracket open, 0: Bracket close\n-// 3..0  Class type\n-\n-const (\n-\topenMask     = 0x10\n-\txorMaskShift = 5\n-)"
    },
    {
      "sha": "30a3aa93343d22d5cb928b2c7cb54b25e41b95c3",
      "filename": "backend/vendor/golang.org/x/text/unicode/norm/maketables.go",
      "status": "removed",
      "additions": 0,
      "deletions": 986,
      "changes": 986,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/norm/maketables.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/norm/maketables.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/text/unicode/norm/maketables.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,986 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// Normalization table generator.\n-// Data read from the web.\n-// See forminfo.go for a description of the trie values associated with each rune.\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/binary\"\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"log\"\n-\t\"sort\"\n-\t\"strconv\"\n-\t\"strings\"\n-\n-\t\"golang.org/x/text/internal/gen\"\n-\t\"golang.org/x/text/internal/triegen\"\n-\t\"golang.org/x/text/internal/ucd\"\n-)\n-\n-func main() {\n-\tgen.Init()\n-\tloadUnicodeData()\n-\tcompactCCC()\n-\tloadCompositionExclusions()\n-\tcompleteCharFields(FCanonical)\n-\tcompleteCharFields(FCompatibility)\n-\tcomputeNonStarterCounts()\n-\tverifyComputed()\n-\tprintChars()\n-\ttestDerived()\n-\tprintTestdata()\n-\tmakeTables()\n-}\n-\n-var (\n-\ttablelist = flag.String(\"tables\",\n-\t\t\"all\",\n-\t\t\"comma-separated list of which tables to generate; \"+\n-\t\t\t\"can be 'decomp', 'recomp', 'info' and 'all'\")\n-\ttest = flag.Bool(\"test\",\n-\t\tfalse,\n-\t\t\"test existing tables against DerivedNormalizationProps and generate test data for regression testing\")\n-\tverbose = flag.Bool(\"verbose\",\n-\t\tfalse,\n-\t\t\"write data to stdout as it is parsed\")\n-)\n-\n-const MaxChar = 0x10FFFF // anything above this shouldn't exist\n-\n-// Quick Check properties of runes allow us to quickly\n-// determine whether a rune may occur in a normal form.\n-// For a given normal form, a rune may be guaranteed to occur\n-// verbatim (QC=Yes), may or may not combine with another\n-// rune (QC=Maybe), or may not occur (QC=No).\n-type QCResult int\n-\n-const (\n-\tQCUnknown QCResult = iota\n-\tQCYes\n-\tQCNo\n-\tQCMaybe\n-)\n-\n-func (r QCResult) String() string {\n-\tswitch r {\n-\tcase QCYes:\n-\t\treturn \"Yes\"\n-\tcase QCNo:\n-\t\treturn \"No\"\n-\tcase QCMaybe:\n-\t\treturn \"Maybe\"\n-\t}\n-\treturn \"***UNKNOWN***\"\n-}\n-\n-const (\n-\tFCanonical     = iota // NFC or NFD\n-\tFCompatibility        // NFKC or NFKD\n-\tFNumberOfFormTypes\n-)\n-\n-const (\n-\tMComposed   = iota // NFC or NFKC\n-\tMDecomposed        // NFD or NFKD\n-\tMNumberOfModes\n-)\n-\n-// This contains only the properties we're interested in.\n-type Char struct {\n-\tname          string\n-\tcodePoint     rune  // if zero, this index is not a valid code point.\n-\tccc           uint8 // canonical combining class\n-\torigCCC       uint8\n-\texcludeInComp bool // from CompositionExclusions.txt\n-\tcompatDecomp  bool // it has a compatibility expansion\n-\n-\tnTrailingNonStarters uint8\n-\tnLeadingNonStarters  uint8 // must be equal to trailing if non-zero\n-\n-\tforms [FNumberOfFormTypes]FormInfo // For FCanonical and FCompatibility\n-\n-\tstate State\n-}\n-\n-var chars = make([]Char, MaxChar+1)\n-var cccMap = make(map[uint8]uint8)\n-\n-func (c Char) String() string {\n-\tbuf := new(bytes.Buffer)\n-\n-\tfmt.Fprintf(buf, \"%U [%s]:\\n\", c.codePoint, c.name)\n-\tfmt.Fprintf(buf, \"  ccc: %v\\n\", c.ccc)\n-\tfmt.Fprintf(buf, \"  excludeInComp: %v\\n\", c.excludeInComp)\n-\tfmt.Fprintf(buf, \"  compatDecomp: %v\\n\", c.compatDecomp)\n-\tfmt.Fprintf(buf, \"  state: %v\\n\", c.state)\n-\tfmt.Fprintf(buf, \"  NFC:\\n\")\n-\tfmt.Fprint(buf, c.forms[FCanonical])\n-\tfmt.Fprintf(buf, \"  NFKC:\\n\")\n-\tfmt.Fprint(buf, c.forms[FCompatibility])\n-\n-\treturn buf.String()\n-}\n-\n-// In UnicodeData.txt, some ranges are marked like this:\n-//\t3400;<CJK Ideograph Extension A, First>;Lo;0;L;;;;;N;;;;;\n-//\t4DB5;<CJK Ideograph Extension A, Last>;Lo;0;L;;;;;N;;;;;\n-// parseCharacter keeps a state variable indicating the weirdness.\n-type State int\n-\n-const (\n-\tSNormal State = iota // known to be zero for the type\n-\tSFirst\n-\tSLast\n-\tSMissing\n-)\n-\n-var lastChar = rune('\\u0000')\n-\n-func (c Char) isValid() bool {\n-\treturn c.codePoint != 0 && c.state != SMissing\n-}\n-\n-type FormInfo struct {\n-\tquickCheck [MNumberOfModes]QCResult // index: MComposed or MDecomposed\n-\tverified   [MNumberOfModes]bool     // index: MComposed or MDecomposed\n-\n-\tcombinesForward  bool // May combine with rune on the right\n-\tcombinesBackward bool // May combine with rune on the left\n-\tisOneWay         bool // Never appears in result\n-\tinDecomp         bool // Some decompositions result in this char.\n-\tdecomp           Decomposition\n-\texpandedDecomp   Decomposition\n-}\n-\n-func (f FormInfo) String() string {\n-\tbuf := bytes.NewBuffer(make([]byte, 0))\n-\n-\tfmt.Fprintf(buf, \"    quickCheck[C]: %v\\n\", f.quickCheck[MComposed])\n-\tfmt.Fprintf(buf, \"    quickCheck[D]: %v\\n\", f.quickCheck[MDecomposed])\n-\tfmt.Fprintf(buf, \"    cmbForward: %v\\n\", f.combinesForward)\n-\tfmt.Fprintf(buf, \"    cmbBackward: %v\\n\", f.combinesBackward)\n-\tfmt.Fprintf(buf, \"    isOneWay: %v\\n\", f.isOneWay)\n-\tfmt.Fprintf(buf, \"    inDecomp: %v\\n\", f.inDecomp)\n-\tfmt.Fprintf(buf, \"    decomposition: %X\\n\", f.decomp)\n-\tfmt.Fprintf(buf, \"    expandedDecomp: %X\\n\", f.expandedDecomp)\n-\n-\treturn buf.String()\n-}\n-\n-type Decomposition []rune\n-\n-func parseDecomposition(s string, skipfirst bool) (a []rune, err error) {\n-\tdecomp := strings.Split(s, \" \")\n-\tif len(decomp) > 0 && skipfirst {\n-\t\tdecomp = decomp[1:]\n-\t}\n-\tfor _, d := range decomp {\n-\t\tpoint, err := strconv.ParseUint(d, 16, 64)\n-\t\tif err != nil {\n-\t\t\treturn a, err\n-\t\t}\n-\t\ta = append(a, rune(point))\n-\t}\n-\treturn a, nil\n-}\n-\n-func loadUnicodeData() {\n-\tf := gen.OpenUCDFile(\"UnicodeData.txt\")\n-\tdefer f.Close()\n-\tp := ucd.New(f)\n-\tfor p.Next() {\n-\t\tr := p.Rune(ucd.CodePoint)\n-\t\tchar := &chars[r]\n-\n-\t\tchar.ccc = uint8(p.Uint(ucd.CanonicalCombiningClass))\n-\t\tdecmap := p.String(ucd.DecompMapping)\n-\n-\t\texp, err := parseDecomposition(decmap, false)\n-\t\tisCompat := false\n-\t\tif err != nil {\n-\t\t\tif len(decmap) > 0 {\n-\t\t\t\texp, err = parseDecomposition(decmap, true)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Fatalf(`%U: bad decomp |%v|: \"%s\"`, r, decmap, err)\n-\t\t\t\t}\n-\t\t\t\tisCompat = true\n-\t\t\t}\n-\t\t}\n-\n-\t\tchar.name = p.String(ucd.Name)\n-\t\tchar.codePoint = r\n-\t\tchar.forms[FCompatibility].decomp = exp\n-\t\tif !isCompat {\n-\t\t\tchar.forms[FCanonical].decomp = exp\n-\t\t} else {\n-\t\t\tchar.compatDecomp = true\n-\t\t}\n-\t\tif len(decmap) > 0 {\n-\t\t\tchar.forms[FCompatibility].decomp = exp\n-\t\t}\n-\t}\n-\tif err := p.Err(); err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-}\n-\n-// compactCCC converts the sparse set of CCC values to a continguous one,\n-// reducing the number of bits needed from 8 to 6.\n-func compactCCC() {\n-\tm := make(map[uint8]uint8)\n-\tfor i := range chars {\n-\t\tc := &chars[i]\n-\t\tm[c.ccc] = 0\n-\t}\n-\tcccs := []int{}\n-\tfor v, _ := range m {\n-\t\tcccs = append(cccs, int(v))\n-\t}\n-\tsort.Ints(cccs)\n-\tfor i, c := range cccs {\n-\t\tcccMap[uint8(i)] = uint8(c)\n-\t\tm[uint8(c)] = uint8(i)\n-\t}\n-\tfor i := range chars {\n-\t\tc := &chars[i]\n-\t\tc.origCCC = c.ccc\n-\t\tc.ccc = m[c.ccc]\n-\t}\n-\tif len(m) >= 1<<6 {\n-\t\tlog.Fatalf(\"too many difference CCC values: %d >= 64\", len(m))\n-\t}\n-}\n-\n-// CompositionExclusions.txt has form:\n-// 0958    # ...\n-// See https://unicode.org/reports/tr44/ for full explanation\n-func loadCompositionExclusions() {\n-\tf := gen.OpenUCDFile(\"CompositionExclusions.txt\")\n-\tdefer f.Close()\n-\tp := ucd.New(f)\n-\tfor p.Next() {\n-\t\tc := &chars[p.Rune(0)]\n-\t\tif c.excludeInComp {\n-\t\t\tlog.Fatalf(\"%U: Duplicate entry in exclusions.\", c.codePoint)\n-\t\t}\n-\t\tc.excludeInComp = true\n-\t}\n-\tif e := p.Err(); e != nil {\n-\t\tlog.Fatal(e)\n-\t}\n-}\n-\n-// hasCompatDecomp returns true if any of the recursive\n-// decompositions contains a compatibility expansion.\n-// In this case, the character may not occur in NFK*.\n-func hasCompatDecomp(r rune) bool {\n-\tc := &chars[r]\n-\tif c.compatDecomp {\n-\t\treturn true\n-\t}\n-\tfor _, d := range c.forms[FCompatibility].decomp {\n-\t\tif hasCompatDecomp(d) {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-// Hangul related constants.\n-const (\n-\tHangulBase = 0xAC00\n-\tHangulEnd  = 0xD7A4 // hangulBase + Jamo combinations (19 * 21 * 28)\n-\n-\tJamoLBase = 0x1100\n-\tJamoLEnd  = 0x1113\n-\tJamoVBase = 0x1161\n-\tJamoVEnd  = 0x1176\n-\tJamoTBase = 0x11A8\n-\tJamoTEnd  = 0x11C3\n-\n-\tJamoLVTCount = 19 * 21 * 28\n-\tJamoTCount   = 28\n-)\n-\n-func isHangul(r rune) bool {\n-\treturn HangulBase <= r && r < HangulEnd\n-}\n-\n-func isHangulWithoutJamoT(r rune) bool {\n-\tif !isHangul(r) {\n-\t\treturn false\n-\t}\n-\tr -= HangulBase\n-\treturn r < JamoLVTCount && r%JamoTCount == 0\n-}\n-\n-func ccc(r rune) uint8 {\n-\treturn chars[r].ccc\n-}\n-\n-// Insert a rune in a buffer, ordered by Canonical Combining Class.\n-func insertOrdered(b Decomposition, r rune) Decomposition {\n-\tn := len(b)\n-\tb = append(b, 0)\n-\tcc := ccc(r)\n-\tif cc > 0 {\n-\t\t// Use bubble sort.\n-\t\tfor ; n > 0; n-- {\n-\t\t\tif ccc(b[n-1]) <= cc {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tb[n] = b[n-1]\n-\t\t}\n-\t}\n-\tb[n] = r\n-\treturn b\n-}\n-\n-// Recursively decompose.\n-func decomposeRecursive(form int, r rune, d Decomposition) Decomposition {\n-\tdcomp := chars[r].forms[form].decomp\n-\tif len(dcomp) == 0 {\n-\t\treturn insertOrdered(d, r)\n-\t}\n-\tfor _, c := range dcomp {\n-\t\td = decomposeRecursive(form, c, d)\n-\t}\n-\treturn d\n-}\n-\n-func completeCharFields(form int) {\n-\t// Phase 0: pre-expand decomposition.\n-\tfor i := range chars {\n-\t\tf := &chars[i].forms[form]\n-\t\tif len(f.decomp) == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\texp := make(Decomposition, 0)\n-\t\tfor _, c := range f.decomp {\n-\t\t\texp = decomposeRecursive(form, c, exp)\n-\t\t}\n-\t\tf.expandedDecomp = exp\n-\t}\n-\n-\t// Phase 1: composition exclusion, mark decomposition.\n-\tfor i := range chars {\n-\t\tc := &chars[i]\n-\t\tf := &c.forms[form]\n-\n-\t\t// Marks script-specific exclusions and version restricted.\n-\t\tf.isOneWay = c.excludeInComp\n-\n-\t\t// Singletons\n-\t\tf.isOneWay = f.isOneWay || len(f.decomp) == 1\n-\n-\t\t// Non-starter decompositions\n-\t\tif len(f.decomp) > 1 {\n-\t\t\tchk := c.ccc != 0 || chars[f.decomp[0]].ccc != 0\n-\t\t\tf.isOneWay = f.isOneWay || chk\n-\t\t}\n-\n-\t\t// Runes that decompose into more than two runes.\n-\t\tf.isOneWay = f.isOneWay || len(f.decomp) > 2\n-\n-\t\tif form == FCompatibility {\n-\t\t\tf.isOneWay = f.isOneWay || hasCompatDecomp(c.codePoint)\n-\t\t}\n-\n-\t\tfor _, r := range f.decomp {\n-\t\t\tchars[r].forms[form].inDecomp = true\n-\t\t}\n-\t}\n-\n-\t// Phase 2: forward and backward combining.\n-\tfor i := range chars {\n-\t\tc := &chars[i]\n-\t\tf := &c.forms[form]\n-\n-\t\tif !f.isOneWay && len(f.decomp) == 2 {\n-\t\t\tf0 := &chars[f.decomp[0]].forms[form]\n-\t\t\tf1 := &chars[f.decomp[1]].forms[form]\n-\t\t\tif !f0.isOneWay {\n-\t\t\t\tf0.combinesForward = true\n-\t\t\t}\n-\t\t\tif !f1.isOneWay {\n-\t\t\t\tf1.combinesBackward = true\n-\t\t\t}\n-\t\t}\n-\t\tif isHangulWithoutJamoT(rune(i)) {\n-\t\t\tf.combinesForward = true\n-\t\t}\n-\t}\n-\n-\t// Phase 3: quick check values.\n-\tfor i := range chars {\n-\t\tc := &chars[i]\n-\t\tf := &c.forms[form]\n-\n-\t\tswitch {\n-\t\tcase len(f.decomp) > 0:\n-\t\t\tf.quickCheck[MDecomposed] = QCNo\n-\t\tcase isHangul(rune(i)):\n-\t\t\tf.quickCheck[MDecomposed] = QCNo\n-\t\tdefault:\n-\t\t\tf.quickCheck[MDecomposed] = QCYes\n-\t\t}\n-\t\tswitch {\n-\t\tcase f.isOneWay:\n-\t\t\tf.quickCheck[MComposed] = QCNo\n-\t\tcase (i & 0xffff00) == JamoLBase:\n-\t\t\tf.quickCheck[MComposed] = QCYes\n-\t\t\tif JamoLBase <= i && i < JamoLEnd {\n-\t\t\t\tf.combinesForward = true\n-\t\t\t}\n-\t\t\tif JamoVBase <= i && i < JamoVEnd {\n-\t\t\t\tf.quickCheck[MComposed] = QCMaybe\n-\t\t\t\tf.combinesBackward = true\n-\t\t\t\tf.combinesForward = true\n-\t\t\t}\n-\t\t\tif JamoTBase <= i && i < JamoTEnd {\n-\t\t\t\tf.quickCheck[MComposed] = QCMaybe\n-\t\t\t\tf.combinesBackward = true\n-\t\t\t}\n-\t\tcase !f.combinesBackward:\n-\t\t\tf.quickCheck[MComposed] = QCYes\n-\t\tdefault:\n-\t\t\tf.quickCheck[MComposed] = QCMaybe\n-\t\t}\n-\t}\n-}\n-\n-func computeNonStarterCounts() {\n-\t// Phase 4: leading and trailing non-starter count\n-\tfor i := range chars {\n-\t\tc := &chars[i]\n-\n-\t\trunes := []rune{rune(i)}\n-\t\t// We always use FCompatibility so that the CGJ insertion points do not\n-\t\t// change for repeated normalizations with different forms.\n-\t\tif exp := c.forms[FCompatibility].expandedDecomp; len(exp) > 0 {\n-\t\t\trunes = exp\n-\t\t}\n-\t\t// We consider runes that combine backwards to be non-starters for the\n-\t\t// purpose of Stream-Safe Text Processing.\n-\t\tfor _, r := range runes {\n-\t\t\tif cr := &chars[r]; cr.ccc == 0 && !cr.forms[FCompatibility].combinesBackward {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tc.nLeadingNonStarters++\n-\t\t}\n-\t\tfor i := len(runes) - 1; i >= 0; i-- {\n-\t\t\tif cr := &chars[runes[i]]; cr.ccc == 0 && !cr.forms[FCompatibility].combinesBackward {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tc.nTrailingNonStarters++\n-\t\t}\n-\t\tif c.nTrailingNonStarters > 3 {\n-\t\t\tlog.Fatalf(\"%U: Decomposition with more than 3 (%d) trailing modifiers (%U)\", i, c.nTrailingNonStarters, runes)\n-\t\t}\n-\n-\t\tif isHangul(rune(i)) {\n-\t\t\tc.nTrailingNonStarters = 2\n-\t\t\tif isHangulWithoutJamoT(rune(i)) {\n-\t\t\t\tc.nTrailingNonStarters = 1\n-\t\t\t}\n-\t\t}\n-\n-\t\tif l, t := c.nLeadingNonStarters, c.nTrailingNonStarters; l > 0 && l != t {\n-\t\t\tlog.Fatalf(\"%U: number of leading and trailing non-starters should be equal (%d vs %d)\", i, l, t)\n-\t\t}\n-\t\tif t := c.nTrailingNonStarters; t > 3 {\n-\t\t\tlog.Fatalf(\"%U: number of trailing non-starters is %d > 3\", t)\n-\t\t}\n-\t}\n-}\n-\n-func printBytes(w io.Writer, b []byte, name string) {\n-\tfmt.Fprintf(w, \"// %s: %d bytes\\n\", name, len(b))\n-\tfmt.Fprintf(w, \"var %s = [...]byte {\", name)\n-\tfor i, c := range b {\n-\t\tswitch {\n-\t\tcase i%64 == 0:\n-\t\t\tfmt.Fprintf(w, \"\\n// Bytes %x - %x\\n\", i, i+63)\n-\t\tcase i%8 == 0:\n-\t\t\tfmt.Fprintf(w, \"\\n\")\n-\t\t}\n-\t\tfmt.Fprintf(w, \"0x%.2X, \", c)\n-\t}\n-\tfmt.Fprint(w, \"\\n}\\n\\n\")\n-}\n-\n-// See forminfo.go for format.\n-func makeEntry(f *FormInfo, c *Char) uint16 {\n-\te := uint16(0)\n-\tif r := c.codePoint; HangulBase <= r && r < HangulEnd {\n-\t\te |= 0x40\n-\t}\n-\tif f.combinesForward {\n-\t\te |= 0x20\n-\t}\n-\tif f.quickCheck[MDecomposed] == QCNo {\n-\t\te |= 0x4\n-\t}\n-\tswitch f.quickCheck[MComposed] {\n-\tcase QCYes:\n-\tcase QCNo:\n-\t\te |= 0x10\n-\tcase QCMaybe:\n-\t\te |= 0x18\n-\tdefault:\n-\t\tlog.Fatalf(\"Illegal quickcheck value %v.\", f.quickCheck[MComposed])\n-\t}\n-\te |= uint16(c.nTrailingNonStarters)\n-\treturn e\n-}\n-\n-// decompSet keeps track of unique decompositions, grouped by whether\n-// the decomposition is followed by a trailing and/or leading CCC.\n-type decompSet [7]map[string]bool\n-\n-const (\n-\tnormalDecomp = iota\n-\tfirstMulti\n-\tfirstCCC\n-\tendMulti\n-\tfirstLeadingCCC\n-\tfirstCCCZeroExcept\n-\tfirstStarterWithNLead\n-\tlastDecomp\n-)\n-\n-var cname = []string{\"firstMulti\", \"firstCCC\", \"endMulti\", \"firstLeadingCCC\", \"firstCCCZeroExcept\", \"firstStarterWithNLead\", \"lastDecomp\"}\n-\n-func makeDecompSet() decompSet {\n-\tm := decompSet{}\n-\tfor i := range m {\n-\t\tm[i] = make(map[string]bool)\n-\t}\n-\treturn m\n-}\n-func (m *decompSet) insert(key int, s string) {\n-\tm[key][s] = true\n-}\n-\n-func printCharInfoTables(w io.Writer) int {\n-\tmkstr := func(r rune, f *FormInfo) (int, string) {\n-\t\td := f.expandedDecomp\n-\t\ts := string([]rune(d))\n-\t\tif max := 1 << 6; len(s) >= max {\n-\t\t\tconst msg = \"%U: too many bytes in decomposition: %d >= %d\"\n-\t\t\tlog.Fatalf(msg, r, len(s), max)\n-\t\t}\n-\t\thead := uint8(len(s))\n-\t\tif f.quickCheck[MComposed] != QCYes {\n-\t\t\thead |= 0x40\n-\t\t}\n-\t\tif f.combinesForward {\n-\t\t\thead |= 0x80\n-\t\t}\n-\t\ts = string([]byte{head}) + s\n-\n-\t\tlccc := ccc(d[0])\n-\t\ttccc := ccc(d[len(d)-1])\n-\t\tcc := ccc(r)\n-\t\tif cc != 0 && lccc == 0 && tccc == 0 {\n-\t\t\tlog.Fatalf(\"%U: trailing and leading ccc are 0 for non-zero ccc %d\", r, cc)\n-\t\t}\n-\t\tif tccc < lccc && lccc != 0 {\n-\t\t\tconst msg = \"%U: lccc (%d) must be <= tcc (%d)\"\n-\t\t\tlog.Fatalf(msg, r, lccc, tccc)\n-\t\t}\n-\t\tindex := normalDecomp\n-\t\tnTrail := chars[r].nTrailingNonStarters\n-\t\tnLead := chars[r].nLeadingNonStarters\n-\t\tif tccc > 0 || lccc > 0 || nTrail > 0 {\n-\t\t\ttccc <<= 2\n-\t\t\ttccc |= nTrail\n-\t\t\ts += string([]byte{tccc})\n-\t\t\tindex = endMulti\n-\t\t\tfor _, r := range d[1:] {\n-\t\t\t\tif ccc(r) == 0 {\n-\t\t\t\t\tindex = firstCCC\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif lccc > 0 || nLead > 0 {\n-\t\t\t\ts += string([]byte{lccc})\n-\t\t\t\tif index == firstCCC {\n-\t\t\t\t\tlog.Fatalf(\"%U: multi-segment decomposition not supported for decompositions with leading CCC != 0\", r)\n-\t\t\t\t}\n-\t\t\t\tindex = firstLeadingCCC\n-\t\t\t}\n-\t\t\tif cc != lccc {\n-\t\t\t\tif cc != 0 {\n-\t\t\t\t\tlog.Fatalf(\"%U: for lccc != ccc, expected ccc to be 0; was %d\", r, cc)\n-\t\t\t\t}\n-\t\t\t\tindex = firstCCCZeroExcept\n-\t\t\t}\n-\t\t} else if len(d) > 1 {\n-\t\t\tindex = firstMulti\n-\t\t}\n-\t\treturn index, s\n-\t}\n-\n-\tdecompSet := makeDecompSet()\n-\tconst nLeadStr = \"\\x00\\x01\" // 0-byte length and tccc with nTrail.\n-\tdecompSet.insert(firstStarterWithNLead, nLeadStr)\n-\n-\t// Store the uniqued decompositions in a byte buffer,\n-\t// preceded by their byte length.\n-\tfor _, c := range chars {\n-\t\tfor _, f := range c.forms {\n-\t\t\tif len(f.expandedDecomp) == 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif f.combinesBackward {\n-\t\t\t\tlog.Fatalf(\"%U: combinesBackward and decompose\", c.codePoint)\n-\t\t\t}\n-\t\t\tindex, s := mkstr(c.codePoint, &f)\n-\t\t\tdecompSet.insert(index, s)\n-\t\t}\n-\t}\n-\n-\tdecompositions := bytes.NewBuffer(make([]byte, 0, 10000))\n-\tsize := 0\n-\tpositionMap := make(map[string]uint16)\n-\tdecompositions.WriteString(\"\\000\")\n-\tfmt.Fprintln(w, \"const (\")\n-\tfor i, m := range decompSet {\n-\t\tsa := []string{}\n-\t\tfor s := range m {\n-\t\t\tsa = append(sa, s)\n-\t\t}\n-\t\tsort.Strings(sa)\n-\t\tfor _, s := range sa {\n-\t\t\tp := decompositions.Len()\n-\t\t\tdecompositions.WriteString(s)\n-\t\t\tpositionMap[s] = uint16(p)\n-\t\t}\n-\t\tif cname[i] != \"\" {\n-\t\t\tfmt.Fprintf(w, \"%s = 0x%X\\n\", cname[i], decompositions.Len())\n-\t\t}\n-\t}\n-\tfmt.Fprintln(w, \"maxDecomp = 0x8000\")\n-\tfmt.Fprintln(w, \")\")\n-\tb := decompositions.Bytes()\n-\tprintBytes(w, b, \"decomps\")\n-\tsize += len(b)\n-\n-\tvarnames := []string{\"nfc\", \"nfkc\"}\n-\tfor i := 0; i < FNumberOfFormTypes; i++ {\n-\t\ttrie := triegen.NewTrie(varnames[i])\n-\n-\t\tfor r, c := range chars {\n-\t\t\tf := c.forms[i]\n-\t\t\td := f.expandedDecomp\n-\t\t\tif len(d) != 0 {\n-\t\t\t\t_, key := mkstr(c.codePoint, &f)\n-\t\t\t\ttrie.Insert(rune(r), uint64(positionMap[key]))\n-\t\t\t\tif c.ccc != ccc(d[0]) {\n-\t\t\t\t\t// We assume the lead ccc of a decomposition !=0 in this case.\n-\t\t\t\t\tif ccc(d[0]) == 0 {\n-\t\t\t\t\t\tlog.Fatalf(\"Expected leading CCC to be non-zero; ccc is %d\", c.ccc)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else if c.nLeadingNonStarters > 0 && len(f.expandedDecomp) == 0 && c.ccc == 0 && !f.combinesBackward {\n-\t\t\t\t// Handle cases where it can't be detected that the nLead should be equal\n-\t\t\t\t// to nTrail.\n-\t\t\t\ttrie.Insert(c.codePoint, uint64(positionMap[nLeadStr]))\n-\t\t\t} else if v := makeEntry(&f, &c)<<8 | uint16(c.ccc); v != 0 {\n-\t\t\t\ttrie.Insert(c.codePoint, uint64(0x8000|v))\n-\t\t\t}\n-\t\t}\n-\t\tsz, err := trie.Gen(w, triegen.Compact(&normCompacter{name: varnames[i]}))\n-\t\tif err != nil {\n-\t\t\tlog.Fatal(err)\n-\t\t}\n-\t\tsize += sz\n-\t}\n-\treturn size\n-}\n-\n-func contains(sa []string, s string) bool {\n-\tfor _, a := range sa {\n-\t\tif a == s {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-func makeTables() {\n-\tw := &bytes.Buffer{}\n-\n-\tsize := 0\n-\tif *tablelist == \"\" {\n-\t\treturn\n-\t}\n-\tlist := strings.Split(*tablelist, \",\")\n-\tif *tablelist == \"all\" {\n-\t\tlist = []string{\"recomp\", \"info\"}\n-\t}\n-\n-\t// Compute maximum decomposition size.\n-\tmax := 0\n-\tfor _, c := range chars {\n-\t\tif n := len(string(c.forms[FCompatibility].expandedDecomp)); n > max {\n-\t\t\tmax = n\n-\t\t}\n-\t}\n-\tfmt.Fprintln(w, `import \"sync\"`)\n-\tfmt.Fprintln(w)\n-\n-\tfmt.Fprintln(w, \"const (\")\n-\tfmt.Fprintln(w, \"\\t// Version is the Unicode edition from which the tables are derived.\")\n-\tfmt.Fprintf(w, \"\\tVersion = %q\\n\", gen.UnicodeVersion())\n-\tfmt.Fprintln(w)\n-\tfmt.Fprintln(w, \"\\t// MaxTransformChunkSize indicates the maximum number of bytes that Transform\")\n-\tfmt.Fprintln(w, \"\\t// may need to write atomically for any Form. Making a destination buffer at\")\n-\tfmt.Fprintln(w, \"\\t// least this size ensures that Transform can always make progress and that\")\n-\tfmt.Fprintln(w, \"\\t// the user does not need to grow the buffer on an ErrShortDst.\")\n-\tfmt.Fprintf(w, \"\\tMaxTransformChunkSize = %d+maxNonStarters*4\\n\", len(string(0x034F))+max)\n-\tfmt.Fprintln(w, \")\\n\")\n-\n-\t// Print the CCC remap table.\n-\tsize += len(cccMap)\n-\tfmt.Fprintf(w, \"var ccc = [%d]uint8{\", len(cccMap))\n-\tfor i := 0; i < len(cccMap); i++ {\n-\t\tif i%8 == 0 {\n-\t\t\tfmt.Fprintln(w)\n-\t\t}\n-\t\tfmt.Fprintf(w, \"%3d, \", cccMap[uint8(i)])\n-\t}\n-\tfmt.Fprintln(w, \"\\n}\\n\")\n-\n-\tif contains(list, \"info\") {\n-\t\tsize += printCharInfoTables(w)\n-\t}\n-\n-\tif contains(list, \"recomp\") {\n-\t\t// Note that we use 32 bit keys, instead of 64 bit.\n-\t\t// This clips the bits of three entries, but we know\n-\t\t// this won't cause a collision. The compiler will catch\n-\t\t// any changes made to UnicodeData.txt that introduces\n-\t\t// a collision.\n-\t\t// Note that the recomposition map for NFC and NFKC\n-\t\t// are identical.\n-\n-\t\t// Recomposition map\n-\t\tnrentries := 0\n-\t\tfor _, c := range chars {\n-\t\t\tf := c.forms[FCanonical]\n-\t\t\tif !f.isOneWay && len(f.decomp) > 0 {\n-\t\t\t\tnrentries++\n-\t\t\t}\n-\t\t}\n-\t\tsz := nrentries * 8\n-\t\tsize += sz\n-\t\tfmt.Fprintf(w, \"// recompMap: %d bytes (entries only)\\n\", sz)\n-\t\tfmt.Fprintln(w, \"var recompMap map[uint32]rune\")\n-\t\tfmt.Fprintln(w, \"var recompMapOnce sync.Once\\n\")\n-\t\tfmt.Fprintln(w, `const recompMapPacked = \"\" +`)\n-\t\tvar buf [8]byte\n-\t\tfor i, c := range chars {\n-\t\t\tf := c.forms[FCanonical]\n-\t\t\td := f.decomp\n-\t\t\tif !f.isOneWay && len(d) > 0 {\n-\t\t\t\tkey := uint32(uint16(d[0]))<<16 + uint32(uint16(d[1]))\n-\t\t\t\tbinary.BigEndian.PutUint32(buf[:4], key)\n-\t\t\t\tbinary.BigEndian.PutUint32(buf[4:], uint32(i))\n-\t\t\t\tfmt.Fprintf(w, \"\\t\\t%q + // 0x%.8X: 0x%.8X\\n\", string(buf[:]), key, uint32(i))\n-\t\t\t}\n-\t\t}\n-\t\t// hack so we don't have to special case the trailing plus sign\n-\t\tfmt.Fprintf(w, `\t\"\"`)\n-\t\tfmt.Fprintln(w)\n-\t}\n-\n-\tfmt.Fprintf(w, \"// Total size of tables: %dKB (%d bytes)\\n\", (size+512)/1024, size)\n-\tgen.WriteVersionedGoFile(\"tables.go\", \"norm\", w.Bytes())\n-}\n-\n-func printChars() {\n-\tif *verbose {\n-\t\tfor _, c := range chars {\n-\t\t\tif !c.isValid() || c.state == SMissing {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tfmt.Println(c)\n-\t\t}\n-\t}\n-}\n-\n-// verifyComputed does various consistency tests.\n-func verifyComputed() {\n-\tfor i, c := range chars {\n-\t\tfor _, f := range c.forms {\n-\t\t\tisNo := (f.quickCheck[MDecomposed] == QCNo)\n-\t\t\tif (len(f.decomp) > 0) != isNo && !isHangul(rune(i)) {\n-\t\t\t\tlog.Fatalf(\"%U: NF*D QC must be No if rune decomposes\", i)\n-\t\t\t}\n-\n-\t\t\tisMaybe := f.quickCheck[MComposed] == QCMaybe\n-\t\t\tif f.combinesBackward != isMaybe {\n-\t\t\t\tlog.Fatalf(\"%U: NF*C QC must be Maybe if combinesBackward\", i)\n-\t\t\t}\n-\t\t\tif len(f.decomp) > 0 && f.combinesForward && isMaybe {\n-\t\t\t\tlog.Fatalf(\"%U: NF*C QC must be Yes or No if combinesForward and decomposes\", i)\n-\t\t\t}\n-\n-\t\t\tif len(f.expandedDecomp) != 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif a, b := c.nLeadingNonStarters > 0, (c.ccc > 0 || f.combinesBackward); a != b {\n-\t\t\t\t// We accept these runes to be treated differently (it only affects\n-\t\t\t\t// segment breaking in iteration, most likely on improper use), but\n-\t\t\t\t// reconsider if more characters are added.\n-\t\t\t\t// U+FF9E HALFWIDTH KATAKANA VOICED SOUND MARK;Lm;0;L;<narrow> 3099;;;;N;;;;;\n-\t\t\t\t// U+FF9F HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK;Lm;0;L;<narrow> 309A;;;;N;;;;;\n-\t\t\t\t// U+3133 HANGUL LETTER KIYEOK-SIOS;Lo;0;L;<compat> 11AA;;;;N;HANGUL LETTER GIYEOG SIOS;;;;\n-\t\t\t\t// U+318E HANGUL LETTER ARAEAE;Lo;0;L;<compat> 11A1;;;;N;HANGUL LETTER ALAE AE;;;;\n-\t\t\t\t// U+FFA3 HALFWIDTH HANGUL LETTER KIYEOK-SIOS;Lo;0;L;<narrow> 3133;;;;N;HALFWIDTH HANGUL LETTER GIYEOG SIOS;;;;\n-\t\t\t\t// U+FFDC HALFWIDTH HANGUL LETTER I;Lo;0;L;<narrow> 3163;;;;N;;;;;\n-\t\t\t\tif i != 0xFF9E && i != 0xFF9F && !(0x3133 <= i && i <= 0x318E) && !(0xFFA3 <= i && i <= 0xFFDC) {\n-\t\t\t\t\tlog.Fatalf(\"%U: nLead was %v; want %v\", i, a, b)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tnfc := c.forms[FCanonical]\n-\t\tnfkc := c.forms[FCompatibility]\n-\t\tif nfc.combinesBackward != nfkc.combinesBackward {\n-\t\t\tlog.Fatalf(\"%U: Cannot combine combinesBackward\\n\", c.codePoint)\n-\t\t}\n-\t}\n-}\n-\n-// Use values in DerivedNormalizationProps.txt to compare against the\n-// values we computed.\n-// DerivedNormalizationProps.txt has form:\n-// 00C0..00C5    ; NFD_QC; N # ...\n-// 0374          ; NFD_QC; N # ...\n-// See https://unicode.org/reports/tr44/ for full explanation\n-func testDerived() {\n-\tf := gen.OpenUCDFile(\"DerivedNormalizationProps.txt\")\n-\tdefer f.Close()\n-\tp := ucd.New(f)\n-\tfor p.Next() {\n-\t\tr := p.Rune(0)\n-\t\tc := &chars[r]\n-\n-\t\tvar ftype, mode int\n-\t\tqt := p.String(1)\n-\t\tswitch qt {\n-\t\tcase \"NFC_QC\":\n-\t\t\tftype, mode = FCanonical, MComposed\n-\t\tcase \"NFD_QC\":\n-\t\t\tftype, mode = FCanonical, MDecomposed\n-\t\tcase \"NFKC_QC\":\n-\t\t\tftype, mode = FCompatibility, MComposed\n-\t\tcase \"NFKD_QC\":\n-\t\t\tftype, mode = FCompatibility, MDecomposed\n-\t\tdefault:\n-\t\t\tcontinue\n-\t\t}\n-\t\tvar qr QCResult\n-\t\tswitch p.String(2) {\n-\t\tcase \"Y\":\n-\t\t\tqr = QCYes\n-\t\tcase \"N\":\n-\t\t\tqr = QCNo\n-\t\tcase \"M\":\n-\t\t\tqr = QCMaybe\n-\t\tdefault:\n-\t\t\tlog.Fatalf(`Unexpected quick check value \"%s\"`, p.String(2))\n-\t\t}\n-\t\tif got := c.forms[ftype].quickCheck[mode]; got != qr {\n-\t\t\tlog.Printf(\"%U: FAILED %s (was %v need %v)\\n\", r, qt, got, qr)\n-\t\t}\n-\t\tc.forms[ftype].verified[mode] = true\n-\t}\n-\tif err := p.Err(); err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\t// Any unspecified value must be QCYes. Verify this.\n-\tfor i, c := range chars {\n-\t\tfor j, fd := range c.forms {\n-\t\t\tfor k, qr := range fd.quickCheck {\n-\t\t\t\tif !fd.verified[k] && qr != QCYes {\n-\t\t\t\t\tm := \"%U: FAIL F:%d M:%d (was %v need Yes) %s\\n\"\n-\t\t\t\t\tlog.Printf(m, i, j, k, qr, c.name)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-var testHeader = `const (\n-\tYes = iota\n-\tNo\n-\tMaybe\n-)\n-\n-type formData struct {\n-\tqc              uint8\n-\tcombinesForward bool\n-\tdecomposition   string\n-}\n-\n-type runeData struct {\n-\tr      rune\n-\tccc    uint8\n-\tnLead  uint8\n-\tnTrail uint8\n-\tf      [2]formData // 0: canonical; 1: compatibility\n-}\n-\n-func f(qc uint8, cf bool, dec string) [2]formData {\n-\treturn [2]formData{{qc, cf, dec}, {qc, cf, dec}}\n-}\n-\n-func g(qc, qck uint8, cf, cfk bool, d, dk string) [2]formData {\n-\treturn [2]formData{{qc, cf, d}, {qck, cfk, dk}}\n-}\n-\n-var testData = []runeData{\n-`\n-\n-func printTestdata() {\n-\ttype lastInfo struct {\n-\t\tccc    uint8\n-\t\tnLead  uint8\n-\t\tnTrail uint8\n-\t\tf      string\n-\t}\n-\n-\tlast := lastInfo{}\n-\tw := &bytes.Buffer{}\n-\tfmt.Fprintf(w, testHeader)\n-\tfor r, c := range chars {\n-\t\tf := c.forms[FCanonical]\n-\t\tqc, cf, d := f.quickCheck[MComposed], f.combinesForward, string(f.expandedDecomp)\n-\t\tf = c.forms[FCompatibility]\n-\t\tqck, cfk, dk := f.quickCheck[MComposed], f.combinesForward, string(f.expandedDecomp)\n-\t\ts := \"\"\n-\t\tif d == dk && qc == qck && cf == cfk {\n-\t\t\ts = fmt.Sprintf(\"f(%s, %v, %q)\", qc, cf, d)\n-\t\t} else {\n-\t\t\ts = fmt.Sprintf(\"g(%s, %s, %v, %v, %q, %q)\", qc, qck, cf, cfk, d, dk)\n-\t\t}\n-\t\tcurrent := lastInfo{c.ccc, c.nLeadingNonStarters, c.nTrailingNonStarters, s}\n-\t\tif last != current {\n-\t\t\tfmt.Fprintf(w, \"\\t{0x%x, %d, %d, %d, %s},\\n\", r, c.origCCC, c.nLeadingNonStarters, c.nTrailingNonStarters, s)\n-\t\t\tlast = current\n-\t\t}\n-\t}\n-\tfmt.Fprintln(w, \"}\")\n-\tgen.WriteVersionedGoFile(\"data_test.go\", \"norm\", w.Bytes())\n-}"
    },
    {
      "sha": "45d711900d144f5e66fb29941c1a8700049ab0c9",
      "filename": "backend/vendor/golang.org/x/text/unicode/norm/triegen.go",
      "status": "removed",
      "additions": 0,
      "deletions": 117,
      "changes": 117,
      "blob_url": "https://github.com/umputun/remark/blob/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/norm/triegen.go",
      "raw_url": "https://github.com/umputun/remark/raw/7971ebe6f49e5a9a944407ef2f380d0fb405572b/backend/vendor/golang.org/x/text/unicode/norm/triegen.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/text/unicode/norm/triegen.go?ref=7971ebe6f49e5a9a944407ef2f380d0fb405572b",
      "patch": "@@ -1,117 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-// Trie table generator.\n-// Used by make*tables tools to generate a go file with trie data structures\n-// for mapping UTF-8 to a 16-bit value. All but the last byte in a UTF-8 byte\n-// sequence are used to lookup offsets in the index table to be used for the\n-// next byte. The last byte is used to index into a table with 16-bit values.\n-\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-)\n-\n-const maxSparseEntries = 16\n-\n-type normCompacter struct {\n-\tsparseBlocks [][]uint64\n-\tsparseOffset []uint16\n-\tsparseCount  int\n-\tname         string\n-}\n-\n-func mostFrequentStride(a []uint64) int {\n-\tcounts := make(map[int]int)\n-\tvar v int\n-\tfor _, x := range a {\n-\t\tif stride := int(x) - v; v != 0 && stride >= 0 {\n-\t\t\tcounts[stride]++\n-\t\t}\n-\t\tv = int(x)\n-\t}\n-\tvar maxs, maxc int\n-\tfor stride, cnt := range counts {\n-\t\tif cnt > maxc || (cnt == maxc && stride < maxs) {\n-\t\t\tmaxs, maxc = stride, cnt\n-\t\t}\n-\t}\n-\treturn maxs\n-}\n-\n-func countSparseEntries(a []uint64) int {\n-\tstride := mostFrequentStride(a)\n-\tvar v, count int\n-\tfor _, tv := range a {\n-\t\tif int(tv)-v != stride {\n-\t\t\tif tv != 0 {\n-\t\t\t\tcount++\n-\t\t\t}\n-\t\t}\n-\t\tv = int(tv)\n-\t}\n-\treturn count\n-}\n-\n-func (c *normCompacter) Size(v []uint64) (sz int, ok bool) {\n-\tif n := countSparseEntries(v); n <= maxSparseEntries {\n-\t\treturn (n+1)*4 + 2, true\n-\t}\n-\treturn 0, false\n-}\n-\n-func (c *normCompacter) Store(v []uint64) uint32 {\n-\th := uint32(len(c.sparseOffset))\n-\tc.sparseBlocks = append(c.sparseBlocks, v)\n-\tc.sparseOffset = append(c.sparseOffset, uint16(c.sparseCount))\n-\tc.sparseCount += countSparseEntries(v) + 1\n-\treturn h\n-}\n-\n-func (c *normCompacter) Handler() string {\n-\treturn c.name + \"Sparse.lookup\"\n-}\n-\n-func (c *normCompacter) Print(w io.Writer) (retErr error) {\n-\tp := func(f string, x ...interface{}) {\n-\t\tif _, err := fmt.Fprintf(w, f, x...); retErr == nil && err != nil {\n-\t\t\tretErr = err\n-\t\t}\n-\t}\n-\n-\tls := len(c.sparseBlocks)\n-\tp(\"// %sSparseOffset: %d entries, %d bytes\\n\", c.name, ls, ls*2)\n-\tp(\"var %sSparseOffset = %#v\\n\\n\", c.name, c.sparseOffset)\n-\n-\tns := c.sparseCount\n-\tp(\"// %sSparseValues: %d entries, %d bytes\\n\", c.name, ns, ns*4)\n-\tp(\"var %sSparseValues = [%d]valueRange {\", c.name, ns)\n-\tfor i, b := range c.sparseBlocks {\n-\t\tp(\"\\n// Block %#x, offset %#x\", i, c.sparseOffset[i])\n-\t\tvar v int\n-\t\tstride := mostFrequentStride(b)\n-\t\tn := countSparseEntries(b)\n-\t\tp(\"\\n{value:%#04x,lo:%#02x},\", stride, uint8(n))\n-\t\tfor i, nv := range b {\n-\t\t\tif int(nv)-v != stride {\n-\t\t\t\tif v != 0 {\n-\t\t\t\t\tp(\",hi:%#02x},\", 0x80+i-1)\n-\t\t\t\t}\n-\t\t\t\tif nv != 0 {\n-\t\t\t\t\tp(\"\\n{value:%#04x,lo:%#02x\", nv, 0x80+i)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tv = int(nv)\n-\t\t}\n-\t\tif v != 0 {\n-\t\t\tp(\",hi:%#02x},\", 0x80+len(b)-1)\n-\t\t}\n-\t}\n-\tp(\"\\n}\\n\\n\")\n-\treturn\n-}"
    },
    {
      "sha": "4dda574206c39db04ba51b9a1de94f03ef3eff33",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/umputun/remark/blob/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/vendor/modules.txt",
      "raw_url": "https://github.com/umputun/remark/raw/e018fac6c4c24ea313e1339d25c1ffc8fa32a93f/backend/vendor/modules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/modules.txt?ref=e018fac6c4c24ea313e1339d25c1ffc8fa32a93f",
      "patch": "@@ -23,24 +23,24 @@ github.com/didip/tollbooth_chi\n # github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8\n github.com/globalsign/mgo\n github.com/globalsign/mgo/bson\n+github.com/globalsign/mgo/internal/json\n github.com/globalsign/mgo/internal/sasl\n github.com/globalsign/mgo/internal/scram\n-github.com/globalsign/mgo/internal/json\n # github.com/go-chi/chi v4.0.2+incompatible\n github.com/go-chi/chi\n github.com/go-chi/chi/middleware\n # github.com/go-chi/cors v1.0.0\n github.com/go-chi/cors\n # github.com/go-chi/render v1.0.1\n github.com/go-chi/render\n-# github.com/go-pkgz/auth v0.8.2\n+# github.com/go-pkgz/auth v0.8.3\n github.com/go-pkgz/auth\n github.com/go-pkgz/auth/avatar\n+github.com/go-pkgz/auth/logger\n+github.com/go-pkgz/auth/middleware\n github.com/go-pkgz/auth/provider\n github.com/go-pkgz/auth/provider/sender\n github.com/go-pkgz/auth/token\n-github.com/go-pkgz/auth/logger\n-github.com/go-pkgz/auth/middleware\n # github.com/go-pkgz/jrpc v0.1.0\n github.com/go-pkgz/jrpc\n # github.com/go-pkgz/lcw v0.3.1\n@@ -53,8 +53,8 @@ github.com/go-pkgz/mongo\n github.com/go-pkgz/repeater\n github.com/go-pkgz/repeater/strategy\n # github.com/go-pkgz/rest v1.4.1\n-github.com/go-pkgz/rest/cache\n github.com/go-pkgz/rest\n+github.com/go-pkgz/rest/cache\n github.com/go-pkgz/rest/logger\n # github.com/go-pkgz/syncs v1.1.1\n github.com/go-pkgz/syncs\n@@ -94,54 +94,54 @@ github.com/shurcooL/sanitized_anchor_name\n # github.com/stretchr/objx v0.2.0\n github.com/stretchr/objx\n # github.com/stretchr/testify v1.4.0\n-github.com/stretchr/testify/mock\n github.com/stretchr/testify/assert\n+github.com/stretchr/testify/mock\n github.com/stretchr/testify/require\n # golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586\n-golang.org/x/crypto/acme/autocert\n golang.org/x/crypto/acme\n+golang.org/x/crypto/acme/autocert\n # golang.org/x/image v0.0.0-20190823064033-3a9bac650e44\n golang.org/x/image/draw\n golang.org/x/image/math/f64\n # golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7\n+golang.org/x/net/context\n+golang.org/x/net/context/ctxhttp\n golang.org/x/net/html\n-golang.org/x/net/idna\n golang.org/x/net/html/atom\n-golang.org/x/net/context/ctxhttp\n-golang.org/x/net/context\n+golang.org/x/net/idna\n # golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45\n golang.org/x/oauth2\n golang.org/x/oauth2/facebook\n golang.org/x/oauth2/github\n golang.org/x/oauth2/google\n-golang.org/x/oauth2/yandex\n golang.org/x/oauth2/internal\n golang.org/x/oauth2/jws\n golang.org/x/oauth2/jwt\n+golang.org/x/oauth2/yandex\n # golang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a\n golang.org/x/sys/unix\n # golang.org/x/text v0.3.2\n golang.org/x/text/secure/bidirule\n+golang.org/x/text/transform\n golang.org/x/text/unicode/bidi\n golang.org/x/text/unicode/norm\n-golang.org/x/text/transform\n # golang.org/x/time v0.0.0-20190308202827-9d24e82272b4\n golang.org/x/time/rate\n # google.golang.org/appengine v1.6.1\n google.golang.org/appengine\n-google.golang.org/appengine/urlfetch\n google.golang.org/appengine/internal\n google.golang.org/appengine/internal/app_identity\n-google.golang.org/appengine/internal/modules\n-google.golang.org/appengine/internal/urlfetch\n google.golang.org/appengine/internal/base\n google.golang.org/appengine/internal/datastore\n google.golang.org/appengine/internal/log\n+google.golang.org/appengine/internal/modules\n google.golang.org/appengine/internal/remote_api\n+google.golang.org/appengine/internal/urlfetch\n+google.golang.org/appengine/urlfetch\n # gopkg.in/oauth2.v3 v3.10.1\n-gopkg.in/oauth2.v3/server\n gopkg.in/oauth2.v3\n gopkg.in/oauth2.v3/errors\n+gopkg.in/oauth2.v3/server\n # gopkg.in/russross/blackfriday.v2 v2.0.1 => github.com/russross/blackfriday/v2 v2.0.1\n gopkg.in/russross/blackfriday.v2\n # gopkg.in/yaml.v2 v2.2.2"
    }
  ]
}
