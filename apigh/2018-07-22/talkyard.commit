{
  "sha": "e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
  "node_id": "MDY6Q29tbWl0MTA1NjMzMjI6ZTY0ZjI5Y2JjZjRiM2E0OGFlYWY2M2JlYjdkMTgzYjc4ZjczZTVhOQ==",
  "commit": {
    "author": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2018-07-22T02:36:25Z"
    },
    "committer": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2018-07-22T02:48:01Z"
    },
    "message": "Rename some 'transaction' to 'tx'.",
    "tree": {
      "sha": "6f992d6b808eabdd8483e9845e97d9387d3b3b94",
      "url": "https://api.github.com/repos/debiki/talkyard/git/trees/6f992d6b808eabdd8483e9845e97d9387d3b3b94"
    },
    "url": "https://api.github.com/repos/debiki/talkyard/git/commits/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/debiki/talkyard/commits/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
  "html_url": "https://github.com/debiki/talkyard/commit/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
  "comments_url": "https://api.github.com/repos/debiki/talkyard/commits/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/comments",
  "author": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6a29ce1e56539e7ba65a4004b2833cffaacbdfae",
      "url": "https://api.github.com/repos/debiki/talkyard/commits/6a29ce1e56539e7ba65a4004b2833cffaacbdfae",
      "html_url": "https://github.com/debiki/talkyard/commit/6a29ce1e56539e7ba65a4004b2833cffaacbdfae"
    }
  ],
  "stats": {
    "total": 511,
    "additions": 254,
    "deletions": 257
  },
  "files": [
    {
      "sha": "93e9e62c1b445da315349ec44f3eac74bb1b3815",
      "filename": "app/debiki/dao/CategoriesDao.scala",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/debiki/talkyard/blob/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/CategoriesDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/CategoriesDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/CategoriesDao.scala?ref=e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
      "patch": "@@ -421,9 +421,9 @@ trait CategoriesDao {\n \n   def editCategory(editCategoryData: CategoryToSave, permissions: immutable.Seq[PermsOnPages],\n         who: Who): Category = {\n-    val (oldCategory, editedCategory, permissionsChanged) = readWriteTransaction { transaction =>\n+    val (oldCategory, editedCategory, permissionsChanged) = readWriteTransaction { tx =>\n       val categoryId = editCategoryData.anyId getOrDie \"DwE7KPE0\"\n-      val oldCategory = transaction.loadCategory(categoryId).getOrElse(throwNotFound(\n+      val oldCategory = tx.loadCategory(categoryId).getOrElse(throwNotFound(\n         \"DwE5FRA2\", s\"Category not found, id: $categoryId\"))\n       // Currently cannot change parent category because then topic counts will be wrong.\n       // Could just remove all counts, who cares anyway\n@@ -435,15 +435,15 @@ trait CategoriesDao {\n         newTopicTypes = editCategoryData.newTopicTypes,\n         unlisted = editCategoryData.unlisted,\n         includeInSummaries = editCategoryData.includeInSummaries,\n-        updatedAt = transaction.now.toJavaDate)\n+        updatedAt = tx.now.toJavaDate)\n \n       if (editCategoryData.shallBeDefaultCategory) {\n-        setDefaultCategory(editedCategory, transaction)\n+        setDefaultCategory(editedCategory, tx)\n       }\n \n-      transaction.updateCategoryMarkSectionPageStale(editedCategory)\n+      tx.updateCategoryMarkSectionPageStale(editedCategory)\n \n-      val permissionsChanged = addRemovePermsOnCategory(categoryId, permissions)(transaction)._2\n+      val permissionsChanged = addRemovePermsOnCategory(categoryId, permissions)(tx)._2\n       (oldCategory, editedCategory, permissionsChanged)\n       // COULD create audit log entry\n     }\n@@ -476,9 +476,9 @@ trait CategoriesDao {\n \n \n   def createCategoryImpl(newCategoryData: CategoryToSave, permissions: immutable.Seq[PermsOnPages],\n-        byWho: Who)(transaction: SiteTransaction): CreateCategoryResult = {\n+        byWho: Who)(tx: SiteTransaction): CreateCategoryResult = {\n \n-    val categoryId = transaction.nextCategoryId()  // [4GKWSR1]\n+    val categoryId = tx.nextCategoryId()  // [4GKWSR1]\n     newCategoryData.anyId foreach { id =>\n       if (id < 0) {\n         // Fine, this means we're to choose an id here. The requester specifies\n@@ -496,8 +496,8 @@ trait CategoriesDao {\n     // Can remove this later, when I think I won't want to add more cat perms via db migrations.\n     throwForbiddenIf(categoryId > 65, \"EdE7LKG2\", \"Too many categories, > 65\") // see [B0GKWU52]\n \n-    val category = newCategoryData.makeCategory(categoryId, transaction.now.toJavaDate)\n-    transaction.insertCategoryMarkSectionPageStale(category)\n+    val category = newCategoryData.makeCategory(categoryId, tx.now.toJavaDate)\n+    tx.insertCategoryMarkSectionPageStale(category)\n \n     val titleTextAndHtml = newCategoryData.makeAboutTopicTitle(textAndHtmlMaker)\n     val bodyTextAndHtml = newCategoryData.makeAboutTopicBody(textAndHtmlMaker)\n@@ -511,17 +511,17 @@ trait CategoriesDao {\n         bodyHtmlSanitized = bodyTextAndHtml.safeHtml,\n         pinOrder = Some(ForumDao.AboutCategoryTopicPinOrder),\n         pinWhere = Some(PinPageWhere.InCategory),\n-        byWho, spamRelReqStuff = None, transaction)\n+        byWho, spamRelReqStuff = None, tx)\n \n     if (newCategoryData.shallBeDefaultCategory) {\n-      setDefaultCategory(category, transaction)\n+      setDefaultCategory(category, tx)\n     }\n \n     permissions foreach { p =>\n       dieIf(p.onCategoryId != newCategoryData.anyId, \"EdE7UKW02\")\n     }\n     val permsWithCatId = permissions.map(_.copy(onCategoryId = Some(categoryId)))\n-    val permsWithId = addRemovePermsOnCategory(categoryId, permsWithCatId)(transaction)._1\n+    val permsWithId = addRemovePermsOnCategory(categoryId, permsWithCatId)(tx)._1\n \n     // COULD create audit log entry\n \n@@ -530,39 +530,39 @@ trait CategoriesDao {\n \n \n   def deleteUndeleteCategory(categoryId: CategoryId, delete: Boolean, who: Who) {\n-    readWriteTransaction { transaction =>\n-      throwForbiddenIf(!transaction.isAdmin(who.id), \"EdEGEF239S\", \"Not admin\")\n-      val categoryBefore = transaction.loadCategory(categoryId) getOrElse {\n+    readWriteTransaction { tx =>\n+      throwForbiddenIf(!tx.isAdmin(who.id), \"EdEGEF239S\", \"Not admin\")\n+      val categoryBefore = tx.loadCategory(categoryId) getOrElse {\n         throwNotFound(\"EdE5FK8E2\", s\"No category with id $categoryId\")\n       }\n       val categoryAfter = categoryBefore.copy(\n-        deletedAt = if (delete) Some(transaction.now.toJavaDate) else None)\n-      transaction.updateCategoryMarkSectionPageStale(categoryAfter)\n+        deletedAt = if (delete) Some(tx.now.toJavaDate) else None)\n+      tx.updateCategoryMarkSectionPageStale(categoryAfter)\n     }\n     // All pages in the category now needs to be rerendered.\n     COULD_OPTIMIZE // only remove-from-cache / mark-as-dirty pages inside the category.\n     emptyCache()\n   }\n \n \n-  private def setDefaultCategory(category: Category, transaction: SiteTransaction) {\n+  private def setDefaultCategory(category: Category, tx: SiteTransaction) {\n     val rootCategoryId = category.parentId getOrDie \"EsE2PK8O4\"\n-    val rootCategory = transaction.loadCategory(rootCategoryId) getOrDie \"EsE5KG02\"\n+    val rootCategory = tx.loadCategory(rootCategoryId) getOrDie \"EsE5KG02\"\n     if (rootCategory.defaultCategoryId.contains(category.id))\n       return\n     val rootWithNewDefault = rootCategory.copy(defaultCategoryId = Some(category.id))\n     // (The section page will be marked as stale anyway, doesn't matter if we do it here too.)\n-    transaction.updateCategoryMarkSectionPageStale(rootWithNewDefault)\n+    tx.updateCategoryMarkSectionPageStale(rootWithNewDefault)\n   }\n \n \n   private def addRemovePermsOnCategory(categoryId: CategoryId,\n-        permissions: immutable.Seq[PermsOnPages])(transaction: SiteTransaction)\n+        permissions: immutable.Seq[PermsOnPages])(tx: SiteTransaction)\n         : (immutable.Seq[PermsOnPages], Boolean) = {\n     dieIf(permissions.exists(_.onCategoryId.isNot(categoryId)), \"EdE2FK0YU5\")\n     val permsWithIds = ArrayBuffer[PermsOnPages]()\n     val oldPermissionsById: mutable.Map[PermissionId, PermsOnPages] =\n-      transaction.loadPermsOnCategory(categoryId).map(p => (p.id, p))(collection.breakOut)\n+      tx.loadPermsOnCategory(categoryId).map(p => (p.id, p))(collection.breakOut)\n     var wasChangesMade = false\n     permissions foreach { permission =>\n       var alreadyExists = false\n@@ -573,23 +573,23 @@ trait CategoriesDao {\n             wasChangesMade = true\n             if (permission.isEverythingUndefined) {\n               // latent BUG: not incl info about this deleted perm in the fn result [0YKAG25L]\n-              transaction.deletePermsOnPages(Seq(permission.id))\n+              tx.deletePermsOnPages(Seq(permission.id))\n             }\n             else {\n-              transaction.updatePermsOnPages(permission)\n+              tx.updatePermsOnPages(permission)\n               permsWithIds.append(permission)\n             }\n           }\n         }\n       }\n       if (!alreadyExists) {\n         wasChangesMade = true\n-        val permWithId = transaction.insertPermsOnPages(permission)\n+        val permWithId = tx.insertPermsOnPages(permission)\n         permsWithIds.append(permWithId)\n       }\n     }\n     // latent BUG: not incl info about these deleted perms in the fn result [0YKAG25L]\n-    transaction.deletePermsOnPages(oldPermissionsById.keys)\n+    tx.deletePermsOnPages(oldPermissionsById.keys)\n     wasChangesMade ||= oldPermissionsById.nonEmpty\n \n     (permsWithIds.toVector, wasChangesMade)"
    },
    {
      "sha": "d9b58e4ab09c22a682fc4ff3ca7487f7dee9d901",
      "filename": "app/debiki/dao/ForumDao.scala",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/debiki/talkyard/blob/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/ForumDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/ForumDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/ForumDao.scala?ref=e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
      "patch": "@@ -64,25 +64,25 @@ trait ForumDao {\n     val titleHtmlSanitized = context.nashorn.sanitizeHtml(options.title, followLinks = false)\n     val isForEmbCmts = options.isForEmbeddedComments\n \n-    val result = readWriteTransaction { transaction =>\n+    val result = readWriteTransaction { tx =>\n \n       // The forum page points to the root category, which points back.\n-      transaction.deferConstraints()\n-      val creator = transaction.loadTheMember(byWho.id)\n+      tx.deferConstraints()\n+      val creator = tx.loadTheMember(byWho.id)\n \n       AuditDao.insertAuditLogEntry(AuditLogEntry(\n         siteId,\n         id = AuditLogEntry.UnassignedId,\n         didWhat = AuditLogEntryType.CreateForum,\n         doerId = byWho.id,\n-        doneAt = transaction.now.toJavaDate,\n+        doneAt = tx.now.toJavaDate,\n         // Incl email, so will remember forever the created-by-email, even if the user\n         // changes hens email later.\n         emailAddress = creator.email.trimNoneIfEmpty,\n         browserIdData = byWho.browserIdData,\n-        browserLocation = None), transaction)\n+        browserLocation = None), tx)\n \n-      val rootCategoryId = transaction.nextCategoryId()\n+      val rootCategoryId = tx.nextCategoryId()\n \n       // Create forum page.\n       val introText = isForEmbCmts ? EmbeddedCommentsIntroText | ForumIntroText\n@@ -92,12 +92,12 @@ trait ForumDao {\n         titleSource = options.title, titleHtmlSanitized = titleHtmlSanitized,\n         bodySource = introText.source, bodyHtmlSanitized = introText.html,\n         pinOrder = None, pinWhere = None,\n-        byWho, spamRelReqStuff = None, transaction, layout = Some(options.topicListStyle))\n+        byWho, spamRelReqStuff = None, tx, layout = Some(options.topicListStyle))\n \n       val forumPageId = forumPagePath.pageId getOrDie \"DwE5KPFW2\"\n \n       val partialResult: CreateForumResult = createDefaultCategoriesAndTopics(\n-        forumPageId, rootCategoryId, isForEmbCmts = isForEmbCmts, options, byWho, transaction)\n+        forumPageId, rootCategoryId, isForEmbCmts = isForEmbCmts, options, byWho, tx)\n \n       val settings =\n         if (isForEmbCmts) {\n@@ -113,7 +113,7 @@ trait ForumDao {\n         }\n         else None\n \n-      settings.foreach(transaction.upsertSiteSettings)\n+      settings.foreach(tx.upsertSiteSettings)\n \n       partialResult.copy(pagePath = forumPagePath)\n     }\n@@ -126,15 +126,15 @@ trait ForumDao {\n \n \n   private def createDefaultCategoriesAndTopics(forumPageId: PageId, rootCategoryId: CategoryId,\n-        isForEmbCmts: Boolean, options: CreateForumOptions, byWho: Who, transaction: SiteTransaction)\n+        isForEmbCmts: Boolean, options: CreateForumOptions, byWho: Who, tx: SiteTransaction)\n         : CreateForumResult = {\n \n     val staffCategoryId = rootCategoryId + 1\n     val defaultCategoryId = rootCategoryId + 2\n     val bySystem = Who(SystemUserId, byWho.browserIdData)\n \n     // Create forum root category.\n-    transaction.insertCategoryMarkSectionPageStale(Category(\n+    tx.insertCategoryMarkSectionPageStale(Category(\n       id = rootCategoryId,\n       sectionPageId = forumPageId,\n       parentId = None,\n@@ -146,8 +146,8 @@ trait ForumDao {\n       newTopicTypes = Nil,\n       unlisted = false,\n       includeInSummaries = IncludeInSummaries.Default,\n-      createdAt = transaction.now.toJavaDate,\n-      updatedAt = transaction.now.toJavaDate))\n+      createdAt = tx.now.toJavaDate,\n+      updatedAt = tx.now.toJavaDate))\n \n     // Create the Staff category.\n     createCategoryImpl(\n@@ -165,14 +165,14 @@ trait ForumDao {\n         includeInSummaries = IncludeInSummaries.Default),\n       immutable.Seq[PermsOnPages](\n         makeStaffCategoryPerms(staffCategoryId)),\n-      bySystem)(transaction)\n+      bySystem)(tx)\n \n     if (options.isForEmbeddedComments)\n       createEmbeddedCommentsCategory(forumPageId, rootCategoryId, defaultCategoryId,\n-        staffCategoryId, options, bySystem, transaction)\n+        staffCategoryId, options, bySystem, tx)\n     else\n       createForumCategories(forumPageId, rootCategoryId, defaultCategoryId,\n-        staffCategoryId, options, bySystem, transaction)\n+        staffCategoryId, options, bySystem, tx)\n   }\n \n \n@@ -211,7 +211,7 @@ trait ForumDao {\n   private def createForumCategories(\n     forumPageId: PageId, rootCategoryId: CategoryId, defaultCategoryId: CategoryId,\n     staffCategoryId: CategoryId, options: CreateForumOptions,\n-    bySystem: Who, transaction: SiteTransaction): CreateForumResult = {\n+    bySystem: Who, tx: SiteTransaction): CreateForumResult = {\n \n     dieIf(options.isForEmbeddedComments, \"TyE2PKQ9\")\n \n@@ -244,7 +244,7 @@ trait ForumDao {\n         immutable.Seq[PermsOnPages](\n           makeEveryonesDefaultCategoryPerms(categoryId),\n           makeStaffCategoryPerms(categoryId)),\n-        bySystem)(transaction)\n+        bySystem)(tx)\n     }\n \n     if (options.createIdeasCategory) {\n@@ -266,7 +266,7 @@ trait ForumDao {\n         immutable.Seq[PermsOnPages](\n           makeEveryonesDefaultCategoryPerms(categoryId),\n           makeStaffCategoryPerms(categoryId)),\n-        bySystem)(transaction)\n+        bySystem)(tx)\n     }\n \n     // Create the Uncategorized category.\n@@ -287,7 +287,7 @@ trait ForumDao {\n         immutable.Seq[PermsOnPages](\n           makeEveryonesDefaultCategoryPerms(uncategorizedCategoryId),\n           makeStaffCategoryPerms(uncategorizedCategoryId)),\n-        bySystem)(transaction)\n+        bySystem)(tx)\n \n     // Create forum welcome topic.\n     createPageImpl(\n@@ -302,7 +302,7 @@ trait ForumDao {\n       pinWhere = Some(PinPageWhere.Globally),\n       bySystem,\n       spamRelReqStuff = None,\n-      transaction)\n+      tx)\n \n     // Create staff chat\n     createPageImpl(\n@@ -317,7 +317,7 @@ trait ForumDao {\n       pinWhere = None,\n       bySystem,\n       spamRelReqStuff = None,\n-      transaction)\n+      tx)\n \n     // Create example threaded discussion.\n     if (options.createSampleTopics) createPageImpl(\n@@ -332,7 +332,7 @@ trait ForumDao {\n       pinWhere = None,\n       bySystem,\n       spamRelReqStuff = None,\n-      transaction)\n+      tx)\n \n     // Create example problem.\n     if (options.createSampleTopics) createPageImpl(\n@@ -347,7 +347,7 @@ trait ForumDao {\n       pinWhere = None,\n       bySystem,\n       spamRelReqStuff = None,\n-      transaction)\n+      tx)\n \n     // Create example question.\n     if (options.createSampleTopics) {\n@@ -363,10 +363,10 @@ trait ForumDao {\n         pinWhere = None,\n         bySystem,\n         spamRelReqStuff = None,\n-        transaction)._1\n+        tx)._1\n       insertReplyImpl(textAndHtmlMaker.wrapInParagraphNoMentionsOrLinks(SampleAnswerText, isTitle = false),\n         questionPagePath.thePageId, replyToPostNrs = Set(PageParts.BodyNr), PostType.Normal,\n-        bySystem, SystemSpamStuff, globals.now(), SystemUserId, transaction, skipNotifications = true)\n+        bySystem, SystemSpamStuff, globals.now(), SystemUserId, tx, skipNotifications = true)\n     }\n \n     // Create example idea.\n@@ -383,7 +383,7 @@ trait ForumDao {\n       pinWhere = None,\n       bySystem,\n       spamRelReqStuff = None,\n-      transaction)\n+      tx)\n \n     CreateForumResult(null, defaultCategoryId = defaultCategoryId,\n       staffCategoryId = staffCategoryId)"
    },
    {
      "sha": "dc7e09692567888df03dacc089304c5042aa138a",
      "filename": "app/debiki/dao/MessagesDao.scala",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/debiki/talkyard/blob/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/MessagesDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/MessagesDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/MessagesDao.scala?ref=e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
      "patch": "@@ -55,25 +55,25 @@ trait MessagesDao {\n \n     quickCheckIfSpamThenThrow(sentByWho, body, spamRelReqStuff)\n \n-    val (pagePath, notfs) = readWriteTransaction { transaction =>\n-      val sender = loadUserAndLevels(sentByWho, transaction)\n+    val (pagePath, notfs) = readWriteTransaction { tx =>\n+      val sender = loadUserAndLevels(sentByWho, tx)\n \n       // 1) Don't let unpolite users start private-messaging other well behaved users.\n       // But do let them talk with staff, e.g. ask \"why am I not allowed to ...\".\n       // 2) TrustLevle.New members haven't spent much time at the site, and it's a bit risky to\n       // let them start sending PMs directly.\n       if ((sender.threatLevel.toInt >= ThreatLevel.ModerateThreat.toInt ||\n           sender.trustLevel == TrustLevel.NewMember) && !sender.isStaff) {\n-        val toUsers = transaction.loadUsers(toUserIds)\n+        val toUsers = tx.loadUsers(toUserIds)\n         if (toUsers.exists(!_.isStaff))\n           throwForbidden(\"EsE8GY2F4_\", \"You may send direct messages to staff only\")\n       }\n \n       val (pagePath, bodyPost) = createPageImpl2(pageRole, title, body,\n-        byWho = sentByWho, spamRelReqStuff = Some(spamRelReqStuff), transaction = transaction)\n+        byWho = sentByWho, spamRelReqStuff = Some(spamRelReqStuff), tx = tx)\n \n       (toUserIds + sentById) foreach { userId =>\n-        transaction.insertMessageMember(pagePath.pageId.getOrDie(\"EsE6JMUY2\"), userId,\n+        tx.insertMessageMember(pagePath.pageId.getOrDie(\"EsE6JMUY2\"), userId,\n           addedById = sentById)\n       }\n \n@@ -83,11 +83,11 @@ trait MessagesDao {\n           Notifications.None\n         }\n         else {\n-          NotificationGenerator(transaction, context.nashorn).generateForMessage(\n+          NotificationGenerator(tx, context.nashorn).generateForMessage(\n             sender.user, bodyPost, toUserIds)\n         }\n \n-      transaction.saveDeleteNotifications(notifications)\n+      tx.saveDeleteNotifications(notifications)\n       (pagePath, notifications)\n     }\n "
    },
    {
      "sha": "c23b6b5cc03fb74a28de61927e74fc5c1fed6de7",
      "filename": "app/debiki/dao/PagesDao.scala",
      "status": "modified",
      "additions": 48,
      "deletions": 48,
      "changes": 96,
      "blob_url": "https://github.com/debiki/talkyard/blob/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/PagesDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/PagesDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/PagesDao.scala?ref=e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
      "patch": "@@ -113,13 +113,13 @@ trait PagesDao {\n         anyFolder: Option[String] = None, anySlug: Option[String] = None, showId: Boolean = true,\n         pinOrder: Option[Int] = None, pinWhere: Option[PinPageWhere] = None,\n         byWho: Who, spamRelReqStuff: Option[SpamRelReqStuff],\n-        transaction: SiteTransaction): (PagePath, Post) =\n+        tx: SiteTransaction): (PagePath, Post) =\n     createPageImpl(pageRole, pageStatus, anyCategoryId = anyCategoryId,\n       anyFolder = anyFolder, anySlug = anySlug, showId = showId,\n       titleSource = title.text, titleHtmlSanitized = title.safeHtml,\n       bodySource = body.text, bodyHtmlSanitized = body.safeHtml,\n       pinOrder = pinOrder, pinWhere = pinWhere,\n-      byWho, spamRelReqStuff, transaction = transaction, layout = None)\n+      byWho, spamRelReqStuff, tx = tx, layout = None)\n \n \n   def createPageImpl(pageRole: PageRole, pageStatus: PageStatus,\n@@ -129,18 +129,18 @@ trait PagesDao {\n       bodySource: String, bodyHtmlSanitized: String,\n       pinOrder: Option[Int], pinWhere: Option[PinPageWhere],\n       byWho: Who, spamRelReqStuff: Option[SpamRelReqStuff],\n-      transaction: SiteTransaction, hidePageBody: Boolean = false,\n+      tx: SiteTransaction, hidePageBody: Boolean = false,\n       layout: Option[TopicListLayout] = None,\n       bodyPostType: PostType = PostType.Normal,\n       altPageId: Option[AltPageId] = None, embeddingUrl: Option[String] = None): (PagePath, Post) = {\n \n     val now = globals.now()\n     val authorId = byWho.id\n-    val authorAndLevels = loadUserAndLevels(byWho, transaction)\n+    val authorAndLevels = loadUserAndLevels(byWho, tx)\n     val author = authorAndLevels.user\n-    val categoryPath = transaction.loadCategoryPathRootLast(anyCategoryId)\n-    val groupIds = transaction.loadGroupIds(author)\n-    val permissions = transaction.loadPermsOnPages()\n+    val categoryPath = tx.loadCategoryPathRootLast(anyCategoryId)\n+    val groupIds = tx.loadGroupIds(author)\n+    val permissions = tx.loadPermsOnPages()\n     val authzCtx = ForumAuthzContext(Some(author), groupIds, permissions)\n \n     dieOrThrowNoUnless(Authz.mayCreatePage(  // REFACTOR COULD pass a pageAuthzCtx instead [5FLK02]\n@@ -161,7 +161,7 @@ trait PagesDao {\n \n     COULD // try to move this authz + review-reason check to ed.server.auth.Authz?\n     val (reviewReasons: Seq[ReviewReason], shallApprove) =\n-      throwOrFindReviewNewPageReasons(authorAndLevels, pageRole, transaction)\n+      throwOrFindReviewNewPageReasons(authorAndLevels, pageRole, tx)\n \n     val approvedById =\n       if (author.isStaff) {\n@@ -177,13 +177,13 @@ trait PagesDao {\n       val categoryId = anyCategoryId getOrElse {\n         throwForbidden(\"DwE4KFE0\", s\"Pages type $pageRole needs a root category id\")\n       }\n-      if (transaction.loadCategory(categoryId).isDefined) {\n+      if (tx.loadCategory(categoryId).isDefined) {\n         throwForbidden(\"DwE5KPW2\", s\"Category already exists, id: $categoryId\")\n       }\n     }\n     else {\n       anyCategoryId foreach { categoryId =>\n-        val category = transaction.loadCategory(categoryId) getOrElse throwNotFound(\n+        val category = tx.loadCategory(categoryId) getOrElse throwNotFound(\n           \"DwE4KGP8\", s\"Category not found, id: $categoryId\")\n         def whichCategory = s\"The '${category.name}' category\"\n         if (category.isRoot)\n@@ -201,12 +201,12 @@ trait PagesDao {\n     val folder = anyFolder getOrElse \"/\"\n     SECURITY // Maybe page id shouldn't be public? [rand-page-id] To prevent people from\n     // discovering all pages. E.g. iterating through all discussions, in a public blog.\n-    val pageId = transaction.nextPageId()\n-    val siteId = transaction.siteId // [5GKEPMW2] remove this row later\n+    val pageId = tx.nextPageId()\n+    val siteId = tx.siteId // [5GKEPMW2] remove this row later\n     val pagePath = PagePath(siteId, folder = folder, pageId = Some(pageId),\n       showId = showId, pageSlug = pageSlug)\n \n-    val titleUniqueId = transaction.nextPostId()\n+    val titleUniqueId = tx.nextPostId()\n     val bodyUniqueId = titleUniqueId + 1\n \n     val titlePost = Post.createTitle(\n@@ -243,7 +243,7 @@ trait PagesDao {\n \n     val reviewTask = if (reviewReasons.isEmpty) None\n     else Some(ReviewTask(\n-      id = transaction.nextReviewTaskId(),\n+      id = tx.nextReviewTaskId(),\n       reasons = reviewReasons.to[immutable.Seq],\n       createdById = SystemUserId,\n       createdAt = now.toJavaDate,\n@@ -273,36 +273,36 @@ trait PagesDao {\n       numDiscourseTopicsCreated = pageRole.isChat ? 0 | 1,\n       numChatTopicsCreated = pageRole.isChat ? 1 | 0)\n \n-    addUserStats(stats)(transaction)\n-    transaction.insertPageMetaMarkSectionPageStale(pageMeta)\n-    transaction.insertPagePath(pagePath)\n-    transaction.insertPost(titlePost)\n-    transaction.insertPost(bodyPost)\n+    addUserStats(stats)(tx)\n+    tx.insertPageMetaMarkSectionPageStale(pageMeta)\n+    tx.insertPagePath(pagePath)\n+    tx.insertPost(titlePost)\n+    tx.insertPost(bodyPost)\n     // By default, one follows all activity on a page one has created â€” unless this is some page\n     // that gets auto created by System. [EXCLSYS]\n     if (author.id != SystemUserId) {\n-      transaction.saveUserPageSettings(\n+      tx.saveUserPageSettings(\n         authorId, pageId = pageId, UserPageSettings(NotfLevel.WatchingAll))\n     }\n     if (approvedById.isDefined) {\n-      updatePagePopularity(PreLoadedPageParts(pageId, Vector(titlePost, bodyPost)), transaction)\n+      updatePagePopularity(PreLoadedPageParts(pageId, Vector(titlePost, bodyPost)), tx)\n     }\n     uploadPaths foreach { hashPathSuffix =>\n-      transaction.insertUploadedFileReference(bodyPost.id, hashPathSuffix, authorId)\n+      tx.insertUploadedFileReference(bodyPost.id, hashPathSuffix, authorId)\n     }\n \n-    altPageId.foreach(transaction.insertAltPageId(_, realPageId = pageId))\n+    altPageId.foreach(tx.insertAltPageId(_, realPageId = pageId))\n     if (altPageId != embeddingUrl) {\n       // If the url already points to another embedded discussion, keep it pointing to the old one.\n       // Then, seems like lower risk for some hijack-a-discussion-by-forging-the-url security issue.\n-      embeddingUrl.foreach(transaction.insertAltPageIdIfFree(_, realPageId = pageId))\n+      embeddingUrl.foreach(tx.insertAltPageIdIfFree(_, realPageId = pageId))\n     }\n \n-    reviewTask.foreach(transaction.upsertReviewTask)\n-    insertAuditLogEntry(auditLogEntry, transaction)\n+    reviewTask.foreach(tx.upsertReviewTask)\n+    insertAuditLogEntry(auditLogEntry, tx)\n \n-    transaction.indexPostsSoon(titlePost, bodyPost)\n-    spamRelReqStuff.foreach(transaction.spamCheckPostsSoon(byWho, _, titlePost, bodyPost))\n+    tx.indexPostsSoon(titlePost, bodyPost)\n+    spamRelReqStuff.foreach(tx.spamCheckPostsSoon(byWho, _, titlePost, bodyPost))\n \n     // Don't start rendering html for this page in the background. [5KWC58]\n     // (Instead, when the user requests the page, we'll render it directly in\n@@ -315,8 +315,8 @@ trait PagesDao {\n \n \n   def throwOrFindReviewNewPageReasons(author: UserAndLevels, pageRole: PageRole,\n-        transaction: SiteTransaction): (Seq[ReviewReason], Boolean) = {\n-    throwOrFindReviewReasonsImpl(author, pageMeta = None, newPageRole = Some(pageRole), transaction)\n+        tx: SiteTransaction): (Seq[ReviewReason], Boolean) = {\n+    throwOrFindReviewReasonsImpl(author, pageMeta = None, newPageRole = Some(pageRole), tx)\n   }\n \n \n@@ -362,16 +362,16 @@ trait PagesDao {\n \n   def ifAuthAcceptAnswer(pageId: PageId, postUniqueId: PostId, userId: UserId,\n         browserIdData: BrowserIdData): Option[ju.Date] = {\n-    val answeredAt = readWriteTransaction { transaction =>\n-      val user = transaction.loadTheUser(userId)\n-      val oldMeta = transaction.loadThePageMeta(pageId)\n+    val answeredAt = readWriteTransaction { tx =>\n+      val user = tx.loadTheUser(userId)\n+      val oldMeta = tx.loadThePageMeta(pageId)\n       if (oldMeta.pageRole != PageRole.Question)\n         throwBadReq(\"DwE4KGP2\", \"This page is not a question so no answer can be selected\")\n \n       if (!user.isStaff && user.id != oldMeta.authorId)\n         throwForbidden(\"DwE8JGY3\", \"Only staff and the topic author can accept an answer\")\n \n-      val post = transaction.loadThePost(postUniqueId)\n+      val post = tx.loadThePost(postUniqueId)\n       throwBadRequestIf(post.isDeleted, \"TyE4BQR20\", \"That post has been deleted, cannot mark as answer\")\n       throwBadRequestIf(post.pageId != pageId,\n           \"DwE5G2Y2\", \"That post is placed on another page, page id: \" + post.pageId)\n@@ -382,13 +382,13 @@ trait PagesDao {\n       if (oldMeta.closedAt.isDefined)\n         throwBadReq(\"DwE0PG26\", \"This question is closed, therefore no answer can be accepted\")\n \n-      val answeredAt = Some(transaction.now.toJavaDate)\n+      val answeredAt = Some(tx.now.toJavaDate)\n       val newMeta = oldMeta.copy(\n         answeredAt = answeredAt,\n         answerPostUniqueId = Some(postUniqueId),\n         closedAt = answeredAt,\n         version = oldMeta.version + 1)\n-      transaction.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n+      tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n       // (COULD update audit log)\n       // (COULD wait 5 minutes (in case the answer gets un-accepted) then send email\n       // to the author of the answer)\n@@ -400,17 +400,17 @@ trait PagesDao {\n \n \n   def ifAuthUnacceptAnswer(pageId: PageId, userId: UserId, browserIdData: BrowserIdData) {\n-    readWriteTransaction { transaction =>\n-      val user = transaction.loadTheUser(userId)\n-      val oldMeta = transaction.loadThePageMeta(pageId)\n+    readWriteTransaction { tx =>\n+      val user = tx.loadTheUser(userId)\n+      val oldMeta = tx.loadThePageMeta(pageId)\n       if (!user.isStaff && user.id != oldMeta.authorId)\n         throwForbidden(\"DwE2GKU4\", \"Only staff and the topic author can unaccept the answer\")\n \n       // Dupl line. [4UKP58B]\n       val newMeta = oldMeta.copy(answeredAt = None, answerPostUniqueId = None, closedAt = None,\n         version = oldMeta.version + 1)\n \n-      transaction.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n+      tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n       // (COULD update audit log)\n     }\n     refreshPageInMemCache(pageId)\n@@ -422,9 +422,9 @@ trait PagesDao {\n   def cyclePageDoneIfAuth(pageId: PageId, userId: UserId, browserIdData: BrowserIdData)\n         : PageMeta = {\n     val now = globals.now()\n-    val newMeta = readWriteTransaction { transaction =>\n-      val user = transaction.loadTheUser(userId)\n-      val oldMeta = transaction.loadThePageMeta(pageId)\n+    val newMeta = readWriteTransaction { tx =>\n+      val user = tx.loadTheUser(userId)\n+      val oldMeta = tx.loadThePageMeta(pageId)\n       if (!user.isStaff && user.id != oldMeta.authorId)\n         throwForbidden(\"EsE4YK0W2\", \"Only the page author and staff may change the page status\")\n \n@@ -477,9 +477,9 @@ trait PagesDao {\n         numPostsTotal = oldMeta.numPostsTotal + 1,\n         version = oldMeta.version + 1)\n \n-      transaction.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n+      tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n       // Update audit log\n-      addMetaMessage(user, s\" marked this topic as $newStatus\", pageId, transaction)\n+      addMetaMessage(user, s\" marked this topic as $newStatus\", pageId, tx)\n \n       newMeta\n     }\n@@ -640,8 +640,8 @@ trait PagesDao {\n \n \n   def refreshPageMetaBumpVersion(pageId: PageId, markSectionPageStale: Boolean,\n-        transaction: SiteTransaction) {\n-    val page = PageDao(pageId, transaction)\n+        tx: SiteTransaction) {\n+    val page = PageDao(pageId, tx)\n     val newMeta = page.meta.copy(\n       lastReplyAt = page.parts.lastVisibleReply.map(_.createdAt),\n       lastReplyById = page.parts.lastVisibleReply.map(_.createdById),\n@@ -661,7 +661,7 @@ trait PagesDao {\n       answeredAt = page.anyAnswerPost.map(_.createdAt),\n       answerPostUniqueId = page.anyAnswerPost.map(_.id),\n       version = page.version + 1)\n-    transaction.updatePageMeta(newMeta, oldMeta = page.meta,\n+    tx.updatePageMeta(newMeta, oldMeta = page.meta,\n       markSectionPageStale = markSectionPageStale)\n   }\n }"
    },
    {
      "sha": "d59e3cd91d998793d33f180c947043b8b1ec1ec9",
      "filename": "app/debiki/dao/PostsDao.scala",
      "status": "modified",
      "additions": 145,
      "deletions": 148,
      "changes": 293,
      "blob_url": "https://github.com/debiki/talkyard/blob/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/PostsDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9/app/debiki/dao/PostsDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/PostsDao.scala?ref=e64f29cbcf4b3a48aeaf63beb7d183b78f73e5a9",
      "patch": "@@ -97,26 +97,26 @@ trait PostsDao {\n \n   def insertReplyImpl(textAndHtml: TextAndHtml, pageId: PageId, replyToPostNrs: Set[PostNr],\n         postType: PostType, byWho: Who, spamRelReqStuff: SpamRelReqStuff,\n-        now: When, authorId: UserId, transaction: SiteTransaction, skipNotifications: Boolean = false)\n+        now: When, authorId: UserId, tx: SiteTransaction, skipNotifications: Boolean = false)\n         : (Post, User, Notifications, Option[ReviewTask]) = {\n \n-    val authorAndLevels = loadUserAndLevels(byWho, transaction)\n+    val authorAndLevels = loadUserAndLevels(byWho, tx)\n     val author = authorAndLevels.user\n-    val page = PageDao(pageId, transaction)\n+    val page = PageDao(pageId, tx)\n     val replyToPosts = page.parts.getPostsAllOrError(replyToPostNrs) getOrIfBad  { missingPostNr =>\n       throwNotFound(s\"Post nr $missingPostNr not found\", \"EdE4JK2RJ\")\n     }\n \n-    dieOrThrowNoUnless(Authz.mayPostReply(authorAndLevels, transaction.loadGroupIds(author),\n-      postType, page.meta, replyToPosts, transaction.loadAnyPrivateGroupTalkMembers(page.meta),\n-      transaction.loadCategoryPathRootLast(page.meta.categoryId),\n-      transaction.loadPermsOnPages()), \"EdEMAY0RE\")\n+    dieOrThrowNoUnless(Authz.mayPostReply(authorAndLevels, tx.loadGroupIds(author),\n+      postType, page.meta, replyToPosts, tx.loadAnyPrivateGroupTalkMembers(page.meta),\n+      tx.loadCategoryPathRootLast(page.meta.categoryId),\n+      tx.loadPermsOnPages()), \"EdEMAY0RE\")\n \n     if (page.role.isChat)\n       throwForbidden(\"EsE50WG4\", s\"Page '${page.id}' is a chat page; cannot post normal replies\")\n \n     // Some dupl code [3GTKYA02]\n-    val uniqueId = transaction.nextPostId()\n+    val uniqueId = tx.nextPostId()\n     val postNr = page.parts.highestReplyNr.map(_ + 1).map(max(FirstReplyNr, _)) getOrElse FirstReplyNr\n     val commonAncestorNr = page.parts.findCommonAncestorNr(replyToPostNrs.toSeq)\n     val anyParent =\n@@ -143,7 +143,7 @@ trait PostsDao {\n         \"The parent post has been deleted; cannot reply to a deleted post\", \"DwE5KDE7\")\n \n     val (reviewReasons: Seq[ReviewReason], shallApprove) =\n-      throwOrFindReviewPostReasons(page.meta, authorAndLevels, transaction)\n+      throwOrFindReviewPostReasons(page.meta, authorAndLevels, tx)\n \n     val approverId =\n       if (author.isStaff) {\n@@ -206,7 +206,7 @@ trait PostsDao {\n \n     val anyReviewTask = if (reviewReasons.isEmpty) None\n     else Some(ReviewTask(\n-      id = transaction.nextReviewTaskId(),\n+      id = tx.nextReviewTaskId(),\n       reasons = reviewReasons.to[immutable.Seq],\n       createdById = SystemUserId,\n       createdAt = now.toJavaDate,\n@@ -223,26 +223,26 @@ trait PostsDao {\n       numDiscourseRepliesPosted = 1,\n       numDiscourseTopicsRepliedIn = 0) // SHOULD update properly\n \n-    addUserStats(stats)(transaction)\n-    transaction.insertPost(newPost)\n-    transaction.indexPostsSoon(newPost)\n-    transaction.spamCheckPostsSoon(byWho, spamRelReqStuff, newPost)\n-    transaction.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = shallApprove)\n+    addUserStats(stats)(tx)\n+    tx.insertPost(newPost)\n+    tx.indexPostsSoon(newPost)\n+    tx.spamCheckPostsSoon(byWho, spamRelReqStuff, newPost)\n+    tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = shallApprove)\n     if (shallApprove) {\n       val pagePartsInclNewPost = PreLoadedPageParts(pageId, page.parts.allPosts :+ newPost)\n-      updatePagePopularity(pagePartsInclNewPost, transaction)\n+      updatePagePopularity(pagePartsInclNewPost, tx)\n     }\n     uploadRefs foreach { uploadRef =>\n-      transaction.insertUploadedFileReference(newPost.id, uploadRef, authorId)\n+      tx.insertUploadedFileReference(newPost.id, uploadRef, authorId)\n     }\n-    insertAuditLogEntry(auditLogEntry, transaction)\n-    anyReviewTask.foreach(transaction.upsertReviewTask)\n+    insertAuditLogEntry(auditLogEntry, tx)\n+    anyReviewTask.foreach(tx.upsertReviewTask)\n \n     val notifications =\n       if (skipNotifications) Notifications.None\n-      else NotificationGenerator(transaction, nashorn).generateForNewPost(\n+      else NotificationGenerator(tx, nashorn).generateForNewPost(\n         page, newPost, Some(textAndHtml))\n-    transaction.saveDeleteNotifications(notifications)\n+    tx.saveDeleteNotifications(notifications)\n \n     (newPost, author, notifications, anyReviewTask)\n   }\n@@ -251,13 +251,13 @@ trait PostsDao {\n   /** Returns (review-reasons, shall-approve).\n     */\n   def throwOrFindReviewPostReasons(pageMeta: PageMeta, author: UserAndLevels,\n-        transaction: SiteTransaction): (Seq[ReviewReason], Boolean) = {\n-    throwOrFindReviewReasonsImpl(author, Some(pageMeta), newPageRole = None, transaction)\n+        tx: SiteTransaction): (Seq[ReviewReason], Boolean) = {\n+    throwOrFindReviewReasonsImpl(author, Some(pageMeta), newPageRole = None, tx)\n   }\n \n \n   def throwOrFindReviewReasonsImpl(author: UserAndLevels, pageMeta: Option[PageMeta],\n-        newPageRole: Option[PageRole], transaction: SiteTransaction)\n+        newPageRole: Option[PageRole], tx: SiteTransaction)\n         : (Seq[ReviewReason], Boolean) = {\n     if (author.isStaff)\n       return (Nil, true)\n@@ -299,7 +299,7 @@ trait PostsDao {\n       // to the page members, so we don't know if they are staff.\n       // Later: auto bump threat level to ModerateThreat, then MessagesDao will do all this\n       // automatically.\n-      val tasks = transaction.loadReviewTasksAboutUser(author.id, limit = MaxNumFirstPosts,\n+      val tasks = tx.loadReviewTasksAboutUser(author.id, limit = MaxNumFirstPosts,\n         OrderBy.MostRecentFirst)\n       val numLoaded = tasks.length\n       val numPending = tasks.count(_.decision.isEmpty)\n@@ -311,7 +311,7 @@ trait PostsDao {\n       return (Nil, true)\n     }\n \n-    val settings = loadWholeSiteSettings(transaction)\n+    val settings = loadWholeSiteSettings(tx)\n     val numFirstToAllow = math.min(MaxNumFirstPosts, settings.numFirstPostsToAllow)\n     val numFirstToApprove = math.min(MaxNumFirstPosts, settings.numFirstPostsToApprove)\n     var numFirstToNotify = math.min(MaxNumFirstPosts, settings.numFirstPostsToReview)\n@@ -323,7 +323,7 @@ trait PostsDao {\n     }\n \n     if ((numFirstToAllow > 0 && numFirstToApprove > 0) || numFirstToNotify > 0) {\n-      val tasks = transaction.loadReviewTasksAboutUser(author.id, limit = MaxNumFirstPosts,\n+      val tasks = tx.loadReviewTasksAboutUser(author.id, limit = MaxNumFirstPosts,\n         OrderBy.OldestFirst)\n       val numApproved = tasks.count(_.decision.exists(_.isFine))\n       val numLoaded = tasks.length\n@@ -367,26 +367,26 @@ trait PostsDao {\n \n     quickCheckIfSpamThenThrow(byWho, textAndHtml, spamRelReqStuff)\n \n-    val (post, author, notifications) = readWriteTransaction { transaction =>\n-      val authorAndLevels = loadUserAndLevels(byWho, transaction)\n+    val (post, author, notifications) = readWriteTransaction { tx =>\n+      val authorAndLevels = loadUserAndLevels(byWho, tx)\n       val author = authorAndLevels.user\n \n       SHOULD_OPTIMIZE // don't load all posts [2GKF0S6], because this is a chat, could be too many.\n-      val page = PageDao(pageId, transaction)\n+      val page = PageDao(pageId, tx)\n       val replyToPosts = Nil // currently cannot reply to specific posts, in the chat. [7YKDW3]\n \n-      dieOrThrowNoUnless(Authz.mayPostReply(authorAndLevels, transaction.loadGroupIds(author),\n-        PostType.ChatMessage, page.meta, Nil, transaction.loadAnyPrivateGroupTalkMembers(page.meta),\n-        transaction.loadCategoryPathRootLast(page.meta.categoryId),\n-        transaction.loadPermsOnPages()), \"EdEMAY0CHAT\")\n+      dieOrThrowNoUnless(Authz.mayPostReply(authorAndLevels, tx.loadGroupIds(author),\n+        PostType.ChatMessage, page.meta, Nil, tx.loadAnyPrivateGroupTalkMembers(page.meta),\n+        tx.loadCategoryPathRootLast(page.meta.categoryId),\n+        tx.loadPermsOnPages()), \"EdEMAY0CHAT\")\n \n       val (reviewReasons: Seq[ReviewReason], _) =\n-        throwOrFindReviewPostReasons(page.meta, authorAndLevels, transaction)\n+        throwOrFindReviewPostReasons(page.meta, authorAndLevels, tx)\n \n       if (!page.role.isChat)\n         throwForbidden(\"EsE5F0WJ2\", s\"Page $pageId is not a chat page; cannot insert chat message\")\n \n-      val pageMemberIds = transaction.loadMessageMembers(pageId)\n+      val pageMemberIds = tx.loadMessageMembers(pageId)\n       if (!pageMemberIds.contains(authorId))\n         throwForbidden(\"EsE4UGY7\", \"You are not a member of this chat channel\")\n \n@@ -396,28 +396,28 @@ trait PostsDao {\n       val anyLastMessage = page.parts.lastPostButNotOrigPost\n       val anyLastMessageSameUserRecently = anyLastMessage filter { post =>\n         post.createdById == authorId &&\n-          transaction.now.millis - post.createdAt.getTime < LastChatMessageRecentMs\n+          tx.now.millis - post.createdAt.getTime < LastChatMessageRecentMs\n       }\n \n       val (post, notfs) = anyLastMessageSameUserRecently match {\n         case Some(lastMessage) if !lastMessage.isDeleted && lastMessage.tyype == PostType.ChatMessage =>\n-          appendToLastChatMessage(lastMessage, textAndHtml, byWho, spamRelReqStuff, transaction)\n+          appendToLastChatMessage(lastMessage, textAndHtml, byWho, spamRelReqStuff, tx)\n         case _ =>\n           val (post, notfs) =\n-            createNewChatMessage(page, textAndHtml, byWho, spamRelReqStuff, transaction)\n+            createNewChatMessage(page, textAndHtml, byWho, spamRelReqStuff, tx)\n           // For now, let's create review tasks only for new messages, but not when appending\n           // to the prev message. Should work well enough + won't be too many review tasks.\n           val anyReviewTask = if (reviewReasons.isEmpty) None\n           else Some(ReviewTask(\n-            id = transaction.nextReviewTaskId(),\n+            id = tx.nextReviewTaskId(),\n             reasons = reviewReasons.to[immutable.Seq],\n             createdById = SystemUserId,\n-            createdAt = transaction.now.toJavaDate,\n+            createdAt = tx.now.toJavaDate,\n             createdAtRevNr = Some(post.currentRevisionNr),\n             maybeBadUserId = author.id,\n             postId = Some(post.id),\n             postNr = Some(post.nr)))\n-          anyReviewTask.foreach(transaction.upsertReviewTask)\n+          anyReviewTask.foreach(tx.upsertReviewTask)\n           (post, notfs)\n       }\n       (post, author, notfs)\n@@ -859,22 +859,22 @@ trait PostsDao {\n \n \n   private def saveDeleteUploadRefs(postToEdit: Post, editedPost: Post, editorId: UserId,\n-        transaction: SiteTransaction) {\n+        tx: SiteTransaction) {\n     // Use findUploadRefsInPost (not ...InText) so we'll find refs both in the hereafter\n     // 1) approved version of the post, and 2) the current possibly unapproved version.\n     // Because if any of the approved or the current version links to an uploaded file,\n     // we should keep the file.\n     val currentUploadRefs = findUploadRefsInPost(editedPost)\n-    val oldUploadRefs = transaction.loadUploadedFileReferences(postToEdit.id)\n+    val oldUploadRefs = tx.loadUploadedFileReferences(postToEdit.id)\n     val uploadRefsAdded = currentUploadRefs -- oldUploadRefs\n     val uploadRefsRemoved = oldUploadRefs -- currentUploadRefs\n \n     uploadRefsAdded foreach { hashPathSuffix =>\n-      transaction.insertUploadedFileReference(postToEdit.id, hashPathSuffix, editorId)\n+      tx.insertUploadedFileReference(postToEdit.id, hashPathSuffix, editorId)\n     }\n \n     uploadRefsRemoved foreach { hashPathSuffix =>\n-      val gone = transaction.deleteUploadedFileReference(postToEdit.id, hashPathSuffix)\n+      val gone = tx.deleteUploadedFileReference(postToEdit.id, hashPathSuffix)\n       if (!gone) {\n         p.Logger.warn(o\"\"\"Didn't delete this uploaded file ref: $hashPathSuffix, post id:\n             ${postToEdit.id} [DwE7UMF2]\"\"\")\n@@ -887,17 +887,16 @@ trait PostsDao {\n         userId: Option[UserId]): (Seq[PostRevision], Map[UserId, User]) = {\n     val revisionsRecentFirst = mutable.ArrayStack[PostRevision]()\n     var usersById: Map[UserId, User] = null\n-    readOnlyTransaction { transaction =>\n-      val post = transaction.loadThePost(postId)\n-      val page = PageDao(post.pageId, transaction)\n-      val user = userId.flatMap(transaction.loadUser)\n+    readOnlyTransaction { tx =>\n+      val post = tx.loadThePost(postId)\n+      val page = PageDao(post.pageId, tx)\n+      val user = userId.flatMap(tx.loadUser)\n \n-      throwIfMayNotSeePost(post, user)(transaction)\n+      throwIfMayNotSeePost(post, user)(tx)\n \n-      loadSomeRevisionsWithSourceImpl(postId, revisionNr, revisionsRecentFirst,\n-        atLeast, transaction)\n+      loadSomeRevisionsWithSourceImpl(postId, revisionNr, revisionsRecentFirst, atLeast, tx)\n       if (revisionNr == PostRevision.LastRevisionMagicNr) {\n-        val postNow = transaction.loadThePost(postId)\n+        val postNow = tx.loadThePost(postId)\n         val currentRevision = PostRevision.createFor(postNow, revisionsRecentFirst.headOption)\n           .copy(fullSource = Some(postNow.currentSource))\n         revisionsRecentFirst.push(currentRevision)\n@@ -908,33 +907,33 @@ trait PostsDao {\n         revision.approvedById foreach userIds.add\n         revision.hiddenById foreach userIds.add\n       }\n-      usersById = transaction.loadUsersAsMap(userIds)\n+      usersById = tx.loadUsersAsMap(userIds)\n     }\n     (revisionsRecentFirst.toSeq, usersById)\n   }\n \n \n-  private def loadLastRevisionWithSource(postId: PostId, transaction: SiteTransaction)\n+  private def loadLastRevisionWithSource(postId: PostId, tx: SiteTransaction)\n         : Option[PostRevision] = {\n     val revisionsRecentFirst = mutable.ArrayStack[PostRevision]()\n     loadSomeRevisionsWithSourceImpl(postId, PostRevision.LastRevisionMagicNr,\n-      revisionsRecentFirst, atLeast = 1, transaction)\n+      revisionsRecentFirst, atLeast = 1, tx)\n     revisionsRecentFirst.headOption\n   }\n \n \n   private def loadSomeRevisionsWithSourceImpl(postId: PostId, revisionNr: Int,\n         revisionsRecentFirst: mutable.ArrayStack[PostRevision], atLeast: Int,\n-        transaction: SiteTransaction) {\n-    transaction.loadPostRevision(postId, revisionNr) foreach { revision =>\n-      loadRevisionsFillInSource(revision, revisionsRecentFirst, atLeast, transaction)\n+        tx: SiteTransaction) {\n+    tx.loadPostRevision(postId, revisionNr) foreach { revision =>\n+      loadRevisionsFillInSource(revision, revisionsRecentFirst, atLeast, tx)\n     }\n   }\n \n \n   private def loadRevisionsFillInSource(revision: PostRevision,\n         revisionsRecentFirstWithSource: mutable.ArrayStack[PostRevision],\n-        atLeast: Int, transaction: SiteTransaction) {\n+        atLeast: Int, tx: SiteTransaction) {\n     if (revision.fullSource.isDefined && (atLeast <= 1 || revision.previousNr.isEmpty)) {\n       revisionsRecentFirstWithSource.push(revision)\n       return\n@@ -945,12 +944,12 @@ trait PostsDao {\n           has neither full source nor any previous revision nr\"\"\")\n \n     val previousRevision =\n-      transaction.loadPostRevision(revision.postId, previousRevisionNr).getOrDie(\n+      tx.loadPostRevision(revision.postId, previousRevisionNr).getOrDie(\n         \"DwE5GLK2\", o\"\"\"In site $siteId, post ${revision.postId} revision $previousRevisionNr\n             is missing\"\"\")\n \n     loadRevisionsFillInSource(previousRevision, revisionsRecentFirstWithSource,\n-      atLeast - 1, transaction)\n+      atLeast - 1, tx)\n \n     val prevRevWithSource = revisionsRecentFirstWithSource.headOption getOrDie \"DwE85UF2\"\n     val revisionWithSource =\n@@ -961,8 +960,8 @@ trait PostsDao {\n \n \n   def editPostSettings(postId: PostId, branchSideways: Option[Byte], me: Who): JsValue = {\n-    val (post, patch) = readWriteTransaction { transaction =>\n-      val postBefore = transaction.loadPostsByUniqueId(Seq(postId)).headOption.getOrElse({\n+    val (post, patch) = readWriteTransaction { tx =>\n+      val postBefore = tx.loadPostsByUniqueId(Seq(postId)).headOption.getOrElse({\n         throwNotFound(\"EsE5KJ8W2\", s\"Post not found: $postId\")\n       })._2\n       val postAfter = postBefore.copy(branchSideways = branchSideways)\n@@ -972,25 +971,25 @@ trait PostsDao {\n         id = AuditLogEntry.UnassignedId,\n         didWhat = AuditLogEntryType.ChangePostSettings,\n         doerId = me.id,\n-        doneAt = transaction.now.toJavaDate,\n+        doneAt = tx.now.toJavaDate,\n         browserIdData = me.browserIdData,\n         pageId = Some(postBefore.pageId),\n         uniquePostId = Some(postBefore.id),\n         postNr = Some(postBefore.nr),\n         targetUserId = Some(postBefore.createdById))\n \n-      val oldMeta = transaction.loadThePageMeta(postAfter.pageId)\n+      val oldMeta = tx.loadThePageMeta(postAfter.pageId)\n       val newMeta = oldMeta.copy(version = oldMeta.version + 1)\n \n       // (Don't reindex. For now, don't send any notifications (since currently just toggling\n       // branch-sideways))\n-      transaction.updatePost(postAfter)\n-      transaction.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = false)\n-      insertAuditLogEntry(auditLogEntry, transaction)\n+      tx.updatePost(postAfter)\n+      tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = false)\n+      insertAuditLogEntry(auditLogEntry, tx)\n \n       COULD_OPTIMIZE // try not to load the whole page in makeStorePatch2\n       (postAfter, jsonMaker.makeStorePatch2(postId, postAfter.pageId,\n-          appVersion = globals.applicationVersion, transaction))\n+          appVersion = globals.applicationVersion, tx))\n     }\n     refreshPageInMemCache(post.pageId)\n     patch\n@@ -999,11 +998,11 @@ trait PostsDao {\n \n   def changePostType(pageId: PageId, postNr: PostNr, newType: PostType,\n         changerId: UserId, browserIdData: BrowserIdData) {\n-    readWriteTransaction { transaction =>\n-      val page = PageDao(pageId, transaction)\n+    readWriteTransaction { tx =>\n+      val page = PageDao(pageId, tx)\n       val postBefore = page.parts.thePostByNr(postNr)\n-      val Seq(author, changer) = transaction.loadTheUsers(postBefore.createdById, changerId)\n-      throwIfMayNotSeePage(page, Some(changer))(transaction)\n+      val Seq(author, changer) = tx.loadTheUsers(postBefore.createdById, changerId)\n+      throwIfMayNotSeePage(page, Some(changer))(tx)\n \n       val postAfter = postBefore.copy(tyype = newType)\n \n@@ -1036,7 +1035,7 @@ trait PostsDao {\n         id = AuditLogEntry.UnassignedId,\n         didWhat = AuditLogEntryType.ChangePostSettings,\n         doerId = changerId,\n-        doneAt = transaction.now.toJavaDate,\n+        doneAt = tx.now.toJavaDate,\n         browserIdData = browserIdData,\n         pageId = Some(pageId),\n         uniquePostId = Some(postBefore.id),\n@@ -1047,9 +1046,9 @@ trait PostsDao {\n       val newMeta = oldMeta.copy(version = oldMeta.version + 1)\n \n       // (Don't reindex)\n-      transaction.updatePost(postAfter)\n-      transaction.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = false)\n-      insertAuditLogEntry(auditLogEntry, transaction)\n+      tx.updatePost(postAfter)\n+      tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = false)\n+      insertAuditLogEntry(auditLogEntry, tx)\n       // COULD generate some notification? E.g. \"Your post was made wiki-editable.\"\n     }\n \n@@ -1468,11 +1467,11 @@ trait PostsDao {\n         voterId: UserId, voterIp: String, postNrsRead: Set[PostNr]) {\n     require(postNr >= PageParts.BodyNr, \"TyE5WKAB20\")\n \n-    readWriteTransaction { transaction =>\n-      val page = PageDao(pageId, transaction)\n-      val voter = transaction.loadTheUser(voterId)\n+    readWriteTransaction { tx =>\n+      val page = PageDao(pageId, tx)\n+      val voter = tx.loadTheUser(voterId)\n       SECURITY // minor. Should be if-may-not-see-*post*. And should do a pre-check in VoteController.\n-      throwIfMayNotSeePage(page, Some(voter))(transaction)\n+      throwIfMayNotSeePage(page, Some(voter))(tx)\n \n       val post = page.parts.thePostByNr(postNr)\n \n@@ -1489,7 +1488,7 @@ trait PostsDao {\n       }\n \n       try {\n-        transaction.insertVote(post.id, pageId, postNr, voteType, voterId = voterId)\n+        tx.insertVote(post.id, pageId, postNr, voteType, voterId = voterId)\n       }\n       catch {\n         case DbDao.DuplicateVoteException =>\n@@ -1514,11 +1513,11 @@ trait PostsDao {\n           Set(postNr)\n         }\n \n-      transaction.updatePostsReadStats(pageId, postsToMarkAsRead, readById = voterId,\n+      tx.updatePostsReadStats(pageId, postsToMarkAsRead, readById = voterId,\n         readFromIp = voterIp)\n-      updateVoteCounts(page.parts, post, transaction)\n-      addUserStats(UserStats(post.createdById, numLikesReceived = 1))(transaction)\n-      addUserStats(UserStats(voterId, numLikesGiven = 1))(transaction)\n+      updateVoteCounts(page.parts, post, tx)\n+      addUserStats(UserStats(post.createdById, numLikesReceived = 1))(tx)\n+      addUserStats(UserStats(voterId, numLikesGiven = 1))(tx)\n     }\n     refreshPageInMemCache(pageId)\n   }\n@@ -1658,15 +1657,15 @@ trait PostsDao {\n \n \n   def loadThingsToReview(): ThingsToReview = {\n-    readOnlyTransaction { transaction =>\n-      val posts = transaction.loadPostsToReview()\n-      val pageMetas = transaction.loadPageMetas(posts.map(_.pageId))\n-      val flags = transaction.loadFlagsFor(posts.map(_.pagePostNr))\n+    readOnlyTransaction { tx =>\n+      val posts = tx.loadPostsToReview()\n+      val pageMetas = tx.loadPageMetas(posts.map(_.pageId))\n+      val flags = tx.loadFlagsFor(posts.map(_.pagePostNr))\n       val userIds = mutable.HashSet[UserId]()\n       userIds ++= posts.map(_.createdById)\n       userIds ++= posts.map(_.currentRevisionById)\n       userIds ++= flags.map(_.flaggerId)\n-      val users = transaction.loadUsers(userIds.toSeq)\n+      val users = tx.loadUsers(userIds.toSeq)\n       ThingsToReview(posts, pageMetas, users, flags)\n     }\n   }\n@@ -1688,18 +1687,18 @@ trait PostsDao {\n \n   private def doFlagPost(pageId: PageId, postNr: PostNr, flagType: PostFlagType,\n         flaggerId: UserId): (Post, Boolean) = {\n-    readWriteTransaction { transaction =>\n-      val flagger = transaction.loadTheMember(flaggerId)\n-      val postBefore = transaction.loadThePost(pageId, postNr)\n-      val pageMeta = transaction.loadThePageMeta(pageId)\n-      val categories = transaction.loadCategoryPathRootLast(pageMeta.categoryId)\n-      val settings = loadWholeSiteSettings(transaction)\n+    readWriteTransaction { tx =>\n+      val flagger = tx.loadTheMember(flaggerId)\n+      val postBefore = tx.loadThePost(pageId, postNr)\n+      val pageMeta = tx.loadThePageMeta(pageId)\n+      val categories = tx.loadCategoryPathRootLast(pageMeta.categoryId)\n+      val settings = loadWholeSiteSettings(tx)\n \n       dieOrThrowNoUnless(Authz.mayFlagPost(\n-        flagger, transaction.loadGroupIds(flagger),\n-        postBefore, pageMeta, transaction.loadAnyPrivateGroupTalkMembers(pageMeta),\n+        flagger, tx.loadGroupIds(flagger),\n+        postBefore, pageMeta, tx.loadAnyPrivateGroupTalkMembers(pageMeta),\n         inCategoriesRootLast = categories,\n-        permissions = transaction.loadPermsOnPages()), \"EdEZBXKSM2\")\n+        permissions = tx.loadPermsOnPages()), \"EdEZBXKSM2\")\n \n       dieIf(postBefore.isDeleted, \"TyE2FKG69\")\n       dieIf(pageMeta.isDeleted, \"TyE4FKBFA2\")\n@@ -1708,19 +1707,19 @@ trait PostsDao {\n       var postAfter = postBefore.copy(numPendingFlags = newNumFlags)\n \n       val reviewTask = createOrAmendOldReviewTask(flaggerId, postAfter,\n-        immutable.Seq(ReviewReason.PostFlagged), transaction)\n+        immutable.Seq(ReviewReason.PostFlagged), tx)\n \n       // Hide post, update page?\n       val shallHide = newNumFlags >= settings.numFlagsToHidePost && !postBefore.isBodyHidden\n       if (shallHide) {\n-        hidePostsOnPage(Vector(postAfter), pageId, \"This post was flagged\")(transaction)\n+        hidePostsOnPage(Vector(postAfter), pageId, \"This post was flagged\")(tx)\n       }\n       else {\n-        transaction.updatePost(postAfter)\n+        tx.updatePost(postAfter)\n       }\n \n-      transaction.insertFlag(postBefore.id, pageId, postNr, flagType, flaggerId)\n-      transaction.upsertReviewTask(reviewTask)\n+      tx.insertFlag(postBefore.id, pageId, postNr, flagType, flaggerId)\n+      tx.upsertReviewTask(reviewTask)\n       (postAfter, shallHide)\n     }\n   }\n@@ -1731,14 +1730,14 @@ trait PostsDao {\n   private def ifBadAuthorCensorEverything(post: Post): immutable.Seq[Post] = {\n     val userId = post.createdById\n     val pageIdsToRefresh = mutable.Set[PageId]()\n-    val postsHidden = readWriteTransaction { transaction =>\n-      val user = transaction.loadUser(userId) getOrDie \"EdE6FKW02\"\n+    val postsHidden = readWriteTransaction { tx =>\n+      val user = tx.loadUser(userId) getOrDie \"EdE6FKW02\"\n       if (user.effectiveTrustLevel != TrustLevel.NewMember)\n         return Nil\n \n       // Keep small, there's an O(n^2) loop below (6WKUT02).\n       val numThings = 100\n-      val settings = loadWholeSiteSettings(transaction)\n+      val settings = loadWholeSiteSettings(tx)\n \n       // For members, we'll use the user id.  For guests, we'll use the browser-ip & -id-cookie.\n       var anyBrowserIdData: Option[BrowserIdData] = None\n@@ -1747,18 +1746,18 @@ trait PostsDao {\n \n       var tasks =\n         if (user.isMember) {\n-          transaction.loadReviewTasksAboutUser(user.id, limit = numThings,\n+          tx.loadReviewTasksAboutUser(user.id, limit = numThings,\n             orderBy = OrderBy.MostRecentFirst)\n         }\n         else {\n-          val auditLogEntry = transaction.loadCreatePostAuditLogEntry(post.id) getOrElse {\n+          val auditLogEntry = tx.loadCreatePostAuditLogEntry(post.id) getOrElse {\n             // Audit log data apparently deleted, so cannot find out if the guest author is bad.\n             return Nil\n           }\n           anyBrowserIdData = Some(auditLogEntry.browserIdData)\n           guestPostIds = loadPostIdsByGuestBrowser(theBrowserIdData, limit = numThings,\n-              orderBy = OrderBy.MostRecentFirst)(transaction)\n-          transaction.loadReviewTasksAboutPostIds(guestPostIds)\n+              orderBy = OrderBy.MostRecentFirst)(tx)\n+          tx.loadReviewTasksAboutPostIds(guestPostIds)\n         }\n \n       tasks = tasks.filter(_.reasons.contains(ReviewReason.PostFlagged))\n@@ -1781,13 +1780,13 @@ trait PostsDao {\n       // Block the user.\n       if (user.isMember) {\n         COULD_OPTIMIZE // edit & save the user directly [6DCU0WYX2]\n-        val member = transaction.loadMemberInclDetails(user.id) getOrDie \"EdE5KW0U4\"\n+        val member = tx.loadMemberInclDetails(user.id) getOrDie \"EdE5KW0U4\"\n         val memberAfter = member.copyWithMaxThreatLevel(ThreatLevel.ModerateThreat)\n-        transaction.updateMemberInclDetails(memberAfter)\n+        tx.updateMemberInclDetails(memberAfter)\n       }\n       else {\n         blockGuestImpl(theBrowserIdData, user.id, numDays = 31,\n-          threatLevel = ThreatLevel.ModerateThreat, blockerId = SystemUserId)(transaction)\n+          threatLevel = ThreatLevel.ModerateThreat, blockerId = SystemUserId)(tx)\n       }\n \n       SECURITY ; BUG // minor: if the author has posted > numThings post, only the most recent ones\n@@ -1797,11 +1796,11 @@ trait PostsDao {\n       // Censor the user's posts.\n       val postToMaybeHide =\n         if (user.isMember) {\n-          transaction.loadPostsByAuthorSkipTitles(\n+          tx.loadPostsByAuthorSkipTitles(\n               userId, limit = numThings, OrderBy.MostRecentFirst).filter(!_.isBodyHidden)\n         }\n         else {\n-          transaction.loadPostsByUniqueId(guestPostIds).values.filter(!_.isBodyHidden)\n+          tx.loadPostsByUniqueId(guestPostIds).values.filter(!_.isBodyHidden)\n         }\n \n       // Don't hide posts that have been reviewed and deemed okay.\n@@ -1814,8 +1813,7 @@ trait PostsDao {\n \n       val postToHideByPage = postToHide.groupBy(_.pageId)\n       for ((pageId, posts) <- postToHideByPage) {\n-        hidePostsOnPage(posts, pageId, \"Many posts by this author got flagged, hiding all\")(\n-            transaction)\n+        hidePostsOnPage(posts, pageId, \"Many posts by this author got flagged, hiding all\")(tx)\n         pageIdsToRefresh += pageId\n       }\n       postToHide\n@@ -1831,8 +1829,8 @@ trait PostsDao {\n     * by that browser (ip address and browser-id-cookie, perhaps fingerprint later).\n     */\n   private def loadPostIdsByGuestBrowser(browserIdData: BrowserIdData, limit: Int,\n-        orderBy: OrderBy)(transaction: SiteTransaction): Set[PostId] = {\n-    val manyEntries = transaction.loadCreatePostAuditLogEntriesBy(\n+        orderBy: OrderBy)(tx: SiteTransaction): Set[PostId] = {\n+    val manyEntries = tx.loadCreatePostAuditLogEntriesBy(\n       browserIdData, limit = limit, orderBy)\n     val fewerEntries = manyEntries filter { entry =>\n       User.isGuestId(entry.doerId) && !entry.postNr.contains(PageParts.TitleNr)\n@@ -1842,14 +1840,14 @@ trait PostsDao {\n \n \n   private def hidePostsOnPage(posts: Iterable[Post], pageId: PageId, reason: String)(\n-        transaction: SiteTransaction) {\n+        tx: SiteTransaction) {\n     dieIf(posts.exists(_.pageId != pageId), \"EdE7GKU23Y4\")\n     dieIf(posts.exists(_.isTitle), \"EdE5KP0WY2\") ; SECURITY ; ANNOYING // end users can trigger internal error\n     val postsToHide = posts.filter(!_.isBodyHidden)\n     if (postsToHide.isEmpty)\n       return\n \n-    val pageMetaBefore = transaction.loadPageMeta(pageId) getOrDie \"EdE7KP0F2\"\n+    val pageMetaBefore = tx.loadPageMeta(pageId) getOrDie \"EdE7KP0F2\"\n     var numOrigPostRepliesHidden = 0\n     var numRepliesHidden = 0\n     var isHidingOrigPost = false\n@@ -1860,11 +1858,11 @@ trait PostsDao {\n       isHidingOrigPost ||= postBefore.isOrigPost\n \n       val postAfter = postBefore.copy(\n-        bodyHiddenAt = Some(transaction.now.toJavaDate),\n+        bodyHiddenAt = Some(tx.now.toJavaDate),\n         bodyHiddenById = Some(SystemUserId),\n         bodyHiddenReason = Some(reason))\n \n-      transaction.updatePost(postAfter)\n+      tx.updatePost(postAfter)\n     }\n \n     var pageMetaAfter = pageMetaBefore.copy(\n@@ -1880,34 +1878,34 @@ trait PostsDao {\n       // Hide page if everything on it hidden.\n       if (!pageMetaBefore.isHidden && pageMetaAfter.numRepliesVisible == 0) {\n         val willOrigPostBeVisible = if (isHidingOrigPost) false else {\n-          val anyOrigPost = transaction.loadOrigPost(pageId)\n+          val anyOrigPost = tx.loadOrigPost(pageId)\n           anyOrigPost.exists(_.isVisible)\n         }\n         if (!willOrigPostBeVisible) {\n-          pageMetaAfter = pageMetaAfter.copy(hiddenAt = Some(transaction.now))\n+          pageMetaAfter = pageMetaAfter.copy(hiddenAt = Some(tx.now))\n         }\n       }\n \n-      transaction.updatePageMeta(pageMetaAfter, oldMeta = pageMetaBefore,\n+      tx.updatePageMeta(pageMetaAfter, oldMeta = pageMetaBefore,\n         // The page might be hidden now, or num-replies has changed, so refresh forum topic list.\n         markSectionPageStale = true)\n-      updatePagePopularity(PagePartsDao(pageId, transaction), transaction)\n+      updatePagePopularity(PagePartsDao(pageId, tx), tx)\n     }\n   }\n \n \n   def clearFlags(pageId: PageId, postNr: PostNr, clearedById: UserId): Unit = {\n-    readWriteTransaction { transaction =>\n-      val clearer = transaction.loadTheUser(clearedById)\n+    readWriteTransaction { tx =>\n+      val clearer = tx.loadTheUser(clearedById)\n       if (!clearer.isStaff)\n         throwForbidden(\"EsE7YKG59\", \"Only staff may clear flags\")\n \n-      val postBefore = transaction.loadThePost(pageId, postNr)\n+      val postBefore = tx.loadThePost(pageId, postNr)\n       val postAfter = postBefore.copy(\n         numPendingFlags = 0,\n         numHandledFlags = postBefore.numHandledFlags + postBefore.numPendingFlags)\n-      transaction.updatePost(postAfter)\n-      transaction.clearFlags(pageId, postNr, clearedById = clearedById)\n+      tx.updatePost(postAfter)\n+      tx.clearFlags(pageId, postNr, clearedById = clearedById)\n       // Need not update page version: flags aren't shown (except perhaps for staff users).\n     }\n     // In case the post gets unhidden now when flags gone:\n@@ -1941,10 +1939,10 @@ trait PostsDao {\n     }\n \n \n-  private def updateVoteCounts(pageParts: PageParts, post: Post, transaction: SiteTransaction) {\n+  private def updateVoteCounts(pageParts: PageParts, post: Post, tx: SiteTransaction) {\n     dieIf(post.nr < PageParts.BodyNr, \"TyE4WKAB02\")\n-    val actions = transaction.loadActionsDoneToPost(post.pageId, postNr = post.nr)\n-    val readStats = transaction.loadPostsReadStats(post.pageId, Some(post.nr))\n+    val actions = tx.loadActionsDoneToPost(post.pageId, postNr = post.nr)\n+    val readStats = tx.loadPostsReadStats(post.pageId, Some(post.nr))\n     val postAfter = post.copyWithUpdatedVoteAndReadCounts(actions, readStats)\n \n     val numNewLikes = postAfter.numLikeVotes - post.numLikeVotes\n@@ -1958,7 +1956,7 @@ trait PostsDao {\n       else\n         (0, 0, 0, 0)\n \n-    val pageMetaBefore = transaction.loadThePageMeta(post.pageId)\n+    val pageMetaBefore = tx.loadThePageMeta(post.pageId)\n     val pageMetaAfter = pageMetaBefore.copy(\n       numLikes = pageMetaBefore.numLikes + numNewLikes,\n       numWrongs = pageMetaBefore.numWrongs + numNewWrongs,\n@@ -1973,9 +1971,9 @@ trait PostsDao {\n       version = pageMetaBefore.version + 1)\n \n     // (Don't reindex)\n-    transaction.updatePost(postAfter)\n-    transaction.updatePageMeta(pageMetaAfter, oldMeta = pageMetaBefore, markSectionPageStale = true)\n-    updatePagePopularity(pageParts, transaction)\n+    tx.updatePost(postAfter)\n+    tx.updatePageMeta(pageMetaAfter, oldMeta = pageMetaBefore, markSectionPageStale = true)\n+    updatePagePopularity(pageParts, tx)\n \n     // COULD split e.g. num_like_votes into ..._total and ..._unique? And update here.\n   }\n@@ -2006,14 +2004,13 @@ object PostsDao {\n \n \n   def createOrAmendOldReviewTask(createdById: UserId, post: Post, reasons: immutable.Seq[ReviewReason],\n-        transaction: SiteTransaction): ReviewTask = {\n-    val pendingTask = transaction.loadUndecidedPostReviewTask(post.id,\n-      taskCreatedById = createdById)\n+        tx: SiteTransaction): ReviewTask = {\n+    val pendingTask = tx.loadUndecidedPostReviewTask(post.id, taskCreatedById = createdById)\n     val newTask = ReviewTask(\n-      id = pendingTask.map(_.id).getOrElse(transaction.nextReviewTaskId()),\n+      id = pendingTask.map(_.id).getOrElse(tx.nextReviewTaskId()),\n       reasons = reasons,\n       createdById = createdById,\n-      createdAt = transaction.now.toJavaDate,\n+      createdAt = tx.now.toJavaDate,\n       createdAtRevNr = Some(post.currentRevisionNr),\n       maybeBadUserId = post.createdById,\n       postId = Some(post.id),"
    }
  ]
}
