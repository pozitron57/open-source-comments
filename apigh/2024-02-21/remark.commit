{
  "sha": "1313dee829ff781f20c6c5614473e2534a88bd30",
  "node_id": "C_kwDOBtgov9oAKDEzMTNkZWU4MjlmZjc4MWYyMGM2YzU2MTQ0NzNlMjUzNGE4OGJkMzA",
  "commit": {
    "author": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2024-02-20T19:27:50Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2024-02-20T20:15:35Z"
    },
    "message": "update to lcw v2 with generic types",
    "tree": {
      "sha": "ae8324ab24c5a5ea4a136824e2303b175451bebe",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/ae8324ab24c5a5ea4a136824e2303b175451bebe"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/1313dee829ff781f20c6c5614473e2534a88bd30",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/1313dee829ff781f20c6c5614473e2534a88bd30",
  "html_url": "https://github.com/umputun/remark42/commit/1313dee829ff781f20c6c5614473e2534a88bd30",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/1313dee829ff781f20c6c5614473e2534a88bd30/comments",
  "author": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "url": "https://api.github.com/repos/umputun/remark42/commits/3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "html_url": "https://github.com/umputun/remark42/commit/3210de8f7bb627ac23669e4e88ef28fc466c7778"
    }
  ],
  "stats": {
    "total": 2302,
    "additions": 1162,
    "deletions": 1140
  },
  "files": [
    {
      "sha": "5936dda21b81ac687a64c99919bb9c2372aff0c9",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 14,
      "deletions": 12,
      "changes": 26,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fcmd%2Fserver.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fcmd%2Fserver.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fserver.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -16,7 +16,7 @@ import (\n \t\"time\"\n \n \t\"github.com/go-pkgz/jrpc\"\n-\t\"github.com/go-pkgz/lcw/eventbus\"\n+\t\"github.com/go-pkgz/lcw/v2/eventbus\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tntf \"github.com/go-pkgz/notify\"\n \t\"github.com/golang-jwt/jwt\"\n@@ -28,7 +28,7 @@ import (\n \t\"github.com/go-pkgz/auth/provider\"\n \t\"github.com/go-pkgz/auth/provider/sender\"\n \t\"github.com/go-pkgz/auth/token\"\n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \n \t\"github.com/umputun/remark42/backend/app/migrator\"\n \t\"github.com/umputun/remark42/backend/app/notify\"\n@@ -869,27 +869,28 @@ func (s *ServerCommand) makeAdminStore() (admin.Store, error) {\n \n func (s *ServerCommand) makeCache() (LoadingCache, error) {\n \tlog.Printf(\"[INFO] make cache, type=%s\", s.Cache.Type)\n+\to := cache.NewOpts[[]byte]()\n \tswitch s.Cache.Type {\n \tcase \"redis_pub_sub\":\n \t\tredisPubSub, err := eventbus.NewRedisPubSub(s.Cache.RedisAddr, \"remark42-cache\")\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"cache backend initialization, redis PubSub initialisation: %w\", err)\n \t\t}\n-\t\tbackend, err := cache.NewLruCache(cache.MaxCacheSize(s.Cache.Max.Size), cache.MaxValSize(s.Cache.Max.Value),\n-\t\t\tcache.MaxKeys(s.Cache.Max.Items), cache.EventBus(redisPubSub))\n+\t\tbackend, err := cache.NewLruCache(o.MaxCacheSize(s.Cache.Max.Size), o.MaxValSize(s.Cache.Max.Value),\n+\t\t\to.MaxKeys(s.Cache.Max.Items), o.EventBus(redisPubSub))\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"cache backend initialization: %w\", err)\n \t\t}\n-\t\treturn cache.NewScache(backend), nil\n+\t\treturn cache.NewScache[[]byte](backend), nil\n \tcase \"mem\":\n-\t\tbackend, err := cache.NewLruCache(cache.MaxCacheSize(s.Cache.Max.Size), cache.MaxValSize(s.Cache.Max.Value),\n-\t\t\tcache.MaxKeys(s.Cache.Max.Items))\n+\t\tbackend, err := cache.NewLruCache(o.MaxCacheSize(s.Cache.Max.Size), o.MaxValSize(s.Cache.Max.Value),\n+\t\t\to.MaxKeys(s.Cache.Max.Items))\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"cache backend initialization: %w\", err)\n \t\t}\n-\t\treturn cache.NewScache(backend), nil\n+\t\treturn cache.NewScache[[]byte](backend), nil\n \tcase \"none\":\n-\t\treturn cache.NewScache(&cache.Nop{}), nil\n+\t\treturn cache.NewScache[[]byte](&cache.Nop[[]byte]{}), nil\n \t}\n \treturn nil, fmt.Errorf(\"unsupported cache type %s\", s.Cache.Type)\n }\n@@ -1326,11 +1327,12 @@ func splitAtCommas(s string) []string {\n \n // authRefreshCache used by authenticator to minimize repeatable token refreshes\n type authRefreshCache struct {\n-\tcache.LoadingCache\n+\tcache.LoadingCache[string]\n }\n \n func newAuthRefreshCache() *authRefreshCache {\n-\texpirableCache, _ := cache.NewExpirableCache(cache.TTL(5 * time.Minute))\n+\to := cache.NewOpts[string]()\n+\texpirableCache, _ := cache.NewExpirableCache(o.TTL(5 * time.Minute))\n \treturn &authRefreshCache{LoadingCache: expirableCache}\n }\n \n@@ -1341,5 +1343,5 @@ func (c *authRefreshCache) Get(key interface{}) (interface{}, bool) {\n \n // Set implements cache setter with key converted to string\n func (c *authRefreshCache) Set(key, value interface{}) {\n-\t_, _ = c.LoadingCache.Get(key.(string), func() (interface{}, error) { return value, nil })\n+\t_, _ = c.LoadingCache.Get(key.(string), func() (string, error) { return value.(string), nil })\n }"
    },
    {
      "sha": "170e2d620564ffad6f62b793bb8cb2eca4bc2789",
      "filename": "backend/app/cmd/server_test.go",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fcmd%2Fserver_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fcmd%2Fserver_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fserver_test.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -848,5 +848,10 @@ func createAppFromCmd(t *testing.T, cmd ServerCommand) (*serverApp, context.Cont\n \n func TestMain(m *testing.M) {\n \t// ignore is added only for GitHub Actions, can't reproduce locally\n-\tgoleak.VerifyTestMain(m, goleak.IgnoreTopFunction(\"net/http.(*Server).Shutdown\"))\n+\tgoleak.VerifyTestMain(\n+\t\tm,\n+\t\tgoleak.IgnoreTopFunction(\"net/http.(*Server).Shutdown\"),\n+\t\t// this will be fixed in https://github.com/hashicorp/golang-lru/issues/159\n+\t\tgoleak.IgnoreTopFunction(\"github.com/hashicorp/golang-lru/v2/expirable.NewLRU[...].func1\"),\n+\t)\n }"
    },
    {
      "sha": "2154e7447b9f608ff1ce33d49dbb95c7ec0af569",
      "filename": "backend/app/main_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fmain_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fmain_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmain_test.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -157,5 +157,7 @@ func TestMain(m *testing.M) {\n \t\tm,\n \t\tgoleak.IgnoreTopFunction(\"github.com/umputun/remark42/backend/app.init.0.func1\"),\n \t\tgoleak.IgnoreTopFunction(\"net/http.(*Server).Shutdown\"),\n+\t\t// this will be fixed in https://github.com/hashicorp/golang-lru/issues/159\n+\t\tgoleak.IgnoreTopFunction(\"github.com/hashicorp/golang-lru/v2/expirable.NewLRU[...].func1\"),\n \t)\n }"
    },
    {
      "sha": "d6e1f94b880266b8124b65c5c0ba78f3a49bee28",
      "filename": "backend/app/rest/api/admin.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fadmin.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -9,7 +9,7 @@ import (\n \t\"github.com/go-chi/chi/v5\"\n \t\"github.com/go-chi/render\"\n \t\"github.com/go-pkgz/auth\"\n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n "
    },
    {
      "sha": "4b6279805388041c36a88a243693339400b42489",
      "filename": "backend/app/rest/api/admin_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Fadmin_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Fadmin_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fadmin_test.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -14,7 +14,7 @@ import (\n \t\"time\"\n \n \t\"github.com/go-pkgz/auth/token\"\n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/golang-jwt/jwt\"\n \t\"github.com/stretchr/testify/assert\"\n@@ -348,7 +348,7 @@ func TestAdmin_Block(t *testing.T) {\n \tassert.Equal(t, \"test test #1\", comments.Comments[2].Text, \"comment not removed and not cleared\")\n \tassert.False(t, comments.Comments[2].Deleted, \"not deleted\")\n \n-\tsrv.pubRest.cache = cache.NewScache(cache.NewNopCache()) // TODO: with lru cache it won't be refreshed and invalidated for long\n+\tsrv.pubRest.cache = cache.NewScache[[]byte](cache.NewNopCache[[]byte]()) // TODO: with lru cache it won't be refreshed and invalidated for long\n \t// time\n \ttime.Sleep(50 * time.Millisecond)\n \tres, code = get(t, ts.URL+\"/api/v1/find?site=remark42&url=https://radio-t.com/blah&sort=+time\")"
    },
    {
      "sha": "00e43fa06c1f96f6a26959394adb64a6230b3509",
      "filename": "backend/app/rest/api/migrator.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Fmigrator.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Fmigrator.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fmigrator.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -11,7 +11,7 @@ import (\n \t\"time\"\n \n \t\"github.com/go-chi/render\"\n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n "
    },
    {
      "sha": "a2e07ce73a621207ba9da174c98483d89fbd129e",
      "filename": "backend/app/rest/api/rest.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -22,7 +22,7 @@ import (\n \t\"github.com/go-chi/cors\"\n \t\"github.com/go-chi/render\"\n \t\"github.com/go-pkgz/auth\"\n-\t\"github.com/go-pkgz/lcw\"\n+\t\"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/go-pkgz/rest/logger\""
    },
    {
      "sha": "d723a1a2aabd944e018242bc1d004cadfe132236",
      "filename": "backend/app/rest/api/rest_private.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_private.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -18,7 +18,7 @@ import (\n \t\"github.com/go-chi/render\"\n \t\"github.com/go-pkgz/auth\"\n \t\"github.com/go-pkgz/auth/token\"\n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/golang-jwt/jwt\""
    },
    {
      "sha": "4d7230afd290880695ad05b618db1bd672dc4ea3",
      "filename": "backend/app/rest/api/rest_public.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_public.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_public.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_public.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -13,7 +13,7 @@ import (\n \n \t\"github.com/go-chi/chi/v5\"\n \t\"github.com/go-chi/render\"\n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/skip2/go-qrcode\""
    },
    {
      "sha": "8d3db1ae5b59a25e206b6e3ffce79aac8c1e0b08",
      "filename": "backend/app/rest/api/rest_public_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_public_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_public_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_public_test.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -11,7 +11,7 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\""
    },
    {
      "sha": "430d947f0d58080701920a5e636de15885412978",
      "filename": "backend/app/rest/api/rest_test.go",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_test.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -20,7 +20,7 @@ import (\n \t\"github.com/go-pkgz/auth/avatar\"\n \t\"github.com/go-pkgz/auth/provider\"\n \t\"github.com/go-pkgz/auth/token\"\n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n@@ -438,7 +438,7 @@ func startupT(t *testing.T, srvHook ...func(srv *Rest)) (ts *httptest.Server, sr\n \tb, err := engine.NewBoltDB(bolt.Options{}, engine.BoltSite{FileName: testDB, SiteID: \"remark42\"})\n \trequire.NoError(t, err)\n \n-\tmemCache := cache.NewScache(cache.NewNopCache())\n+\tmemCache := cache.NewScache[[]byte](cache.NewNopCache[[]byte]())\n \n \tastore := adminstore.NewStaticStore(\"123456\", []string{\"remark42\"}, []string{\"a1\", \"a2\"}, \"admin@remark-42.com\")\n \trestrictedWordsMatcher := service.NewRestrictedWordsMatcher(service.StaticRestrictedWordsLister{Words: []string{\"duck\"}})\n@@ -658,5 +658,9 @@ func waitForHTTPSServerStart(port int) {\n }\n \n func TestMain(m *testing.M) {\n-\tgoleak.VerifyTestMain(m)\n+\tgoleak.VerifyTestMain(\n+\t\tm,\n+\t\t// this will be fixed in https://github.com/hashicorp/golang-lru/issues/159\n+\t\tgoleak.IgnoreTopFunction(\"github.com/hashicorp/golang-lru/v2/expirable.NewLRU[...].func1\"),\n+\t)\n }"
    },
    {
      "sha": "82baf8f25eb98511ba2f7b8bbf7e308a45c8ae9c",
      "filename": "backend/app/rest/api/rss.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frss.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Frest%2Fapi%2Frss.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frss.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -5,7 +5,7 @@ import (\n \t\"net/http\"\n \t\"time\"\n \n-\tcache \"github.com/go-pkgz/lcw\"\n+\tcache \"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/gorilla/feeds\"\n "
    },
    {
      "sha": "5f4a6dba9969d8e2cd820b55ff454b21e9c0e958",
      "filename": "backend/app/store/service/service.go",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fstore%2Fservice%2Fservice.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fstore%2Fservice%2Fservice.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Fservice.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -11,7 +11,7 @@ import (\n \t\"sync\"\n \t\"time\"\n \n-\t\"github.com/go-pkgz/lcw\"\n+\t\"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/google/uuid\"\n \t\"github.com/hashicorp/go-multierror\"\n@@ -49,7 +49,7 @@ type DataStore struct {\n \t}\n \n \trepliesCache struct {\n-\t\tlcw.LoadingCache\n+\t\tlcw.LoadingCache[struct{}]\n \t\tonce sync.Once\n \t}\n }\n@@ -534,7 +534,8 @@ func (s *DataStore) EditComment(locator store.Locator, commentID string, req Edi\n func (s *DataStore) HasReplies(comment store.Comment) bool {\n \ts.repliesCache.once.Do(func() {\n \t\t// default expiration time of 5 minutes and cleanup time of 2.5 minutes\n-\t\ts.repliesCache.LoadingCache, _ = lcw.NewExpirableCache(lcw.TTL(5 * time.Minute))\n+\t\to := lcw.NewOpts[struct{}]()\n+\t\ts.repliesCache.LoadingCache, _ = lcw.NewExpirableCache[struct{}](o.TTL(5 * time.Minute))\n \t})\n \n \tif _, found := s.repliesCache.Peek(comment.ID); found {\n@@ -554,7 +555,7 @@ func (s *DataStore) HasReplies(comment store.Comment) bool {\n \t\t\t\t// When this code is reached, key \"comment.ID\" is not in cache.\n \t\t\t\t// Calling cache.Get on it will put it in cache with 5 minutes TTL.\n \t\t\t\t// We call it with empty struct as value as we care about keys and not values.\n-\t\t\t\t_, _ = s.repliesCache.Get(comment.ID, func() (interface{}, error) { return struct{}{}, nil })\n+\t\t\t\t_, _ = s.repliesCache.Get(comment.ID, func() (struct{}, error) { return struct{}{}, nil })\n \t\t\t\treturn true\n \t\t\t}\n \t\t}"
    },
    {
      "sha": "9ee497a9d7281fc7e74ff8bab20e007771bc3b1a",
      "filename": "backend/app/store/service/title.go",
      "status": "modified",
      "additions": 11,
      "deletions": 10,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fstore%2Fservice%2Ftitle.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fapp%2Fstore%2Fservice%2Ftitle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Ftitle.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -8,7 +8,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"github.com/go-pkgz/lcw\"\n+\t\"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"golang.org/x/net/html\"\n )\n@@ -21,7 +21,7 @@ const (\n // TitleExtractor gets html title from remote page, cached\n type TitleExtractor struct {\n \tclient         http.Client\n-\tcache          lcw.LoadingCache\n+\tcache          lcw.LoadingCache[string]\n \tallowedDomains []string\n }\n \n@@ -33,10 +33,11 @@ func NewTitleExtractor(client http.Client, allowedDomains []string) *TitleExtrac\n \t\tallowedDomains: allowedDomains,\n \t}\n \tvar err error\n-\tres.cache, err = lcw.NewExpirableCache(lcw.TTL(teCacheTTL), lcw.MaxKeySize(teCacheMaxRecs))\n+\to := lcw.NewOpts[string]()\n+\tres.cache, err = lcw.NewExpirableCache(o.TTL(teCacheTTL), o.MaxKeySize(teCacheMaxRecs))\n \tif err != nil {\n \t\tlog.Printf(\"[WARN] failed to make cache, caching disabled for titles, %v\", err)\n-\t\tres.cache = &lcw.Nop{}\n+\t\tres.cache = &lcw.Nop[string]{}\n \t}\n \treturn &res\n }\n@@ -62,34 +63,34 @@ func (t *TitleExtractor) Get(pageURL string) (string, error) {\n \t}\n \tclient := http.Client{Timeout: t.client.Timeout, Transport: t.client.Transport}\n \tdefer client.CloseIdleConnections()\n-\tb, err := t.cache.Get(pageURL, func() (interface{}, error) {\n+\tb, err := t.cache.Get(pageURL, func() (string, error) {\n \t\tresp, e := client.Get(pageURL)\n \t\tif e != nil {\n-\t\t\treturn nil, fmt.Errorf(\"failed to load page %s: %w\", pageURL, e)\n+\t\t\treturn \"\", fmt.Errorf(\"failed to load page %s: %w\", pageURL, e)\n \t\t}\n \t\tdefer func() {\n \t\t\tif err = resp.Body.Close(); err != nil {\n \t\t\t\tlog.Printf(\"[WARN] failed to close title extractor body, %v\", err)\n \t\t\t}\n \t\t}()\n \t\tif resp.StatusCode != 200 {\n-\t\t\treturn nil, fmt.Errorf(\"can't load page %s, code %d\", pageURL, resp.StatusCode)\n+\t\t\treturn \"\", fmt.Errorf(\"can't load page %s, code %d\", pageURL, resp.StatusCode)\n \t\t}\n \n \t\ttitle, ok := t.getTitle(resp.Body)\n \t\tif !ok {\n-\t\t\treturn nil, fmt.Errorf(\"can't get title for %s\", pageURL)\n+\t\t\treturn \"\", fmt.Errorf(\"can't get title for %s\", pageURL)\n \t\t}\n \t\treturn title, nil\n \t})\n \n \t// on error save result (empty string) to cache too and return \"\" title\n \tif err != nil {\n-\t\t_, _ = t.cache.Get(pageURL, func() (interface{}, error) { return \"\", nil })\n+\t\t_, _ = t.cache.Get(pageURL, func() (string, error) { return \"\", nil })\n \t\treturn \"\", err\n \t}\n \n-\treturn b.(string), nil\n+\treturn b, nil\n }\n \n // Close title extractor"
    },
    {
      "sha": "9d04a58a0c5844ad867e61716b1b541ab8301f84",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fgo.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fgo.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fgo.mod?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -13,7 +13,7 @@ require (\n \tgithub.com/go-chi/render v1.0.3\n \tgithub.com/go-pkgz/auth v1.22.2-0.20240117071454-f721b8c33b05\n \tgithub.com/go-pkgz/jrpc v0.3.0\n-\tgithub.com/go-pkgz/lcw v1.1.0\n+\tgithub.com/go-pkgz/lcw/v2 v2.0.0\n \tgithub.com/go-pkgz/lgr v0.11.1\n \tgithub.com/go-pkgz/notify v1.1.0\n \tgithub.com/go-pkgz/repeater v1.1.3\n@@ -56,7 +56,7 @@ require (\n \tgithub.com/gorilla/css v1.0.1 // indirect\n \tgithub.com/gorilla/websocket v1.5.1 // indirect\n \tgithub.com/hashicorp/errwrap v1.1.0 // indirect\n-\tgithub.com/hashicorp/golang-lru v1.0.2 // indirect\n+\tgithub.com/hashicorp/golang-lru/v2 v2.0.7 // indirect\n \tgithub.com/klauspost/compress v1.17.4 // indirect\n \tgithub.com/montanaflynn/stats v0.7.1 // indirect\n \tgithub.com/pmezard/go-difflib v1.0.0 // indirect"
    },
    {
      "sha": "e4fbd4ad336ebb6e1caa34c260d83071af25ba25",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fgo.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fgo.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fgo.sum?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -15,8 +15,8 @@ github.com/alecthomas/chroma/v2 v2.12.0 h1:Wh8qLEgMMsN7mgyG8/qIpegky2Hvzr4By6gEF\n github.com/alecthomas/chroma/v2 v2.12.0/go.mod h1:4TQu7gdfuPjSh76j78ietmqh9LiurGF0EpseFXdKMBw=\n github.com/alecthomas/repr v0.2.0 h1:HAzS41CIzNW5syS8Mf9UwXhNH1J9aix/BvDRf1Ml2Yk=\n github.com/alecthomas/repr v0.2.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=\n-github.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a h1:HbKu58rmZpUGpz5+4FfNmIU+FmZg2P3Xaj2v2bfNWmk=\n-github.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\n+github.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302 h1:uvdUDbHQHO85qeSydJtItA4T55Pw6BtAejd0APRJOCE=\n+github.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\n github.com/alicebob/miniredis/v2 v2.31.1 h1:7XAt0uUg3DtwEKW5ZAGa+K7FZV2DdKQo5K/6TTnfX8Y=\n github.com/alicebob/miniredis/v2 v2.31.1/go.mod h1:UB/T2Uztp7MlFSDakaX1sTXUv5CASoprx0wulRT6HBg=\n github.com/andybalholm/brotli v1.0.4 h1:V7DdXeJtZscaqfNuAdSRuRFzuiKlHSC/Zh3zl9qY3JY=\n@@ -72,8 +72,8 @@ github.com/go-pkgz/expirable-cache v1.0.0 h1:ns5+1hjY8hntGv8bPaQd9Gr7Jyo+Uw5SLyI\n github.com/go-pkgz/expirable-cache v1.0.0/go.mod h1:GTrEl0X+q0mPNqN6dtcQXksACnzCBQ5k/k1SwXJsZKs=\n github.com/go-pkgz/jrpc v0.3.0 h1:Fls38KqPsHzvp0FWfivr6cGnncC+iFBodHBqvUPY+0U=\n github.com/go-pkgz/jrpc v0.3.0/go.mod h1:MFtKs75JESiSqVicsQkgN2iDFFuCd3gVT1/vKiwRi00=\n-github.com/go-pkgz/lcw v1.1.0 h1:hDJdQJZf4iw19a7cTgQvF6Poz/L7mL4E7FgG5jGs4lA=\n-github.com/go-pkgz/lcw v1.1.0/go.mod h1:zwT7RSxFskQsHWHJezYq6n0iTn0n4yIYRDijXq3awM0=\n+github.com/go-pkgz/lcw/v2 v2.0.0 h1:gTwXpiJBhQeA1rXuqkRuLcV79uATFna8CckH8ZBBrH0=\n+github.com/go-pkgz/lcw/v2 v2.0.0/go.mod h1:yxJHOn+IbQBQHxUqkCtMrbGjIfdYcsBAZcVCBaL1Va8=\n github.com/go-pkgz/lgr v0.11.1 h1:hXFhZcznehI6imLhEa379oMOKFz7TQUmisAqb3oLOSM=\n github.com/go-pkgz/lgr v0.11.1/go.mod h1:tgDF4RXQnBfIgJqjgkv0yOeTQ3F1yewWIZkpUhHnAkU=\n github.com/go-pkgz/notify v1.1.0 h1:xdMKoY7W5t9lewGzn61yM6Z6oWafPiPS1WtAMO81p2k=\n@@ -132,8 +132,8 @@ github.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY\n github.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\n github.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=\n github.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=\n-github.com/hashicorp/golang-lru v1.0.2 h1:dV3g9Z/unq5DpblPpw+Oqcv4dU/1omnb4Ok8iPY6p1c=\n-github.com/hashicorp/golang-lru v1.0.2/go.mod h1:iADmTwqILo4mZ8BN3D2Q6+9jd8WM5uGBxy+E8yxSoD4=\n+github.com/hashicorp/golang-lru/v2 v2.0.7 h1:a+bsQ5rvGLjzHuww6tVxozPZFVghXaHOwFs4luLUK2k=\n+github.com/hashicorp/golang-lru/v2 v2.0.7/go.mod h1:QeFd9opnmA6QUJc5vARoKUSoFhyfM2/ZepoAG6RGpeM=\n github.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=\n github.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=\n github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\n@@ -189,8 +189,6 @@ github.com/sergi/go-diff v1.1.0 h1:we8PVUC3FE2uYfodKH/nBHMSetSfHDR6scGdBi+erh0=\n github.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\n github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e h1:MRM5ITcdelLK2j1vwZ3Je0FKVCfqOLp5zO6trqMLYs0=\n github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e/go.mod h1:XV66xRDqSt+GTGFMVlhk3ULuV0y9ZmzeVGR4mloJI3M=\n-github.com/slack-go/slack v0.12.2 h1:x3OppyMyGIbbiyFhsBmpf9pwkUzMhthJMRNmNlA4LaQ=\n-github.com/slack-go/slack v0.12.2/go.mod h1:hlGi5oXA+Gt+yWTPP0plCdRKmjsDxecdHxYQdlMQKOw=\n github.com/slack-go/slack v0.12.4 h1:4iLT2opw+/QptmQxBNA7S8pNfSIvtn0NDGu7Jq0emi4=\n github.com/slack-go/slack v0.12.4/go.mod h1:hlGi5oXA+Gt+yWTPP0plCdRKmjsDxecdHxYQdlMQKOw=\n github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\n@@ -253,8 +251,8 @@ github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 h1:BHyfKlQyqbsFN5p3Ifn\n github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82/go.mod h1:lgjkn3NuSvDfVJdfcVVdX+jpBxNmX4rDAzaS45IcYoM=\n github.com/yudai/pp v2.0.1+incompatible/go.mod h1:PuxR/8QJ7cyCkFp/aUDS+JY727OFEZkTdatxwunjIkc=\n github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\n-github.com/yuin/gopher-lua v1.1.0 h1:BojcDhfyDWgU2f2TOzYK/g5p2gxMrku8oupLDqlnSqE=\n-github.com/yuin/gopher-lua v1.1.0/go.mod h1:GBR0iDaNXjAgGg9zfCvksxSRnQx76gclCIb7kdAd1Pw=\n+github.com/yuin/gopher-lua v1.1.1 h1:kYKnWBjvbNP4XLT3+bPEwAXJx262OhaHDWDVOPjL46M=\n+github.com/yuin/gopher-lua v1.1.1/go.mod h1:GBR0iDaNXjAgGg9zfCvksxSRnQx76gclCIb7kdAd1Pw=\n go.etcd.io/bbolt v1.3.8 h1:xs88BrvEv273UsB79e0hcVrlUWmS0a8upikMFhSyAtA=\n go.etcd.io/bbolt v1.3.8/go.mod h1:N9Mkw9X8x5fupy0IKsmuqVtoGDyxsaDlbk4Rd05IAQw=\n go.mongodb.org/mongo-driver v1.13.1 h1:YIc7HTYsKndGK4RFzJ3covLz1byri52x0IoMB0Pt/vk="
    },
    {
      "sha": "f1c181ec9c5c921245027c6b452ecfc1d3626364",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/.gitignore",
      "status": "removed",
      "additions": 0,
      "deletions": 12,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.gitignore?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,12 +0,0 @@\n-# Binaries for programs and plugins\n-*.exe\n-*.exe~\n-*.dll\n-*.so\n-*.dylib\n-\n-# Test binary, build with `go test -c`\n-*.test\n-\n-# Output of the go coverage tool, specifically when used with LiteIDE\n-*.out"
    },
    {
      "sha": "00588ced1eddbfd895b2f8d615183ae27bc6fac3",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/.golangci.yml",
      "status": "removed",
      "additions": 0,
      "deletions": 50,
      "changes": 50,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.golangci.yml?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,50 +0,0 @@\n-linters-settings:\n-  govet:\n-    check-shadowing: true\n-  gocyclo:\n-    min-complexity: 15\n-  maligned:\n-    suggest-new: true\n-  goconst:\n-    min-len: 2\n-    min-occurrences: 2\n-  misspell:\n-    locale: US\n-  lll:\n-    line-length: 140\n-  gocritic:\n-    enabled-tags:\n-      - performance\n-      - style\n-      - experimental\n-    disabled-checks:\n-      - wrapperFunc\n-\n-linters:\n-  enable:\n-    - megacheck\n-    - revive\n-    - govet\n-    - unconvert\n-    - gas\n-    - gocyclo\n-    - dupl\n-    - misspell\n-    - unparam\n-    - typecheck\n-    - ineffassign\n-    - stylecheck\n-    - gochecknoinits\n-    - exportloopref\n-    - gocritic\n-    - nakedret\n-    - gosimple\n-    - prealloc\n-  fast: false\n-  disable-all: true\n-\n-run:\n-  output:\n-    format: tab\n-  skip-dirs:\n-    - vendor"
    },
    {
      "sha": "6a553a106a762cc42329693435a74ffe951e155e",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/README.md",
      "status": "removed",
      "additions": 0,
      "deletions": 86,
      "changes": 86,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2FREADME.md?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,86 +0,0 @@\n-# Loading Cache Wrapper [![Build Status](https://github.com/go-pkgz/lcw/workflows/build/badge.svg)](https://github.com/go-pkgz/lcw/actions) [![Coverage Status](https://coveralls.io/repos/github/go-pkgz/lcw/badge.svg?branch=master)](https://coveralls.io/github/go-pkgz/lcw?branch=master) [![godoc](https://godoc.org/github.com/go-pkgz/lcw?status.svg)](https://godoc.org/github.com/go-pkgz/lcw)\n-\n-The library adds a thin layer on top of [lru cache](https://github.com/hashicorp/golang-lru) and internal implementation\n-of expirable cache.\n-\n-| Cache name     | Constructor           | Defaults          | Description             |\n-|----------------|-----------------------|-------------------|-------------------------|\n-| LruCache       | lcw.NewLruCache       | keys=1000         | LRU cache with limits   |\n-| ExpirableCache | lcw.NewExpirableCache | keys=1000, ttl=5m | TTL cache with limits   |\n-| RedisCache     | lcw.NewRedisCache     | ttl=5m            | Redis cache with limits |\n-| Nop            | lcw.NewNopCache       |                   | Do-nothing cache        |\n-\n-Main features:\n-\n-- LoadingCache (guava style)\n-- Limit maximum cache size (in bytes)\n-- Limit maximum key size\n-- Limit maximum size of a value\n-- Limit number of keys\n-- TTL support (`ExpirableCache` and `RedisCache`)\n-- Callback on eviction event (not supported in `RedisCache`)\n-- Functional style invalidation\n-- Functional options\n-- Sane defaults\n-\n-## Install and update\n-\n-`go get -u github.com/go-pkgz/lcw`\n-\n-## Usage\n-\n-```go\n-package main\n-\n-import (\n-\t\"github.com/go-pkgz/lcw\"\n-)\n-\n-func main() {\n-\tcache, err := lcw.NewLruCache(lcw.MaxKeys(500), lcw.MaxCacheSize(65536), lcw.MaxValSize(200), lcw.MaxKeySize(32))\n-\tif err != nil {\n-\t\tpanic(\"failed to create cache\")\n-\t}\n-\tdefer cache.Close()\n-\n-\tval, err := cache.Get(\"key123\", func() (interface{}, error) {\n-\t\tres, err := getDataFromSomeSource(params) // returns string\n-\t\treturn res, err\n-\t})\n-\n-\tif err != nil {\n-\t\tpanic(\"failed to get data\")\n-\t}\n-\n-\ts := val.(string) // cached value\n-}\n-```\n-\n-### Cache with URI\n-\n-Cache can be created with URIs:\n-\n-- `mem://lru?max_key_size=10&max_val_size=1024&max_keys=50&max_cache_size=64000` - creates LRU cache with given limits\n-- `mem://expirable?ttl=30s&max_key_size=10&max_val_size=1024&max_keys=50&max_cache_size=64000` - create expirable cache\n-- `redis://10.0.0.1:1234?db=16&password=qwerty&network=tcp4&dial_timeout=1s&read_timeout=5s&write_timeout=3s` - create\n-  redis cache\n-- `nop://` - create Nop cache\n-\n-## Scoped cache\n-\n-`Scache` provides a wrapper on top of all implementations of `LoadingCache` with a number of special features:\n-\n-1. Key is not a string, but a composed type made from partition, key-id and list of scopes (tags).\n-1. Value type limited to `[]byte`\n-1. Added `Flush` method for scoped/tagged invalidation of multiple records in a given partition\n-1. A simplified interface with Get, Stat, Flush and Close only.\n-\n-## Details\n-\n-- In all cache types other than Redis (e.g. LRU and Expirable at the moment) values are stored as-is which means\n-  that mutable values can be changed outside of cache. `ExampleLoadingCache_Mutability` illustrates that.\n-- All byte-size limits (MaxCacheSize and MaxValSize) only work for values implementing `lcw.Sizer` interface.\n-- Negative limits (max options) rejected\n-- The implementation started as a part of [remark42](https://github.com/umputun/remark)\n-  and later on moved to [go-pkgz/rest](https://github.com/go-pkgz/rest/tree/master/cache)\n-  library and finally generalized to become `lcw`."
    },
    {
      "sha": "b1d386e3c385aa46ebc28237cf1e3a0f99282df7",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/internal/cache/cache.go",
      "status": "removed",
      "additions": 0,
      "deletions": 247,
      "changes": 247,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Fcache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Fcache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Fcache.go?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,247 +0,0 @@\n-// Package cache implements LoadingCache.\n-//\n-// Support LRC TTL-based eviction.\n-package cache\n-\n-import (\n-\t\"fmt\"\n-\t\"sort\"\n-\t\"sync\"\n-\t\"time\"\n-)\n-\n-// LoadingCache provides expirable loading cache with LRC eviction.\n-type LoadingCache struct {\n-\tpurgeEvery time.Duration\n-\tttl        time.Duration\n-\tmaxKeys    int64\n-\tdone       chan struct{}\n-\tonEvicted  func(key string, value interface{})\n-\n-\tmu   sync.Mutex\n-\tdata map[string]*cacheItem\n-}\n-\n-// noEvictionTTL - very long ttl to prevent eviction\n-const noEvictionTTL = time.Hour * 24 * 365 * 10\n-\n-// NewLoadingCache returns a new expirable LRC cache, activates purge with purgeEvery (0 to never purge).\n-// Default MaxKeys is unlimited (0).\n-func NewLoadingCache(options ...Option) (*LoadingCache, error) {\n-\tres := LoadingCache{\n-\t\tdata:       map[string]*cacheItem{},\n-\t\tttl:        noEvictionTTL,\n-\t\tpurgeEvery: 0,\n-\t\tmaxKeys:    0,\n-\t\tdone:       make(chan struct{}),\n-\t}\n-\n-\tfor _, opt := range options {\n-\t\tif err := opt(&res); err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n-\t\t}\n-\t}\n-\n-\tif res.maxKeys > 0 || res.purgeEvery > 0 {\n-\t\tif res.purgeEvery == 0 {\n-\t\t\tres.purgeEvery = time.Minute * 5 // non-zero purge enforced because maxKeys defined\n-\t\t}\n-\t\tgo func(done <-chan struct{}) {\n-\t\t\tticker := time.NewTicker(res.purgeEvery)\n-\t\t\tfor {\n-\t\t\t\tselect {\n-\t\t\t\tcase <-done:\n-\t\t\t\t\treturn\n-\t\t\t\tcase <-ticker.C:\n-\t\t\t\t\tres.mu.Lock()\n-\t\t\t\t\tres.purge(res.maxKeys)\n-\t\t\t\t\tres.mu.Unlock()\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}(res.done)\n-\t}\n-\treturn &res, nil\n-}\n-\n-// Set key\n-func (c *LoadingCache) Set(key string, value interface{}) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\n-\tnow := time.Now()\n-\tif _, ok := c.data[key]; !ok {\n-\t\tc.data[key] = &cacheItem{}\n-\t}\n-\tc.data[key].data = value\n-\tc.data[key].expiresAt = now.Add(c.ttl)\n-\n-\t// Enforced purge call in addition the one from the ticker\n-\t// to limit the worst-case scenario with a lot of sets in the\n-\t// short period of time (between two timed purge calls)\n-\tif c.maxKeys > 0 && int64(len(c.data)) >= c.maxKeys*2 {\n-\t\tc.purge(c.maxKeys)\n-\t}\n-}\n-\n-// Get returns the key value\n-func (c *LoadingCache) Get(key string) (interface{}, bool) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tvalue, ok := c.getValue(key)\n-\tif !ok {\n-\t\treturn nil, false\n-\t}\n-\treturn value, ok\n-}\n-\n-// Peek returns the key value (or undefined if not found) without updating the \"recently used\"-ness of the key.\n-func (c *LoadingCache) Peek(key string) (interface{}, bool) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tvalue, ok := c.getValue(key)\n-\tif !ok {\n-\t\treturn nil, false\n-\t}\n-\treturn value, ok\n-}\n-\n-// Invalidate key (item) from the cache\n-func (c *LoadingCache) Invalidate(key string) {\n-\tc.mu.Lock()\n-\tif value, ok := c.data[key]; ok {\n-\t\tdelete(c.data, key)\n-\t\tif c.onEvicted != nil {\n-\t\t\tc.onEvicted(key, value.data)\n-\t\t}\n-\t}\n-\tc.mu.Unlock()\n-}\n-\n-// InvalidateFn deletes multiple keys if predicate is true\n-func (c *LoadingCache) InvalidateFn(fn func(key string) bool) {\n-\tc.mu.Lock()\n-\tfor key, value := range c.data {\n-\t\tif fn(key) {\n-\t\t\tdelete(c.data, key)\n-\t\t\tif c.onEvicted != nil {\n-\t\t\t\tc.onEvicted(key, value.data)\n-\t\t\t}\n-\t\t}\n-\t}\n-\tc.mu.Unlock()\n-}\n-\n-// Keys return slice of current keys in the cache\n-func (c *LoadingCache) Keys() []string {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tkeys := make([]string, 0, len(c.data))\n-\tfor k := range c.data {\n-\t\tkeys = append(keys, k)\n-\t}\n-\treturn keys\n-}\n-\n-// get value respecting the expiration, should be called with lock\n-func (c *LoadingCache) getValue(key string) (interface{}, bool) {\n-\tvalue, ok := c.data[key]\n-\tif !ok {\n-\t\treturn nil, false\n-\t}\n-\tif time.Now().After(c.data[key].expiresAt) {\n-\t\treturn nil, false\n-\t}\n-\treturn value.data, ok\n-}\n-\n-// Purge clears the cache completely.\n-func (c *LoadingCache) Purge() {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tfor k, v := range c.data {\n-\t\tdelete(c.data, k)\n-\t\tif c.onEvicted != nil {\n-\t\t\tc.onEvicted(k, v.data)\n-\t\t}\n-\t}\n-}\n-\n-// DeleteExpired clears cache of expired items\n-func (c *LoadingCache) DeleteExpired() {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tc.purge(0)\n-}\n-\n-// ItemCount return count of items in cache\n-func (c *LoadingCache) ItemCount() int {\n-\tc.mu.Lock()\n-\tn := len(c.data)\n-\tc.mu.Unlock()\n-\treturn n\n-}\n-\n-// Close cleans the cache and destroys running goroutines\n-func (c *LoadingCache) Close() {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\t// don't panic in case service is already closed\n-\tselect {\n-\tcase <-c.done:\n-\t\treturn\n-\tdefault:\n-\t}\n-\tclose(c.done)\n-}\n-\n-// keysWithTS includes list of keys with ts. This is for sorting keys\n-// in order to provide least recently added sorting for size-based eviction\n-type keysWithTS []struct {\n-\tkey string\n-\tts  time.Time\n-}\n-\n-// purge records > maxKeys. Has to be called with lock!\n-// call with maxKeys 0 will only clear expired entries.\n-func (c *LoadingCache) purge(maxKeys int64) {\n-\tkts := keysWithTS{}\n-\n-\tfor key, value := range c.data {\n-\t\t// ttl eviction\n-\t\tif time.Now().After(c.data[key].expiresAt) {\n-\t\t\tdelete(c.data, key)\n-\t\t\tif c.onEvicted != nil {\n-\t\t\t\tc.onEvicted(key, value.data)\n-\t\t\t}\n-\t\t}\n-\n-\t\t// prepare list of keysWithTS for size eviction\n-\t\tif maxKeys > 0 && int64(len(c.data)) > maxKeys {\n-\t\t\tts := c.data[key].expiresAt\n-\n-\t\t\tkts = append(kts, struct {\n-\t\t\t\tkey string\n-\t\t\t\tts  time.Time\n-\t\t\t}{key, ts})\n-\t\t}\n-\t}\n-\n-\t// size eviction\n-\tsize := int64(len(c.data))\n-\tif len(kts) > 0 {\n-\t\tsort.Slice(kts, func(i int, j int) bool { return kts[i].ts.Before(kts[j].ts) })\n-\t\tfor d := 0; int64(d) < size-maxKeys; d++ {\n-\t\t\tkey := kts[d].key\n-\t\t\tvalue := c.data[key].data\n-\t\t\tdelete(c.data, key)\n-\t\t\tif c.onEvicted != nil {\n-\t\t\t\tc.onEvicted(key, value)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-type cacheItem struct {\n-\texpiresAt time.Time\n-\tdata      interface{}\n-}"
    },
    {
      "sha": "f1262e9daa004d7137ae5ecfd0654ae797e95d65",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/internal/cache/options.go",
      "status": "removed",
      "additions": 0,
      "deletions": 42,
      "changes": 42,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Foptions.go",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Foptions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Foptions.go?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,42 +0,0 @@\n-package cache\n-\n-import \"time\"\n-\n-// Option func type\n-type Option func(lc *LoadingCache) error\n-\n-// OnEvicted called automatically for expired and manually deleted entries\n-func OnEvicted(fn func(key string, value interface{})) Option {\n-\treturn func(lc *LoadingCache) error {\n-\t\tlc.onEvicted = fn\n-\t\treturn nil\n-\t}\n-}\n-\n-// PurgeEvery functional option defines purge interval\n-// by default it is 0, i.e. never. If MaxKeys set to any non-zero this default will be 5minutes\n-func PurgeEvery(interval time.Duration) Option {\n-\treturn func(lc *LoadingCache) error {\n-\t\tlc.purgeEvery = interval\n-\t\treturn nil\n-\t}\n-}\n-\n-// MaxKeys functional option defines how many keys to keep.\n-// By default it is 0, which means unlimited.\n-// If any non-zero MaxKeys set, default PurgeEvery will be set to 5 minutes\n-func MaxKeys(max int) Option {\n-\treturn func(lc *LoadingCache) error {\n-\t\tlc.maxKeys = int64(max)\n-\t\treturn nil\n-\t}\n-}\n-\n-// TTL functional option defines TTL for all cache entries.\n-// By default it is set to 10 years, sane option for expirable cache might be 5 minutes.\n-func TTL(ttl time.Duration) Option {\n-\treturn func(lc *LoadingCache) error {\n-\t\tlc.ttl = ttl\n-\t\treturn nil\n-\t}\n-}"
    },
    {
      "sha": "c1b684bfdd131c354389d84f2b103eba2eaf9536",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/LICENSE",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2FLICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2FLICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2FLICENSE?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/LICENSE"
    },
    {
      "sha": "58e259bb6d884a92fb6e71216ced7eab84294447",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/cache.go",
      "status": "renamed",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fcache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fcache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fcache.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -17,15 +17,15 @@ type Sizer interface {\n }\n \n // LoadingCache defines guava-like cache with Get method returning cached value ao retrieving it if not in cache\n-type LoadingCache interface {\n-\tGet(key string, fn func() (interface{}, error)) (val interface{}, err error) // load or get from cache\n-\tPeek(key string) (interface{}, bool)                                         // get from cache by key\n-\tInvalidate(fn func(key string) bool)                                         // invalidate items for func(key) == true\n-\tDelete(key string)                                                           // delete by key\n-\tPurge()                                                                      // clear cache\n-\tStat() CacheStat                                                             // cache stats\n-\tKeys() []string                                                              // list of all keys\n-\tClose() error                                                                // close open connections\n+type LoadingCache[V any] interface {\n+\tGet(key string, fn func() (V, error)) (val V, err error) // load or get from cache\n+\tPeek(key string) (V, bool)                               // get from cache by key\n+\tInvalidate(fn func(key string) bool)                     // invalidate items for func(key) == true\n+\tDelete(key string)                                       // delete by key\n+\tPurge()                                                  // clear cache\n+\tStat() CacheStat                                         // cache stats\n+\tKeys() []string                                          // list of all keys\n+\tClose() error                                            // close open connections\n }\n \n // CacheStat represent stats values\n@@ -48,37 +48,37 @@ func (s CacheStat) String() string {\n }\n \n // Nop is do-nothing implementation of LoadingCache\n-type Nop struct{}\n+type Nop[V any] struct{}\n \n // NewNopCache makes new do-nothing cache\n-func NewNopCache() *Nop {\n-\treturn &Nop{}\n+func NewNopCache[V any]() *Nop[V] {\n+\treturn &Nop[V]{}\n }\n \n // Get calls fn without any caching\n-func (n *Nop) Get(_ string, fn func() (interface{}, error)) (interface{}, error) { return fn() }\n+func (n *Nop[V]) Get(_ string, fn func() (V, error)) (V, error) { return fn() }\n \n // Peek does nothing and always returns false\n-func (n *Nop) Peek(string) (interface{}, bool) { return nil, false }\n+func (n *Nop[V]) Peek(string) (V, bool) { var emptyValue V; return emptyValue, false }\n \n // Invalidate does nothing for nop cache\n-func (n *Nop) Invalidate(func(key string) bool) {}\n+func (n *Nop[V]) Invalidate(func(key string) bool) {}\n \n // Purge does nothing for nop cache\n-func (n *Nop) Purge() {}\n+func (n *Nop[V]) Purge() {}\n \n // Delete does nothing for nop cache\n-func (n *Nop) Delete(string) {}\n+func (n *Nop[V]) Delete(string) {}\n \n // Keys does nothing for nop cache\n-func (n *Nop) Keys() []string { return nil }\n+func (n *Nop[V]) Keys() []string { return nil }\n \n // Stat always 0s for nop cache\n-func (n *Nop) Stat() CacheStat {\n+func (n *Nop[V]) Stat() CacheStat {\n \treturn CacheStat{}\n }\n \n // Close does nothing for nop cache\n-func (n *Nop) Close() error {\n+func (n *Nop[V]) Close() error {\n \treturn nil\n }",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/cache.go"
    },
    {
      "sha": "c0afcfb00f270a51889a2de3bc9878ae9ee0c091",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/eventbus/pubsub.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Feventbus%2Fpubsub.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Feventbus%2Fpubsub.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Feventbus%2Fpubsub.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/eventbus/pubsub.go"
    },
    {
      "sha": "b97870c88ccfc6261851a32f1067009a6564a433",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/eventbus/redis.go",
      "status": "renamed",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Feventbus%2Fredis.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Feventbus%2Fredis.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Feventbus%2Fredis.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -6,9 +6,8 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"github.com/redis/go-redis/v9\"\n-\n \t\"github.com/hashicorp/go-multierror\"\n+\t\"github.com/redis/go-redis/v9\"\n )\n \n // NewRedisPubSub creates new RedisPubSub with given parameters.\n@@ -67,6 +66,7 @@ func (m *RedisPubSub) Publish(fromID, key string) error {\n // Close cleans up running goroutines and closes Redis clients\n func (m *RedisPubSub) Close() error {\n \tclose(m.done)\n+\n \terrs := new(multierror.Error)\n \tif err := m.pubSub.Close(); err != nil {\n \t\terrs = multierror.Append(errs, fmt.Errorf(\"problem closing pubSub client: %w\", err))",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/eventbus/redis.go"
    },
    {
      "sha": "6d64f4a99262f57b2f3fa1b807678c5b8fe50779",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/expirable_cache.go",
      "status": "renamed",
      "additions": 52,
      "deletions": 54,
      "changes": 106,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fexpirable_cache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fexpirable_cache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fexpirable_cache.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -5,24 +5,25 @@ import (\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/go-pkgz/lcw/eventbus\"\n-\t\"github.com/go-pkgz/lcw/internal/cache\"\n \t\"github.com/google/uuid\"\n+\t\"github.com/hashicorp/golang-lru/v2/expirable\"\n+\n+\t\"github.com/go-pkgz/lcw/v2/eventbus\"\n )\n \n // ExpirableCache implements LoadingCache with TTL.\n-type ExpirableCache struct {\n-\toptions\n+type ExpirableCache[V any] struct {\n+\tWorkers[V]\n \tCacheStat\n \tcurrentSize int64\n \tid          string\n-\tbackend     *cache.LoadingCache\n+\tbackend     *expirable.LRU[string, V]\n }\n \n // NewExpirableCache makes expirable LoadingCache implementation, 1000 max keys by default and 5m TTL\n-func NewExpirableCache(opts ...Option) (*ExpirableCache, error) {\n-\tres := ExpirableCache{\n-\t\toptions: options{\n+func NewExpirableCache[V any](opts ...Option[V]) (*ExpirableCache[V], error) {\n+\tres := ExpirableCache[V]{\n+\t\tWorkers: Workers[V]{\n \t\t\tmaxKeys:      1000,\n \t\t\tmaxValueSize: 0,\n \t\t\tttl:          5 * time.Minute,\n@@ -32,7 +33,7 @@ func NewExpirableCache(opts ...Option) (*ExpirableCache, error) {\n \t}\n \n \tfor _, opt := range opts {\n-\t\tif err := opt(&res.options); err != nil {\n+\t\tif err := opt(&res.Workers); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n \t\t}\n \t}\n@@ -41,34 +42,25 @@ func NewExpirableCache(opts ...Option) (*ExpirableCache, error) {\n \t\treturn nil, fmt.Errorf(\"can't subscribe to event bus: %w\", err)\n \t}\n \n-\tbackend, err := cache.NewLoadingCache(\n-\t\tcache.MaxKeys(res.maxKeys),\n-\t\tcache.TTL(res.ttl),\n-\t\tcache.PurgeEvery(res.ttl/2),\n-\t\tcache.OnEvicted(func(key string, value interface{}) {\n-\t\t\tif res.onEvicted != nil {\n-\t\t\t\tres.onEvicted(key, value)\n-\t\t\t}\n-\t\t\tif s, ok := value.(Sizer); ok {\n-\t\t\t\tsize := s.Size()\n-\t\t\t\tatomic.AddInt64(&res.currentSize, -1*int64(size))\n-\t\t\t}\n-\t\t\t// ignore the error on Publish as we don't have log inside the module and\n-\t\t\t// there is no other way to handle it: we publish the cache invalidation\n-\t\t\t// and hope for the best\n-\t\t\t_ = res.eventBus.Publish(res.id, key)\n-\t\t}),\n-\t)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"error creating backend: %w\", err)\n-\t}\n-\tres.backend = backend\n+\tres.backend = expirable.NewLRU[string, V](res.maxKeys, func(key string, value V) {\n+\t\tif res.onEvicted != nil {\n+\t\t\tres.onEvicted(key, value)\n+\t\t}\n+\t\tif s, ok := any(value).(Sizer); ok {\n+\t\t\tsize := s.Size()\n+\t\t\tatomic.AddInt64(&res.currentSize, -1*int64(size))\n+\t\t}\n+\t\t// ignore the error on Publish as we don't have log inside the module and\n+\t\t// there is no other way to handle it: we publish the cache invalidation\n+\t\t// and hope for the best\n+\t\t_ = res.eventBus.Publish(res.id, key)\n+\t}, res.ttl)\n \n \treturn &res, nil\n }\n \n // Get gets value by key or load with fn if not found in cache\n-func (c *ExpirableCache) Get(key string, fn func() (interface{}, error)) (data interface{}, err error) {\n+func (c *ExpirableCache[V]) Get(key string, fn func() (V, error)) (data V, err error) {\n \tif v, ok := c.backend.Get(key); ok {\n \t\tatomic.AddInt64(&c.Hits, 1)\n \t\treturn v, nil\n@@ -84,47 +76,50 @@ func (c *ExpirableCache) Get(key string, fn func() (interface{}, error)) (data i\n \t\treturn data, nil\n \t}\n \n-\tif s, ok := data.(Sizer); ok {\n+\tif s, ok := any(data).(Sizer); ok {\n \t\tif c.maxCacheSize > 0 && atomic.LoadInt64(&c.currentSize)+int64(s.Size()) >= c.maxCacheSize {\n-\t\t\tc.backend.DeleteExpired()\n \t\t\treturn data, nil\n \t\t}\n \t\tatomic.AddInt64(&c.currentSize, int64(s.Size()))\n \t}\n \n-\tc.backend.Set(key, data)\n+\tc.backend.Add(key, data)\n \n \treturn data, nil\n }\n \n // Invalidate removes keys with passed predicate fn, i.e. fn(key) should be true to get evicted\n-func (c *ExpirableCache) Invalidate(fn func(key string) bool) {\n-\tc.backend.InvalidateFn(fn)\n+func (c *ExpirableCache[V]) Invalidate(fn func(key string) bool) {\n+\tfor _, key := range c.backend.Keys() {\n+\t\tif fn(key) {\n+\t\t\tc.backend.Remove(key)\n+\t\t}\n+\t}\n }\n \n // Peek returns the key value (or undefined if not found) without updating the \"recently used\"-ness of the key.\n-func (c *ExpirableCache) Peek(key string) (interface{}, bool) {\n+func (c *ExpirableCache[V]) Peek(key string) (V, bool) {\n \treturn c.backend.Peek(key)\n }\n \n // Purge clears the cache completely.\n-func (c *ExpirableCache) Purge() {\n+func (c *ExpirableCache[V]) Purge() {\n \tc.backend.Purge()\n \tatomic.StoreInt64(&c.currentSize, 0)\n }\n \n // Delete cache item by key\n-func (c *ExpirableCache) Delete(key string) {\n-\tc.backend.Invalidate(key)\n+func (c *ExpirableCache[V]) Delete(key string) {\n+\tc.backend.Remove(key)\n }\n \n // Keys returns cache keys\n-func (c *ExpirableCache) Keys() (res []string) {\n+func (c *ExpirableCache[V]) Keys() (res []string) {\n \treturn c.backend.Keys()\n }\n \n // Stat returns cache statistics\n-func (c *ExpirableCache) Stat() CacheStat {\n+func (c *ExpirableCache[V]) Stat() CacheStat {\n \treturn CacheStat{\n \t\tHits:   c.Hits,\n \t\tMisses: c.Misses,\n@@ -134,35 +129,38 @@ func (c *ExpirableCache) Stat() CacheStat {\n \t}\n }\n \n-// Close kills cleanup goroutine\n-func (c *ExpirableCache) Close() error {\n-\tc.backend.Close()\n+// Close supposed to kill cleanup goroutine,\n+// but it's not possible before https://github.com/hashicorp/golang-lru/issues/159 is solved\n+// so for now it just cleans it.\n+func (c *ExpirableCache[V]) Close() error {\n+\tc.backend.Purge()\n+\tatomic.StoreInt64(&c.currentSize, 0)\n \treturn nil\n }\n \n // onBusEvent reacts on invalidation message triggered by event bus from another cache instance\n-func (c *ExpirableCache) onBusEvent(id, key string) {\n+func (c *ExpirableCache[V]) onBusEvent(id, key string) {\n \tif id != c.id {\n-\t\tc.backend.Invalidate(key)\n+\t\tc.backend.Remove(key)\n \t}\n }\n \n-func (c *ExpirableCache) size() int64 {\n+func (c *ExpirableCache[V]) size() int64 {\n \treturn atomic.LoadInt64(&c.currentSize)\n }\n \n-func (c *ExpirableCache) keys() int {\n-\treturn c.backend.ItemCount()\n+func (c *ExpirableCache[V]) keys() int {\n+\treturn c.backend.Len()\n }\n \n-func (c *ExpirableCache) allowed(key string, data interface{}) bool {\n-\tif c.backend.ItemCount() >= c.maxKeys {\n+func (c *ExpirableCache[V]) allowed(key string, data V) bool {\n+\tif c.backend.Len() >= c.maxKeys {\n \t\treturn false\n \t}\n \tif c.maxKeySize > 0 && len(key) > c.maxKeySize {\n \t\treturn false\n \t}\n-\tif s, ok := data.(Sizer); ok {\n+\tif s, ok := any(data).(Sizer); ok {\n \t\tif c.maxValueSize > 0 && s.Size() >= c.maxValueSize {\n \t\t\treturn false\n \t\t}",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/expirable_cache.go"
    },
    {
      "sha": "9c63490b6fd844aeadb91f6743bc4270b3a46c82",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/lru_cache.go",
      "status": "renamed",
      "additions": 33,
      "deletions": 37,
      "changes": 70,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Flru_cache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Flru_cache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Flru_cache.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -4,32 +4,33 @@ import (\n \t\"fmt\"\n \t\"sync/atomic\"\n \n-\t\"github.com/go-pkgz/lcw/eventbus\"\n \t\"github.com/google/uuid\"\n-\tlru \"github.com/hashicorp/golang-lru\"\n+\tlru \"github.com/hashicorp/golang-lru/v2\"\n+\n+\t\"github.com/go-pkgz/lcw/v2/eventbus\"\n )\n \n // LruCache wraps lru.LruCache with loading cache Get and size limits\n-type LruCache struct {\n-\toptions\n+type LruCache[V any] struct {\n+\tWorkers[V]\n \tCacheStat\n-\tbackend     *lru.Cache\n+\tbackend     *lru.Cache[string, V]\n \tcurrentSize int64\n \tid          string // uuid identifying cache instance\n }\n \n // NewLruCache makes LRU LoadingCache implementation, 1000 max keys by default\n-func NewLruCache(opts ...Option) (*LruCache, error) {\n-\tres := LruCache{\n-\t\toptions: options{\n+func NewLruCache[V any](opts ...Option[V]) (*LruCache[V], error) {\n+\tres := LruCache[V]{\n+\t\tWorkers: Workers[V]{\n \t\t\tmaxKeys:      1000,\n \t\t\tmaxValueSize: 0,\n \t\t\teventBus:     &eventbus.NopPubSub{},\n \t\t},\n \t\tid: uuid.New().String(),\n \t}\n \tfor _, opt := range opts {\n-\t\tif err := opt(&res.options); err != nil {\n+\t\tif err := opt(&res.Workers); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n \t\t}\n \t}\n@@ -38,33 +39,33 @@ func NewLruCache(opts ...Option) (*LruCache, error) {\n \treturn &res, err\n }\n \n-func (c *LruCache) init() error {\n+func (c *LruCache[V]) init() error {\n \tif err := c.eventBus.Subscribe(c.onBusEvent); err != nil {\n \t\treturn fmt.Errorf(\"can't subscribe to event bus: %w\", err)\n \t}\n \n-\tonEvicted := func(key interface{}, value interface{}) {\n+\tonEvicted := func(key string, value V) {\n \t\tif c.onEvicted != nil {\n-\t\t\tc.onEvicted(key.(string), value)\n+\t\t\tc.onEvicted(key, value)\n \t\t}\n-\t\tif s, ok := value.(Sizer); ok {\n+\t\tif s, ok := any(value).(Sizer); ok {\n \t\t\tsize := s.Size()\n \t\t\tatomic.AddInt64(&c.currentSize, -1*int64(size))\n \t\t}\n-\t\t_ = c.eventBus.Publish(c.id, key.(string)) // signal invalidation to other nodes\n+\t\t_ = c.eventBus.Publish(c.id, key) // signal invalidation to other nodes\n \t}\n \n \tvar err error\n \t// OnEvicted called automatically for expired and manually deleted\n-\tif c.backend, err = lru.NewWithEvict(c.maxKeys, onEvicted); err != nil {\n+\tif c.backend, err = lru.NewWithEvict[string, V](c.maxKeys, onEvicted); err != nil {\n \t\treturn fmt.Errorf(\"failed to make lru cache backend: %w\", err)\n \t}\n \n \treturn nil\n }\n \n // Get gets value by key or load with fn if not found in cache\n-func (c *LruCache) Get(key string, fn func() (interface{}, error)) (data interface{}, err error) {\n+func (c *LruCache[V]) Get(key string, fn func() (V, error)) (data V, err error) {\n \tif v, ok := c.backend.Get(key); ok {\n \t\tatomic.AddInt64(&c.Hits, 1)\n \t\treturn v, nil\n@@ -83,7 +84,7 @@ func (c *LruCache) Get(key string, fn func() (interface{}, error)) (data interfa\n \n \tc.backend.Add(key, data)\n \n-\tif s, ok := data.(Sizer); ok {\n+\tif s, ok := any(data).(Sizer); ok {\n \t\tatomic.AddInt64(&c.currentSize, int64(s.Size()))\n \t\tif c.maxCacheSize > 0 && atomic.LoadInt64(&c.currentSize) > c.maxCacheSize {\n \t\t\tfor atomic.LoadInt64(&c.currentSize) > c.maxCacheSize {\n@@ -96,42 +97,37 @@ func (c *LruCache) Get(key string, fn func() (interface{}, error)) (data interfa\n }\n \n // Peek returns the key value (or undefined if not found) without updating the \"recently used\"-ness of the key.\n-func (c *LruCache) Peek(key string) (interface{}, bool) {\n+func (c *LruCache[V]) Peek(key string) (V, bool) {\n \treturn c.backend.Peek(key)\n }\n \n // Purge clears the cache completely.\n-func (c *LruCache) Purge() {\n+func (c *LruCache[V]) Purge() {\n \tc.backend.Purge()\n \tatomic.StoreInt64(&c.currentSize, 0)\n }\n \n // Invalidate removes keys with passed predicate fn, i.e. fn(key) should be true to get evicted\n-func (c *LruCache) Invalidate(fn func(key string) bool) {\n+func (c *LruCache[V]) Invalidate(fn func(key string) bool) {\n \tfor _, k := range c.backend.Keys() { // Keys() returns copy of cache's key, safe to remove directly\n-\t\tif key, ok := k.(string); ok && fn(key) {\n-\t\t\tc.backend.Remove(key)\n+\t\tif fn(k) {\n+\t\t\tc.backend.Remove(k)\n \t\t}\n \t}\n }\n \n // Delete cache item by key\n-func (c *LruCache) Delete(key string) {\n+func (c *LruCache[V]) Delete(key string) {\n \tc.backend.Remove(key)\n }\n \n // Keys returns cache keys\n-func (c *LruCache) Keys() (res []string) {\n-\tkeys := c.backend.Keys()\n-\tres = make([]string, 0, len(keys))\n-\tfor _, key := range keys {\n-\t\tres = append(res, key.(string))\n-\t}\n-\treturn res\n+func (c *LruCache[V]) Keys() (res []string) {\n+\treturn c.backend.Keys()\n }\n \n // Stat returns cache statistics\n-func (c *LruCache) Stat() CacheStat {\n+func (c *LruCache[V]) Stat() CacheStat {\n \treturn CacheStat{\n \t\tHits:   c.Hits,\n \t\tMisses: c.Misses,\n@@ -142,30 +138,30 @@ func (c *LruCache) Stat() CacheStat {\n }\n \n // Close does nothing for this type of cache\n-func (c *LruCache) Close() error {\n+func (c *LruCache[V]) Close() error {\n \treturn nil\n }\n \n // onBusEvent reacts on invalidation message triggered by event bus from another cache instance\n-func (c *LruCache) onBusEvent(id, key string) {\n+func (c *LruCache[V]) onBusEvent(id, key string) {\n \tif id != c.id && c.backend.Contains(key) { // prevent reaction on event from this cache\n \t\tc.backend.Remove(key)\n \t}\n }\n \n-func (c *LruCache) size() int64 {\n+func (c *LruCache[V]) size() int64 {\n \treturn atomic.LoadInt64(&c.currentSize)\n }\n \n-func (c *LruCache) keys() int {\n+func (c *LruCache[V]) keys() int {\n \treturn c.backend.Len()\n }\n \n-func (c *LruCache) allowed(key string, data interface{}) bool {\n+func (c *LruCache[V]) allowed(key string, data V) bool {\n \tif c.maxKeySize > 0 && len(key) > c.maxKeySize {\n \t\treturn false\n \t}\n-\tif s, ok := data.(Sizer); ok {\n+\tif s, ok := any(data).(Sizer); ok {\n \t\tif c.maxValueSize > 0 && s.Size() >= c.maxValueSize {\n \t\t\treturn false\n \t\t}",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/lru_cache.go"
    },
    {
      "sha": "c960d13e4d812d9786d9d6f2a1b0221df5c3da3a",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/options.go",
      "status": "renamed",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Foptions.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Foptions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Foptions.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -4,26 +4,35 @@ import (\n \t\"fmt\"\n \t\"time\"\n \n-\t\"github.com/go-pkgz/lcw/eventbus\"\n+\t\"github.com/go-pkgz/lcw/v2/eventbus\"\n )\n \n-type options struct {\n+type Workers[V any] struct {\n \tmaxKeys      int\n \tmaxValueSize int\n \tmaxKeySize   int\n \tmaxCacheSize int64\n \tttl          time.Duration\n-\tonEvicted    func(key string, value interface{})\n+\tonEvicted    func(key string, value V)\n \teventBus     eventbus.PubSub\n+\tstrToV       func(string) V\n }\n \n // Option func type\n-type Option func(o *options) error\n+type Option[V any] func(o *Workers[V]) error\n+\n+// WorkerOptions holds the option setting methods\n+type WorkerOptions[T any] struct{}\n+\n+// NewOpts creates a new WorkerOptions instance\n+func NewOpts[T any]() *WorkerOptions[T] {\n+\treturn &WorkerOptions[T]{}\n+}\n \n // MaxValSize functional option defines the largest value's size allowed to be cached\n // By default it is 0, which means unlimited.\n-func MaxValSize(max int) Option {\n-\treturn func(o *options) error {\n+func (o *WorkerOptions[V]) MaxValSize(max int) Option[V] {\n+\treturn func(o *Workers[V]) error {\n \t\tif max < 0 {\n \t\t\treturn fmt.Errorf(\"negative max value size\")\n \t\t}\n@@ -34,8 +43,8 @@ func MaxValSize(max int) Option {\n \n // MaxKeySize functional option defines the largest key's size allowed to be used in cache\n // By default it is 0, which means unlimited.\n-func MaxKeySize(max int) Option {\n-\treturn func(o *options) error {\n+func (o *WorkerOptions[V]) MaxKeySize(max int) Option[V] {\n+\treturn func(o *Workers[V]) error {\n \t\tif max < 0 {\n \t\t\treturn fmt.Errorf(\"negative max key size\")\n \t\t}\n@@ -45,9 +54,9 @@ func MaxKeySize(max int) Option {\n }\n \n // MaxKeys functional option defines how many keys to keep.\n-// By default it is 0, which means unlimited.\n-func MaxKeys(max int) Option {\n-\treturn func(o *options) error {\n+// By default, it is 0, which means unlimited.\n+func (o *WorkerOptions[V]) MaxKeys(max int) Option[V] {\n+\treturn func(o *Workers[V]) error {\n \t\tif max < 0 {\n \t\t\treturn fmt.Errorf(\"negative max keys\")\n \t\t}\n@@ -57,9 +66,9 @@ func MaxKeys(max int) Option {\n }\n \n // MaxCacheSize functional option defines the total size of cached data.\n-// By default it is 0, which means unlimited.\n-func MaxCacheSize(max int64) Option {\n-\treturn func(o *options) error {\n+// By default, it is 0, which means unlimited.\n+func (o *WorkerOptions[V]) MaxCacheSize(max int64) Option[V] {\n+\treturn func(o *Workers[V]) error {\n \t\tif max < 0 {\n \t\t\treturn fmt.Errorf(\"negative max cache size\")\n \t\t}\n@@ -70,8 +79,8 @@ func MaxCacheSize(max int64) Option {\n \n // TTL functional option defines duration.\n // Works for ExpirableCache only\n-func TTL(ttl time.Duration) Option {\n-\treturn func(o *options) error {\n+func (o *WorkerOptions[V]) TTL(ttl time.Duration) Option[V] {\n+\treturn func(o *Workers[V]) error {\n \t\tif ttl < 0 {\n \t\t\treturn fmt.Errorf(\"negative ttl\")\n \t\t}\n@@ -81,17 +90,25 @@ func TTL(ttl time.Duration) Option {\n }\n \n // OnEvicted sets callback on invalidation event\n-func OnEvicted(fn func(key string, value interface{})) Option {\n-\treturn func(o *options) error {\n+func (o *WorkerOptions[V]) OnEvicted(fn func(key string, value V)) Option[V] {\n+\treturn func(o *Workers[V]) error {\n \t\to.onEvicted = fn\n \t\treturn nil\n \t}\n }\n \n // EventBus sets PubSub for distributed cache invalidation\n-func EventBus(pubSub eventbus.PubSub) Option {\n-\treturn func(o *options) error {\n+func (o *WorkerOptions[V]) EventBus(pubSub eventbus.PubSub) Option[V] {\n+\treturn func(o *Workers[V]) error {\n \t\to.eventBus = pubSub\n \t\treturn nil\n \t}\n }\n+\n+// StrToV sets strToV function for RedisCache\n+func (o *WorkerOptions[V]) StrToV(fn func(string) V) Option[V] {\n+\treturn func(o *Workers[V]) error {\n+\t\to.strToV = fn\n+\t\treturn nil\n+\t}\n+}",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/options.go"
    },
    {
      "sha": "732ddf3140ef171aba6844c60e050ef40b40e00b",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/redis_cache.go",
      "status": "renamed",
      "additions": 61,
      "deletions": 26,
      "changes": 87,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fredis_cache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fredis_cache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fredis_cache.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -2,7 +2,9 @@ package lcw\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n+\t\"reflect\"\n \t\"sync/atomic\"\n \t\"time\"\n \n@@ -13,25 +15,42 @@ import (\n const RedisValueSizeLimit = 512 * 1024 * 1024\n \n // RedisCache implements LoadingCache for Redis.\n-type RedisCache struct {\n-\toptions\n+type RedisCache[V any] struct {\n+\tWorkers[V]\n \tCacheStat\n \tbackend *redis.Client\n }\n \n // NewRedisCache makes Redis LoadingCache implementation.\n-func NewRedisCache(backend *redis.Client, opts ...Option) (*RedisCache, error) {\n-\tres := RedisCache{\n-\t\toptions: options{\n+// Supports only string and string-based types and will return error otherwise.\n+func NewRedisCache[V any](backend *redis.Client, opts ...Option[V]) (*RedisCache[V], error) {\n+\t// check if V is string, not underlying type but directly, and otherwise return error if strToV is nil as it should be defined\n+\n+\tres := RedisCache[V]{\n+\t\tWorkers: Workers[V]{\n \t\t\tttl: 5 * time.Minute,\n \t\t},\n \t}\n \tfor _, opt := range opts {\n-\t\tif err := opt(&res.options); err != nil {\n+\t\tif err := opt(&res.Workers); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n \t\t}\n \t}\n \n+\t// check if underlying type is string, so we can safely store it in Redis\n+\tvar v V\n+\tif reflect.TypeOf(v).Kind() != reflect.String {\n+\t\treturn nil, fmt.Errorf(\"can't store non-string types in Redis cache\")\n+\t}\n+\tswitch any(v).(type) {\n+\tcase string:\n+\t// check strToV option only for string-like but non string types\n+\tdefault:\n+\t\tif res.strToV == nil {\n+\t\t\treturn nil, fmt.Errorf(\"StrToV option should be set for string-like type\")\n+\t\t}\n+\t}\n+\n \tif res.maxValueSize <= 0 || res.maxValueSize > RedisValueSizeLimit {\n \t\tres.maxValueSize = RedisValueSizeLimit\n \t}\n@@ -42,23 +61,33 @@ func NewRedisCache(backend *redis.Client, opts ...Option) (*RedisCache, error) {\n }\n \n // Get gets value by key or load with fn if not found in cache\n-func (c *RedisCache) Get(key string, fn func() (interface{}, error)) (data interface{}, err error) {\n+func (c *RedisCache[V]) Get(key string, fn func() (V, error)) (data V, err error) {\n \tv, getErr := c.backend.Get(context.Background(), key).Result()\n-\tswitch getErr {\n+\tswitch {\n \t// RedisClient returns nil when find a key in DB\n-\tcase nil:\n+\tcase getErr == nil:\n \t\tatomic.AddInt64(&c.Hits, 1)\n-\t\treturn v, nil\n+\t\tswitch any(data).(type) {\n+\t\tcase string:\n+\t\t\treturn any(v).(V), nil\n+\t\tdefault:\n+\t\t\treturn c.strToV(v), nil\n+\t\t}\n \t// RedisClient returns redis.Nil when doesn't find a key in DB\n-\tcase redis.Nil:\n+\tcase errors.Is(getErr, redis.Nil):\n \t\tif data, err = fn(); err != nil {\n \t\t\tatomic.AddInt64(&c.Errors, 1)\n \t\t\treturn data, err\n \t\t}\n-\t// RedisClient returns !nil when something goes wrong while get data\n+\t\t// RedisClient returns !nil when something goes wrong while get data\n \tdefault:\n \t\tatomic.AddInt64(&c.Errors, 1)\n-\t\treturn v, getErr\n+\t\tswitch any(data).(type) {\n+\t\tcase string:\n+\t\t\treturn any(v).(V), getErr\n+\t\tdefault:\n+\t\t\treturn c.strToV(v), getErr\n+\t\t}\n \t}\n \tatomic.AddInt64(&c.Misses, 1)\n \n@@ -76,7 +105,7 @@ func (c *RedisCache) Get(key string, fn func() (interface{}, error)) (data inter\n }\n \n // Invalidate removes keys with passed predicate fn, i.e. fn(key) should be true to get evicted\n-func (c *RedisCache) Invalidate(fn func(key string) bool) {\n+func (c *RedisCache[V]) Invalidate(fn func(key string) bool) {\n \tfor _, key := range c.backend.Keys(context.Background(), \"*\").Val() { // Keys() returns copy of cache's key, safe to remove directly\n \t\tif fn(key) {\n \t\t\tc.backend.Del(context.Background(), key)\n@@ -85,32 +114,38 @@ func (c *RedisCache) Invalidate(fn func(key string) bool) {\n }\n \n // Peek returns the key value (or undefined if not found) without updating the \"recently used\"-ness of the key.\n-func (c *RedisCache) Peek(key string) (interface{}, bool) {\n+func (c *RedisCache[V]) Peek(key string) (data V, found bool) {\n \tret, err := c.backend.Get(context.Background(), key).Result()\n \tif err != nil {\n-\t\treturn nil, false\n+\t\tvar emptyValue V\n+\t\treturn emptyValue, false\n+\t}\n+\tswitch any(data).(type) {\n+\tcase string:\n+\t\treturn any(ret).(V), true\n+\tdefault:\n+\t\treturn any(ret).(V), true\n \t}\n-\treturn ret, true\n }\n \n // Purge clears the cache completely.\n-func (c *RedisCache) Purge() {\n+func (c *RedisCache[V]) Purge() {\n \tc.backend.FlushDB(context.Background())\n \n }\n \n // Delete cache item by key\n-func (c *RedisCache) Delete(key string) {\n+func (c *RedisCache[V]) Delete(key string) {\n \tc.backend.Del(context.Background(), key)\n }\n \n // Keys gets all keys for the cache\n-func (c *RedisCache) Keys() (res []string) {\n+func (c *RedisCache[V]) Keys() (res []string) {\n \treturn c.backend.Keys(context.Background(), \"*\").Val()\n }\n \n // Stat returns cache statistics\n-func (c *RedisCache) Stat() CacheStat {\n+func (c *RedisCache[V]) Stat() CacheStat {\n \treturn CacheStat{\n \t\tHits:   c.Hits,\n \t\tMisses: c.Misses,\n@@ -121,26 +156,26 @@ func (c *RedisCache) Stat() CacheStat {\n }\n \n // Close closes underlying connections\n-func (c *RedisCache) Close() error {\n+func (c *RedisCache[V]) Close() error {\n \treturn c.backend.Close()\n }\n \n-func (c *RedisCache) size() int64 {\n+func (c *RedisCache[V]) size() int64 {\n \treturn 0\n }\n \n-func (c *RedisCache) keys() int {\n+func (c *RedisCache[V]) keys() int {\n \treturn int(c.backend.DBSize(context.Background()).Val())\n }\n \n-func (c *RedisCache) allowed(key string, data interface{}) bool {\n+func (c *RedisCache[V]) allowed(key string, data V) bool {\n \tif c.maxKeys > 0 && c.backend.DBSize(context.Background()).Val() >= int64(c.maxKeys) {\n \t\treturn false\n \t}\n \tif c.maxKeySize > 0 && len(key) > c.maxKeySize {\n \t\treturn false\n \t}\n-\tif s, ok := data.(Sizer); ok {\n+\tif s, ok := any(data).(Sizer); ok {\n \t\tif c.maxValueSize > 0 && (s.Size() >= c.maxValueSize) {\n \t\t\treturn false\n \t\t}",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/redis_cache.go"
    },
    {
      "sha": "d60cfc3eea7497f29120399fa4c43e6e70eddabb",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/scache.go",
      "status": "renamed",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fscache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fscache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Fscache.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -7,36 +7,36 @@ import (\n \n // Scache wraps LoadingCache with partitions (sub-system), and scopes.\n // Simplified interface with just 4 funcs - Get, Flush, Stats and Close\n-type Scache struct {\n-\tlc LoadingCache\n+type Scache[V any] struct {\n+\tlc LoadingCache[V]\n }\n \n // NewScache creates Scache on top of LoadingCache\n-func NewScache(lc LoadingCache) *Scache {\n-\treturn &Scache{lc: lc}\n+func NewScache[V any](lc LoadingCache[V]) *Scache[V] {\n+\treturn &Scache[V]{lc: lc}\n }\n \n // Get retrieves a key from underlying backend\n-func (m *Scache) Get(key Key, fn func() ([]byte, error)) (data []byte, err error) {\n+func (m *Scache[V]) Get(key Key, fn func() (V, error)) (data V, err error) {\n \tkeyStr := key.String()\n-\tval, err := m.lc.Get(keyStr, func() (value interface{}, e error) {\n+\tval, err := m.lc.Get(keyStr, func() (value V, e error) {\n \t\treturn fn()\n \t})\n-\treturn val.([]byte), err\n+\treturn val, err\n }\n \n // Stat delegates the call to the underlying cache backend\n-func (m *Scache) Stat() CacheStat {\n+func (m *Scache[V]) Stat() CacheStat {\n \treturn m.lc.Stat()\n }\n \n // Close calls Close function of the underlying cache\n-func (m *Scache) Close() error {\n+func (m *Scache[V]) Close() error {\n \treturn m.lc.Close()\n }\n \n // Flush clears cache and calls postFlushFn async\n-func (m *Scache) Flush(req FlusherRequest) {\n+func (m *Scache[V]) Flush(req FlusherRequest) {\n \tif len(req.scopes) == 0 {\n \t\tm.lc.Purge()\n \t\treturn",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/scache.go"
    },
    {
      "sha": "8328696e0575d8a33e43da8e03719cb6ec0507f7",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/v2/url.go",
      "status": "renamed",
      "additions": 12,
      "deletions": 11,
      "changes": 23,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Furl.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Furl.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fv2%2Furl.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -16,14 +16,14 @@ import (\n //   - mem://lru?max_keys=10&max_cache_size=1024\n //   - mem://expirable?ttl=30s&max_val_size=100\n //   - nop://\n-func New(uri string) (LoadingCache, error) {\n+func New[V any](uri string) (LoadingCache[V], error) {\n \tu, err := url.Parse(uri)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"parse cache uri %s: %w\", uri, err)\n \t}\n \n \tquery := u.Query()\n-\topts, err := optionsFromQuery(query)\n+\topts, err := optionsFromQuery[V](query)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"parse uri options %s: %w\", uri, err)\n \t}\n@@ -42,27 +42,28 @@ func New(uri string) (LoadingCache, error) {\n \tcase \"mem\":\n \t\tswitch u.Hostname() {\n \t\tcase \"lru\":\n-\t\t\treturn NewLruCache(opts...)\n+\t\t\treturn NewLruCache[V](opts...)\n \t\tcase \"expirable\":\n-\t\t\treturn NewExpirableCache(opts...)\n+\t\t\treturn NewExpirableCache[V](opts...)\n \t\tdefault:\n \t\t\treturn nil, fmt.Errorf(\"unsupported mem cache type %s\", u.Hostname())\n \t\t}\n \tcase \"nop\":\n-\t\treturn NewNopCache(), nil\n+\t\treturn NewNopCache[V](), nil\n \t}\n \treturn nil, fmt.Errorf(\"unsupported cache type %s\", u.Scheme)\n }\n \n-func optionsFromQuery(q url.Values) (opts []Option, err error) {\n+func optionsFromQuery[V any](q url.Values) (opts []Option[V], err error) {\n \terrs := new(multierror.Error)\n+\to := NewOpts[V]()\n \n \tif v := q.Get(\"max_val_size\"); v != \"\" {\n \t\tvv, e := strconv.Atoi(v)\n \t\tif e != nil {\n \t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_val_size query param %s: %w\", v, e))\n \t\t} else {\n-\t\t\topts = append(opts, MaxValSize(vv))\n+\t\t\topts = append(opts, o.MaxValSize(vv))\n \t\t}\n \t}\n \n@@ -71,7 +72,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \t\tif e != nil {\n \t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_key_size query param %s: %w\", v, e))\n \t\t} else {\n-\t\t\topts = append(opts, MaxKeySize(vv))\n+\t\t\topts = append(opts, o.MaxKeySize(vv))\n \t\t}\n \t}\n \n@@ -80,7 +81,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \t\tif e != nil {\n \t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_keys query param %s: %w\", v, e))\n \t\t} else {\n-\t\t\topts = append(opts, MaxKeys(vv))\n+\t\t\topts = append(opts, o.MaxKeys(vv))\n \t\t}\n \t}\n \n@@ -89,7 +90,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \t\tif e != nil {\n \t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_cache_size query param %s: %w\", v, e))\n \t\t} else {\n-\t\t\topts = append(opts, MaxCacheSize(vv))\n+\t\t\topts = append(opts, o.MaxCacheSize(vv))\n \t\t}\n \t}\n \n@@ -98,7 +99,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \t\tif e != nil {\n \t\t\terrs = multierror.Append(errs, fmt.Errorf(\"ttl query param %s: %w\", v, e))\n \t\t} else {\n-\t\t\topts = append(opts, TTL(vv))\n+\t\t\topts = append(opts, o.TTL(vv))\n \t\t}\n \t}\n ",
      "previous_filename": "backend/vendor/github.com/go-pkgz/lcw/url.go"
    },
    {
      "sha": "49202fc41e645679a0f8d1088237b5b4aa22f49d",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/.golangci.yml",
      "status": "removed",
      "additions": 0,
      "deletions": 30,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2F.golangci.yml?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,30 +0,0 @@\n-linters:\n-  enable:\n-    - megacheck\n-    - revive\n-    - govet\n-    - unconvert\n-    - megacheck\n-    - gas\n-    - gocyclo\n-    - dupl\n-    - misspell\n-    - unparam\n-    - unused\n-    - typecheck\n-    - ineffassign\n-    - stylecheck\n-    - exportloopref\n-    - gocritic\n-    - nakedret\n-    - gosimple\n-    - prealloc\n-  fast: false\n-  disable-all: true\n-\n-issues:\n-  exclude-rules:\n-    - path: _test\\.go\n-      linters:\n-        - dupl\n-  exclude-use-default: false"
    },
    {
      "sha": "03bcfb5b76b60756c6464edb9a2d1d6893ef43f3",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/README.md",
      "status": "removed",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2FREADME.md?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,7 +0,0 @@\n-golang-lru\n-==========\n-\n-Please upgrade to github.com/hashicorp/golang-lru/v2 for all new code as v1 will\n-not be updated anymore. The v2 version supports generics and is faster; old code\n-can specify a specific tag, e.g. github.com/hashicorp/golang-lru/v1.0.2 for\n-backwards compatibility."
    },
    {
      "sha": "e396f8428aa3b0953d1442f6f5554fe08f837d60",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/arc.go",
      "status": "removed",
      "additions": 0,
      "deletions": 256,
      "changes": 256,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Farc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Farc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Farc.go?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,256 +0,0 @@\n-package lru\n-\n-import (\n-\t\"sync\"\n-\n-\t\"github.com/hashicorp/golang-lru/simplelru\"\n-)\n-\n-// ARCCache is a thread-safe fixed size Adaptive Replacement Cache (ARC).\n-// ARC is an enhancement over the standard LRU cache in that tracks both\n-// frequency and recency of use. This avoids a burst in access to new\n-// entries from evicting the frequently used older entries. It adds some\n-// additional tracking overhead to a standard LRU cache, computationally\n-// it is roughly 2x the cost, and the extra memory overhead is linear\n-// with the size of the cache. ARC has been patented by IBM, but is\n-// similar to the TwoQueueCache (2Q) which requires setting parameters.\n-type ARCCache struct {\n-\tsize int // Size is the total capacity of the cache\n-\tp    int // P is the dynamic preference towards T1 or T2\n-\n-\tt1 simplelru.LRUCache // T1 is the LRU for recently accessed items\n-\tb1 simplelru.LRUCache // B1 is the LRU for evictions from t1\n-\n-\tt2 simplelru.LRUCache // T2 is the LRU for frequently accessed items\n-\tb2 simplelru.LRUCache // B2 is the LRU for evictions from t2\n-\n-\tlock sync.RWMutex\n-}\n-\n-// NewARC creates an ARC of the given size\n-func NewARC(size int) (*ARCCache, error) {\n-\t// Create the sub LRUs\n-\tb1, err := simplelru.NewLRU(size, nil)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tb2, err := simplelru.NewLRU(size, nil)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tt1, err := simplelru.NewLRU(size, nil)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tt2, err := simplelru.NewLRU(size, nil)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\t// Initialize the ARC\n-\tc := &ARCCache{\n-\t\tsize: size,\n-\t\tp:    0,\n-\t\tt1:   t1,\n-\t\tb1:   b1,\n-\t\tt2:   t2,\n-\t\tb2:   b2,\n-\t}\n-\treturn c, nil\n-}\n-\n-// Get looks up a key's value from the cache.\n-func (c *ARCCache) Get(key interface{}) (value interface{}, ok bool) {\n-\tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\n-\t// If the value is contained in T1 (recent), then\n-\t// promote it to T2 (frequent)\n-\tif val, ok := c.t1.Peek(key); ok {\n-\t\tc.t1.Remove(key)\n-\t\tc.t2.Add(key, val)\n-\t\treturn val, ok\n-\t}\n-\n-\t// Check if the value is contained in T2 (frequent)\n-\tif val, ok := c.t2.Get(key); ok {\n-\t\treturn val, ok\n-\t}\n-\n-\t// No hit\n-\treturn nil, false\n-}\n-\n-// Add adds a value to the cache.\n-func (c *ARCCache) Add(key, value interface{}) {\n-\tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\n-\t// Check if the value is contained in T1 (recent), and potentially\n-\t// promote it to frequent T2\n-\tif c.t1.Contains(key) {\n-\t\tc.t1.Remove(key)\n-\t\tc.t2.Add(key, value)\n-\t\treturn\n-\t}\n-\n-\t// Check if the value is already in T2 (frequent) and update it\n-\tif c.t2.Contains(key) {\n-\t\tc.t2.Add(key, value)\n-\t\treturn\n-\t}\n-\n-\t// Check if this value was recently evicted as part of the\n-\t// recently used list\n-\tif c.b1.Contains(key) {\n-\t\t// T1 set is too small, increase P appropriately\n-\t\tdelta := 1\n-\t\tb1Len := c.b1.Len()\n-\t\tb2Len := c.b2.Len()\n-\t\tif b2Len > b1Len {\n-\t\t\tdelta = b2Len / b1Len\n-\t\t}\n-\t\tif c.p+delta >= c.size {\n-\t\t\tc.p = c.size\n-\t\t} else {\n-\t\t\tc.p += delta\n-\t\t}\n-\n-\t\t// Potentially need to make room in the cache\n-\t\tif c.t1.Len()+c.t2.Len() >= c.size {\n-\t\t\tc.replace(false)\n-\t\t}\n-\n-\t\t// Remove from B1\n-\t\tc.b1.Remove(key)\n-\n-\t\t// Add the key to the frequently used list\n-\t\tc.t2.Add(key, value)\n-\t\treturn\n-\t}\n-\n-\t// Check if this value was recently evicted as part of the\n-\t// frequently used list\n-\tif c.b2.Contains(key) {\n-\t\t// T2 set is too small, decrease P appropriately\n-\t\tdelta := 1\n-\t\tb1Len := c.b1.Len()\n-\t\tb2Len := c.b2.Len()\n-\t\tif b1Len > b2Len {\n-\t\t\tdelta = b1Len / b2Len\n-\t\t}\n-\t\tif delta >= c.p {\n-\t\t\tc.p = 0\n-\t\t} else {\n-\t\t\tc.p -= delta\n-\t\t}\n-\n-\t\t// Potentially need to make room in the cache\n-\t\tif c.t1.Len()+c.t2.Len() >= c.size {\n-\t\t\tc.replace(true)\n-\t\t}\n-\n-\t\t// Remove from B2\n-\t\tc.b2.Remove(key)\n-\n-\t\t// Add the key to the frequently used list\n-\t\tc.t2.Add(key, value)\n-\t\treturn\n-\t}\n-\n-\t// Potentially need to make room in the cache\n-\tif c.t1.Len()+c.t2.Len() >= c.size {\n-\t\tc.replace(false)\n-\t}\n-\n-\t// Keep the size of the ghost buffers trim\n-\tif c.b1.Len() > c.size-c.p {\n-\t\tc.b1.RemoveOldest()\n-\t}\n-\tif c.b2.Len() > c.p {\n-\t\tc.b2.RemoveOldest()\n-\t}\n-\n-\t// Add to the recently seen list\n-\tc.t1.Add(key, value)\n-}\n-\n-// replace is used to adaptively evict from either T1 or T2\n-// based on the current learned value of P\n-func (c *ARCCache) replace(b2ContainsKey bool) {\n-\tt1Len := c.t1.Len()\n-\tif t1Len > 0 && (t1Len > c.p || (t1Len == c.p && b2ContainsKey)) {\n-\t\tk, _, ok := c.t1.RemoveOldest()\n-\t\tif ok {\n-\t\t\tc.b1.Add(k, nil)\n-\t\t}\n-\t} else {\n-\t\tk, _, ok := c.t2.RemoveOldest()\n-\t\tif ok {\n-\t\t\tc.b2.Add(k, nil)\n-\t\t}\n-\t}\n-}\n-\n-// Len returns the number of cached entries\n-func (c *ARCCache) Len() int {\n-\tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\treturn c.t1.Len() + c.t2.Len()\n-}\n-\n-// Keys returns all the cached keys\n-func (c *ARCCache) Keys() []interface{} {\n-\tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\tk1 := c.t1.Keys()\n-\tk2 := c.t2.Keys()\n-\treturn append(k1, k2...)\n-}\n-\n-// Remove is used to purge a key from the cache\n-func (c *ARCCache) Remove(key interface{}) {\n-\tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\tif c.t1.Remove(key) {\n-\t\treturn\n-\t}\n-\tif c.t2.Remove(key) {\n-\t\treturn\n-\t}\n-\tif c.b1.Remove(key) {\n-\t\treturn\n-\t}\n-\tif c.b2.Remove(key) {\n-\t\treturn\n-\t}\n-}\n-\n-// Purge is used to clear the cache\n-func (c *ARCCache) Purge() {\n-\tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\tc.t1.Purge()\n-\tc.t2.Purge()\n-\tc.b1.Purge()\n-\tc.b2.Purge()\n-}\n-\n-// Contains is used to check if the cache contains a key\n-// without updating recency or frequency.\n-func (c *ARCCache) Contains(key interface{}) bool {\n-\tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\treturn c.t1.Contains(key) || c.t2.Contains(key)\n-}\n-\n-// Peek is used to inspect the cache value of a key\n-// without updating recency or frequency.\n-func (c *ARCCache) Peek(key interface{}) (value interface{}, ok bool) {\n-\tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\tif val, ok := c.t1.Peek(key); ok {\n-\t\treturn val, ok\n-\t}\n-\treturn c.t2.Peek(key)\n-}"
    },
    {
      "sha": "2547df979d0baf6a9f942477f1e907d4fe8fecbe",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/doc.go",
      "status": "removed",
      "additions": 0,
      "deletions": 21,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fdoc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fdoc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fdoc.go?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,21 +0,0 @@\n-// Package lru provides three different LRU caches of varying sophistication.\n-//\n-// Cache is a simple LRU cache. It is based on the\n-// LRU implementation in groupcache:\n-// https://github.com/golang/groupcache/tree/master/lru\n-//\n-// TwoQueueCache tracks frequently used and recently used entries separately.\n-// This avoids a burst of accesses from taking out frequently used entries,\n-// at the cost of about 2x computational overhead and some extra bookkeeping.\n-//\n-// ARCCache is an adaptive replacement cache. It tracks recent evictions as\n-// well as recent usage in both the frequent and recent caches. Its\n-// computational overhead is comparable to TwoQueueCache, but the memory\n-// overhead is linear with the size of the cache.\n-//\n-// ARC has been patented by IBM, so do not use it if that is problematic for\n-// your program.\n-//\n-// All caches in this package take locks while operating, and are therefore\n-// thread-safe for consumers.\n-package lru"
    },
    {
      "sha": "492760782c5eafdbec94dbd31ae7a9580346feb6",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/testing.go",
      "status": "removed",
      "additions": 0,
      "deletions": 16,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark42/blob/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Ftesting.go",
      "raw_url": "https://github.com/umputun/remark42/raw/3210de8f7bb627ac23669e4e88ef28fc466c7778/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Ftesting.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Ftesting.go?ref=3210de8f7bb627ac23669e4e88ef28fc466c7778",
      "patch": "@@ -1,16 +0,0 @@\n-package lru\n-\n-import (\n-\t\"crypto/rand\"\n-\t\"math\"\n-\t\"math/big\"\n-\t\"testing\"\n-)\n-\n-func getRand(tb testing.TB) int64 {\n-\tout, err := rand.Int(rand.Reader, big.NewInt(math.MaxInt64))\n-\tif err != nil {\n-\t\ttb.Fatal(err)\n-\t}\n-\treturn out.Int64()\n-}"
    },
    {
      "sha": "836562412fe8a44fa99a515eeff68d2bc1a86daa",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/.gitignore",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F.gitignore?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "previous_filename": "backend/vendor/github.com/hashicorp/golang-lru/.gitignore"
    },
    {
      "sha": "7e7b8a96275a66dd67543772e7d1498cb91e9086",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/.golangci.yml",
      "status": "added",
      "additions": 46,
      "deletions": 0,
      "changes": 46,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F.golangci.yml?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -0,0 +1,46 @@\n+# Copyright (c) HashiCorp, Inc.\n+# SPDX-License-Identifier: MPL-2.0\n+\n+linters:\n+  fast: false\n+  disable-all: true\n+  enable:\n+    - revive\n+    - megacheck\n+    - govet\n+    - unconvert\n+    - gas\n+    - gocyclo\n+    - dupl\n+    - misspell\n+    - unparam\n+    - unused\n+    - typecheck\n+    - ineffassign\n+    # - stylecheck\n+    - exportloopref\n+    - gocritic\n+    - nakedret\n+    - gosimple\n+    - prealloc\n+\n+# golangci-lint configuration file\n+linters-settings:\n+  revive:\n+    ignore-generated-header: true\n+    severity: warning\n+    rules:\n+      - name: package-comments\n+        severity: warning\n+        disabled: true\n+      - name: exported\n+        severity: warning\n+        disabled: false\n+        arguments: [\"checkPrivateReceivers\", \"disableStutteringCheck\"]\n+\n+issues:\n+  exclude-use-default: false\n+  exclude-rules:\n+    - path: _test\\.go\n+      linters:\n+        - dupl"
    },
    {
      "sha": "8c95252b6f2740941bad828199e62a7b5ed2d0d1",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/2q.go",
      "status": "renamed",
      "additions": 74,
      "deletions": 29,
      "changes": 103,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F2q.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F2q.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2F2q.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -1,10 +1,13 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n package lru\n \n import (\n-\t\"fmt\"\n+\t\"errors\"\n \t\"sync\"\n \n-\t\"github.com/hashicorp/golang-lru/simplelru\"\n+\t\"github.com/hashicorp/golang-lru/v2/simplelru\"\n )\n \n const (\n@@ -26,57 +29,61 @@ const (\n // computationally about 2x the cost, and adds some metadata over\n // head. The ARCCache is similar, but does not require setting any\n // parameters.\n-type TwoQueueCache struct {\n-\tsize       int\n-\trecentSize int\n+type TwoQueueCache[K comparable, V any] struct {\n+\tsize        int\n+\trecentSize  int\n+\trecentRatio float64\n+\tghostRatio  float64\n \n-\trecent      simplelru.LRUCache\n-\tfrequent    simplelru.LRUCache\n-\trecentEvict simplelru.LRUCache\n+\trecent      simplelru.LRUCache[K, V]\n+\tfrequent    simplelru.LRUCache[K, V]\n+\trecentEvict simplelru.LRUCache[K, struct{}]\n \tlock        sync.RWMutex\n }\n \n // New2Q creates a new TwoQueueCache using the default\n // values for the parameters.\n-func New2Q(size int) (*TwoQueueCache, error) {\n-\treturn New2QParams(size, Default2QRecentRatio, Default2QGhostEntries)\n+func New2Q[K comparable, V any](size int) (*TwoQueueCache[K, V], error) {\n+\treturn New2QParams[K, V](size, Default2QRecentRatio, Default2QGhostEntries)\n }\n \n // New2QParams creates a new TwoQueueCache using the provided\n // parameter values.\n-func New2QParams(size int, recentRatio, ghostRatio float64) (*TwoQueueCache, error) {\n+func New2QParams[K comparable, V any](size int, recentRatio, ghostRatio float64) (*TwoQueueCache[K, V], error) {\n \tif size <= 0 {\n-\t\treturn nil, fmt.Errorf(\"invalid size\")\n+\t\treturn nil, errors.New(\"invalid size\")\n \t}\n \tif recentRatio < 0.0 || recentRatio > 1.0 {\n-\t\treturn nil, fmt.Errorf(\"invalid recent ratio\")\n+\t\treturn nil, errors.New(\"invalid recent ratio\")\n \t}\n \tif ghostRatio < 0.0 || ghostRatio > 1.0 {\n-\t\treturn nil, fmt.Errorf(\"invalid ghost ratio\")\n+\t\treturn nil, errors.New(\"invalid ghost ratio\")\n \t}\n \n \t// Determine the sub-sizes\n \trecentSize := int(float64(size) * recentRatio)\n \tevictSize := int(float64(size) * ghostRatio)\n \n \t// Allocate the LRUs\n-\trecent, err := simplelru.NewLRU(size, nil)\n+\trecent, err := simplelru.NewLRU[K, V](size, nil)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tfrequent, err := simplelru.NewLRU(size, nil)\n+\tfrequent, err := simplelru.NewLRU[K, V](size, nil)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\trecentEvict, err := simplelru.NewLRU(evictSize, nil)\n+\trecentEvict, err := simplelru.NewLRU[K, struct{}](evictSize, nil)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \t// Initialize the cache\n-\tc := &TwoQueueCache{\n+\tc := &TwoQueueCache[K, V]{\n \t\tsize:        size,\n \t\trecentSize:  recentSize,\n+\t\trecentRatio: recentRatio,\n+\t\tghostRatio:  ghostRatio,\n \t\trecent:      recent,\n \t\tfrequent:    frequent,\n \t\trecentEvict: recentEvict,\n@@ -85,7 +92,7 @@ func New2QParams(size int, recentRatio, ghostRatio float64) (*TwoQueueCache, err\n }\n \n // Get looks up a key's value from the cache.\n-func (c *TwoQueueCache) Get(key interface{}) (value interface{}, ok bool) {\n+func (c *TwoQueueCache[K, V]) Get(key K) (value V, ok bool) {\n \tc.lock.Lock()\n \tdefer c.lock.Unlock()\n \n@@ -103,11 +110,11 @@ func (c *TwoQueueCache) Get(key interface{}) (value interface{}, ok bool) {\n \t}\n \n \t// No hit\n-\treturn nil, false\n+\treturn\n }\n \n // Add adds a value to the cache.\n-func (c *TwoQueueCache) Add(key, value interface{}) {\n+func (c *TwoQueueCache[K, V]) Add(key K, value V) {\n \tc.lock.Lock()\n \tdefer c.lock.Unlock()\n \n@@ -141,7 +148,7 @@ func (c *TwoQueueCache) Add(key, value interface{}) {\n }\n \n // ensureSpace is used to ensure we have space in the cache\n-func (c *TwoQueueCache) ensureSpace(recentEvict bool) {\n+func (c *TwoQueueCache[K, V]) ensureSpace(recentEvict bool) {\n \t// If we have space, nothing to do\n \trecentLen := c.recent.Len()\n \tfreqLen := c.frequent.Len()\n@@ -153,7 +160,7 @@ func (c *TwoQueueCache) ensureSpace(recentEvict bool) {\n \t// the target, evict from there\n \tif recentLen > 0 && (recentLen > c.recentSize || (recentLen == c.recentSize && !recentEvict)) {\n \t\tk, _, _ := c.recent.RemoveOldest()\n-\t\tc.recentEvict.Add(k, nil)\n+\t\tc.recentEvict.Add(k, struct{}{})\n \t\treturn\n \t}\n \n@@ -162,24 +169,62 @@ func (c *TwoQueueCache) ensureSpace(recentEvict bool) {\n }\n \n // Len returns the number of items in the cache.\n-func (c *TwoQueueCache) Len() int {\n+func (c *TwoQueueCache[K, V]) Len() int {\n \tc.lock.RLock()\n \tdefer c.lock.RUnlock()\n \treturn c.recent.Len() + c.frequent.Len()\n }\n \n+// Resize changes the cache size.\n+func (c *TwoQueueCache[K, V]) Resize(size int) (evicted int) {\n+\tc.lock.Lock()\n+\tdefer c.lock.Unlock()\n+\n+\t// Recalculate the sub-sizes\n+\trecentSize := int(float64(size) * c.recentRatio)\n+\tevictSize := int(float64(size) * c.ghostRatio)\n+\tc.size = size\n+\tc.recentSize = recentSize\n+\n+\t// ensureSpace\n+\tdiff := c.recent.Len() + c.frequent.Len() - size\n+\tif diff < 0 {\n+\t\tdiff = 0\n+\t}\n+\tfor i := 0; i < diff; i++ {\n+\t\tc.ensureSpace(true)\n+\t}\n+\n+\t// Reallocate the LRUs\n+\tc.recent.Resize(size)\n+\tc.frequent.Resize(size)\n+\tc.recentEvict.Resize(evictSize)\n+\n+\treturn diff\n+}\n+\n // Keys returns a slice of the keys in the cache.\n // The frequently used keys are first in the returned slice.\n-func (c *TwoQueueCache) Keys() []interface{} {\n+func (c *TwoQueueCache[K, V]) Keys() []K {\n \tc.lock.RLock()\n \tdefer c.lock.RUnlock()\n \tk1 := c.frequent.Keys()\n \tk2 := c.recent.Keys()\n \treturn append(k1, k2...)\n }\n \n+// Values returns a slice of the values in the cache.\n+// The frequently used values are first in the returned slice.\n+func (c *TwoQueueCache[K, V]) Values() []V {\n+\tc.lock.RLock()\n+\tdefer c.lock.RUnlock()\n+\tv1 := c.frequent.Values()\n+\tv2 := c.recent.Values()\n+\treturn append(v1, v2...)\n+}\n+\n // Remove removes the provided key from the cache.\n-func (c *TwoQueueCache) Remove(key interface{}) {\n+func (c *TwoQueueCache[K, V]) Remove(key K) {\n \tc.lock.Lock()\n \tdefer c.lock.Unlock()\n \tif c.frequent.Remove(key) {\n@@ -194,7 +239,7 @@ func (c *TwoQueueCache) Remove(key interface{}) {\n }\n \n // Purge is used to completely clear the cache.\n-func (c *TwoQueueCache) Purge() {\n+func (c *TwoQueueCache[K, V]) Purge() {\n \tc.lock.Lock()\n \tdefer c.lock.Unlock()\n \tc.recent.Purge()\n@@ -204,15 +249,15 @@ func (c *TwoQueueCache) Purge() {\n \n // Contains is used to check if the cache contains a key\n // without updating recency or frequency.\n-func (c *TwoQueueCache) Contains(key interface{}) bool {\n+func (c *TwoQueueCache[K, V]) Contains(key K) bool {\n \tc.lock.RLock()\n \tdefer c.lock.RUnlock()\n \treturn c.frequent.Contains(key) || c.recent.Contains(key)\n }\n \n // Peek is used to inspect the cache value of a key\n // without updating recency or frequency.\n-func (c *TwoQueueCache) Peek(key interface{}) (value interface{}, ok bool) {\n+func (c *TwoQueueCache[K, V]) Peek(key K) (value V, ok bool) {\n \tc.lock.RLock()\n \tdefer c.lock.RUnlock()\n \tif val, ok := c.frequent.Peek(key); ok {",
      "previous_filename": "backend/vendor/github.com/hashicorp/golang-lru/2q.go"
    },
    {
      "sha": "0e5d580e0e9643a332da623d3b9976c8569b8c5e",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/LICENSE",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2FLICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2FLICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2FLICENSE?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "previous_filename": "backend/vendor/github.com/hashicorp/golang-lru/LICENSE"
    },
    {
      "sha": "a942eb5397006f6a147e485c074ea8e3f8cb2e59",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/README.md",
      "status": "added",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2FREADME.md?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -0,0 +1,79 @@\n+golang-lru\n+==========\n+\n+This provides the `lru` package which implements a fixed-size\n+thread safe LRU cache. It is based on the cache in Groupcache.\n+\n+Documentation\n+=============\n+\n+Full docs are available on [Go Packages](https://pkg.go.dev/github.com/hashicorp/golang-lru/v2)\n+\n+LRU cache example\n+=================\n+\n+```go\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/hashicorp/golang-lru/v2\"\n+)\n+\n+func main() {\n+\tl, _ := lru.New[int, any](128)\n+\tfor i := 0; i < 256; i++ {\n+\t\tl.Add(i, nil)\n+\t}\n+\tif l.Len() != 128 {\n+\t\tpanic(fmt.Sprintf(\"bad len: %v\", l.Len()))\n+\t}\n+}\n+```\n+\n+Expirable LRU cache example\n+===========================\n+\n+```go\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"time\"\n+\n+\t\"github.com/hashicorp/golang-lru/v2/expirable\"\n+)\n+\n+func main() {\n+\t// make cache with 10ms TTL and 5 max keys\n+\tcache := expirable.NewLRU[string, string](5, nil, time.Millisecond*10)\n+\n+\n+\t// set value under key1.\n+\tcache.Add(\"key1\", \"val1\")\n+\n+\t// get value under key1\n+\tr, ok := cache.Get(\"key1\")\n+\n+\t// check for OK value\n+\tif ok {\n+\t\tfmt.Printf(\"value before expiration is found: %v, value: %q\\n\", ok, r)\n+\t}\n+\n+\t// wait for cache to expire\n+\ttime.Sleep(time.Millisecond * 12)\n+\n+\t// get value under key1 after key expiration\n+\tr, ok = cache.Get(\"key1\")\n+\tfmt.Printf(\"value after expiration is found: %v, value: %q\\n\", ok, r)\n+\n+\t// set value under key2, would evict old entry because it is already expired.\n+\tcache.Add(\"key2\", \"val2\")\n+\n+\tfmt.Printf(\"Cache len: %d\\n\", cache.Len())\n+\t// Output:\n+\t// value before expiration is found: true, value: \"val1\"\n+\t// value after expiration is found: false, value: \"\"\n+\t// Cache len: 1\n+}\n+```"
    },
    {
      "sha": "24107ee0edeefbc9346ae3c97a5ef768bf30cfb5",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/doc.go",
      "status": "added",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fdoc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fdoc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fdoc.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+// Package lru provides three different LRU caches of varying sophistication.\n+//\n+// Cache is a simple LRU cache. It is based on the LRU implementation in\n+// groupcache: https://github.com/golang/groupcache/tree/master/lru\n+//\n+// TwoQueueCache tracks frequently used and recently used entries separately.\n+// This avoids a burst of accesses from taking out frequently used entries, at\n+// the cost of about 2x computational overhead and some extra bookkeeping.\n+//\n+// ARCCache is an adaptive replacement cache. It tracks recent evictions as well\n+// as recent usage in both the frequent and recent caches. Its computational\n+// overhead is comparable to TwoQueueCache, but the memory overhead is linear\n+// with the size of the cache.\n+//\n+// ARC has been patented by IBM, so do not use it if that is problematic for\n+// your program. For this reason, it is in a separate go module contained within\n+// this repository.\n+//\n+// All caches in this package take locks while operating, and are therefore\n+// thread-safe for consumers.\n+package lru"
    },
    {
      "sha": "89978d6d23926e7c2c5426916a08be9df1c79943",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/expirable/expirable_lru.go",
      "status": "added",
      "additions": 338,
      "deletions": 0,
      "changes": 338,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fexpirable%2Fexpirable_lru.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fexpirable%2Fexpirable_lru.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fexpirable%2Fexpirable_lru.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -0,0 +1,338 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package expirable\n+\n+import (\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/hashicorp/golang-lru/v2/internal\"\n+)\n+\n+// EvictCallback is used to get a callback when a cache entry is evicted\n+type EvictCallback[K comparable, V any] func(key K, value V)\n+\n+// LRU implements a thread-safe LRU with expirable entries.\n+type LRU[K comparable, V any] struct {\n+\tsize      int\n+\tevictList *internal.LruList[K, V]\n+\titems     map[K]*internal.Entry[K, V]\n+\tonEvict   EvictCallback[K, V]\n+\n+\t// expirable options\n+\tmu   sync.Mutex\n+\tttl  time.Duration\n+\tdone chan struct{}\n+\n+\t// buckets for expiration\n+\tbuckets []bucket[K, V]\n+\t// uint8 because it's number between 0 and numBuckets\n+\tnextCleanupBucket uint8\n+}\n+\n+// bucket is a container for holding entries to be expired\n+type bucket[K comparable, V any] struct {\n+\tentries     map[K]*internal.Entry[K, V]\n+\tnewestEntry time.Time\n+}\n+\n+// noEvictionTTL - very long ttl to prevent eviction\n+const noEvictionTTL = time.Hour * 24 * 365 * 10\n+\n+// because of uint8 usage for nextCleanupBucket, should not exceed 256.\n+// casting it as uint8 explicitly requires type conversions in multiple places\n+const numBuckets = 100\n+\n+// NewLRU returns a new thread-safe cache with expirable entries.\n+//\n+// Size parameter set to 0 makes cache of unlimited size, e.g. turns LRU mechanism off.\n+//\n+// Providing 0 TTL turns expiring off.\n+//\n+// Delete expired entries every 1/100th of ttl value. Goroutine which deletes expired entries runs indefinitely.\n+func NewLRU[K comparable, V any](size int, onEvict EvictCallback[K, V], ttl time.Duration) *LRU[K, V] {\n+\tif size < 0 {\n+\t\tsize = 0\n+\t}\n+\tif ttl <= 0 {\n+\t\tttl = noEvictionTTL\n+\t}\n+\n+\tres := LRU[K, V]{\n+\t\tttl:       ttl,\n+\t\tsize:      size,\n+\t\tevictList: internal.NewList[K, V](),\n+\t\titems:     make(map[K]*internal.Entry[K, V]),\n+\t\tonEvict:   onEvict,\n+\t\tdone:      make(chan struct{}),\n+\t}\n+\n+\t// initialize the buckets\n+\tres.buckets = make([]bucket[K, V], numBuckets)\n+\tfor i := 0; i < numBuckets; i++ {\n+\t\tres.buckets[i] = bucket[K, V]{entries: make(map[K]*internal.Entry[K, V])}\n+\t}\n+\n+\t// enable deleteExpired() running in separate goroutine for cache with non-zero TTL\n+\t//\n+\t// Important: done channel is never closed, so deleteExpired() goroutine will never exit,\n+\t// it's decided to add functionality to close it in the version later than v2.\n+\tif res.ttl != noEvictionTTL {\n+\t\tgo func(done <-chan struct{}) {\n+\t\t\tticker := time.NewTicker(res.ttl / numBuckets)\n+\t\t\tdefer ticker.Stop()\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-done:\n+\t\t\t\t\treturn\n+\t\t\t\tcase <-ticker.C:\n+\t\t\t\t\tres.deleteExpired()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}(res.done)\n+\t}\n+\treturn &res\n+}\n+\n+// Purge clears the cache completely.\n+// onEvict is called for each evicted key.\n+func (c *LRU[K, V]) Purge() {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tfor k, v := range c.items {\n+\t\tif c.onEvict != nil {\n+\t\t\tc.onEvict(k, v.Value)\n+\t\t}\n+\t\tdelete(c.items, k)\n+\t}\n+\tfor _, b := range c.buckets {\n+\t\tfor _, ent := range b.entries {\n+\t\t\tdelete(b.entries, ent.Key)\n+\t\t}\n+\t}\n+\tc.evictList.Init()\n+}\n+\n+// Add adds a value to the cache. Returns true if an eviction occurred.\n+// Returns false if there was no eviction: the item was already in the cache,\n+// or the size was not exceeded.\n+func (c *LRU[K, V]) Add(key K, value V) (evicted bool) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tnow := time.Now()\n+\n+\t// Check for existing item\n+\tif ent, ok := c.items[key]; ok {\n+\t\tc.evictList.MoveToFront(ent)\n+\t\tc.removeFromBucket(ent) // remove the entry from its current bucket as expiresAt is renewed\n+\t\tent.Value = value\n+\t\tent.ExpiresAt = now.Add(c.ttl)\n+\t\tc.addToBucket(ent)\n+\t\treturn false\n+\t}\n+\n+\t// Add new item\n+\tent := c.evictList.PushFrontExpirable(key, value, now.Add(c.ttl))\n+\tc.items[key] = ent\n+\tc.addToBucket(ent) // adds the entry to the appropriate bucket and sets entry.expireBucket\n+\n+\tevict := c.size > 0 && c.evictList.Length() > c.size\n+\t// Verify size not exceeded\n+\tif evict {\n+\t\tc.removeOldest()\n+\t}\n+\treturn evict\n+}\n+\n+// Get looks up a key's value from the cache.\n+func (c *LRU[K, V]) Get(key K) (value V, ok bool) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tvar ent *internal.Entry[K, V]\n+\tif ent, ok = c.items[key]; ok {\n+\t\t// Expired item check\n+\t\tif time.Now().After(ent.ExpiresAt) {\n+\t\t\treturn value, false\n+\t\t}\n+\t\tc.evictList.MoveToFront(ent)\n+\t\treturn ent.Value, true\n+\t}\n+\treturn\n+}\n+\n+// Contains checks if a key is in the cache, without updating the recent-ness\n+// or deleting it for being stale.\n+func (c *LRU[K, V]) Contains(key K) (ok bool) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\t_, ok = c.items[key]\n+\treturn ok\n+}\n+\n+// Peek returns the key value (or undefined if not found) without updating\n+// the \"recently used\"-ness of the key.\n+func (c *LRU[K, V]) Peek(key K) (value V, ok bool) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tvar ent *internal.Entry[K, V]\n+\tif ent, ok = c.items[key]; ok {\n+\t\t// Expired item check\n+\t\tif time.Now().After(ent.ExpiresAt) {\n+\t\t\treturn value, false\n+\t\t}\n+\t\treturn ent.Value, true\n+\t}\n+\treturn\n+}\n+\n+// Remove removes the provided key from the cache, returning if the\n+// key was contained.\n+func (c *LRU[K, V]) Remove(key K) bool {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif ent, ok := c.items[key]; ok {\n+\t\tc.removeElement(ent)\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// RemoveOldest removes the oldest item from the cache.\n+func (c *LRU[K, V]) RemoveOldest() (key K, value V, ok bool) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif ent := c.evictList.Back(); ent != nil {\n+\t\tc.removeElement(ent)\n+\t\treturn ent.Key, ent.Value, true\n+\t}\n+\treturn\n+}\n+\n+// GetOldest returns the oldest entry\n+func (c *LRU[K, V]) GetOldest() (key K, value V, ok bool) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif ent := c.evictList.Back(); ent != nil {\n+\t\treturn ent.Key, ent.Value, true\n+\t}\n+\treturn\n+}\n+\n+// Keys returns a slice of the keys in the cache, from oldest to newest.\n+func (c *LRU[K, V]) Keys() []K {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tkeys := make([]K, 0, len(c.items))\n+\tfor ent := c.evictList.Back(); ent != nil; ent = ent.PrevEntry() {\n+\t\tkeys = append(keys, ent.Key)\n+\t}\n+\treturn keys\n+}\n+\n+// Values returns a slice of the values in the cache, from oldest to newest.\n+// Expired entries are filtered out.\n+func (c *LRU[K, V]) Values() []V {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tvalues := make([]V, len(c.items))\n+\ti := 0\n+\tnow := time.Now()\n+\tfor ent := c.evictList.Back(); ent != nil; ent = ent.PrevEntry() {\n+\t\tif now.After(ent.ExpiresAt) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvalues[i] = ent.Value\n+\t\ti++\n+\t}\n+\treturn values\n+}\n+\n+// Len returns the number of items in the cache.\n+func (c *LRU[K, V]) Len() int {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\treturn c.evictList.Length()\n+}\n+\n+// Resize changes the cache size. Size of 0 means unlimited.\n+func (c *LRU[K, V]) Resize(size int) (evicted int) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif size <= 0 {\n+\t\tc.size = 0\n+\t\treturn 0\n+\t}\n+\tdiff := c.evictList.Length() - size\n+\tif diff < 0 {\n+\t\tdiff = 0\n+\t}\n+\tfor i := 0; i < diff; i++ {\n+\t\tc.removeOldest()\n+\t}\n+\tc.size = size\n+\treturn diff\n+}\n+\n+// Close destroys cleanup goroutine. To clean up the cache, run Purge() before Close().\n+// func (c *LRU[K, V]) Close() {\n+//\tc.mu.Lock()\n+//\tdefer c.mu.Unlock()\n+//\tselect {\n+//\tcase <-c.done:\n+//\t\treturn\n+//\tdefault:\n+//\t}\n+//\tclose(c.done)\n+// }\n+\n+// removeOldest removes the oldest item from the cache. Has to be called with lock!\n+func (c *LRU[K, V]) removeOldest() {\n+\tif ent := c.evictList.Back(); ent != nil {\n+\t\tc.removeElement(ent)\n+\t}\n+}\n+\n+// removeElement is used to remove a given list element from the cache. Has to be called with lock!\n+func (c *LRU[K, V]) removeElement(e *internal.Entry[K, V]) {\n+\tc.evictList.Remove(e)\n+\tdelete(c.items, e.Key)\n+\tc.removeFromBucket(e)\n+\tif c.onEvict != nil {\n+\t\tc.onEvict(e.Key, e.Value)\n+\t}\n+}\n+\n+// deleteExpired deletes expired records from the oldest bucket, waiting for the newest entry\n+// in it to expire first.\n+func (c *LRU[K, V]) deleteExpired() {\n+\tc.mu.Lock()\n+\tbucketIdx := c.nextCleanupBucket\n+\ttimeToExpire := time.Until(c.buckets[bucketIdx].newestEntry)\n+\t// wait for newest entry to expire before cleanup without holding lock\n+\tif timeToExpire > 0 {\n+\t\tc.mu.Unlock()\n+\t\ttime.Sleep(timeToExpire)\n+\t\tc.mu.Lock()\n+\t}\n+\tfor _, ent := range c.buckets[bucketIdx].entries {\n+\t\tc.removeElement(ent)\n+\t}\n+\tc.nextCleanupBucket = (c.nextCleanupBucket + 1) % numBuckets\n+\tc.mu.Unlock()\n+}\n+\n+// addToBucket adds entry to expire bucket so that it will be cleaned up when the time comes. Has to be called with lock!\n+func (c *LRU[K, V]) addToBucket(e *internal.Entry[K, V]) {\n+\tbucketID := (numBuckets + c.nextCleanupBucket - 1) % numBuckets\n+\te.ExpireBucket = bucketID\n+\tc.buckets[bucketID].entries[e.Key] = e\n+\tif c.buckets[bucketID].newestEntry.Before(e.ExpiresAt) {\n+\t\tc.buckets[bucketID].newestEntry = e.ExpiresAt\n+\t}\n+}\n+\n+// removeFromBucket removes the entry from its corresponding bucket. Has to be called with lock!\n+func (c *LRU[K, V]) removeFromBucket(e *internal.Entry[K, V]) {\n+\tdelete(c.buckets[e.ExpireBucket].entries, e.Key)\n+}"
    },
    {
      "sha": "5cd74a03433177aa391f7d66b11d486d945fe3e9",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/internal/list.go",
      "status": "added",
      "additions": 142,
      "deletions": 0,
      "changes": 142,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Finternal%2Flist.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Finternal%2Flist.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Finternal%2Flist.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE_list file.\n+\n+package internal\n+\n+import \"time\"\n+\n+// Entry is an LRU Entry\n+type Entry[K comparable, V any] struct {\n+\t// Next and previous pointers in the doubly-linked list of elements.\n+\t// To simplify the implementation, internally a list l is implemented\n+\t// as a ring, such that &l.root is both the next element of the last\n+\t// list element (l.Back()) and the previous element of the first list\n+\t// element (l.Front()).\n+\tnext, prev *Entry[K, V]\n+\n+\t// The list to which this element belongs.\n+\tlist *LruList[K, V]\n+\n+\t// The LRU Key of this element.\n+\tKey K\n+\n+\t// The Value stored with this element.\n+\tValue V\n+\n+\t// The time this element would be cleaned up, optional\n+\tExpiresAt time.Time\n+\n+\t// The expiry bucket item was put in, optional\n+\tExpireBucket uint8\n+}\n+\n+// PrevEntry returns the previous list element or nil.\n+func (e *Entry[K, V]) PrevEntry() *Entry[K, V] {\n+\tif p := e.prev; e.list != nil && p != &e.list.root {\n+\t\treturn p\n+\t}\n+\treturn nil\n+}\n+\n+// LruList represents a doubly linked list.\n+// The zero Value for LruList is an empty list ready to use.\n+type LruList[K comparable, V any] struct {\n+\troot Entry[K, V] // sentinel list element, only &root, root.prev, and root.next are used\n+\tlen  int         // current list Length excluding (this) sentinel element\n+}\n+\n+// Init initializes or clears list l.\n+func (l *LruList[K, V]) Init() *LruList[K, V] {\n+\tl.root.next = &l.root\n+\tl.root.prev = &l.root\n+\tl.len = 0\n+\treturn l\n+}\n+\n+// NewList returns an initialized list.\n+func NewList[K comparable, V any]() *LruList[K, V] { return new(LruList[K, V]).Init() }\n+\n+// Length returns the number of elements of list l.\n+// The complexity is O(1).\n+func (l *LruList[K, V]) Length() int { return l.len }\n+\n+// Back returns the last element of list l or nil if the list is empty.\n+func (l *LruList[K, V]) Back() *Entry[K, V] {\n+\tif l.len == 0 {\n+\t\treturn nil\n+\t}\n+\treturn l.root.prev\n+}\n+\n+// lazyInit lazily initializes a zero List Value.\n+func (l *LruList[K, V]) lazyInit() {\n+\tif l.root.next == nil {\n+\t\tl.Init()\n+\t}\n+}\n+\n+// insert inserts e after at, increments l.len, and returns e.\n+func (l *LruList[K, V]) insert(e, at *Entry[K, V]) *Entry[K, V] {\n+\te.prev = at\n+\te.next = at.next\n+\te.prev.next = e\n+\te.next.prev = e\n+\te.list = l\n+\tl.len++\n+\treturn e\n+}\n+\n+// insertValue is a convenience wrapper for insert(&Entry{Value: v, ExpiresAt: ExpiresAt}, at).\n+func (l *LruList[K, V]) insertValue(k K, v V, expiresAt time.Time, at *Entry[K, V]) *Entry[K, V] {\n+\treturn l.insert(&Entry[K, V]{Value: v, Key: k, ExpiresAt: expiresAt}, at)\n+}\n+\n+// Remove removes e from its list, decrements l.len\n+func (l *LruList[K, V]) Remove(e *Entry[K, V]) V {\n+\te.prev.next = e.next\n+\te.next.prev = e.prev\n+\te.next = nil // avoid memory leaks\n+\te.prev = nil // avoid memory leaks\n+\te.list = nil\n+\tl.len--\n+\n+\treturn e.Value\n+}\n+\n+// move moves e to next to at.\n+func (l *LruList[K, V]) move(e, at *Entry[K, V]) {\n+\tif e == at {\n+\t\treturn\n+\t}\n+\te.prev.next = e.next\n+\te.next.prev = e.prev\n+\n+\te.prev = at\n+\te.next = at.next\n+\te.prev.next = e\n+\te.next.prev = e\n+}\n+\n+// PushFront inserts a new element e with value v at the front of list l and returns e.\n+func (l *LruList[K, V]) PushFront(k K, v V) *Entry[K, V] {\n+\tl.lazyInit()\n+\treturn l.insertValue(k, v, time.Time{}, &l.root)\n+}\n+\n+// PushFrontExpirable inserts a new expirable element e with Value v at the front of list l and returns e.\n+func (l *LruList[K, V]) PushFrontExpirable(k K, v V, expiresAt time.Time) *Entry[K, V] {\n+\tl.lazyInit()\n+\treturn l.insertValue(k, v, expiresAt, &l.root)\n+}\n+\n+// MoveToFront moves element e to the front of list l.\n+// If e is not an element of l, the list is not modified.\n+// The element must not be nil.\n+func (l *LruList[K, V]) MoveToFront(e *Entry[K, V]) {\n+\tif e.list != l || l.root.next == e {\n+\t\treturn\n+\t}\n+\t// see comment in List.Remove about initialization of l\n+\tl.move(e, &l.root)\n+}"
    },
    {
      "sha": "a2655f1f3109395e2e0e1482afcb0a404b716847",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/lru.go",
      "status": "renamed",
      "additions": 54,
      "deletions": 35,
      "changes": 89,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Flru.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Flru.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Flru.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -1,9 +1,12 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n package lru\n \n import (\n \t\"sync\"\n \n-\t\"github.com/hashicorp/golang-lru/simplelru\"\n+\t\"github.com/hashicorp/golang-lru/v2/simplelru\"\n )\n \n const (\n@@ -12,23 +15,24 @@ const (\n )\n \n // Cache is a thread-safe fixed size LRU cache.\n-type Cache struct {\n-\tlru                      *simplelru.LRU\n-\tevictedKeys, evictedVals []interface{}\n-\tonEvictedCB              func(k, v interface{})\n-\tlock                     sync.RWMutex\n+type Cache[K comparable, V any] struct {\n+\tlru         *simplelru.LRU[K, V]\n+\tevictedKeys []K\n+\tevictedVals []V\n+\tonEvictedCB func(k K, v V)\n+\tlock        sync.RWMutex\n }\n \n // New creates an LRU of the given size.\n-func New(size int) (*Cache, error) {\n-\treturn NewWithEvict(size, nil)\n+func New[K comparable, V any](size int) (*Cache[K, V], error) {\n+\treturn NewWithEvict[K, V](size, nil)\n }\n \n // NewWithEvict constructs a fixed size cache with the given eviction\n // callback.\n-func NewWithEvict(size int, onEvicted func(key, value interface{})) (c *Cache, err error) {\n+func NewWithEvict[K comparable, V any](size int, onEvicted func(key K, value V)) (c *Cache[K, V], err error) {\n \t// create a cache with default settings\n-\tc = &Cache{\n+\tc = &Cache[K, V]{\n \t\tonEvictedCB: onEvicted,\n \t}\n \tif onEvicted != nil {\n@@ -39,21 +43,22 @@ func NewWithEvict(size int, onEvicted func(key, value interface{})) (c *Cache, e\n \treturn\n }\n \n-func (c *Cache) initEvictBuffers() {\n-\tc.evictedKeys = make([]interface{}, 0, DefaultEvictedBufferSize)\n-\tc.evictedVals = make([]interface{}, 0, DefaultEvictedBufferSize)\n+func (c *Cache[K, V]) initEvictBuffers() {\n+\tc.evictedKeys = make([]K, 0, DefaultEvictedBufferSize)\n+\tc.evictedVals = make([]V, 0, DefaultEvictedBufferSize)\n }\n \n // onEvicted save evicted key/val and sent in externally registered callback\n // outside of critical section\n-func (c *Cache) onEvicted(k, v interface{}) {\n+func (c *Cache[K, V]) onEvicted(k K, v V) {\n \tc.evictedKeys = append(c.evictedKeys, k)\n \tc.evictedVals = append(c.evictedVals, v)\n }\n \n // Purge is used to completely clear the cache.\n-func (c *Cache) Purge() {\n-\tvar ks, vs []interface{}\n+func (c *Cache[K, V]) Purge() {\n+\tvar ks []K\n+\tvar vs []V\n \tc.lock.Lock()\n \tc.lru.Purge()\n \tif c.onEvictedCB != nil && len(c.evictedKeys) > 0 {\n@@ -70,8 +75,9 @@ func (c *Cache) Purge() {\n }\n \n // Add adds a value to the cache. Returns true if an eviction occurred.\n-func (c *Cache) Add(key, value interface{}) (evicted bool) {\n-\tvar k, v interface{}\n+func (c *Cache[K, V]) Add(key K, value V) (evicted bool) {\n+\tvar k K\n+\tvar v V\n \tc.lock.Lock()\n \tevicted = c.lru.Add(key, value)\n \tif c.onEvictedCB != nil && evicted {\n@@ -86,7 +92,7 @@ func (c *Cache) Add(key, value interface{}) (evicted bool) {\n }\n \n // Get looks up a key's value from the cache.\n-func (c *Cache) Get(key interface{}) (value interface{}, ok bool) {\n+func (c *Cache[K, V]) Get(key K) (value V, ok bool) {\n \tc.lock.Lock()\n \tvalue, ok = c.lru.Get(key)\n \tc.lock.Unlock()\n@@ -95,7 +101,7 @@ func (c *Cache) Get(key interface{}) (value interface{}, ok bool) {\n \n // Contains checks if a key is in the cache, without updating the\n // recent-ness or deleting it for being stale.\n-func (c *Cache) Contains(key interface{}) bool {\n+func (c *Cache[K, V]) Contains(key K) bool {\n \tc.lock.RLock()\n \tcontainKey := c.lru.Contains(key)\n \tc.lock.RUnlock()\n@@ -104,7 +110,7 @@ func (c *Cache) Contains(key interface{}) bool {\n \n // Peek returns the key value (or undefined if not found) without updating\n // the \"recently used\"-ness of the key.\n-func (c *Cache) Peek(key interface{}) (value interface{}, ok bool) {\n+func (c *Cache[K, V]) Peek(key K) (value V, ok bool) {\n \tc.lock.RLock()\n \tvalue, ok = c.lru.Peek(key)\n \tc.lock.RUnlock()\n@@ -114,8 +120,9 @@ func (c *Cache) Peek(key interface{}) (value interface{}, ok bool) {\n // ContainsOrAdd checks if a key is in the cache without updating the\n // recent-ness or deleting it for being stale, and if not, adds the value.\n // Returns whether found and whether an eviction occurred.\n-func (c *Cache) ContainsOrAdd(key, value interface{}) (ok, evicted bool) {\n-\tvar k, v interface{}\n+func (c *Cache[K, V]) ContainsOrAdd(key K, value V) (ok, evicted bool) {\n+\tvar k K\n+\tvar v V\n \tc.lock.Lock()\n \tif c.lru.Contains(key) {\n \t\tc.lock.Unlock()\n@@ -136,8 +143,9 @@ func (c *Cache) ContainsOrAdd(key, value interface{}) (ok, evicted bool) {\n // PeekOrAdd checks if a key is in the cache without updating the\n // recent-ness or deleting it for being stale, and if not, adds the value.\n // Returns whether found and whether an eviction occurred.\n-func (c *Cache) PeekOrAdd(key, value interface{}) (previous interface{}, ok, evicted bool) {\n-\tvar k, v interface{}\n+func (c *Cache[K, V]) PeekOrAdd(key K, value V) (previous V, ok, evicted bool) {\n+\tvar k K\n+\tvar v V\n \tc.lock.Lock()\n \tprevious, ok = c.lru.Peek(key)\n \tif ok {\n@@ -153,12 +161,13 @@ func (c *Cache) PeekOrAdd(key, value interface{}) (previous interface{}, ok, evi\n \tif c.onEvictedCB != nil && evicted {\n \t\tc.onEvictedCB(k, v)\n \t}\n-\treturn nil, false, evicted\n+\treturn\n }\n \n // Remove removes the provided key from the cache.\n-func (c *Cache) Remove(key interface{}) (present bool) {\n-\tvar k, v interface{}\n+func (c *Cache[K, V]) Remove(key K) (present bool) {\n+\tvar k K\n+\tvar v V\n \tc.lock.Lock()\n \tpresent = c.lru.Remove(key)\n \tif c.onEvictedCB != nil && present {\n@@ -173,8 +182,9 @@ func (c *Cache) Remove(key interface{}) (present bool) {\n }\n \n // Resize changes the cache size.\n-func (c *Cache) Resize(size int) (evicted int) {\n-\tvar ks, vs []interface{}\n+func (c *Cache[K, V]) Resize(size int) (evicted int) {\n+\tvar ks []K\n+\tvar vs []V\n \tc.lock.Lock()\n \tevicted = c.lru.Resize(size)\n \tif c.onEvictedCB != nil && evicted > 0 {\n@@ -191,8 +201,9 @@ func (c *Cache) Resize(size int) (evicted int) {\n }\n \n // RemoveOldest removes the oldest item from the cache.\n-func (c *Cache) RemoveOldest() (key, value interface{}, ok bool) {\n-\tvar k, v interface{}\n+func (c *Cache[K, V]) RemoveOldest() (key K, value V, ok bool) {\n+\tvar k K\n+\tvar v V\n \tc.lock.Lock()\n \tkey, value, ok = c.lru.RemoveOldest()\n \tif c.onEvictedCB != nil && ok {\n@@ -207,23 +218,31 @@ func (c *Cache) RemoveOldest() (key, value interface{}, ok bool) {\n }\n \n // GetOldest returns the oldest entry\n-func (c *Cache) GetOldest() (key, value interface{}, ok bool) {\n+func (c *Cache[K, V]) GetOldest() (key K, value V, ok bool) {\n \tc.lock.RLock()\n \tkey, value, ok = c.lru.GetOldest()\n \tc.lock.RUnlock()\n \treturn\n }\n \n // Keys returns a slice of the keys in the cache, from oldest to newest.\n-func (c *Cache) Keys() []interface{} {\n+func (c *Cache[K, V]) Keys() []K {\n \tc.lock.RLock()\n \tkeys := c.lru.Keys()\n \tc.lock.RUnlock()\n \treturn keys\n }\n \n+// Values returns a slice of the values in the cache, from oldest to newest.\n+func (c *Cache[K, V]) Values() []V {\n+\tc.lock.RLock()\n+\tvalues := c.lru.Values()\n+\tc.lock.RUnlock()\n+\treturn values\n+}\n+\n // Len returns the number of items in the cache.\n-func (c *Cache) Len() int {\n+func (c *Cache[K, V]) Len() int {\n \tc.lock.RLock()\n \tlength := c.lru.Len()\n \tc.lock.RUnlock()",
      "previous_filename": "backend/vendor/github.com/hashicorp/golang-lru/lru.go"
    },
    {
      "sha": "c4764e6b2f088df1a3147b2199d05f271d163867",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/simplelru/LICENSE_list",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2FLICENSE_list",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2FLICENSE_list",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2FLICENSE_list?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -0,0 +1,29 @@\n+This license applies to simplelru/list.go\n+\n+Copyright (c) 2009 The Go Authors. All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+   * Redistributions of source code must retain the above copyright\n+notice, this list of conditions and the following disclaimer.\n+   * Redistributions in binary form must reproduce the above\n+copyright notice, this list of conditions and the following disclaimer\n+in the documentation and/or other materials provided with the\n+distribution.\n+   * Neither the name of Google Inc. nor the names of its\n+contributors may be used to endorse or promote products derived from\n+this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
    },
    {
      "sha": "f69792388c1a54d87e970480e400169451a6f990",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/simplelru/lru.go",
      "status": "renamed",
      "additions": 61,
      "deletions": 61,
      "changes": 122,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2Flru.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2Flru.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2Flru.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -1,67 +1,65 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n package simplelru\n \n import (\n-\t\"container/list\"\n \t\"errors\"\n+\n+\t\"github.com/hashicorp/golang-lru/v2/internal\"\n )\n \n // EvictCallback is used to get a callback when a cache entry is evicted\n-type EvictCallback func(key interface{}, value interface{})\n+type EvictCallback[K comparable, V any] func(key K, value V)\n \n // LRU implements a non-thread safe fixed size LRU cache\n-type LRU struct {\n+type LRU[K comparable, V any] struct {\n \tsize      int\n-\tevictList *list.List\n-\titems     map[interface{}]*list.Element\n-\tonEvict   EvictCallback\n-}\n-\n-// entry is used to hold a value in the evictList\n-type entry struct {\n-\tkey   interface{}\n-\tvalue interface{}\n+\tevictList *internal.LruList[K, V]\n+\titems     map[K]*internal.Entry[K, V]\n+\tonEvict   EvictCallback[K, V]\n }\n \n // NewLRU constructs an LRU of the given size\n-func NewLRU(size int, onEvict EvictCallback) (*LRU, error) {\n+func NewLRU[K comparable, V any](size int, onEvict EvictCallback[K, V]) (*LRU[K, V], error) {\n \tif size <= 0 {\n \t\treturn nil, errors.New(\"must provide a positive size\")\n \t}\n-\tc := &LRU{\n+\n+\tc := &LRU[K, V]{\n \t\tsize:      size,\n-\t\tevictList: list.New(),\n-\t\titems:     make(map[interface{}]*list.Element),\n+\t\tevictList: internal.NewList[K, V](),\n+\t\titems:     make(map[K]*internal.Entry[K, V]),\n \t\tonEvict:   onEvict,\n \t}\n \treturn c, nil\n }\n \n // Purge is used to completely clear the cache.\n-func (c *LRU) Purge() {\n+func (c *LRU[K, V]) Purge() {\n \tfor k, v := range c.items {\n \t\tif c.onEvict != nil {\n-\t\t\tc.onEvict(k, v.Value.(*entry).value)\n+\t\t\tc.onEvict(k, v.Value)\n \t\t}\n \t\tdelete(c.items, k)\n \t}\n \tc.evictList.Init()\n }\n \n // Add adds a value to the cache.  Returns true if an eviction occurred.\n-func (c *LRU) Add(key, value interface{}) (evicted bool) {\n+func (c *LRU[K, V]) Add(key K, value V) (evicted bool) {\n \t// Check for existing item\n \tif ent, ok := c.items[key]; ok {\n \t\tc.evictList.MoveToFront(ent)\n-\t\tent.Value.(*entry).value = value\n+\t\tent.Value = value\n \t\treturn false\n \t}\n \n \t// Add new item\n-\tent := &entry{key, value}\n-\tentry := c.evictList.PushFront(ent)\n-\tc.items[key] = entry\n+\tent := c.evictList.PushFront(key, value)\n+\tc.items[key] = ent\n \n-\tevict := c.evictList.Len() > c.size\n+\tevict := c.evictList.Length() > c.size\n \t// Verify size not exceeded\n \tif evict {\n \t\tc.removeOldest()\n@@ -70,37 +68,34 @@ func (c *LRU) Add(key, value interface{}) (evicted bool) {\n }\n \n // Get looks up a key's value from the cache.\n-func (c *LRU) Get(key interface{}) (value interface{}, ok bool) {\n+func (c *LRU[K, V]) Get(key K) (value V, ok bool) {\n \tif ent, ok := c.items[key]; ok {\n \t\tc.evictList.MoveToFront(ent)\n-\t\tif ent.Value.(*entry) == nil {\n-\t\t\treturn nil, false\n-\t\t}\n-\t\treturn ent.Value.(*entry).value, true\n+\t\treturn ent.Value, true\n \t}\n \treturn\n }\n \n // Contains checks if a key is in the cache, without updating the recent-ness\n // or deleting it for being stale.\n-func (c *LRU) Contains(key interface{}) (ok bool) {\n+func (c *LRU[K, V]) Contains(key K) (ok bool) {\n \t_, ok = c.items[key]\n \treturn ok\n }\n \n // Peek returns the key value (or undefined if not found) without updating\n // the \"recently used\"-ness of the key.\n-func (c *LRU) Peek(key interface{}) (value interface{}, ok bool) {\n-\tvar ent *list.Element\n+func (c *LRU[K, V]) Peek(key K) (value V, ok bool) {\n+\tvar ent *internal.Entry[K, V]\n \tif ent, ok = c.items[key]; ok {\n-\t\treturn ent.Value.(*entry).value, true\n+\t\treturn ent.Value, true\n \t}\n-\treturn nil, ok\n+\treturn\n }\n \n // Remove removes the provided key from the cache, returning if the\n // key was contained.\n-func (c *LRU) Remove(key interface{}) (present bool) {\n+func (c *LRU[K, V]) Remove(key K) (present bool) {\n \tif ent, ok := c.items[key]; ok {\n \t\tc.removeElement(ent)\n \t\treturn true\n@@ -109,44 +104,51 @@ func (c *LRU) Remove(key interface{}) (present bool) {\n }\n \n // RemoveOldest removes the oldest item from the cache.\n-func (c *LRU) RemoveOldest() (key, value interface{}, ok bool) {\n-\tent := c.evictList.Back()\n-\tif ent != nil {\n+func (c *LRU[K, V]) RemoveOldest() (key K, value V, ok bool) {\n+\tif ent := c.evictList.Back(); ent != nil {\n \t\tc.removeElement(ent)\n-\t\tkv := ent.Value.(*entry)\n-\t\treturn kv.key, kv.value, true\n+\t\treturn ent.Key, ent.Value, true\n \t}\n-\treturn nil, nil, false\n+\treturn\n }\n \n // GetOldest returns the oldest entry\n-func (c *LRU) GetOldest() (key, value interface{}, ok bool) {\n-\tent := c.evictList.Back()\n-\tif ent != nil {\n-\t\tkv := ent.Value.(*entry)\n-\t\treturn kv.key, kv.value, true\n+func (c *LRU[K, V]) GetOldest() (key K, value V, ok bool) {\n+\tif ent := c.evictList.Back(); ent != nil {\n+\t\treturn ent.Key, ent.Value, true\n \t}\n-\treturn nil, nil, false\n+\treturn\n }\n \n // Keys returns a slice of the keys in the cache, from oldest to newest.\n-func (c *LRU) Keys() []interface{} {\n-\tkeys := make([]interface{}, len(c.items))\n+func (c *LRU[K, V]) Keys() []K {\n+\tkeys := make([]K, c.evictList.Length())\n \ti := 0\n-\tfor ent := c.evictList.Back(); ent != nil; ent = ent.Prev() {\n-\t\tkeys[i] = ent.Value.(*entry).key\n+\tfor ent := c.evictList.Back(); ent != nil; ent = ent.PrevEntry() {\n+\t\tkeys[i] = ent.Key\n \t\ti++\n \t}\n \treturn keys\n }\n \n+// Values returns a slice of the values in the cache, from oldest to newest.\n+func (c *LRU[K, V]) Values() []V {\n+\tvalues := make([]V, len(c.items))\n+\ti := 0\n+\tfor ent := c.evictList.Back(); ent != nil; ent = ent.PrevEntry() {\n+\t\tvalues[i] = ent.Value\n+\t\ti++\n+\t}\n+\treturn values\n+}\n+\n // Len returns the number of items in the cache.\n-func (c *LRU) Len() int {\n-\treturn c.evictList.Len()\n+func (c *LRU[K, V]) Len() int {\n+\treturn c.evictList.Length()\n }\n \n // Resize changes the cache size.\n-func (c *LRU) Resize(size int) (evicted int) {\n+func (c *LRU[K, V]) Resize(size int) (evicted int) {\n \tdiff := c.Len() - size\n \tif diff < 0 {\n \t\tdiff = 0\n@@ -159,19 +161,17 @@ func (c *LRU) Resize(size int) (evicted int) {\n }\n \n // removeOldest removes the oldest item from the cache.\n-func (c *LRU) removeOldest() {\n-\tent := c.evictList.Back()\n-\tif ent != nil {\n+func (c *LRU[K, V]) removeOldest() {\n+\tif ent := c.evictList.Back(); ent != nil {\n \t\tc.removeElement(ent)\n \t}\n }\n \n // removeElement is used to remove a given list element from the cache\n-func (c *LRU) removeElement(e *list.Element) {\n+func (c *LRU[K, V]) removeElement(e *internal.Entry[K, V]) {\n \tc.evictList.Remove(e)\n-\tkv := e.Value.(*entry)\n-\tdelete(c.items, kv.key)\n+\tdelete(c.items, e.Key)\n \tif c.onEvict != nil {\n-\t\tc.onEvict(kv.key, kv.value)\n+\t\tc.onEvict(e.Key, e.Value)\n \t}\n }",
      "previous_filename": "backend/vendor/github.com/hashicorp/golang-lru/simplelru/lru.go"
    },
    {
      "sha": "043b8bcc3f3f5f39563be3496dbd15d5f4cd57cc",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/v2/simplelru/lru_interface.go",
      "status": "renamed",
      "additions": 15,
      "deletions": 9,
      "changes": 24,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2Flru_interface.go",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2Flru_interface.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fhashicorp%2Fgolang-lru%2Fv2%2Fsimplelru%2Flru_interface.go?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -1,33 +1,39 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n // Package simplelru provides simple LRU implementation based on build-in container/list.\n package simplelru\n \n // LRUCache is the interface for simple LRU cache.\n-type LRUCache interface {\n+type LRUCache[K comparable, V any] interface {\n \t// Adds a value to the cache, returns true if an eviction occurred and\n \t// updates the \"recently used\"-ness of the key.\n-\tAdd(key, value interface{}) bool\n+\tAdd(key K, value V) bool\n \n \t// Returns key's value from the cache and\n \t// updates the \"recently used\"-ness of the key. #value, isFound\n-\tGet(key interface{}) (value interface{}, ok bool)\n+\tGet(key K) (value V, ok bool)\n \n \t// Checks if a key exists in cache without updating the recent-ness.\n-\tContains(key interface{}) (ok bool)\n+\tContains(key K) (ok bool)\n \n \t// Returns key's value without updating the \"recently used\"-ness of the key.\n-\tPeek(key interface{}) (value interface{}, ok bool)\n+\tPeek(key K) (value V, ok bool)\n \n \t// Removes a key from the cache.\n-\tRemove(key interface{}) bool\n+\tRemove(key K) bool\n \n \t// Removes the oldest entry from cache.\n-\tRemoveOldest() (interface{}, interface{}, bool)\n+\tRemoveOldest() (K, V, bool)\n \n \t// Returns the oldest entry from the cache. #key, value, isFound\n-\tGetOldest() (interface{}, interface{}, bool)\n+\tGetOldest() (K, V, bool)\n \n \t// Returns a slice of the keys in the cache, from oldest to newest.\n-\tKeys() []interface{}\n+\tKeys() []K\n+\n+\t// Values returns a slice of the values in the cache, from oldest to newest.\n+\tValues() []V\n \n \t// Returns the number of items in the cache.\n \tLen() int",
      "previous_filename": "backend/vendor/github.com/hashicorp/golang-lru/simplelru/lru_interface.go"
    },
    {
      "sha": "6288a8535919c43048f2e37776a42058293bfc36",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 9,
      "deletions": 8,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark42/blob/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fmodules.txt",
      "raw_url": "https://github.com/umputun/remark42/raw/1313dee829ff781f20c6c5614473e2534a88bd30/backend%2Fvendor%2Fmodules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fmodules.txt?ref=1313dee829ff781f20c6c5614473e2534a88bd30",
      "patch": "@@ -86,11 +86,10 @@ github.com/go-pkgz/expirable-cache\n # github.com/go-pkgz/jrpc v0.3.0\n ## explicit; go 1.16\n github.com/go-pkgz/jrpc\n-# github.com/go-pkgz/lcw v1.1.0\n+# github.com/go-pkgz/lcw/v2 v2.0.0\n ## explicit; go 1.21\n-github.com/go-pkgz/lcw\n-github.com/go-pkgz/lcw/eventbus\n-github.com/go-pkgz/lcw/internal/cache\n+github.com/go-pkgz/lcw/v2\n+github.com/go-pkgz/lcw/v2/eventbus\n # github.com/go-pkgz/lgr v0.11.1\n ## explicit; go 1.20\n github.com/go-pkgz/lgr\n@@ -136,10 +135,12 @@ github.com/hashicorp/errwrap\n # github.com/hashicorp/go-multierror v1.1.1\n ## explicit; go 1.13\n github.com/hashicorp/go-multierror\n-# github.com/hashicorp/golang-lru v1.0.2\n-## explicit; go 1.12\n-github.com/hashicorp/golang-lru\n-github.com/hashicorp/golang-lru/simplelru\n+# github.com/hashicorp/golang-lru/v2 v2.0.7\n+## explicit; go 1.18\n+github.com/hashicorp/golang-lru/v2\n+github.com/hashicorp/golang-lru/v2/expirable\n+github.com/hashicorp/golang-lru/v2/internal\n+github.com/hashicorp/golang-lru/v2/simplelru\n # github.com/jessevdk/go-flags v1.5.0\n ## explicit; go 1.15\n github.com/jessevdk/go-flags"
    }
  ]
}
