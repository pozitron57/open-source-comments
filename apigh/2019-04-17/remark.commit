{
  "sha": "68b892f5e913e60ed9a2d38fe96af0b63e05a642",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOjY4Yjg5MmY1ZTkxM2U2MGVkOWEyZDM4ZmU5NmFmMGI2M2UwNWE2NDI=",
  "commit": {
    "author": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-04-17T07:53:35Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2019-04-17T07:53:35Z"
    },
    "message": "Image resize (#311)\n\n* resize uploaded images #309\r\n\r\n* fix temp files created in current dire after image test\r\n\r\n* update mod\r\n\r\n* missing image test files\r\n\r\n* fix failed goroutine test on image-resize submit\r\n\r\n* switch to mockery\r\n\r\n* missing in mock change\r\n\r\n* resize by both ResizeWidth and ResizeHeight\r\n\r\n* add IMAGE_RESIZE params to readme\r\n\r\n* add latest features to the description\r\n\r\n* lint: missing file close in image test",
    "tree": {
      "sha": "d387f2bcb9f643461fe23aa8fcbb4abb6d7f3eff",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/d387f2bcb9f643461fe23aa8fcbb4abb6d7f3eff"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/68b892f5e913e60ed9a2d38fe96af0b63e05a642",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcttt/CRBK7hj4Ov3rIwAAdHIIAKTrMaQOcP81eFY9MpeVfxy1\nldJkSo0mlMHN9Bgnynl+seR6xippu/z1J0PbD1WmUKKPJ+dZT8NjmLi/DmTgvgL/\nwM3U+kYHw6By5URnvKEOuLBoTylZFZeDBUNTfgUa7LkbV6B6+TtJ7933+QCPuzgh\nzLkXgzyoxBTPM32xmj8fg670fHkSxjHt3C6CPtXCx9ItA3MKs7Dew/maHcwZlLBa\nDdl3nfruKPLy6at0/lR52cPzBNdtLgUqS2tnYyQQ2S4h6TYZ5v12xzbynaVrmOO3\nvhVMHd7TUG5l/swl67fy0GlcRh4BVuaRI+seCOOf1PrEQuln0djZXTcEgioh6vo=\n=K95Y\n-----END PGP SIGNATURE-----\n",
      "payload": "tree d387f2bcb9f643461fe23aa8fcbb4abb6d7f3eff\nparent 24606e46bff1e4e06da449ecf149f4702ff9d36a\nauthor Umputun <umputun@gmail.com> 1555487615 -0500\ncommitter GitHub <noreply@github.com> 1555487615 -0500\n\nImage resize (#311)\n\n* resize uploaded images #309\r\n\r\n* fix temp files created in current dire after image test\r\n\r\n* update mod\r\n\r\n* missing image test files\r\n\r\n* fix failed goroutine test on image-resize submit\r\n\r\n* switch to mockery\r\n\r\n* missing in mock change\r\n\r\n* resize by both ResizeWidth and ResizeHeight\r\n\r\n* add IMAGE_RESIZE params to readme\r\n\r\n* add latest features to the description\r\n\r\n* lint: missing file close in image test\r\n"
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/68b892f5e913e60ed9a2d38fe96af0b63e05a642",
  "html_url": "https://github.com/umputun/remark/commit/68b892f5e913e60ed9a2d38fe96af0b63e05a642",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/68b892f5e913e60ed9a2d38fe96af0b63e05a642/comments",
  "author": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "24606e46bff1e4e06da449ecf149f4702ff9d36a",
      "url": "https://api.github.com/repos/umputun/remark/commits/24606e46bff1e4e06da449ecf149f4702ff9d36a",
      "html_url": "https://github.com/umputun/remark/commit/24606e46bff1e4e06da449ecf149f4702ff9d36a"
    }
  ],
  "stats": {
    "total": 12991,
    "additions": 11623,
    "deletions": 1368
  },
  "files": [
    {
      "sha": "2ed34d72992c7f4de2af472df529239ceb395912",
      "filename": "README.md",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/README.md?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -6,18 +6,19 @@ Remark42 is a self-hosted, lightweight, and simple (yet functional) comment engi\n * Optional anonymous access\n * Multi-level nested comments with both tree and plain presentations\n * Import from disqus and wordpress\n-* Markdown support\n+* Markdown support with friendly formatter toolbar\n * Moderator can remove comments and block users\n * Voting, pinning and verification system\n * Sortable comments\n+* Images upload with drag-and-drop\n * Extractor for recent comments, cross-post\n * RSS for all comments and each post\n * Telegram notifications\n * Export data to json with automatic backups\n * No external databases, everything embedded in a single data file\n * Fully dockerized and can be deployed in a single command\n * Self-contained executable can be deployed directly to Linux, Windows and MacOS\n-* Clean, lightweight and customizable UI\n+* Clean, lightweight and customizable UI with white and dark themes\n * Multi-site mode from a single instance\n * Integration with automatic ssl (direct and via [nginx-le](https://github.com/umputun/nginx-le))\n * [Privacy focused](#privacy)\n@@ -112,6 +113,8 @@ _this is the recommended way to run remark42_\n | image.fs.path           | IMAGE_FS_PATH           | `./var/pictures`         | permanent location of images                     |\n | image.fs.staging        | IMAGE_FS_STAGING        | `./var/pictures.staging` | staging location of images                       |\n | image.fs.partitions     | IMAGE_FS_PARTITIONS     | `100`                    | number of image partitions                       |\n+| image.resize-width      | IMAGE_RESIZE_WIDTH      | `800`                    | width of resized image                          |\n+| image.resize-height     | IMAGE_RESIZE_HEIGHT     | `300`                    | height of resized image                          |\n | auth.ttl.jwt            | AUTH_TTL_JWT            | `5m`                     | jwt TTL                                          |\n | auth.ttl.cookie         | AUTH_TTL_COOKIE         | `200h`                   | cookie TTL                                       |\n | auth.google.cid         | AUTH_GOOGLE_CID         |                          | Google OAuth client ID                           |"
    },
    {
      "sha": "cd1ca5c077407ed23b3d838ff04dcf6eef10c510",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/cmd/server.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/cmd/server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/cmd/server.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -106,7 +106,9 @@ type ImageGroup struct {\n \tBolt struct {\n \t\tFile string `long:\"file\" env:\"FILE\" default:\"./var/pictures.db\" description:\"images bolt file location\"`\n \t} `group:\"bolt\" namespace:\"bolt\" env-namespace:\"bolt\"`\n-\tMaxSize int `long:\"max-size\" env:\"MAX_SIZE\" default:\"5000000\" description:\"max size of image file\"`\n+\tMaxSize      int `long:\"max-size\" env:\"MAX_SIZE\" default:\"5000000\" description:\"max size of image file\"`\n+\tResizeWidth  int `long:\"resize-width\" env:\"RESIZE_WIDTH\" default:\"800\" description:\"width of resized image\"`\n+\tResizeHeight int `long:\"resize-height\" env:\"RESIZE_HEIGHT\" default:\"300\" description:\"height of resized image\"`\n }\n \n // AvatarGroup defines options group for avatar params\n@@ -448,6 +450,8 @@ func (s *ServerCommand) makePicturesStore() (*image.Service, error) {\n \t\t\t\tStaging:    s.Image.FS.Staging,\n \t\t\t\tPartitions: s.Image.FS.Partitions,\n \t\t\t\tMaxSize:    s.Image.MaxSize,\n+\t\t\t\tMaxHeight:  s.Image.ResizeHeight,\n+\t\t\t\tMaxWidth:   s.Image.ResizeWidth,\n \t\t\t},\n \t\t\tTTL: s.EditDuration + time.Second, // add extra second to image TTL for staging\n \t\t}, nil"
    },
    {
      "sha": "568829b605100f3c0dbf21395f2f5ada3aefa781",
      "filename": "backend/app/cmd/server_test.go",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/cmd/server_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/cmd/server_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/cmd/server_test.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -144,7 +144,7 @@ func TestServerApp_WithMongo(t *testing.T) {\n \t\t\"--avatar.type=mongo\", \"--mongo.url=\" + mongoURL, \"--mongo.db=test_remark\", \"--port=12345\", \"--admin.type=mongo\"})\n \trequire.Nil(t, err)\n \topts.Auth.Github.CSEC, opts.Auth.Github.CID = \"csec\", \"cid\"\n-\topts.BackupLocation = \"/tmp\"\n+\topts.BackupLocation, opts.Image.FS.Path = \"/tmp\", \"/tmp\"\n \n \t// create app\n \tapp, err := opts.newServerApp()\n@@ -187,8 +187,10 @@ func TestServerApp_WithSSL(t *testing.T) {\n \n \t// prepare options\n \tp := flags.NewParser(&opts, flags.Default)\n-\t_, err := p.ParseArgs([]string{\"--admin-passwd=password\", \"--port=18080\", \"--store.bolt.path=/tmp/xyz\", \"--backup=/tmp\", \"--avatar.type=bolt\", \"--avatar.bolt.file=/tmp/ava-test.db\", \"--notify.type=none\",\n-\t\t\"--ssl.type=static\", \"--ssl.cert=testdata/cert.pem\", \"--ssl.key=testdata/key.pem\", \"--ssl.port=18443\"})\n+\t_, err := p.ParseArgs([]string{\"--admin-passwd=password\", \"--port=18080\", \"--store.bolt.path=/tmp/xyz\", \"--backup=/tmp\",\n+\t\t\"--avatar.type=bolt\", \"--avatar.bolt.file=/tmp/ava-test.db\", \"--notify.type=none\",\n+\t\t\"--ssl.type=static\", \"--ssl.cert=testdata/cert.pem\", \"--ssl.key=testdata/key.pem\",\n+\t\t\"--ssl.port=18443\", \"--image.fs.path=/tmp\"})\n \trequire.Nil(t, err)\n \n \t// create app\n@@ -242,7 +244,7 @@ func TestServerApp_Failed(t *testing.T) {\n \tp := flags.NewParser(&opts, flags.Default)\n \n \t// RO bolt location\n-\t_, err := p.ParseArgs([]string{\"--backup=/tmp\", \"--store.bolt.path=/dev/null\"})\n+\t_, err := p.ParseArgs([]string{\"--backup=/tmp\", \"--store.bolt.path=/dev/null\", \"--image.fs.path=/tmp\"})\n \tassert.Nil(t, err)\n \t_, err = opts.newServerApp()\n \tassert.EqualError(t, err, \"failed to make data store engine: failed to create bolt store: can't make directory /dev/null: mkdir /dev/null: not a directory\")\n@@ -306,7 +308,7 @@ func TestServerApp_MainSignal(t *testing.T) {\n \n \tp := flags.NewParser(&s, flags.Default)\n \targs := []string{\"test\", \"--store.bolt.path=/tmp/xyz\", \"--backup=/tmp\", \"--avatar.type=bolt\",\n-\t\t\"--avatar.bolt.file=/tmp/ava-test.db\", \"--port=18100\", \"--notify.type=none\"}\n+\t\t\"--avatar.bolt.file=/tmp/ava-test.db\", \"--port=18100\", \"--notify.type=none\", \"--image.fs.path=/tmp\"}\n \tdefer os.Remove(\"/tmp/ava-test.db\")\n \t_, err := p.ParseArgs(args)\n \trequire.Nil(t, err)\n@@ -432,7 +434,7 @@ func prepServerApp(t *testing.T, duration time.Duration, fn func(o ServerCommand\n \tp := flags.NewParser(&cmd, flags.Default)\n \t_, err := p.ParseArgs([]string{\"--admin-passwd=password\", \"--site=remark\"})\n \trequire.Nil(t, err)\n-\tcmd.Avatar.FS.Path, cmd.Avatar.Type, cmd.BackupLocation = \"/tmp\", \"fs\", \"/tmp\"\n+\tcmd.Avatar.FS.Path, cmd.Avatar.Type, cmd.BackupLocation, cmd.Image.FS.Path = \"/tmp\", \"fs\", \"/tmp\", \"/tmp\"\n \tcmd.Store.Bolt.Path = fmt.Sprintf(\"/tmp/%d\", cmd.Port)\n \tcmd.Store.Bolt.Timeout = 10 * time.Second\n \tcmd.Auth.Github.CSEC, cmd.Auth.Github.CID = \"csec\", \"cid\""
    },
    {
      "sha": "f1d49216889ceec8130e2cfde5853045cfd1a3b5",
      "filename": "backend/app/rest/api/rest_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/rest/api/rest_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/rest/api/rest_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest_test.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -290,6 +290,7 @@ func startupT(t *testing.T) (ts *httptest.Server, srv *Rest, teardown func()) {\n \t\t\t\tLocation:   \"/tmp/pics-remark42\",\n \t\t\t\tPartitions: 100,\n \t\t\t\tMaxSize:    10000,\n+\t\t\t\tStaging:    \"/tmp/pics-remark42/staging\",\n \t\t\t},\n \t\t\tTTL: time.Millisecond * 100,\n \t\t},"
    },
    {
      "sha": "c7c8f7d0cd46fbfb716bdbbd5c549cce43ced70a",
      "filename": "backend/app/store/image/fs_store.go",
      "status": "modified",
      "additions": 22,
      "deletions": 14,
      "changes": 36,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/fs_store.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/fs_store.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/fs_store.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -25,6 +25,8 @@ type FileSystem struct {\n \tStaging    string\n \tMaxSize    int\n \tPartitions int\n+\tMaxHeight  int\n+\tMaxWidth   int\n \n \tcrc struct {\n \t\t*crc64.Table\n@@ -38,18 +40,6 @@ type FileSystem struct {\n // Files partitioned across multiple subdirectories and the final path includes part, i.e. /location/user1/03/123-4567.png\n func (f *FileSystem) Save(fileName string, userID string, r io.Reader) (id string, err error) {\n \n-\tid = path.Join(userID, guid()) + filepath.Ext(fileName) // make id as user/uuid.ext\n-\tdst := f.location(f.Staging, id)\n-\n-\tif err = os.MkdirAll(path.Dir(dst), 0700); err != nil {\n-\t\treturn \"\", errors.Wrap(err, \"can't make image directory\")\n-\t}\n-\n-\tfh, err := os.Create(dst)\n-\tif err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can't make image file %s\", dst)\n-\t}\n-\n \tlr := io.LimitReader(r, int64(f.MaxSize)+1)\n \n \t// read header first, needs it to check if data is valid png/gif/jpeg\n@@ -62,7 +52,25 @@ func (f *FileSystem) Save(fileName string, userID string, r io.Reader) (id strin\n \t\treturn \"\", errors.Errorf(\"file %s is not in allowed format\", fileName)\n \t}\n \n-\twritten, err := io.Copy(fh, io.MultiReader(bytes.NewReader(header[:hl]), lr)) // write header and the rest of input\n+\treader, resized := resize(io.MultiReader(bytes.NewReader(header[:hl]), lr), f.MaxWidth, f.MaxHeight)\n+\n+\tid = path.Join(userID, guid()) + filepath.Ext(fileName) // make id as user/uuid.ext\n+\tdst := f.location(f.Staging, id)\n+\tif resized { // resized also converted to png\n+\t\tid = strings.TrimSuffix(id, filepath.Ext(id)) + \".png\"\n+\t\tdst = f.location(f.Staging, id)\n+\t}\n+\n+\tif err = os.MkdirAll(path.Dir(dst), 0700); err != nil {\n+\t\treturn \"\", errors.Wrap(err, \"can't make image directory\")\n+\t}\n+\n+\tfh, err := os.Create(dst)\n+\tif err != nil {\n+\t\treturn \"\", errors.Wrapf(err, \"can't make image file %s\", dst)\n+\t}\n+\n+\twritten, err := io.Copy(fh, reader)\n \tif err != nil {\n \t\treturn \"\", errors.Wrapf(err, \"can't write image file %s\", dst)\n \t}\n@@ -74,7 +82,7 @@ func (f *FileSystem) Save(fileName string, userID string, r io.Reader) (id strin\n \t\tif err = os.Remove(dst); err != nil {\n \t\t\tlog.Printf(\"[WARN] can't remove image file %s, %v\", dst, err)\n \t\t}\n-\t\treturn \"\", errors.Errorf(\"file %s is too large\", fileName)\n+\t\treturn \"\", errors.Errorf(\"file %s is too large (%d)\", fileName, written)\n \t}\n \n \tlog.Printf(\"[DEBUG] file %s saved for image %s\", fh.Name(), fileName)"
    },
    {
      "sha": "a1e26bb1a2901212af378d93df6f8130e42a9f28",
      "filename": "backend/app/store/image/fs_store_test.go",
      "status": "modified",
      "additions": 58,
      "deletions": 1,
      "changes": 59,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/fs_store_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/fs_store_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/fs_store_test.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -17,7 +17,25 @@ import (\n )\n \n // gopher png for test, from https://golang.org/src/image/png/example_test.go\n-const gopher = `iVBORw0KGgoAAAANSUhEUgAAAEsAAAA8CAAAAAALAhhPAAAFfUlEQVRYw62XeWwUVRzHf2+OPbo9d7tsWyiyaZti6eWGAhISoIGKECEKCAiJJkYTiUgTMYSIosYYBBIUIxoSPIINEBDi2VhwkQrVsj1ESgu9doHWdrul7ba73WNm3vOPtsseM9MdwvvrzTs+8/t95ze/33sI5BqiabU6m9En8oNjduLnAEDLUsQXFF8tQ5oxK3vmnNmDSMtrncks9Hhtt/qeWZapHb1ha3UqYSWVl2ZmpWgaXMXGohQAvmeop3bjTRtv6SgaK/Pb9/bFzUrYslbFAmHPp+3WhAYdr+7GN/YnpN46Opv55VDsJkoEpMrY/vO2BIYQ6LLvm0ThY3MzDzzeSJeeWNyTkgnIE5ePKsvKlcg/0T9QMzXalwXMlj54z4c0rh/mzEfr+FgWEz2w6uk8dkzFAgcARAgNp1ZYef8bH2AgvuStbc2/i6CiWGj98y2tw2l4FAXKkQBIf+exyRnteY83LfEwDQAYCoK+P6bxkZm/0966LxcAAILHB56kgD95PPxltuYcMtFTWw/FKkY/6Opf3GGd9ZF+Qp6mzJxzuRSractOmJrH1u8XTvWFHINNkLQLMR+XHXvfPPHw967raE1xxwtA36IMRfkAAG29/7mLuQcb2WOnsJReZGfpiHsSBX81cvMKywYZHhX5hFPtOqPGWZCXnhWGAu6lX91ElKXSalcLXu3UaOXVay57ZSe5f6Gpx7J2MXAsi7EqSp09b/MirKSyJfnfEEgeDjl8FgDAfvewP03zZ+AJ0m9aFRM8eEHBDRKjfcreDXnZdQuAxXpT2NRJ7xl3UkLBhuVGU16gZiGOgZmrSbRdqkILuL/yYoSXHHkl9KXgqNu3PB8oRg0geC5vFmLjad6mUyTKLmF3OtraWDIfACyXqmephaDABawfpi6tqqBZytfQMqOz6S09iWXhktrRaB8Xz4Yi/8gyABDm5NVe6qq/3VzPrcjELWrebVuyY2T7ar4zQyybUCtsQ5Es1FGaZVrRVQwAgHGW2ZCRZshI5bGQi7HesyE972pOSeMM0dSktlzxRdrlqb3Osa6CCS8IJoQQQgBAbTAa5l5epO34rJszibJI8rxLfGzcp1dRosutGeb2VDNgqYrwTiPNsLxXiPi3dz7LiS1WBRBDBOnqEjyy3aQb+/bLiJzz9dIkscVBBLxMfSEac7kO4Fpkngi0ruNBeSOal+u8jgOuqPz12nryMLCniEjtOOOmpt+KEIqsEdocJjYXwrh9OZqWJQyPCTo67LNS/TdxLAv6R5ZNK9npEjbYdT33gRo4o5oTqR34R+OmaSzDBWsAIPhuRcgyoteNi9gF0KzNYWVItPf2TLoXEg+7isNC7uJkgo1iQWOfRSP9NR11RtbZZ3OMG/VhL6jvx+J1m87+RCfJChAtEBQkSBX2PnSiihc/Twh3j0h7qdYQAoRVsRGmq7HU2QRbaxVGa1D6nIOqaIWRjyRZpHMQKWKpZM5feA+lzC4ZFultV8S6T0mzQGhQohi5I8iw+CsqBSxhFMuwyLgSwbghGb0AiIKkSDmGZVmJSiKihsiyOAUs70UkywooYP0bii9GdH4sfr1UNysd3fUyLLMQN+rsmo3grHl9VNJHbbwxoa47Vw5gupIqrZcjPh9R4Nye3nRDk199V+aetmvVtDRE8/+cbgAAgMIWGb3UA0MGLE9SCbWX670TDy1y98c3D27eppUjsZ6fql3jcd5rUe7+ZIlLNQny3Rd+E5Tct3WVhTM5RBCEdiEK0b6B+/ca2gYU393nFj/n1AygRQxPIUA043M42u85+z2SnssKrPl8Mx76NL3E6eXc3be7OD+H4WHbJkKI8AU8irbITQjZ+0hQcPEgId/Fn/pl9crKH02+5o2b9T/eMx7pKoskYgAAAABJRU5ErkJggg==`\n+const gopher = \"iVBORw0KGgoAAAANSUhEUgAAAEsAAAA8CAAAAAALAhhPAAAFfUlEQVRYw62XeWwUVRzHf2\" +\n+\t\"+OPbo9d7tsWyiyaZti6eWGAhISoIGKECEKCAiJJkYTiUgTMYSIosYYBBIUIxoSPIINEBDi2VhwkQrVsj1ESgu9doHWdrul7ba\" +\n+\t\"73WNm3vOPtsseM9MdwvvrzTs+8/t95ze/33sI5BqiabU6m9En8oNjduLnAEDLUsQXFF8tQ5oxK3vmnNmDSMtrncks9Hhtt\" +\n+\t\"/qeWZapHb1ha3UqYSWVl2ZmpWgaXMXGohQAvmeop3bjTRtv6SgaK/Pb9/bFzUrYslbFAmHPp+3WhAYdr+7GN/YnpN46Opv55VDs\" +\n+\t\"JkoEpMrY/vO2BIYQ6LLvm0ThY3MzDzzeSJeeWNyTkgnIE5ePKsvKlcg/0T9QMzXalwXMlj54z4c0rh/mzEfr+FgWEz2w6uk\" +\n+\t\"8dkzFAgcARAgNp1ZYef8bH2AgvuStbc2/i6CiWGj98y2tw2l4FAXKkQBIf+exyRnteY83LfEwDQAYCoK+P6bxkZm/0966LxcAA\" +\n+\t\"ILHB56kgD95PPxltuYcMtFTWw/FKkY/6Opf3GGd9ZF+Qp6mzJxzuRSractOmJrH1u8XTvWFHINNkLQLMR+XHXvfPPHw967raE1xxwtA36I\" +\n+\t\"MRfkAAG29/7mLuQcb2WOnsJReZGfpiHsSBX81cvMKywYZHhX5hFPtOqPGWZCXnhWGAu6lX91ElKXSalcLXu3UaOXVay57ZSe5f6Gpx7J2\" +\n+\t\"MXAsi7EqSp09b/MirKSyJfnfEEgeDjl8FgDAfvewP03zZ+AJ0m9aFRM8eEHBDRKjfcreDXnZdQuAxXpT2NRJ7xl3UkLBhuVGU16gZiGOgZm\" +\n+\t\"rSbRdqkILuL/yYoSXHHkl9KXgqNu3PB8oRg0geC5vFmLjad6mUyTKLmF3OtraWDIfACyXqmephaDABawfpi6tqqBZytfQMqOz6S09iWXhkt\" +\n+\t\"rRaB8Xz4Yi/8gyABDm5NVe6qq/3VzPrcjELWrebVuyY2T7ar4zQyybUCtsQ5Es1FGaZVrRVQwAgHGW2ZCRZshI5bGQi7HesyE972pOSeMM0\" +\n+\t\"dSktlzxRdrlqb3Osa6CCS8IJoQQQgBAbTAa5l5epO34rJszibJI8rxLfGzcp1dRosutGeb2VDNgqYrwTiPNsLxXiPi3dz7LiS1WBRBDBOnqEj\" +\n+\t\"yy3aQb+/bLiJzz9dIkscVBBLxMfSEac7kO4Fpkngi0ruNBeSOal+u8jgOuqPz12nryMLCniEjtOOOmpt+KEIqsEdocJjYXwrh9OZqWJQyPCTo67\" +\n+\t\"LNS/TdxLAv6R5ZNK9npEjbYdT33gRo4o5oTqR34R+OmaSzDBWsAIPhuRcgyoteNi9gF0KzNYWVItPf2TLoXEg+7isNC7uJkgo1iQWOfRSP9NR\" +\n+\t\"11RtbZZ3OMG/VhL6jvx+J1m87+RCfJChAtEBQkSBX2PnSiihc/Twh3j0h7qdYQAoRVsRGmq7HU2QRbaxVGa1D6nIOqaIWRjyRZpHMQKWKpZM5fe\" +\n+\t\"A+lzC4ZFultV8S6T0mzQGhQohi5I8iw+CsqBSxhFMuwyLgSwbghGb0AiIKkSDmGZVmJSiKihsiyOAUs70UkywooYP0bii9GdH4sfr1UNysd3fU\" +\n+\t\"yLLMQN+rsmo3grHl9VNJHbbwxoa47Vw5gupIqrZcjPh9R4Nye3nRDk199V+aetmvVtDRE8/+cbgAAgMIWGb3UA0MGLE9SCbWX670TDy\" +\n+\t\"1y98c3D27eppUjsZ6fql3jcd5rUe7+ZIlLNQny3Rd+E5Tct3WVhTM5RBCEdiEK0b6B+/ca2gYU393nFj/n1AygRQxPIUA043M42u85+z2S\" +\n+\t\"nssKrPl8Mx76NL3E6eXc3be7OD+H4WHbJkKI8AU8irbITQjZ+0hQcPEgId/Fn/pl9crKH02+5o2b9T/eMx7pKoskYgAAAABJRU5ErkJggg==\"\n \n func gopherPNG() io.Reader { return base64.NewDecoder(base64.StdEncoding, strings.NewReader(gopher)) }\n \n@@ -38,6 +56,45 @@ func TestFsStore_Save(t *testing.T) {\n \tassert.Equal(t, 1462, len(data))\n }\n \n+func TestFsStore_SaveWithResize(t *testing.T) {\n+\tsvc, _ := prepareImageTest(t)\n+\tsvc.MaxWidth, svc.MaxHeight = 32, 32\n+\t// defer teardown()\n+\n+\tid, err := svc.Save(\"file1.png\", \"user1\", gopherPNG())\n+\tassert.NoError(t, err)\n+\tassert.Contains(t, id, \"user1/\")\n+\tassert.Contains(t, id, \".png\")\n+\tt.Log(id)\n+\n+\timg := svc.location(svc.Staging, id)\n+\tt.Log(img)\n+\tdata, err := ioutil.ReadFile(img)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 1142, len(data))\n+}\n+\n+func TestFsStore_SaveWithResizeJpeg(t *testing.T) {\n+\tsvc, _ := prepareImageTest(t)\n+\tsvc.MaxWidth, svc.MaxHeight = 400, 300\n+\tsvc.MaxSize = 32000\n+\n+\tfh, err := os.Open(\"testdata/circles.jpg\")\n+\tdefer func() { assert.NoError(t, fh.Close()) }()\n+\tassert.NoError(t, err)\n+\tid, err := svc.Save(\"circles.jpg\", \"user1\", fh)\n+\tassert.NoError(t, err)\n+\tassert.Contains(t, id, \"user1/\")\n+\tassert.Contains(t, id, \".png\")\n+\tt.Log(id)\n+\n+\timg := svc.location(svc.Staging, id)\n+\tt.Log(img)\n+\tdata, err := ioutil.ReadFile(img)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 10786, len(data))\n+}\n+\n func TestFsStore_WrongFormat(t *testing.T) {\n \tsvc, teardown := prepareImageTest(t)\n \tdefer teardown()"
    },
    {
      "sha": "1f99b35b6c2da7ebe5313122c11acc3abe1d0fc7",
      "filename": "backend/app/store/image/image.go",
      "status": "modified",
      "additions": 62,
      "deletions": 1,
      "changes": 63,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/image.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/image.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/image.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -3,10 +3,15 @@\n // Service object encloses Store and add common methods, this is the one consumer should use\n package image\n \n-//go:generate sh -c \"mockgen -source=image.go -package=image > image_mock.go\"\n+//go:generate sh -c \"mockery -inpkg -name Store -print > /tmp/mock.tmp && mv /tmp/mock.tmp image_mock.go\"\n \n import (\n+\t\"bytes\"\n \t\"context\"\n+\t\"image\"\n+\t_ \"image/gif\"\n+\t_ \"image/jpeg\"\n+\t\"image/png\"\n \t\"io\"\n \t\"net/http\"\n \t\"strings\"\n@@ -18,6 +23,7 @@ import (\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/pkg/errors\"\n \t\"github.com/rs/xid\"\n+\t\"golang.org/x/image/draw\"\n )\n \n // Store defines interface for saving and loading pictures.\n@@ -129,6 +135,61 @@ func (s *Service) Close() {\n \ts.wg.Wait()\n }\n \n+// resize an image of supported format (PNG, JPG, GIF) to the size of \"limit\" px of the\n+// biggest side (width or height) preserving aspect ratio.\n+// Returns original reader if resizing is not needed or failed. If resized the reader will be for png format\n+// and ok flag will be true.\n+func resize(reader io.Reader, limitW, limitH int) (io.Reader, bool) {\n+\tif reader == nil || limitW <= 0 || limitH <= 0 {\n+\t\treturn reader, false\n+\t}\n+\n+\tvar teeBuf bytes.Buffer\n+\ttee := io.TeeReader(reader, &teeBuf)\n+\tsrc, _, err := image.Decode(tee)\n+\tif err != nil {\n+\t\tlog.Printf(\"[WARN] can't decode image, %s\", err)\n+\t\treturn &teeBuf, false\n+\t}\n+\n+\tbounds := src.Bounds()\n+\tw, h := bounds.Dx(), bounds.Dy()\n+\tif w <= limitW && h <= limitH || w <= 0 || h <= 0 {\n+\t\tlog.Printf(\"[DEBUG] resizing image is smaller that the limit or has 0 size\")\n+\t\treturn &teeBuf, false\n+\t}\n+\n+\tnewW, newH := getProportionalSizes(w, h, limitW, limitH)\n+\tm := image.NewRGBA(image.Rect(0, 0, newW, newH))\n+\tdraw.BiLinear.Scale(m, m.Bounds(), src, src.Bounds(), draw.Src, nil)\n+\n+\tvar out bytes.Buffer\n+\tif err = png.Encode(&out, m); err != nil {\n+\t\tlog.Printf(\"[WARN] can't encode resized image to png, %s\", err)\n+\t\treturn &teeBuf, false\n+\t}\n+\treturn &out, true\n+}\n+\n+func getProportionalSizes(srcW, srcH int, limitW, limitH int) (resW, resH int) {\n+\n+\tif srcW <= limitW && srcH <= limitH {\n+\t\treturn srcW, srcH\n+\t}\n+\n+\tratioW := float64(srcW) / float64(limitW)\n+\tpropH := float64(srcH) / ratioW\n+\n+\tratioH := float64(srcH) / float64(limitH)\n+\tpropW := float64(srcW) / ratioH\n+\n+\tif int(propH) > limitH {\n+\t\treturn int(propW), limitH\n+\t}\n+\n+\treturn limitW, int(propH)\n+}\n+\n // check if file f is a valid image format, i.e. gif, png or jpeg\n func isValidImage(b []byte) bool {\n \tct := http.DetectContentType(b)"
    },
    {
      "sha": "0af90abf61347c5086fdbb6faf7535f2ba9168b4",
      "filename": "backend/app/store/image/image_mock.go",
      "status": "modified",
      "additions": 83,
      "deletions": 63,
      "changes": 146,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/image_mock.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/image_mock.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/image_mock.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,85 +1,105 @@\n-// Automatically generated by MockGen. DO NOT EDIT!\n-// Source: image.go\n-\n+// Code generated by mockery v1.0.0. DO NOT EDIT.\n package image\n \n-import (\n-\tcontext \"context\"\n-\tgomock \"github.com/golang/mock/gomock\"\n-\tio \"io\"\n-\ttime \"time\"\n-)\n+import context \"context\"\n+import io \"io\"\n+import mock \"github.com/stretchr/testify/mock\"\n+import time \"time\"\n \n-// Mock of Store interface\n+// MockStore is an autogenerated mock type for the Store type\n type MockStore struct {\n-\tctrl     *gomock.Controller\n-\trecorder *_MockStoreRecorder\n-}\n-\n-// Recorder for MockStore (not exported)\n-type _MockStoreRecorder struct {\n-\tmock *MockStore\n-}\n-\n-func NewMockStore(ctrl *gomock.Controller) *MockStore {\n-\tmock := &MockStore{ctrl: ctrl}\n-\tmock.recorder = &_MockStoreRecorder{mock}\n-\treturn mock\n+\tmock.Mock\n }\n \n-func (_m *MockStore) EXPECT() *_MockStoreRecorder {\n-\treturn _m.recorder\n-}\n+// Cleanup provides a mock function with given fields: ctx, ttl\n+func (_m *MockStore) Cleanup(ctx context.Context, ttl time.Duration) error {\n+\tret := _m.Called(ctx, ttl)\n \n-func (_m *MockStore) Save(fileName string, userID string, r io.Reader) (string, error) {\n-\tret := _m.ctrl.Call(_m, \"Save\", fileName, userID, r)\n-\tret0, _ := ret[0].(string)\n-\tret1, _ := ret[1].(error)\n-\treturn ret0, ret1\n-}\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(context.Context, time.Duration) error); ok {\n+\t\tr0 = rf(ctx, ttl)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n \n-func (_mr *_MockStoreRecorder) Save(arg0, arg1, arg2 interface{}) *gomock.Call {\n-\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"Save\", arg0, arg1, arg2)\n+\treturn r0\n }\n \n+// Commit provides a mock function with given fields: id\n func (_m *MockStore) Commit(id string) error {\n-\tret := _m.ctrl.Call(_m, \"Commit\", id)\n-\tret0, _ := ret[0].(error)\n-\treturn ret0\n-}\n+\tret := _m.Called(id)\n \n-func (_mr *_MockStoreRecorder) Commit(arg0 interface{}) *gomock.Call {\n-\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"Commit\", arg0)\n-}\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(string) error); ok {\n+\t\tr0 = rf(id)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n \n-func (_m *MockStore) Load(id string) (io.ReadCloser, int64, error) {\n-\tret := _m.ctrl.Call(_m, \"Load\", id)\n-\tret0, _ := ret[0].(io.ReadCloser)\n-\tret1, _ := ret[1].(int64)\n-\tret2, _ := ret[2].(error)\n-\treturn ret0, ret1, ret2\n+\treturn r0\n }\n \n-func (_mr *_MockStoreRecorder) Load(arg0 interface{}) *gomock.Call {\n-\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"Load\", arg0)\n-}\n-\n-func (_m *MockStore) Cleanup(ctx context.Context, ttl time.Duration) error {\n-\tret := _m.ctrl.Call(_m, \"Cleanup\", ctx, ttl)\n-\tret0, _ := ret[0].(error)\n-\treturn ret0\n+// Load provides a mock function with given fields: id\n+func (_m *MockStore) Load(id string) (io.ReadCloser, int64, error) {\n+\tret := _m.Called(id)\n+\n+\tvar r0 io.ReadCloser\n+\tif rf, ok := ret.Get(0).(func(string) io.ReadCloser); ok {\n+\t\tr0 = rf(id)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).(io.ReadCloser)\n+\t\t}\n+\t}\n+\n+\tvar r1 int64\n+\tif rf, ok := ret.Get(1).(func(string) int64); ok {\n+\t\tr1 = rf(id)\n+\t} else {\n+\t\tr1 = ret.Get(1).(int64)\n+\t}\n+\n+\tvar r2 error\n+\tif rf, ok := ret.Get(2).(func(string) error); ok {\n+\t\tr2 = rf(id)\n+\t} else {\n+\t\tr2 = ret.Error(2)\n+\t}\n+\n+\treturn r0, r1, r2\n }\n \n-func (_mr *_MockStoreRecorder) Cleanup(arg0, arg1 interface{}) *gomock.Call {\n-\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"Cleanup\", arg0, arg1)\n+// Save provides a mock function with given fields: fileName, userID, r\n+func (_m *MockStore) Save(fileName string, userID string, r io.Reader) (string, error) {\n+\tret := _m.Called(fileName, userID, r)\n+\n+\tvar r0 string\n+\tif rf, ok := ret.Get(0).(func(string, string, io.Reader) string); ok {\n+\t\tr0 = rf(fileName, userID, r)\n+\t} else {\n+\t\tr0 = ret.Get(0).(string)\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(string, string, io.Reader) error); ok {\n+\t\tr1 = rf(fileName, userID, r)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n }\n \n+// SizeLimit provides a mock function with given fields:\n func (_m *MockStore) SizeLimit() int {\n-\tret := _m.ctrl.Call(_m, \"SizeLimit\")\n-\tret0, _ := ret[0].(int)\n-\treturn ret0\n-}\n+\tret := _m.Called()\n+\n+\tvar r0 int\n+\tif rf, ok := ret.Get(0).(func() int); ok {\n+\t\tr0 = rf()\n+\t} else {\n+\t\tr0 = ret.Get(0).(int)\n+\t}\n \n-func (_mr *_MockStoreRecorder) SizeLimit() *gomock.Call {\n-\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"SizeLimit\")\n+\treturn r0\n }"
    },
    {
      "sha": "ba8b2e3ce44f361dc90f54dcc4bd38ec4e8ec65b",
      "filename": "backend/app/store/image/image_test.go",
      "status": "modified",
      "additions": 106,
      "deletions": 29,
      "changes": 135,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/image_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/image_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/image_test.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,12 +1,18 @@\n package image\n \n import (\n+\t\"bytes\"\n \t\"context\"\n+\t\"image\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"strconv\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/golang/mock/gomock\"\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/mock\"\n \t\"github.com/stretchr/testify/require\"\n )\n \n@@ -22,56 +28,127 @@ func TestService_ExtractPictures(t *testing.T) {\n }\n \n func TestService_Cleanup(t *testing.T) {\n-\tctrl := gomock.NewController(t)\n-\tdefer ctrl.Finish()\n+\tstore := MockStore{}\n+\tstore.On(\"Cleanup\", mock.Anything, mock.Anything).Times(10).Return(nil)\n \n-\tstore := NewMockStore(ctrl)\n-\tstore.EXPECT().Cleanup(gomock.Any(), gomock.Any()).Times(10)\n-\n-\tsvc := Service{Store: store, TTL: 100 * time.Millisecond}\n+\tsvc := Service{Store: &store, TTL: 100 * time.Millisecond}\n \tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*549)\n \tdefer cancel()\n \tsvc.Cleanup(ctx)\n+\tstore.AssertNumberOfCalls(t, \"Cleanup\", 10)\n }\n \n func TestService_Submit(t *testing.T) {\n-\tctrl := gomock.NewController(t)\n-\tdefer ctrl.Finish()\n-\tstore := NewMockStore(ctrl)\n-\n-\tstore.EXPECT().Commit(gomock.Any()).Times(5) // all 5 should be committed\n-\tsvc := Service{Store: store, ImageAPI: \"/blah/\", TTL: time.Millisecond * 100}\n+\tstore := MockStore{}\n+\tstore.On(\"Commit\", mock.Anything, mock.Anything).Times(5).Return(nil)\n+\tsvc := Service{Store: &store, ImageAPI: \"/blah/\", TTL: time.Millisecond * 100}\n \tsvc.Submit(func() []string { return []string{\"id1\", \"id2\", \"id3\"} })\n \tsvc.Submit(func() []string { return []string{\"id4\", \"id5\"} })\n \tsvc.Submit(nil)\n-\ttime.Sleep(time.Millisecond * 500)\n+\tstore.AssertNumberOfCalls(t, \"Commit\", 0)\n+\ttime.Sleep(time.Millisecond * 150)\n+\tstore.AssertNumberOfCalls(t, \"Commit\", 5)\n }\n \n func TestService_Close(t *testing.T) {\n-\tctrl := gomock.NewController(t)\n-\tdefer ctrl.Finish()\n-\tstore := NewMockStore(ctrl)\n-\n-\tstore.EXPECT().Commit(gomock.Any()).Times(5) // all 5 should be committed\n-\tsvc := Service{Store: store, ImageAPI: \"/blah/\", TTL: time.Millisecond * 500}\n+\tstore := MockStore{}\n+\tstore.On(\"Commit\", mock.Anything, mock.Anything).Times(5).Return(nil)\n+\tsvc := Service{Store: &store, ImageAPI: \"/blah/\", TTL: time.Millisecond * 500}\n \tsvc.Submit(func() []string { return []string{\"id1\", \"id2\", \"id3\"} })\n \tsvc.Submit(func() []string { return []string{\"id4\", \"id5\"} })\n \tsvc.Submit(nil)\n \tsvc.Close()\n+\tstore.AssertNumberOfCalls(t, \"Commit\", 5)\n }\n \n func TestService_SubmitDelay(t *testing.T) {\n-\tctrl := gomock.NewController(t)\n-\tdefer func() {\n-\t\tctrl.Finish()\n-\t}()\n-\n-\tstore := NewMockStore(ctrl)\n-\n-\tstore.EXPECT().Commit(gomock.Any()).Times(3) // first batch should be committed\n-\tsvc := Service{Store: store, ImageAPI: \"/blah/\", TTL: time.Millisecond * 100}\n+\tstore := MockStore{}\n+\tstore.On(\"Commit\", mock.Anything, mock.Anything).Times(5).Return(nil)\n+\tsvc := Service{Store: &store, ImageAPI: \"/blah/\", TTL: time.Millisecond * 100}\n \tsvc.Submit(func() []string { return []string{\"id1\", \"id2\", \"id3\"} })\n \ttime.Sleep(150 * time.Millisecond) // let first batch to pass TTL\n \tsvc.Submit(func() []string { return []string{\"id4\", \"id5\"} })\n \tsvc.Submit(nil)\n+\tstore.AssertNumberOfCalls(t, \"Commit\", 3)\n+\tsvc.Close()\n+\tstore.AssertNumberOfCalls(t, \"Commit\", 5)\n+}\n+\n+func TestService_resize(t *testing.T) {\n+\n+\tcheckC := func(t *testing.T, r io.Reader, cExp []byte) {\n+\t\tcontent, err := ioutil.ReadAll(r)\n+\t\trequire.NoError(t, err)\n+\t\tassert.Equal(t, cExp, content)\n+\t}\n+\n+\t// Reader is nil.\n+\tresizedR, ok := resize(nil, 100, 100)\n+\tassert.Nil(t, resizedR)\n+\tassert.False(t, ok)\n+\n+\t// Negative limit error.\n+\tresizedR, ok = resize(strings.NewReader(\"some picture bin data\"), -1, -1)\n+\trequire.NotNil(t, resizedR)\n+\tcheckC(t, resizedR, []byte(\"some picture bin data\"))\n+\tassert.False(t, ok)\n+\n+\t// Decode error.\n+\tresizedR, ok = resize(strings.NewReader(\"invalid image content\"), 100, 100)\n+\tassert.NotNil(t, resizedR)\n+\tcheckC(t, resizedR, []byte(\"invalid image content\"))\n+\tassert.False(t, ok)\n+\n+\tcases := []struct {\n+\t\tfile   string\n+\t\twr, hr int\n+\t}{\n+\t\t{\"testdata/circles.png\", 400, 300}, // full size: 800x600 px\n+\t\t{\"testdata/circles.jpg\", 300, 400}, // full size: 600x800 px\n+\t}\n+\n+\tfor _, c := range cases {\n+\t\timg, err := ioutil.ReadFile(c.file)\n+\t\trequire.Nil(t, err, \"can't open test file %s\", c.file)\n+\n+\t\t// No need for resize, image dimensions are smaller than resize limit.\n+\t\tresizedR, ok = resize(bytes.NewReader(img), 800, 800)\n+\t\tassert.NotNil(t, resizedR, \"file %s\", c.file)\n+\t\tcheckC(t, resizedR, img)\n+\t\tassert.False(t, ok)\n+\n+\t\t// Resizing to half of width. Check resizedR image format PNG.\n+\t\tresizedR, ok = resize(bytes.NewReader(img), 400, 400)\n+\t\tassert.NotNil(t, resizedR, \"file %s\", c.file)\n+\t\tassert.True(t, ok)\n+\n+\t\timgRz, format, err := image.Decode(resizedR)\n+\t\tassert.Nil(t, err, \"file %s\", c.file)\n+\t\tassert.Equal(t, \"png\", format, \"file %s\", c.file)\n+\t\tbounds := imgRz.Bounds()\n+\t\tassert.Equal(t, c.wr, bounds.Dx(), \"file %s\", c.file)\n+\t\tassert.Equal(t, c.hr, bounds.Dy(), \"file %s\", c.file)\n+\t}\n+\n+}\n+\n+func TestGetProportionalSizes(t *testing.T) {\n+\ttbl := []struct {\n+\t\tinpW, inpH     int\n+\t\tlimitW, limitH int\n+\t\tresW, resH     int\n+\t}{\n+\t\t{10, 20, 50, 25, 10, 20},\n+\t\t{400, 200, 50, 25, 50, 25},\n+\t\t{100, 100, 50, 25, 25, 25},\n+\t\t{100, 200, 50, 25, 12, 25},\n+\t}\n+\n+\tfor i, tt := range tbl {\n+\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n+\t\t\tresW, resH := getProportionalSizes(tt.inpW, tt.inpH, tt.limitW, tt.limitH)\n+\t\t\tassert.Equal(t, tt.resW, resW, \"width\")\n+\t\t\tassert.Equal(t, tt.resH, resH, \"height\")\n+\t\t})\n+\t}\n }"
    },
    {
      "sha": "2c7048c3a4b524ba2009a6820bd7fced0af45378",
      "filename": "backend/app/store/image/testdata/circles.jpg",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/testdata/circles.jpg",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/testdata/circles.jpg",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/testdata/circles.jpg?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642"
    },
    {
      "sha": "fb30946d44016008b5c28eed4719f6ef6e850367",
      "filename": "backend/app/store/image/testdata/circles.png",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/testdata/circles.png",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/image/testdata/circles.png",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/testdata/circles.png?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642"
    },
    {
      "sha": "dda0568b6701aff162f52b8aea7ac9294b83aef2",
      "filename": "backend/app/store/service/service_test.go",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/service/service_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/app/store/service/service_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/service/service_test.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -14,9 +14,9 @@ import (\n \n \tbolt \"github.com/coreos/bbolt\"\n \t\"github.com/go-pkgz/lgr\"\n-\t\"github.com/golang/mock/gomock\"\n \t\"github.com/pkg/errors\"\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/mock\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/umputun/remark/backend/app/store/image\"\n \n@@ -700,12 +700,9 @@ func TestService_submitImages(t *testing.T) {\n \tdefer teardown(t)\n \tlgr.Setup(lgr.Debug, lgr.CallerFile, lgr.CallerFunc)\n \n-\tctrl := gomock.NewController(t)\n-\tdefer ctrl.Finish()\n-\tmockStore := image.NewMockStore(ctrl)\n-\timgSvc := &image.Service{Store: mockStore, TTL: time.Millisecond * 50}\n-\n-\tmockStore.EXPECT().Commit(gomock.Any()).Times(2)\n+\tmockStore := image.MockStore{}\n+\tmockStore.On(\"Commit\", mock.Anything, mock.Anything).Times(2).Return(nil)\n+\timgSvc := &image.Service{Store: &mockStore, TTL: time.Millisecond * 50}\n \n \t// two comments for https://radio-t.com\n \tb := DataStore{Interface: prepStoreEngine(t), EditDuration: 50 * time.Millisecond,"
    },
    {
      "sha": "fc341351d2f0af1f5188f9d42496ef28032f1ea2",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.mod?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -33,8 +33,9 @@ require (\n \tgithub.com/rs/xid v1.2.1\n \tgithub.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect\n \tgithub.com/stretchr/testify v1.3.0\n-\tgolang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16\n-\tgolang.org/x/net v0.0.0-20190107210223-45ffb0cd1ba0\n+\tgolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2\n+\tgolang.org/x/image v0.0.0-20181116024801-cd38e8056d9b\n+\tgolang.org/x/net v0.0.0-20190415214537-1da14a5a36f2\n \tgolang.org/x/time v0.0.0-20190308202827-9d24e82272b4 // indirect\n \tgopkg.in/russross/blackfriday.v2 v2.0.0\n )"
    },
    {
      "sha": "d124aea310fbb6240ccffc8732464c84c1a988d7",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 6,
      "deletions": 8,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.sum?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -20,8 +20,6 @@ github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d/go.mod h1:YWyI\n github.com/globalsign/mgo v0.0.0-20180615134936-113d3961e731/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\n github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8 h1:DujepqpGd1hyOd7aW59XpK7Qymp8iy83xq74fLr21is=\n github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\n-github.com/go-chi/chi v3.3.2+incompatible h1:uQNcQN3NsV1j4ANsPh42P4ew4t6rnRbJb8frvpp31qQ=\n-github.com/go-chi/chi v3.3.2+incompatible/go.mod h1:eB3wogJHnLi3x/kFX2A+IbTBlXxmMeXJVKy9tTv1XzQ=\n github.com/go-chi/chi v4.0.2+incompatible h1:maB6vn6FqCxrpz4FqWdh4+lwpyZIQS7YEAUcHlgXVRs=\n github.com/go-chi/chi v4.0.2+incompatible/go.mod h1:eB3wogJHnLi3x/kFX2A+IbTBlXxmMeXJVKy9tTv1XzQ=\n github.com/go-chi/cors v1.0.0 h1:e6x8k7uWbUwYs+aXDoiUzeQFT6l0cygBYyNhD7/1Tg0=\n@@ -33,10 +31,6 @@ github.com/go-pkgz/auth v0.5.0/go.mod h1:CWtB8dHmOv+TfF3MUzKwk/YwTLepC2TaDL05A+p\n github.com/go-pkgz/lcw v0.2.0 h1:aFoKUG8q0YybId+ThVRQpDMjjuSG4hkLL1EA2xUtruc=\n github.com/go-pkgz/lcw v0.2.0/go.mod h1:k+PY1CkCMTLXILtFoJOyK65Qqi9rkoTYunFH1vE/C0I=\n github.com/go-pkgz/lgr v0.2.2/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n-github.com/go-pkgz/lgr v0.6.0 h1:Z9FRhfSyuASiF05iXRj+clTAAl8+1EfLR7SeyLIaGKg=\n-github.com/go-pkgz/lgr v0.6.0/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n-github.com/go-pkgz/lgr v0.6.1 h1:poohUbv/iguoQ6bzJ5j/Ubl1VcsjU+rzTbbxsKbkGXk=\n-github.com/go-pkgz/lgr v0.6.1/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n github.com/go-pkgz/lgr v0.6.2 h1:Twf2YIe2J5tg7mKs+IkDDxrDF7GWlTCl/LzqELWjT5o=\n github.com/go-pkgz/lgr v0.6.2/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n github.com/go-pkgz/mongo v1.0.0/go.mod h1:R9si/F2aJsjz4MUxhzuppIHY8yLV3YCeuCpgcI50cu4=\n@@ -92,20 +86,24 @@ github.com/stretchr/objx v0.1.1 h1:2vfRuCMp5sSVIDSqO8oNnWJq7mPa6KVP3iPIwFBuy8A=\n github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\n github.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\n github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\n-golang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16 h1:y6ce7gCWtnH+m3dCjzQ1PCuwl28DDIc3VNnvY29DlIA=\n-golang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\n+golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2 h1:VklqNMn3ovrHsnt90PveolxSbWFaJdECFbxSq0Mqo2M=\n+golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\n golang.org/x/image v0.0.0-20181116024801-cd38e8056d9b h1:VHyIDlv3XkfCa5/a81uzaoDkHH4rr81Z62g+xlnO8uM=\n golang.org/x/image v0.0.0-20181116024801-cd38e8056d9b/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=\n golang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20190107210223-45ffb0cd1ba0 h1:1DW40AJQ7AP4nY6ORUGUdkpXyEC9W2GAXcOPaMZK0K8=\n golang.org/x/net v0.0.0-20190107210223-45ffb0cd1ba0/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20190415214537-1da14a5a36f2 h1:iC0Y6EDq+rhnAePxGvJs2kzUAYcwESqdcGRPzEUfzTU=\n+golang.org/x/net v0.0.0-20190415214537-1da14a5a36f2/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\n golang.org/x/oauth2 v0.0.0-20181203162652-d668ce993890 h1:uESlIz09WIHT2I+pasSXcpLYqYK8wHcdCetU3VuMBJE=\n golang.org/x/oauth2 v0.0.0-20181203162652-d668ce993890/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\n golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4 h1:YUO/7uOKsKeq9UokNS62b8FYywz3ker1l1vDZRCRefw=\n golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sys v0.0.0-20190109145017-48ac38b7c8cb h1:1w588/yEchbPNpa9sEvOcMZYbWHedwJjg4VOAdDHWHk=\n golang.org/x/sys v0.0.0-20190109145017-48ac38b7c8cb/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n+golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a h1:1BGLXjeY4akVXGgbC9HugT3Jv3hCI0z56oJR5vAMgBU=\n+golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\n golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/time v0.0.0-20190308202827-9d24e82272b4 h1:SvFZT6jyqRaOeXpc5h/JSfZenJ2O330aBsf7JfSUXmQ="
    },
    {
      "sha": "010d4ccd58225c4a949eaa72742f7af6eaca6e6e",
      "filename": "backend/vendor/github.com/stretchr/objx/.codeclimate.yml",
      "status": "added",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/.codeclimate.yml",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/.codeclimate.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/.codeclimate.yml?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,13 @@\n+engines:\n+  gofmt:\n+    enabled: true\n+  golint:\n+    enabled: true\n+  govet:\n+    enabled: true\n+\n+exclude_patterns:\n+- \".github/\"\n+- \"vendor/\"\n+- \"codegen/\"\n+- \"doc.go\""
    },
    {
      "sha": "ea58090bd21e1b3182e644a2b27fb181a12cb6f6",
      "filename": "backend/vendor/github.com/stretchr/objx/.gitignore",
      "status": "added",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/.gitignore",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/.gitignore?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,11 @@\n+# Binaries for programs and plugins\n+*.exe\n+*.dll\n+*.so\n+*.dylib\n+\n+# Test binary, build with `go test -c`\n+*.test\n+\n+# Output of the go coverage tool, specifically when used with LiteIDE\n+*.out"
    },
    {
      "sha": "a63efa59d1d5bf42bb86859deb384d7bbd9408ea",
      "filename": "backend/vendor/github.com/stretchr/objx/.travis.yml",
      "status": "added",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/.travis.yml",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/.travis.yml?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,25 @@\n+language: go\n+go:\n+  - 1.8\n+  - 1.9\n+  - tip\n+\n+env:\n+  global:\n+    - CC_TEST_REPORTER_ID=68feaa3410049ce73e145287acbcdacc525087a30627f96f04e579e75bd71c00\n+\n+before_script:\n+  - curl -L https://codeclimate.com/downloads/test-reporter/test-reporter-latest-linux-amd64 > ./cc-test-reporter\n+  - chmod +x ./cc-test-reporter\n+  - ./cc-test-reporter before-build\n+\n+install:\n+- go get github.com/go-task/task/cmd/task\n+\n+script:\n+- task dl-deps\n+- task lint\n+- task test-coverage\n+\n+after_script:\n+  - ./cc-test-reporter after-build --exit-code $TRAVIS_TEST_RESULT"
    },
    {
      "sha": "eebe342a9602606d3b719f13a26b9a36685cf3c4",
      "filename": "backend/vendor/github.com/stretchr/objx/Gopkg.lock",
      "status": "added",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/Gopkg.lock",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/Gopkg.lock",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/Gopkg.lock?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,30 @@\n+# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n+\n+\n+[[projects]]\n+  name = \"github.com/davecgh/go-spew\"\n+  packages = [\"spew\"]\n+  revision = \"346938d642f2ec3594ed81d874461961cd0faa76\"\n+  version = \"v1.1.0\"\n+\n+[[projects]]\n+  name = \"github.com/pmezard/go-difflib\"\n+  packages = [\"difflib\"]\n+  revision = \"792786c7400a136282c1664665ae0a8db921c6c2\"\n+  version = \"v1.0.0\"\n+\n+[[projects]]\n+  name = \"github.com/stretchr/testify\"\n+  packages = [\n+    \"assert\",\n+    \"require\"\n+  ]\n+  revision = \"b91bfb9ebec76498946beb6af7c0230c7cc7ba6c\"\n+  version = \"v1.2.0\"\n+\n+[solve-meta]\n+  analyzer-name = \"dep\"\n+  analyzer-version = 1\n+  inputs-digest = \"2d160a7dea4ffd13c6c31dab40373822f9d78c73beba016d662bef8f7a998876\"\n+  solver-name = \"gps-cdcl\"\n+  solver-version = 1"
    },
    {
      "sha": "d70f1570b95a71d65a5cbf38ff88497d036c016f",
      "filename": "backend/vendor/github.com/stretchr/objx/Gopkg.toml",
      "status": "added",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/Gopkg.toml",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/Gopkg.toml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/Gopkg.toml?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,8 @@\n+[prune]\n+  unused-packages = true\n+  non-go = true\n+  go-tests = true\n+\n+[[constraint]]\n+  name = \"github.com/stretchr/testify\"\n+  version = \"~1.2.0\""
    },
    {
      "sha": "44d4d9d5a7c38acb84d299e75e108e197b3040df",
      "filename": "backend/vendor/github.com/stretchr/objx/LICENSE",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/LICENSE",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/LICENSE?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,22 @@\n+The MIT License\n+\n+Copyright (c) 2014 Stretchr, Inc.\n+Copyright (c) 2017-2018 objx contributors\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
    },
    {
      "sha": "be5750c94c82145577b4f090ac8845a58d1a6fe2",
      "filename": "backend/vendor/github.com/stretchr/objx/README.md",
      "status": "added",
      "additions": 80,
      "deletions": 0,
      "changes": 80,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/README.md?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,80 @@\n+# Objx\n+[![Build Status](https://travis-ci.org/stretchr/objx.svg?branch=master)](https://travis-ci.org/stretchr/objx)\n+[![Go Report Card](https://goreportcard.com/badge/github.com/stretchr/objx)](https://goreportcard.com/report/github.com/stretchr/objx)\n+[![Maintainability](https://api.codeclimate.com/v1/badges/1d64bc6c8474c2074f2b/maintainability)](https://codeclimate.com/github/stretchr/objx/maintainability)\n+[![Test Coverage](https://api.codeclimate.com/v1/badges/1d64bc6c8474c2074f2b/test_coverage)](https://codeclimate.com/github/stretchr/objx/test_coverage)\n+[![Sourcegraph](https://sourcegraph.com/github.com/stretchr/objx/-/badge.svg)](https://sourcegraph.com/github.com/stretchr/objx)\n+[![GoDoc](https://godoc.org/github.com/stretchr/objx?status.svg)](https://godoc.org/github.com/stretchr/objx)\n+\n+Objx - Go package for dealing with maps, slices, JSON and other data.\n+\n+Get started:\n+\n+- Install Objx with [one line of code](#installation), or [update it with another](#staying-up-to-date)\n+- Check out the API Documentation http://godoc.org/github.com/stretchr/objx\n+\n+## Overview\n+Objx provides the `objx.Map` type, which is a `map[string]interface{}` that exposes a powerful `Get` method (among others) that allows you to easily and quickly get access to data within the map, without having to worry too much about type assertions, missing data, default values etc.\n+\n+### Pattern\n+Objx uses a preditable pattern to make access data from within `map[string]interface{}` easy. Call one of the `objx.` functions to create your `objx.Map` to get going:\n+\n+    m, err := objx.FromJSON(json)\n+\n+NOTE: Any methods or functions with the `Must` prefix will panic if something goes wrong, the rest will be optimistic and try to figure things out without panicking.\n+\n+Use `Get` to access the value you're interested in.  You can use dot and array\n+notation too:\n+\n+     m.Get(\"places[0].latlng\")\n+\n+Once you have sought the `Value` you're interested in, you can use the `Is*` methods to determine its type.\n+\n+     if m.Get(\"code\").IsStr() { // Your code... }\n+\n+Or you can just assume the type, and use one of the strong type methods to extract the real value:\n+\n+    m.Get(\"code\").Int()\n+\n+If there's no value there (or if it's the wrong type) then a default value will be returned, or you can be explicit about the default value.\n+\n+     Get(\"code\").Int(-1)\n+\n+If you're dealing with a slice of data as a value, Objx provides many useful methods for iterating, manipulating and selecting that data.  You can find out more by exploring the index below.\n+\n+### Reading data\n+A simple example of how to use Objx:\n+\n+    // Use MustFromJSON to make an objx.Map from some JSON\n+    m := objx.MustFromJSON(`{\"name\": \"Mat\", \"age\": 30}`)\n+\n+    // Get the details\n+    name := m.Get(\"name\").Str()\n+    age := m.Get(\"age\").Int()\n+\n+    // Get their nickname (or use their name if they don't have one)\n+    nickname := m.Get(\"nickname\").Str(name)\n+\n+### Ranging\n+Since `objx.Map` is a `map[string]interface{}` you can treat it as such.  For example, to `range` the data, do what you would expect:\n+\n+    m := objx.MustFromJSON(json)\n+    for key, value := range m {\n+      // Your code...\n+    }\n+\n+## Installation\n+To install Objx, use go get:\n+\n+    go get github.com/stretchr/objx\n+\n+### Staying up to date\n+To update Objx to the latest version, run:\n+\n+    go get -u github.com/stretchr/objx\n+\n+### Supported go versions\n+We support the lastest two major Go versions, which are 1.8 and 1.9 at the moment.\n+\n+## Contributing\n+Please feel free to submit issues, fork the repository and send pull requests!"
    },
    {
      "sha": "f8035641f2d172f8a0f0f30c94d905fca15c31c6",
      "filename": "backend/vendor/github.com/stretchr/objx/Taskfile.yml",
      "status": "added",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/Taskfile.yml",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/Taskfile.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/Taskfile.yml?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,32 @@\n+default:\n+  deps: [test]\n+\n+dl-deps:\n+  desc: Downloads cli dependencies\n+  cmds:\n+    - go get -u github.com/golang/lint/golint\n+    - go get -u github.com/golang/dep/cmd/dep\n+\n+update-deps:\n+  desc: Updates dependencies\n+  cmds:\n+    - dep ensure\n+    - dep ensure -update\n+\n+lint:\n+  desc: Runs golint\n+  cmds:\n+    - go fmt $(go list ./... | grep -v /vendor/)\n+    - go vet $(go list ./... | grep -v /vendor/)\n+    - golint $(ls *.go | grep -v \"doc.go\")\n+  silent: true\n+\n+test:\n+  desc: Runs go tests\n+  cmds:\n+    - go test -race  .\n+\n+test-coverage:\n+  desc: Runs go tests and calucates test coverage\n+  cmds:\n+    - go test -coverprofile=c.out ."
    },
    {
      "sha": "204356a22858a39c51848957af90a3855b402ec7",
      "filename": "backend/vendor/github.com/stretchr/objx/accessors.go",
      "status": "added",
      "additions": 148,
      "deletions": 0,
      "changes": 148,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/accessors.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/accessors.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/accessors.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,148 @@\n+package objx\n+\n+import (\n+\t\"regexp\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+// arrayAccesRegexString is the regex used to extract the array number\n+// from the access path\n+const arrayAccesRegexString = `^(.+)\\[([0-9]+)\\]$`\n+\n+// arrayAccesRegex is the compiled arrayAccesRegexString\n+var arrayAccesRegex = regexp.MustCompile(arrayAccesRegexString)\n+\n+// Get gets the value using the specified selector and\n+// returns it inside a new Obj object.\n+//\n+// If it cannot find the value, Get will return a nil\n+// value inside an instance of Obj.\n+//\n+// Get can only operate directly on map[string]interface{} and []interface.\n+//\n+// Example\n+//\n+// To access the title of the third chapter of the second book, do:\n+//\n+//    o.Get(\"books[1].chapters[2].title\")\n+func (m Map) Get(selector string) *Value {\n+\trawObj := access(m, selector, nil, false)\n+\treturn &Value{data: rawObj}\n+}\n+\n+// Set sets the value using the specified selector and\n+// returns the object on which Set was called.\n+//\n+// Set can only operate directly on map[string]interface{} and []interface\n+//\n+// Example\n+//\n+// To set the title of the third chapter of the second book, do:\n+//\n+//    o.Set(\"books[1].chapters[2].title\",\"Time to Go\")\n+func (m Map) Set(selector string, value interface{}) Map {\n+\taccess(m, selector, value, true)\n+\treturn m\n+}\n+\n+// access accesses the object using the selector and performs the\n+// appropriate action.\n+func access(current, selector, value interface{}, isSet bool) interface{} {\n+\tswitch selector.(type) {\n+\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n+\t\tif array, ok := current.([]interface{}); ok {\n+\t\t\tindex := intFromInterface(selector)\n+\t\t\tif index >= len(array) {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\treturn array[index]\n+\t\t}\n+\t\treturn nil\n+\n+\tcase string:\n+\t\tselStr := selector.(string)\n+\t\tselSegs := strings.SplitN(selStr, PathSeparator, 2)\n+\t\tthisSel := selSegs[0]\n+\t\tindex := -1\n+\t\tvar err error\n+\n+\t\tif strings.Contains(thisSel, \"[\") {\n+\t\t\tarrayMatches := arrayAccesRegex.FindStringSubmatch(thisSel)\n+\t\t\tif len(arrayMatches) > 0 {\n+\t\t\t\t// Get the key into the map\n+\t\t\t\tthisSel = arrayMatches[1]\n+\n+\t\t\t\t// Get the index into the array at the key\n+\t\t\t\tindex, err = strconv.Atoi(arrayMatches[2])\n+\n+\t\t\t\tif err != nil {\n+\t\t\t\t\t// This should never happen. If it does, something has gone\n+\t\t\t\t\t// seriously wrong. Panic.\n+\t\t\t\t\tpanic(\"objx: Array index is not an integer.  Must use array[int].\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif curMap, ok := current.(Map); ok {\n+\t\t\tcurrent = map[string]interface{}(curMap)\n+\t\t}\n+\t\t// get the object in question\n+\t\tswitch current.(type) {\n+\t\tcase map[string]interface{}:\n+\t\t\tcurMSI := current.(map[string]interface{})\n+\t\t\tif len(selSegs) <= 1 && isSet {\n+\t\t\t\tcurMSI[thisSel] = value\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tcurrent = curMSI[thisSel]\n+\t\tdefault:\n+\t\t\tcurrent = nil\n+\t\t}\n+\t\t// do we need to access the item of an array?\n+\t\tif index > -1 {\n+\t\t\tif array, ok := current.([]interface{}); ok {\n+\t\t\t\tif index < len(array) {\n+\t\t\t\t\tcurrent = array[index]\n+\t\t\t\t} else {\n+\t\t\t\t\tcurrent = nil\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif len(selSegs) > 1 {\n+\t\t\tcurrent = access(current, selSegs[1], value, isSet)\n+\t\t}\n+\t}\n+\treturn current\n+}\n+\n+// intFromInterface converts an interface object to the largest\n+// representation of an unsigned integer using a type switch and\n+// assertions\n+func intFromInterface(selector interface{}) int {\n+\tvar value int\n+\tswitch selector.(type) {\n+\tcase int:\n+\t\tvalue = selector.(int)\n+\tcase int8:\n+\t\tvalue = int(selector.(int8))\n+\tcase int16:\n+\t\tvalue = int(selector.(int16))\n+\tcase int32:\n+\t\tvalue = int(selector.(int32))\n+\tcase int64:\n+\t\tvalue = int(selector.(int64))\n+\tcase uint:\n+\t\tvalue = int(selector.(uint))\n+\tcase uint8:\n+\t\tvalue = int(selector.(uint8))\n+\tcase uint16:\n+\t\tvalue = int(selector.(uint16))\n+\tcase uint32:\n+\t\tvalue = int(selector.(uint32))\n+\tcase uint64:\n+\t\tvalue = int(selector.(uint64))\n+\tdefault:\n+\t\treturn 0\n+\t}\n+\treturn value\n+}"
    },
    {
      "sha": "f9eb42a25e0b92a7a2b308a5046b9b71fd1cac9b",
      "filename": "backend/vendor/github.com/stretchr/objx/constants.go",
      "status": "added",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/constants.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/constants.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/constants.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,13 @@\n+package objx\n+\n+const (\n+\t// PathSeparator is the character used to separate the elements\n+\t// of the keypath.\n+\t//\n+\t// For example, `location.address.city`\n+\tPathSeparator string = \".\"\n+\n+\t// SignatureSeparator is the character that is used to\n+\t// separate the Base64 string from the security signature.\n+\tSignatureSeparator = \"_\"\n+)"
    },
    {
      "sha": "5e020f310adc9aef33918db48ef051d82a83858c",
      "filename": "backend/vendor/github.com/stretchr/objx/conversions.go",
      "status": "added",
      "additions": 108,
      "deletions": 0,
      "changes": 108,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/conversions.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/conversions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/conversions.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,108 @@\n+package objx\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net/url\"\n+)\n+\n+// JSON converts the contained object to a JSON string\n+// representation\n+func (m Map) JSON() (string, error) {\n+\tresult, err := json.Marshal(m)\n+\tif err != nil {\n+\t\terr = errors.New(\"objx: JSON encode failed with: \" + err.Error())\n+\t}\n+\treturn string(result), err\n+}\n+\n+// MustJSON converts the contained object to a JSON string\n+// representation and panics if there is an error\n+func (m Map) MustJSON() string {\n+\tresult, err := m.JSON()\n+\tif err != nil {\n+\t\tpanic(err.Error())\n+\t}\n+\treturn result\n+}\n+\n+// Base64 converts the contained object to a Base64 string\n+// representation of the JSON string representation\n+func (m Map) Base64() (string, error) {\n+\tvar buf bytes.Buffer\n+\n+\tjsonData, err := m.JSON()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tencoder := base64.NewEncoder(base64.StdEncoding, &buf)\n+\t_, err = encoder.Write([]byte(jsonData))\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\t_ = encoder.Close()\n+\n+\treturn buf.String(), nil\n+}\n+\n+// MustBase64 converts the contained object to a Base64 string\n+// representation of the JSON string representation and panics\n+// if there is an error\n+func (m Map) MustBase64() string {\n+\tresult, err := m.Base64()\n+\tif err != nil {\n+\t\tpanic(err.Error())\n+\t}\n+\treturn result\n+}\n+\n+// SignedBase64 converts the contained object to a Base64 string\n+// representation of the JSON string representation and signs it\n+// using the provided key.\n+func (m Map) SignedBase64(key string) (string, error) {\n+\tbase64, err := m.Base64()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tsig := HashWithKey(base64, key)\n+\treturn base64 + SignatureSeparator + sig, nil\n+}\n+\n+// MustSignedBase64 converts the contained object to a Base64 string\n+// representation of the JSON string representation and signs it\n+// using the provided key and panics if there is an error\n+func (m Map) MustSignedBase64(key string) string {\n+\tresult, err := m.SignedBase64(key)\n+\tif err != nil {\n+\t\tpanic(err.Error())\n+\t}\n+\treturn result\n+}\n+\n+/*\n+\tURL Query\n+\t------------------------------------------------\n+*/\n+\n+// URLValues creates a url.Values object from an Obj. This\n+// function requires that the wrapped object be a map[string]interface{}\n+func (m Map) URLValues() url.Values {\n+\tvals := make(url.Values)\n+\tfor k, v := range m {\n+\t\t//TODO: can this be done without sprintf?\n+\t\tvals.Set(k, fmt.Sprintf(\"%v\", v))\n+\t}\n+\treturn vals\n+}\n+\n+// URLQuery gets an encoded URL query representing the given\n+// Obj. This function requires that the wrapped object be a\n+// map[string]interface{}\n+func (m Map) URLQuery() (string, error) {\n+\treturn m.URLValues().Encode(), nil\n+}"
    },
    {
      "sha": "6d6af1a83abf0c816be79b131271c1f311d28613",
      "filename": "backend/vendor/github.com/stretchr/objx/doc.go",
      "status": "added",
      "additions": 66,
      "deletions": 0,
      "changes": 66,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/doc.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/doc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/doc.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,66 @@\n+/*\n+Objx - Go package for dealing with maps, slices, JSON and other data.\n+\n+Overview\n+\n+Objx provides the `objx.Map` type, which is a `map[string]interface{}` that exposes\n+a powerful `Get` method (among others) that allows you to easily and quickly get\n+access to data within the map, without having to worry too much about type assertions,\n+missing data, default values etc.\n+\n+Pattern\n+\n+Objx uses a preditable pattern to make access data from within `map[string]interface{}` easy.\n+Call one of the `objx.` functions to create your `objx.Map` to get going:\n+\n+    m, err := objx.FromJSON(json)\n+\n+NOTE: Any methods or functions with the `Must` prefix will panic if something goes wrong,\n+the rest will be optimistic and try to figure things out without panicking.\n+\n+Use `Get` to access the value you're interested in.  You can use dot and array\n+notation too:\n+\n+     m.Get(\"places[0].latlng\")\n+\n+Once you have sought the `Value` you're interested in, you can use the `Is*` methods to determine its type.\n+\n+     if m.Get(\"code\").IsStr() { // Your code... }\n+\n+Or you can just assume the type, and use one of the strong type methods to extract the real value:\n+\n+   m.Get(\"code\").Int()\n+\n+If there's no value there (or if it's the wrong type) then a default value will be returned,\n+or you can be explicit about the default value.\n+\n+     Get(\"code\").Int(-1)\n+\n+If you're dealing with a slice of data as a value, Objx provides many useful methods for iterating,\n+manipulating and selecting that data.  You can find out more by exploring the index below.\n+\n+Reading data\n+\n+A simple example of how to use Objx:\n+\n+   // Use MustFromJSON to make an objx.Map from some JSON\n+   m := objx.MustFromJSON(`{\"name\": \"Mat\", \"age\": 30}`)\n+\n+   // Get the details\n+   name := m.Get(\"name\").Str()\n+   age := m.Get(\"age\").Int()\n+\n+   // Get their nickname (or use their name if they don't have one)\n+   nickname := m.Get(\"nickname\").Str(name)\n+\n+Ranging\n+\n+Since `objx.Map` is a `map[string]interface{}` you can treat it as such.\n+For example, to `range` the data, do what you would expect:\n+\n+    m := objx.MustFromJSON(json)\n+    for key, value := range m {\n+      // Your code...\n+    }\n+*/\n+package objx"
    },
    {
      "sha": "406bc89263515f975b8d6ad2f738d0d71dda1389",
      "filename": "backend/vendor/github.com/stretchr/objx/map.go",
      "status": "added",
      "additions": 190,
      "deletions": 0,
      "changes": 190,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/map.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/map.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/map.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,190 @@\n+package objx\n+\n+import (\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"io/ioutil\"\n+\t\"net/url\"\n+\t\"strings\"\n+)\n+\n+// MSIConvertable is an interface that defines methods for converting your\n+// custom types to a map[string]interface{} representation.\n+type MSIConvertable interface {\n+\t// MSI gets a map[string]interface{} (msi) representing the\n+\t// object.\n+\tMSI() map[string]interface{}\n+}\n+\n+// Map provides extended functionality for working with\n+// untyped data, in particular map[string]interface (msi).\n+type Map map[string]interface{}\n+\n+// Value returns the internal value instance\n+func (m Map) Value() *Value {\n+\treturn &Value{data: m}\n+}\n+\n+// Nil represents a nil Map.\n+var Nil = New(nil)\n+\n+// New creates a new Map containing the map[string]interface{} in the data argument.\n+// If the data argument is not a map[string]interface, New attempts to call the\n+// MSI() method on the MSIConvertable interface to create one.\n+func New(data interface{}) Map {\n+\tif _, ok := data.(map[string]interface{}); !ok {\n+\t\tif converter, ok := data.(MSIConvertable); ok {\n+\t\t\tdata = converter.MSI()\n+\t\t} else {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn Map(data.(map[string]interface{}))\n+}\n+\n+// MSI creates a map[string]interface{} and puts it inside a new Map.\n+//\n+// The arguments follow a key, value pattern.\n+//\n+//\n+// Returns nil if any key argument is non-string or if there are an odd number of arguments.\n+//\n+// Example\n+//\n+// To easily create Maps:\n+//\n+//     m := objx.MSI(\"name\", \"Mat\", \"age\", 29, \"subobj\", objx.MSI(\"active\", true))\n+//\n+//     // creates an Map equivalent to\n+//     m := objx.Map{\"name\": \"Mat\", \"age\": 29, \"subobj\": objx.Map{\"active\": true}}\n+func MSI(keyAndValuePairs ...interface{}) Map {\n+\tnewMap := Map{}\n+\tkeyAndValuePairsLen := len(keyAndValuePairs)\n+\tif keyAndValuePairsLen%2 != 0 {\n+\t\treturn nil\n+\t}\n+\tfor i := 0; i < keyAndValuePairsLen; i = i + 2 {\n+\t\tkey := keyAndValuePairs[i]\n+\t\tvalue := keyAndValuePairs[i+1]\n+\n+\t\t// make sure the key is a string\n+\t\tkeyString, keyStringOK := key.(string)\n+\t\tif !keyStringOK {\n+\t\t\treturn nil\n+\t\t}\n+\t\tnewMap[keyString] = value\n+\t}\n+\treturn newMap\n+}\n+\n+// ****** Conversion Constructors\n+\n+// MustFromJSON creates a new Map containing the data specified in the\n+// jsonString.\n+//\n+// Panics if the JSON is invalid.\n+func MustFromJSON(jsonString string) Map {\n+\to, err := FromJSON(jsonString)\n+\tif err != nil {\n+\t\tpanic(\"objx: MustFromJSON failed with error: \" + err.Error())\n+\t}\n+\treturn o\n+}\n+\n+// FromJSON creates a new Map containing the data specified in the\n+// jsonString.\n+//\n+// Returns an error if the JSON is invalid.\n+func FromJSON(jsonString string) (Map, error) {\n+\tvar data interface{}\n+\terr := json.Unmarshal([]byte(jsonString), &data)\n+\tif err != nil {\n+\t\treturn Nil, err\n+\t}\n+\treturn New(data), nil\n+}\n+\n+// FromBase64 creates a new Obj containing the data specified\n+// in the Base64 string.\n+//\n+// The string is an encoded JSON string returned by Base64\n+func FromBase64(base64String string) (Map, error) {\n+\tdecoder := base64.NewDecoder(base64.StdEncoding, strings.NewReader(base64String))\n+\tdecoded, err := ioutil.ReadAll(decoder)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn FromJSON(string(decoded))\n+}\n+\n+// MustFromBase64 creates a new Obj containing the data specified\n+// in the Base64 string and panics if there is an error.\n+//\n+// The string is an encoded JSON string returned by Base64\n+func MustFromBase64(base64String string) Map {\n+\tresult, err := FromBase64(base64String)\n+\tif err != nil {\n+\t\tpanic(\"objx: MustFromBase64 failed with error: \" + err.Error())\n+\t}\n+\treturn result\n+}\n+\n+// FromSignedBase64 creates a new Obj containing the data specified\n+// in the Base64 string.\n+//\n+// The string is an encoded JSON string returned by SignedBase64\n+func FromSignedBase64(base64String, key string) (Map, error) {\n+\tparts := strings.Split(base64String, SignatureSeparator)\n+\tif len(parts) != 2 {\n+\t\treturn nil, errors.New(\"objx: Signed base64 string is malformed\")\n+\t}\n+\n+\tsig := HashWithKey(parts[0], key)\n+\tif parts[1] != sig {\n+\t\treturn nil, errors.New(\"objx: Signature for base64 data does not match\")\n+\t}\n+\treturn FromBase64(parts[0])\n+}\n+\n+// MustFromSignedBase64 creates a new Obj containing the data specified\n+// in the Base64 string and panics if there is an error.\n+//\n+// The string is an encoded JSON string returned by Base64\n+func MustFromSignedBase64(base64String, key string) Map {\n+\tresult, err := FromSignedBase64(base64String, key)\n+\tif err != nil {\n+\t\tpanic(\"objx: MustFromSignedBase64 failed with error: \" + err.Error())\n+\t}\n+\treturn result\n+}\n+\n+// FromURLQuery generates a new Obj by parsing the specified\n+// query.\n+//\n+// For queries with multiple values, the first value is selected.\n+func FromURLQuery(query string) (Map, error) {\n+\tvals, err := url.ParseQuery(query)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tm := Map{}\n+\tfor k, vals := range vals {\n+\t\tm[k] = vals[0]\n+\t}\n+\treturn m, nil\n+}\n+\n+// MustFromURLQuery generates a new Obj by parsing the specified\n+// query.\n+//\n+// For queries with multiple values, the first value is selected.\n+//\n+// Panics if it encounters an error\n+func MustFromURLQuery(query string) Map {\n+\to, err := FromURLQuery(query)\n+\tif err != nil {\n+\t\tpanic(\"objx: MustFromURLQuery failed with error: \" + err.Error())\n+\t}\n+\treturn o\n+}"
    },
    {
      "sha": "c3400a3f709a29145475a918a8912b550069e3b2",
      "filename": "backend/vendor/github.com/stretchr/objx/mutations.go",
      "status": "added",
      "additions": 77,
      "deletions": 0,
      "changes": 77,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/mutations.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/mutations.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/mutations.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,77 @@\n+package objx\n+\n+// Exclude returns a new Map with the keys in the specified []string\n+// excluded.\n+func (m Map) Exclude(exclude []string) Map {\n+\texcluded := make(Map)\n+\tfor k, v := range m {\n+\t\tif !contains(exclude, k) {\n+\t\t\texcluded[k] = v\n+\t\t}\n+\t}\n+\treturn excluded\n+}\n+\n+// Copy creates a shallow copy of the Obj.\n+func (m Map) Copy() Map {\n+\tcopied := Map{}\n+\tfor k, v := range m {\n+\t\tcopied[k] = v\n+\t}\n+\treturn copied\n+}\n+\n+// Merge blends the specified map with a copy of this map and returns the result.\n+//\n+// Keys that appear in both will be selected from the specified map.\n+// This method requires that the wrapped object be a map[string]interface{}\n+func (m Map) Merge(merge Map) Map {\n+\treturn m.Copy().MergeHere(merge)\n+}\n+\n+// MergeHere blends the specified map with this map and returns the current map.\n+//\n+// Keys that appear in both will be selected from the specified map. The original map\n+// will be modified. This method requires that\n+// the wrapped object be a map[string]interface{}\n+func (m Map) MergeHere(merge Map) Map {\n+\tfor k, v := range merge {\n+\t\tm[k] = v\n+\t}\n+\treturn m\n+}\n+\n+// Transform builds a new Obj giving the transformer a chance\n+// to change the keys and values as it goes. This method requires that\n+// the wrapped object be a map[string]interface{}\n+func (m Map) Transform(transformer func(key string, value interface{}) (string, interface{})) Map {\n+\tnewMap := Map{}\n+\tfor k, v := range m {\n+\t\tmodifiedKey, modifiedVal := transformer(k, v)\n+\t\tnewMap[modifiedKey] = modifiedVal\n+\t}\n+\treturn newMap\n+}\n+\n+// TransformKeys builds a new map using the specified key mapping.\n+//\n+// Unspecified keys will be unaltered.\n+// This method requires that the wrapped object be a map[string]interface{}\n+func (m Map) TransformKeys(mapping map[string]string) Map {\n+\treturn m.Transform(func(key string, value interface{}) (string, interface{}) {\n+\t\tif newKey, ok := mapping[key]; ok {\n+\t\t\treturn newKey, value\n+\t\t}\n+\t\treturn key, value\n+\t})\n+}\n+\n+// Checks if a string slice contains a string\n+func contains(s []string, e string) bool {\n+\tfor _, a := range s {\n+\t\tif a == e {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"
    },
    {
      "sha": "692be8e2a9feb35955e1324b6004adb235838410",
      "filename": "backend/vendor/github.com/stretchr/objx/security.go",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/security.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/security.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/security.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,12 @@\n+package objx\n+\n+import (\n+\t\"crypto/sha1\"\n+\t\"encoding/hex\"\n+)\n+\n+// HashWithKey hashes the specified string using the security key\n+func HashWithKey(data, key string) string {\n+\td := sha1.Sum([]byte(data + \":\" + key))\n+\treturn hex.EncodeToString(d[:])\n+}"
    },
    {
      "sha": "d9e0b479a4c0f89957ed7cebc98d186740d1a96c",
      "filename": "backend/vendor/github.com/stretchr/objx/tests.go",
      "status": "added",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/tests.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/tests.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/tests.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,17 @@\n+package objx\n+\n+// Has gets whether there is something at the specified selector\n+// or not.\n+//\n+// If m is nil, Has will always return false.\n+func (m Map) Has(selector string) bool {\n+\tif m == nil {\n+\t\treturn false\n+\t}\n+\treturn !m.Get(selector).IsNil()\n+}\n+\n+// IsNil gets whether the data is nil or not.\n+func (v *Value) IsNil() bool {\n+\treturn v == nil || v.data == nil\n+}"
    },
    {
      "sha": "202a91f8c199f9d06f1962408ec9c4534b19e773",
      "filename": "backend/vendor/github.com/stretchr/objx/type_specific_codegen.go",
      "status": "added",
      "additions": 2501,
      "deletions": 0,
      "changes": 2501,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/type_specific_codegen.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/type_specific_codegen.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/type_specific_codegen.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,2501 @@\n+package objx\n+\n+/*\n+\tInter (interface{} and []interface{})\n+*/\n+\n+// Inter gets the value as a interface{}, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Inter(optionalDefault ...interface{}) interface{} {\n+\tif s, ok := v.data.(interface{}); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustInter gets the value as a interface{}.\n+//\n+// Panics if the object is not a interface{}.\n+func (v *Value) MustInter() interface{} {\n+\treturn v.data.(interface{})\n+}\n+\n+// InterSlice gets the value as a []interface{}, returns the optionalDefault\n+// value or nil if the value is not a []interface{}.\n+func (v *Value) InterSlice(optionalDefault ...[]interface{}) []interface{} {\n+\tif s, ok := v.data.([]interface{}); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustInterSlice gets the value as a []interface{}.\n+//\n+// Panics if the object is not a []interface{}.\n+func (v *Value) MustInterSlice() []interface{} {\n+\treturn v.data.([]interface{})\n+}\n+\n+// IsInter gets whether the object contained is a interface{} or not.\n+func (v *Value) IsInter() bool {\n+\t_, ok := v.data.(interface{})\n+\treturn ok\n+}\n+\n+// IsInterSlice gets whether the object contained is a []interface{} or not.\n+func (v *Value) IsInterSlice() bool {\n+\t_, ok := v.data.([]interface{})\n+\treturn ok\n+}\n+\n+// EachInter calls the specified callback for each object\n+// in the []interface{}.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachInter(callback func(int, interface{}) bool) *Value {\n+\tfor index, val := range v.MustInterSlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereInter uses the specified decider function to select items\n+// from the []interface{}.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereInter(decider func(int, interface{}) bool) *Value {\n+\tvar selected []interface{}\n+\tv.EachInter(func(index int, val interface{}) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupInter uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]interface{}.\n+func (v *Value) GroupInter(grouper func(int, interface{}) string) *Value {\n+\tgroups := make(map[string][]interface{})\n+\tv.EachInter(func(index int, val interface{}) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]interface{}, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceInter uses the specified function to replace each interface{}s\n+// by iterating each item.  The data in the returned result will be a\n+// []interface{} containing the replaced items.\n+func (v *Value) ReplaceInter(replacer func(int, interface{}) interface{}) *Value {\n+\tarr := v.MustInterSlice()\n+\treplaced := make([]interface{}, len(arr))\n+\tv.EachInter(func(index int, val interface{}) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectInter uses the specified collector function to collect a value\n+// for each of the interface{}s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectInter(collector func(int, interface{}) interface{}) *Value {\n+\tarr := v.MustInterSlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachInter(func(index int, val interface{}) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tMSI (map[string]interface{} and []map[string]interface{})\n+*/\n+\n+// MSI gets the value as a map[string]interface{}, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) MSI(optionalDefault ...map[string]interface{}) map[string]interface{} {\n+\tif s, ok := v.data.(map[string]interface{}); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustMSI gets the value as a map[string]interface{}.\n+//\n+// Panics if the object is not a map[string]interface{}.\n+func (v *Value) MustMSI() map[string]interface{} {\n+\treturn v.data.(map[string]interface{})\n+}\n+\n+// MSISlice gets the value as a []map[string]interface{}, returns the optionalDefault\n+// value or nil if the value is not a []map[string]interface{}.\n+func (v *Value) MSISlice(optionalDefault ...[]map[string]interface{}) []map[string]interface{} {\n+\tif s, ok := v.data.([]map[string]interface{}); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustMSISlice gets the value as a []map[string]interface{}.\n+//\n+// Panics if the object is not a []map[string]interface{}.\n+func (v *Value) MustMSISlice() []map[string]interface{} {\n+\treturn v.data.([]map[string]interface{})\n+}\n+\n+// IsMSI gets whether the object contained is a map[string]interface{} or not.\n+func (v *Value) IsMSI() bool {\n+\t_, ok := v.data.(map[string]interface{})\n+\treturn ok\n+}\n+\n+// IsMSISlice gets whether the object contained is a []map[string]interface{} or not.\n+func (v *Value) IsMSISlice() bool {\n+\t_, ok := v.data.([]map[string]interface{})\n+\treturn ok\n+}\n+\n+// EachMSI calls the specified callback for each object\n+// in the []map[string]interface{}.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachMSI(callback func(int, map[string]interface{}) bool) *Value {\n+\tfor index, val := range v.MustMSISlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereMSI uses the specified decider function to select items\n+// from the []map[string]interface{}.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereMSI(decider func(int, map[string]interface{}) bool) *Value {\n+\tvar selected []map[string]interface{}\n+\tv.EachMSI(func(index int, val map[string]interface{}) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupMSI uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]map[string]interface{}.\n+func (v *Value) GroupMSI(grouper func(int, map[string]interface{}) string) *Value {\n+\tgroups := make(map[string][]map[string]interface{})\n+\tv.EachMSI(func(index int, val map[string]interface{}) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]map[string]interface{}, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceMSI uses the specified function to replace each map[string]interface{}s\n+// by iterating each item.  The data in the returned result will be a\n+// []map[string]interface{} containing the replaced items.\n+func (v *Value) ReplaceMSI(replacer func(int, map[string]interface{}) map[string]interface{}) *Value {\n+\tarr := v.MustMSISlice()\n+\treplaced := make([]map[string]interface{}, len(arr))\n+\tv.EachMSI(func(index int, val map[string]interface{}) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectMSI uses the specified collector function to collect a value\n+// for each of the map[string]interface{}s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectMSI(collector func(int, map[string]interface{}) interface{}) *Value {\n+\tarr := v.MustMSISlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachMSI(func(index int, val map[string]interface{}) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tObjxMap ((Map) and [](Map))\n+*/\n+\n+// ObjxMap gets the value as a (Map), returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) ObjxMap(optionalDefault ...(Map)) Map {\n+\tif s, ok := v.data.((Map)); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn New(nil)\n+}\n+\n+// MustObjxMap gets the value as a (Map).\n+//\n+// Panics if the object is not a (Map).\n+func (v *Value) MustObjxMap() Map {\n+\treturn v.data.((Map))\n+}\n+\n+// ObjxMapSlice gets the value as a [](Map), returns the optionalDefault\n+// value or nil if the value is not a [](Map).\n+func (v *Value) ObjxMapSlice(optionalDefault ...[](Map)) [](Map) {\n+\tif s, ok := v.data.([](Map)); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustObjxMapSlice gets the value as a [](Map).\n+//\n+// Panics if the object is not a [](Map).\n+func (v *Value) MustObjxMapSlice() [](Map) {\n+\treturn v.data.([](Map))\n+}\n+\n+// IsObjxMap gets whether the object contained is a (Map) or not.\n+func (v *Value) IsObjxMap() bool {\n+\t_, ok := v.data.((Map))\n+\treturn ok\n+}\n+\n+// IsObjxMapSlice gets whether the object contained is a [](Map) or not.\n+func (v *Value) IsObjxMapSlice() bool {\n+\t_, ok := v.data.([](Map))\n+\treturn ok\n+}\n+\n+// EachObjxMap calls the specified callback for each object\n+// in the [](Map).\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachObjxMap(callback func(int, Map) bool) *Value {\n+\tfor index, val := range v.MustObjxMapSlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereObjxMap uses the specified decider function to select items\n+// from the [](Map).  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereObjxMap(decider func(int, Map) bool) *Value {\n+\tvar selected [](Map)\n+\tv.EachObjxMap(func(index int, val Map) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupObjxMap uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][](Map).\n+func (v *Value) GroupObjxMap(grouper func(int, Map) string) *Value {\n+\tgroups := make(map[string][](Map))\n+\tv.EachObjxMap(func(index int, val Map) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([](Map), 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceObjxMap uses the specified function to replace each (Map)s\n+// by iterating each item.  The data in the returned result will be a\n+// [](Map) containing the replaced items.\n+func (v *Value) ReplaceObjxMap(replacer func(int, Map) Map) *Value {\n+\tarr := v.MustObjxMapSlice()\n+\treplaced := make([](Map), len(arr))\n+\tv.EachObjxMap(func(index int, val Map) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectObjxMap uses the specified collector function to collect a value\n+// for each of the (Map)s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectObjxMap(collector func(int, Map) interface{}) *Value {\n+\tarr := v.MustObjxMapSlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachObjxMap(func(index int, val Map) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tBool (bool and []bool)\n+*/\n+\n+// Bool gets the value as a bool, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Bool(optionalDefault ...bool) bool {\n+\tif s, ok := v.data.(bool); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn false\n+}\n+\n+// MustBool gets the value as a bool.\n+//\n+// Panics if the object is not a bool.\n+func (v *Value) MustBool() bool {\n+\treturn v.data.(bool)\n+}\n+\n+// BoolSlice gets the value as a []bool, returns the optionalDefault\n+// value or nil if the value is not a []bool.\n+func (v *Value) BoolSlice(optionalDefault ...[]bool) []bool {\n+\tif s, ok := v.data.([]bool); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustBoolSlice gets the value as a []bool.\n+//\n+// Panics if the object is not a []bool.\n+func (v *Value) MustBoolSlice() []bool {\n+\treturn v.data.([]bool)\n+}\n+\n+// IsBool gets whether the object contained is a bool or not.\n+func (v *Value) IsBool() bool {\n+\t_, ok := v.data.(bool)\n+\treturn ok\n+}\n+\n+// IsBoolSlice gets whether the object contained is a []bool or not.\n+func (v *Value) IsBoolSlice() bool {\n+\t_, ok := v.data.([]bool)\n+\treturn ok\n+}\n+\n+// EachBool calls the specified callback for each object\n+// in the []bool.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachBool(callback func(int, bool) bool) *Value {\n+\tfor index, val := range v.MustBoolSlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereBool uses the specified decider function to select items\n+// from the []bool.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereBool(decider func(int, bool) bool) *Value {\n+\tvar selected []bool\n+\tv.EachBool(func(index int, val bool) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupBool uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]bool.\n+func (v *Value) GroupBool(grouper func(int, bool) string) *Value {\n+\tgroups := make(map[string][]bool)\n+\tv.EachBool(func(index int, val bool) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]bool, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceBool uses the specified function to replace each bools\n+// by iterating each item.  The data in the returned result will be a\n+// []bool containing the replaced items.\n+func (v *Value) ReplaceBool(replacer func(int, bool) bool) *Value {\n+\tarr := v.MustBoolSlice()\n+\treplaced := make([]bool, len(arr))\n+\tv.EachBool(func(index int, val bool) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectBool uses the specified collector function to collect a value\n+// for each of the bools in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectBool(collector func(int, bool) interface{}) *Value {\n+\tarr := v.MustBoolSlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachBool(func(index int, val bool) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tStr (string and []string)\n+*/\n+\n+// Str gets the value as a string, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Str(optionalDefault ...string) string {\n+\tif s, ok := v.data.(string); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn \"\"\n+}\n+\n+// MustStr gets the value as a string.\n+//\n+// Panics if the object is not a string.\n+func (v *Value) MustStr() string {\n+\treturn v.data.(string)\n+}\n+\n+// StrSlice gets the value as a []string, returns the optionalDefault\n+// value or nil if the value is not a []string.\n+func (v *Value) StrSlice(optionalDefault ...[]string) []string {\n+\tif s, ok := v.data.([]string); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustStrSlice gets the value as a []string.\n+//\n+// Panics if the object is not a []string.\n+func (v *Value) MustStrSlice() []string {\n+\treturn v.data.([]string)\n+}\n+\n+// IsStr gets whether the object contained is a string or not.\n+func (v *Value) IsStr() bool {\n+\t_, ok := v.data.(string)\n+\treturn ok\n+}\n+\n+// IsStrSlice gets whether the object contained is a []string or not.\n+func (v *Value) IsStrSlice() bool {\n+\t_, ok := v.data.([]string)\n+\treturn ok\n+}\n+\n+// EachStr calls the specified callback for each object\n+// in the []string.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachStr(callback func(int, string) bool) *Value {\n+\tfor index, val := range v.MustStrSlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereStr uses the specified decider function to select items\n+// from the []string.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereStr(decider func(int, string) bool) *Value {\n+\tvar selected []string\n+\tv.EachStr(func(index int, val string) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupStr uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]string.\n+func (v *Value) GroupStr(grouper func(int, string) string) *Value {\n+\tgroups := make(map[string][]string)\n+\tv.EachStr(func(index int, val string) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]string, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceStr uses the specified function to replace each strings\n+// by iterating each item.  The data in the returned result will be a\n+// []string containing the replaced items.\n+func (v *Value) ReplaceStr(replacer func(int, string) string) *Value {\n+\tarr := v.MustStrSlice()\n+\treplaced := make([]string, len(arr))\n+\tv.EachStr(func(index int, val string) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectStr uses the specified collector function to collect a value\n+// for each of the strings in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectStr(collector func(int, string) interface{}) *Value {\n+\tarr := v.MustStrSlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachStr(func(index int, val string) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tInt (int and []int)\n+*/\n+\n+// Int gets the value as a int, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Int(optionalDefault ...int) int {\n+\tif s, ok := v.data.(int); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustInt gets the value as a int.\n+//\n+// Panics if the object is not a int.\n+func (v *Value) MustInt() int {\n+\treturn v.data.(int)\n+}\n+\n+// IntSlice gets the value as a []int, returns the optionalDefault\n+// value or nil if the value is not a []int.\n+func (v *Value) IntSlice(optionalDefault ...[]int) []int {\n+\tif s, ok := v.data.([]int); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustIntSlice gets the value as a []int.\n+//\n+// Panics if the object is not a []int.\n+func (v *Value) MustIntSlice() []int {\n+\treturn v.data.([]int)\n+}\n+\n+// IsInt gets whether the object contained is a int or not.\n+func (v *Value) IsInt() bool {\n+\t_, ok := v.data.(int)\n+\treturn ok\n+}\n+\n+// IsIntSlice gets whether the object contained is a []int or not.\n+func (v *Value) IsIntSlice() bool {\n+\t_, ok := v.data.([]int)\n+\treturn ok\n+}\n+\n+// EachInt calls the specified callback for each object\n+// in the []int.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachInt(callback func(int, int) bool) *Value {\n+\tfor index, val := range v.MustIntSlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereInt uses the specified decider function to select items\n+// from the []int.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereInt(decider func(int, int) bool) *Value {\n+\tvar selected []int\n+\tv.EachInt(func(index int, val int) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupInt uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]int.\n+func (v *Value) GroupInt(grouper func(int, int) string) *Value {\n+\tgroups := make(map[string][]int)\n+\tv.EachInt(func(index int, val int) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]int, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceInt uses the specified function to replace each ints\n+// by iterating each item.  The data in the returned result will be a\n+// []int containing the replaced items.\n+func (v *Value) ReplaceInt(replacer func(int, int) int) *Value {\n+\tarr := v.MustIntSlice()\n+\treplaced := make([]int, len(arr))\n+\tv.EachInt(func(index int, val int) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectInt uses the specified collector function to collect a value\n+// for each of the ints in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectInt(collector func(int, int) interface{}) *Value {\n+\tarr := v.MustIntSlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachInt(func(index int, val int) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tInt8 (int8 and []int8)\n+*/\n+\n+// Int8 gets the value as a int8, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Int8(optionalDefault ...int8) int8 {\n+\tif s, ok := v.data.(int8); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustInt8 gets the value as a int8.\n+//\n+// Panics if the object is not a int8.\n+func (v *Value) MustInt8() int8 {\n+\treturn v.data.(int8)\n+}\n+\n+// Int8Slice gets the value as a []int8, returns the optionalDefault\n+// value or nil if the value is not a []int8.\n+func (v *Value) Int8Slice(optionalDefault ...[]int8) []int8 {\n+\tif s, ok := v.data.([]int8); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustInt8Slice gets the value as a []int8.\n+//\n+// Panics if the object is not a []int8.\n+func (v *Value) MustInt8Slice() []int8 {\n+\treturn v.data.([]int8)\n+}\n+\n+// IsInt8 gets whether the object contained is a int8 or not.\n+func (v *Value) IsInt8() bool {\n+\t_, ok := v.data.(int8)\n+\treturn ok\n+}\n+\n+// IsInt8Slice gets whether the object contained is a []int8 or not.\n+func (v *Value) IsInt8Slice() bool {\n+\t_, ok := v.data.([]int8)\n+\treturn ok\n+}\n+\n+// EachInt8 calls the specified callback for each object\n+// in the []int8.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachInt8(callback func(int, int8) bool) *Value {\n+\tfor index, val := range v.MustInt8Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereInt8 uses the specified decider function to select items\n+// from the []int8.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereInt8(decider func(int, int8) bool) *Value {\n+\tvar selected []int8\n+\tv.EachInt8(func(index int, val int8) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupInt8 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]int8.\n+func (v *Value) GroupInt8(grouper func(int, int8) string) *Value {\n+\tgroups := make(map[string][]int8)\n+\tv.EachInt8(func(index int, val int8) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]int8, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceInt8 uses the specified function to replace each int8s\n+// by iterating each item.  The data in the returned result will be a\n+// []int8 containing the replaced items.\n+func (v *Value) ReplaceInt8(replacer func(int, int8) int8) *Value {\n+\tarr := v.MustInt8Slice()\n+\treplaced := make([]int8, len(arr))\n+\tv.EachInt8(func(index int, val int8) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectInt8 uses the specified collector function to collect a value\n+// for each of the int8s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectInt8(collector func(int, int8) interface{}) *Value {\n+\tarr := v.MustInt8Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachInt8(func(index int, val int8) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tInt16 (int16 and []int16)\n+*/\n+\n+// Int16 gets the value as a int16, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Int16(optionalDefault ...int16) int16 {\n+\tif s, ok := v.data.(int16); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustInt16 gets the value as a int16.\n+//\n+// Panics if the object is not a int16.\n+func (v *Value) MustInt16() int16 {\n+\treturn v.data.(int16)\n+}\n+\n+// Int16Slice gets the value as a []int16, returns the optionalDefault\n+// value or nil if the value is not a []int16.\n+func (v *Value) Int16Slice(optionalDefault ...[]int16) []int16 {\n+\tif s, ok := v.data.([]int16); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustInt16Slice gets the value as a []int16.\n+//\n+// Panics if the object is not a []int16.\n+func (v *Value) MustInt16Slice() []int16 {\n+\treturn v.data.([]int16)\n+}\n+\n+// IsInt16 gets whether the object contained is a int16 or not.\n+func (v *Value) IsInt16() bool {\n+\t_, ok := v.data.(int16)\n+\treturn ok\n+}\n+\n+// IsInt16Slice gets whether the object contained is a []int16 or not.\n+func (v *Value) IsInt16Slice() bool {\n+\t_, ok := v.data.([]int16)\n+\treturn ok\n+}\n+\n+// EachInt16 calls the specified callback for each object\n+// in the []int16.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachInt16(callback func(int, int16) bool) *Value {\n+\tfor index, val := range v.MustInt16Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereInt16 uses the specified decider function to select items\n+// from the []int16.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereInt16(decider func(int, int16) bool) *Value {\n+\tvar selected []int16\n+\tv.EachInt16(func(index int, val int16) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupInt16 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]int16.\n+func (v *Value) GroupInt16(grouper func(int, int16) string) *Value {\n+\tgroups := make(map[string][]int16)\n+\tv.EachInt16(func(index int, val int16) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]int16, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceInt16 uses the specified function to replace each int16s\n+// by iterating each item.  The data in the returned result will be a\n+// []int16 containing the replaced items.\n+func (v *Value) ReplaceInt16(replacer func(int, int16) int16) *Value {\n+\tarr := v.MustInt16Slice()\n+\treplaced := make([]int16, len(arr))\n+\tv.EachInt16(func(index int, val int16) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectInt16 uses the specified collector function to collect a value\n+// for each of the int16s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectInt16(collector func(int, int16) interface{}) *Value {\n+\tarr := v.MustInt16Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachInt16(func(index int, val int16) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tInt32 (int32 and []int32)\n+*/\n+\n+// Int32 gets the value as a int32, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Int32(optionalDefault ...int32) int32 {\n+\tif s, ok := v.data.(int32); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustInt32 gets the value as a int32.\n+//\n+// Panics if the object is not a int32.\n+func (v *Value) MustInt32() int32 {\n+\treturn v.data.(int32)\n+}\n+\n+// Int32Slice gets the value as a []int32, returns the optionalDefault\n+// value or nil if the value is not a []int32.\n+func (v *Value) Int32Slice(optionalDefault ...[]int32) []int32 {\n+\tif s, ok := v.data.([]int32); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustInt32Slice gets the value as a []int32.\n+//\n+// Panics if the object is not a []int32.\n+func (v *Value) MustInt32Slice() []int32 {\n+\treturn v.data.([]int32)\n+}\n+\n+// IsInt32 gets whether the object contained is a int32 or not.\n+func (v *Value) IsInt32() bool {\n+\t_, ok := v.data.(int32)\n+\treturn ok\n+}\n+\n+// IsInt32Slice gets whether the object contained is a []int32 or not.\n+func (v *Value) IsInt32Slice() bool {\n+\t_, ok := v.data.([]int32)\n+\treturn ok\n+}\n+\n+// EachInt32 calls the specified callback for each object\n+// in the []int32.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachInt32(callback func(int, int32) bool) *Value {\n+\tfor index, val := range v.MustInt32Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereInt32 uses the specified decider function to select items\n+// from the []int32.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereInt32(decider func(int, int32) bool) *Value {\n+\tvar selected []int32\n+\tv.EachInt32(func(index int, val int32) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupInt32 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]int32.\n+func (v *Value) GroupInt32(grouper func(int, int32) string) *Value {\n+\tgroups := make(map[string][]int32)\n+\tv.EachInt32(func(index int, val int32) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]int32, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceInt32 uses the specified function to replace each int32s\n+// by iterating each item.  The data in the returned result will be a\n+// []int32 containing the replaced items.\n+func (v *Value) ReplaceInt32(replacer func(int, int32) int32) *Value {\n+\tarr := v.MustInt32Slice()\n+\treplaced := make([]int32, len(arr))\n+\tv.EachInt32(func(index int, val int32) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectInt32 uses the specified collector function to collect a value\n+// for each of the int32s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectInt32(collector func(int, int32) interface{}) *Value {\n+\tarr := v.MustInt32Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachInt32(func(index int, val int32) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tInt64 (int64 and []int64)\n+*/\n+\n+// Int64 gets the value as a int64, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Int64(optionalDefault ...int64) int64 {\n+\tif s, ok := v.data.(int64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustInt64 gets the value as a int64.\n+//\n+// Panics if the object is not a int64.\n+func (v *Value) MustInt64() int64 {\n+\treturn v.data.(int64)\n+}\n+\n+// Int64Slice gets the value as a []int64, returns the optionalDefault\n+// value or nil if the value is not a []int64.\n+func (v *Value) Int64Slice(optionalDefault ...[]int64) []int64 {\n+\tif s, ok := v.data.([]int64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustInt64Slice gets the value as a []int64.\n+//\n+// Panics if the object is not a []int64.\n+func (v *Value) MustInt64Slice() []int64 {\n+\treturn v.data.([]int64)\n+}\n+\n+// IsInt64 gets whether the object contained is a int64 or not.\n+func (v *Value) IsInt64() bool {\n+\t_, ok := v.data.(int64)\n+\treturn ok\n+}\n+\n+// IsInt64Slice gets whether the object contained is a []int64 or not.\n+func (v *Value) IsInt64Slice() bool {\n+\t_, ok := v.data.([]int64)\n+\treturn ok\n+}\n+\n+// EachInt64 calls the specified callback for each object\n+// in the []int64.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachInt64(callback func(int, int64) bool) *Value {\n+\tfor index, val := range v.MustInt64Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereInt64 uses the specified decider function to select items\n+// from the []int64.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereInt64(decider func(int, int64) bool) *Value {\n+\tvar selected []int64\n+\tv.EachInt64(func(index int, val int64) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupInt64 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]int64.\n+func (v *Value) GroupInt64(grouper func(int, int64) string) *Value {\n+\tgroups := make(map[string][]int64)\n+\tv.EachInt64(func(index int, val int64) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]int64, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceInt64 uses the specified function to replace each int64s\n+// by iterating each item.  The data in the returned result will be a\n+// []int64 containing the replaced items.\n+func (v *Value) ReplaceInt64(replacer func(int, int64) int64) *Value {\n+\tarr := v.MustInt64Slice()\n+\treplaced := make([]int64, len(arr))\n+\tv.EachInt64(func(index int, val int64) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectInt64 uses the specified collector function to collect a value\n+// for each of the int64s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectInt64(collector func(int, int64) interface{}) *Value {\n+\tarr := v.MustInt64Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachInt64(func(index int, val int64) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tUint (uint and []uint)\n+*/\n+\n+// Uint gets the value as a uint, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Uint(optionalDefault ...uint) uint {\n+\tif s, ok := v.data.(uint); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustUint gets the value as a uint.\n+//\n+// Panics if the object is not a uint.\n+func (v *Value) MustUint() uint {\n+\treturn v.data.(uint)\n+}\n+\n+// UintSlice gets the value as a []uint, returns the optionalDefault\n+// value or nil if the value is not a []uint.\n+func (v *Value) UintSlice(optionalDefault ...[]uint) []uint {\n+\tif s, ok := v.data.([]uint); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustUintSlice gets the value as a []uint.\n+//\n+// Panics if the object is not a []uint.\n+func (v *Value) MustUintSlice() []uint {\n+\treturn v.data.([]uint)\n+}\n+\n+// IsUint gets whether the object contained is a uint or not.\n+func (v *Value) IsUint() bool {\n+\t_, ok := v.data.(uint)\n+\treturn ok\n+}\n+\n+// IsUintSlice gets whether the object contained is a []uint or not.\n+func (v *Value) IsUintSlice() bool {\n+\t_, ok := v.data.([]uint)\n+\treturn ok\n+}\n+\n+// EachUint calls the specified callback for each object\n+// in the []uint.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachUint(callback func(int, uint) bool) *Value {\n+\tfor index, val := range v.MustUintSlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereUint uses the specified decider function to select items\n+// from the []uint.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereUint(decider func(int, uint) bool) *Value {\n+\tvar selected []uint\n+\tv.EachUint(func(index int, val uint) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupUint uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]uint.\n+func (v *Value) GroupUint(grouper func(int, uint) string) *Value {\n+\tgroups := make(map[string][]uint)\n+\tv.EachUint(func(index int, val uint) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]uint, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceUint uses the specified function to replace each uints\n+// by iterating each item.  The data in the returned result will be a\n+// []uint containing the replaced items.\n+func (v *Value) ReplaceUint(replacer func(int, uint) uint) *Value {\n+\tarr := v.MustUintSlice()\n+\treplaced := make([]uint, len(arr))\n+\tv.EachUint(func(index int, val uint) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectUint uses the specified collector function to collect a value\n+// for each of the uints in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectUint(collector func(int, uint) interface{}) *Value {\n+\tarr := v.MustUintSlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachUint(func(index int, val uint) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tUint8 (uint8 and []uint8)\n+*/\n+\n+// Uint8 gets the value as a uint8, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Uint8(optionalDefault ...uint8) uint8 {\n+\tif s, ok := v.data.(uint8); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustUint8 gets the value as a uint8.\n+//\n+// Panics if the object is not a uint8.\n+func (v *Value) MustUint8() uint8 {\n+\treturn v.data.(uint8)\n+}\n+\n+// Uint8Slice gets the value as a []uint8, returns the optionalDefault\n+// value or nil if the value is not a []uint8.\n+func (v *Value) Uint8Slice(optionalDefault ...[]uint8) []uint8 {\n+\tif s, ok := v.data.([]uint8); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustUint8Slice gets the value as a []uint8.\n+//\n+// Panics if the object is not a []uint8.\n+func (v *Value) MustUint8Slice() []uint8 {\n+\treturn v.data.([]uint8)\n+}\n+\n+// IsUint8 gets whether the object contained is a uint8 or not.\n+func (v *Value) IsUint8() bool {\n+\t_, ok := v.data.(uint8)\n+\treturn ok\n+}\n+\n+// IsUint8Slice gets whether the object contained is a []uint8 or not.\n+func (v *Value) IsUint8Slice() bool {\n+\t_, ok := v.data.([]uint8)\n+\treturn ok\n+}\n+\n+// EachUint8 calls the specified callback for each object\n+// in the []uint8.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachUint8(callback func(int, uint8) bool) *Value {\n+\tfor index, val := range v.MustUint8Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereUint8 uses the specified decider function to select items\n+// from the []uint8.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereUint8(decider func(int, uint8) bool) *Value {\n+\tvar selected []uint8\n+\tv.EachUint8(func(index int, val uint8) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupUint8 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]uint8.\n+func (v *Value) GroupUint8(grouper func(int, uint8) string) *Value {\n+\tgroups := make(map[string][]uint8)\n+\tv.EachUint8(func(index int, val uint8) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]uint8, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceUint8 uses the specified function to replace each uint8s\n+// by iterating each item.  The data in the returned result will be a\n+// []uint8 containing the replaced items.\n+func (v *Value) ReplaceUint8(replacer func(int, uint8) uint8) *Value {\n+\tarr := v.MustUint8Slice()\n+\treplaced := make([]uint8, len(arr))\n+\tv.EachUint8(func(index int, val uint8) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectUint8 uses the specified collector function to collect a value\n+// for each of the uint8s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectUint8(collector func(int, uint8) interface{}) *Value {\n+\tarr := v.MustUint8Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachUint8(func(index int, val uint8) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tUint16 (uint16 and []uint16)\n+*/\n+\n+// Uint16 gets the value as a uint16, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Uint16(optionalDefault ...uint16) uint16 {\n+\tif s, ok := v.data.(uint16); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustUint16 gets the value as a uint16.\n+//\n+// Panics if the object is not a uint16.\n+func (v *Value) MustUint16() uint16 {\n+\treturn v.data.(uint16)\n+}\n+\n+// Uint16Slice gets the value as a []uint16, returns the optionalDefault\n+// value or nil if the value is not a []uint16.\n+func (v *Value) Uint16Slice(optionalDefault ...[]uint16) []uint16 {\n+\tif s, ok := v.data.([]uint16); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustUint16Slice gets the value as a []uint16.\n+//\n+// Panics if the object is not a []uint16.\n+func (v *Value) MustUint16Slice() []uint16 {\n+\treturn v.data.([]uint16)\n+}\n+\n+// IsUint16 gets whether the object contained is a uint16 or not.\n+func (v *Value) IsUint16() bool {\n+\t_, ok := v.data.(uint16)\n+\treturn ok\n+}\n+\n+// IsUint16Slice gets whether the object contained is a []uint16 or not.\n+func (v *Value) IsUint16Slice() bool {\n+\t_, ok := v.data.([]uint16)\n+\treturn ok\n+}\n+\n+// EachUint16 calls the specified callback for each object\n+// in the []uint16.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachUint16(callback func(int, uint16) bool) *Value {\n+\tfor index, val := range v.MustUint16Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereUint16 uses the specified decider function to select items\n+// from the []uint16.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereUint16(decider func(int, uint16) bool) *Value {\n+\tvar selected []uint16\n+\tv.EachUint16(func(index int, val uint16) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupUint16 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]uint16.\n+func (v *Value) GroupUint16(grouper func(int, uint16) string) *Value {\n+\tgroups := make(map[string][]uint16)\n+\tv.EachUint16(func(index int, val uint16) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]uint16, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceUint16 uses the specified function to replace each uint16s\n+// by iterating each item.  The data in the returned result will be a\n+// []uint16 containing the replaced items.\n+func (v *Value) ReplaceUint16(replacer func(int, uint16) uint16) *Value {\n+\tarr := v.MustUint16Slice()\n+\treplaced := make([]uint16, len(arr))\n+\tv.EachUint16(func(index int, val uint16) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectUint16 uses the specified collector function to collect a value\n+// for each of the uint16s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectUint16(collector func(int, uint16) interface{}) *Value {\n+\tarr := v.MustUint16Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachUint16(func(index int, val uint16) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tUint32 (uint32 and []uint32)\n+*/\n+\n+// Uint32 gets the value as a uint32, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Uint32(optionalDefault ...uint32) uint32 {\n+\tif s, ok := v.data.(uint32); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustUint32 gets the value as a uint32.\n+//\n+// Panics if the object is not a uint32.\n+func (v *Value) MustUint32() uint32 {\n+\treturn v.data.(uint32)\n+}\n+\n+// Uint32Slice gets the value as a []uint32, returns the optionalDefault\n+// value or nil if the value is not a []uint32.\n+func (v *Value) Uint32Slice(optionalDefault ...[]uint32) []uint32 {\n+\tif s, ok := v.data.([]uint32); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustUint32Slice gets the value as a []uint32.\n+//\n+// Panics if the object is not a []uint32.\n+func (v *Value) MustUint32Slice() []uint32 {\n+\treturn v.data.([]uint32)\n+}\n+\n+// IsUint32 gets whether the object contained is a uint32 or not.\n+func (v *Value) IsUint32() bool {\n+\t_, ok := v.data.(uint32)\n+\treturn ok\n+}\n+\n+// IsUint32Slice gets whether the object contained is a []uint32 or not.\n+func (v *Value) IsUint32Slice() bool {\n+\t_, ok := v.data.([]uint32)\n+\treturn ok\n+}\n+\n+// EachUint32 calls the specified callback for each object\n+// in the []uint32.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachUint32(callback func(int, uint32) bool) *Value {\n+\tfor index, val := range v.MustUint32Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereUint32 uses the specified decider function to select items\n+// from the []uint32.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereUint32(decider func(int, uint32) bool) *Value {\n+\tvar selected []uint32\n+\tv.EachUint32(func(index int, val uint32) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupUint32 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]uint32.\n+func (v *Value) GroupUint32(grouper func(int, uint32) string) *Value {\n+\tgroups := make(map[string][]uint32)\n+\tv.EachUint32(func(index int, val uint32) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]uint32, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceUint32 uses the specified function to replace each uint32s\n+// by iterating each item.  The data in the returned result will be a\n+// []uint32 containing the replaced items.\n+func (v *Value) ReplaceUint32(replacer func(int, uint32) uint32) *Value {\n+\tarr := v.MustUint32Slice()\n+\treplaced := make([]uint32, len(arr))\n+\tv.EachUint32(func(index int, val uint32) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectUint32 uses the specified collector function to collect a value\n+// for each of the uint32s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectUint32(collector func(int, uint32) interface{}) *Value {\n+\tarr := v.MustUint32Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachUint32(func(index int, val uint32) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tUint64 (uint64 and []uint64)\n+*/\n+\n+// Uint64 gets the value as a uint64, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Uint64(optionalDefault ...uint64) uint64 {\n+\tif s, ok := v.data.(uint64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustUint64 gets the value as a uint64.\n+//\n+// Panics if the object is not a uint64.\n+func (v *Value) MustUint64() uint64 {\n+\treturn v.data.(uint64)\n+}\n+\n+// Uint64Slice gets the value as a []uint64, returns the optionalDefault\n+// value or nil if the value is not a []uint64.\n+func (v *Value) Uint64Slice(optionalDefault ...[]uint64) []uint64 {\n+\tif s, ok := v.data.([]uint64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustUint64Slice gets the value as a []uint64.\n+//\n+// Panics if the object is not a []uint64.\n+func (v *Value) MustUint64Slice() []uint64 {\n+\treturn v.data.([]uint64)\n+}\n+\n+// IsUint64 gets whether the object contained is a uint64 or not.\n+func (v *Value) IsUint64() bool {\n+\t_, ok := v.data.(uint64)\n+\treturn ok\n+}\n+\n+// IsUint64Slice gets whether the object contained is a []uint64 or not.\n+func (v *Value) IsUint64Slice() bool {\n+\t_, ok := v.data.([]uint64)\n+\treturn ok\n+}\n+\n+// EachUint64 calls the specified callback for each object\n+// in the []uint64.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachUint64(callback func(int, uint64) bool) *Value {\n+\tfor index, val := range v.MustUint64Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereUint64 uses the specified decider function to select items\n+// from the []uint64.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereUint64(decider func(int, uint64) bool) *Value {\n+\tvar selected []uint64\n+\tv.EachUint64(func(index int, val uint64) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupUint64 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]uint64.\n+func (v *Value) GroupUint64(grouper func(int, uint64) string) *Value {\n+\tgroups := make(map[string][]uint64)\n+\tv.EachUint64(func(index int, val uint64) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]uint64, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceUint64 uses the specified function to replace each uint64s\n+// by iterating each item.  The data in the returned result will be a\n+// []uint64 containing the replaced items.\n+func (v *Value) ReplaceUint64(replacer func(int, uint64) uint64) *Value {\n+\tarr := v.MustUint64Slice()\n+\treplaced := make([]uint64, len(arr))\n+\tv.EachUint64(func(index int, val uint64) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectUint64 uses the specified collector function to collect a value\n+// for each of the uint64s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectUint64(collector func(int, uint64) interface{}) *Value {\n+\tarr := v.MustUint64Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachUint64(func(index int, val uint64) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tUintptr (uintptr and []uintptr)\n+*/\n+\n+// Uintptr gets the value as a uintptr, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Uintptr(optionalDefault ...uintptr) uintptr {\n+\tif s, ok := v.data.(uintptr); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustUintptr gets the value as a uintptr.\n+//\n+// Panics if the object is not a uintptr.\n+func (v *Value) MustUintptr() uintptr {\n+\treturn v.data.(uintptr)\n+}\n+\n+// UintptrSlice gets the value as a []uintptr, returns the optionalDefault\n+// value or nil if the value is not a []uintptr.\n+func (v *Value) UintptrSlice(optionalDefault ...[]uintptr) []uintptr {\n+\tif s, ok := v.data.([]uintptr); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustUintptrSlice gets the value as a []uintptr.\n+//\n+// Panics if the object is not a []uintptr.\n+func (v *Value) MustUintptrSlice() []uintptr {\n+\treturn v.data.([]uintptr)\n+}\n+\n+// IsUintptr gets whether the object contained is a uintptr or not.\n+func (v *Value) IsUintptr() bool {\n+\t_, ok := v.data.(uintptr)\n+\treturn ok\n+}\n+\n+// IsUintptrSlice gets whether the object contained is a []uintptr or not.\n+func (v *Value) IsUintptrSlice() bool {\n+\t_, ok := v.data.([]uintptr)\n+\treturn ok\n+}\n+\n+// EachUintptr calls the specified callback for each object\n+// in the []uintptr.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachUintptr(callback func(int, uintptr) bool) *Value {\n+\tfor index, val := range v.MustUintptrSlice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereUintptr uses the specified decider function to select items\n+// from the []uintptr.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereUintptr(decider func(int, uintptr) bool) *Value {\n+\tvar selected []uintptr\n+\tv.EachUintptr(func(index int, val uintptr) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupUintptr uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]uintptr.\n+func (v *Value) GroupUintptr(grouper func(int, uintptr) string) *Value {\n+\tgroups := make(map[string][]uintptr)\n+\tv.EachUintptr(func(index int, val uintptr) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]uintptr, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceUintptr uses the specified function to replace each uintptrs\n+// by iterating each item.  The data in the returned result will be a\n+// []uintptr containing the replaced items.\n+func (v *Value) ReplaceUintptr(replacer func(int, uintptr) uintptr) *Value {\n+\tarr := v.MustUintptrSlice()\n+\treplaced := make([]uintptr, len(arr))\n+\tv.EachUintptr(func(index int, val uintptr) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectUintptr uses the specified collector function to collect a value\n+// for each of the uintptrs in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectUintptr(collector func(int, uintptr) interface{}) *Value {\n+\tarr := v.MustUintptrSlice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachUintptr(func(index int, val uintptr) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tFloat32 (float32 and []float32)\n+*/\n+\n+// Float32 gets the value as a float32, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Float32(optionalDefault ...float32) float32 {\n+\tif s, ok := v.data.(float32); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustFloat32 gets the value as a float32.\n+//\n+// Panics if the object is not a float32.\n+func (v *Value) MustFloat32() float32 {\n+\treturn v.data.(float32)\n+}\n+\n+// Float32Slice gets the value as a []float32, returns the optionalDefault\n+// value or nil if the value is not a []float32.\n+func (v *Value) Float32Slice(optionalDefault ...[]float32) []float32 {\n+\tif s, ok := v.data.([]float32); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustFloat32Slice gets the value as a []float32.\n+//\n+// Panics if the object is not a []float32.\n+func (v *Value) MustFloat32Slice() []float32 {\n+\treturn v.data.([]float32)\n+}\n+\n+// IsFloat32 gets whether the object contained is a float32 or not.\n+func (v *Value) IsFloat32() bool {\n+\t_, ok := v.data.(float32)\n+\treturn ok\n+}\n+\n+// IsFloat32Slice gets whether the object contained is a []float32 or not.\n+func (v *Value) IsFloat32Slice() bool {\n+\t_, ok := v.data.([]float32)\n+\treturn ok\n+}\n+\n+// EachFloat32 calls the specified callback for each object\n+// in the []float32.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachFloat32(callback func(int, float32) bool) *Value {\n+\tfor index, val := range v.MustFloat32Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereFloat32 uses the specified decider function to select items\n+// from the []float32.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereFloat32(decider func(int, float32) bool) *Value {\n+\tvar selected []float32\n+\tv.EachFloat32(func(index int, val float32) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupFloat32 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]float32.\n+func (v *Value) GroupFloat32(grouper func(int, float32) string) *Value {\n+\tgroups := make(map[string][]float32)\n+\tv.EachFloat32(func(index int, val float32) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]float32, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceFloat32 uses the specified function to replace each float32s\n+// by iterating each item.  The data in the returned result will be a\n+// []float32 containing the replaced items.\n+func (v *Value) ReplaceFloat32(replacer func(int, float32) float32) *Value {\n+\tarr := v.MustFloat32Slice()\n+\treplaced := make([]float32, len(arr))\n+\tv.EachFloat32(func(index int, val float32) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectFloat32 uses the specified collector function to collect a value\n+// for each of the float32s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectFloat32(collector func(int, float32) interface{}) *Value {\n+\tarr := v.MustFloat32Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachFloat32(func(index int, val float32) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tFloat64 (float64 and []float64)\n+*/\n+\n+// Float64 gets the value as a float64, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Float64(optionalDefault ...float64) float64 {\n+\tif s, ok := v.data.(float64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustFloat64 gets the value as a float64.\n+//\n+// Panics if the object is not a float64.\n+func (v *Value) MustFloat64() float64 {\n+\treturn v.data.(float64)\n+}\n+\n+// Float64Slice gets the value as a []float64, returns the optionalDefault\n+// value or nil if the value is not a []float64.\n+func (v *Value) Float64Slice(optionalDefault ...[]float64) []float64 {\n+\tif s, ok := v.data.([]float64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustFloat64Slice gets the value as a []float64.\n+//\n+// Panics if the object is not a []float64.\n+func (v *Value) MustFloat64Slice() []float64 {\n+\treturn v.data.([]float64)\n+}\n+\n+// IsFloat64 gets whether the object contained is a float64 or not.\n+func (v *Value) IsFloat64() bool {\n+\t_, ok := v.data.(float64)\n+\treturn ok\n+}\n+\n+// IsFloat64Slice gets whether the object contained is a []float64 or not.\n+func (v *Value) IsFloat64Slice() bool {\n+\t_, ok := v.data.([]float64)\n+\treturn ok\n+}\n+\n+// EachFloat64 calls the specified callback for each object\n+// in the []float64.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachFloat64(callback func(int, float64) bool) *Value {\n+\tfor index, val := range v.MustFloat64Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereFloat64 uses the specified decider function to select items\n+// from the []float64.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereFloat64(decider func(int, float64) bool) *Value {\n+\tvar selected []float64\n+\tv.EachFloat64(func(index int, val float64) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupFloat64 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]float64.\n+func (v *Value) GroupFloat64(grouper func(int, float64) string) *Value {\n+\tgroups := make(map[string][]float64)\n+\tv.EachFloat64(func(index int, val float64) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]float64, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceFloat64 uses the specified function to replace each float64s\n+// by iterating each item.  The data in the returned result will be a\n+// []float64 containing the replaced items.\n+func (v *Value) ReplaceFloat64(replacer func(int, float64) float64) *Value {\n+\tarr := v.MustFloat64Slice()\n+\treplaced := make([]float64, len(arr))\n+\tv.EachFloat64(func(index int, val float64) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectFloat64 uses the specified collector function to collect a value\n+// for each of the float64s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectFloat64(collector func(int, float64) interface{}) *Value {\n+\tarr := v.MustFloat64Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachFloat64(func(index int, val float64) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tComplex64 (complex64 and []complex64)\n+*/\n+\n+// Complex64 gets the value as a complex64, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Complex64(optionalDefault ...complex64) complex64 {\n+\tif s, ok := v.data.(complex64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustComplex64 gets the value as a complex64.\n+//\n+// Panics if the object is not a complex64.\n+func (v *Value) MustComplex64() complex64 {\n+\treturn v.data.(complex64)\n+}\n+\n+// Complex64Slice gets the value as a []complex64, returns the optionalDefault\n+// value or nil if the value is not a []complex64.\n+func (v *Value) Complex64Slice(optionalDefault ...[]complex64) []complex64 {\n+\tif s, ok := v.data.([]complex64); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustComplex64Slice gets the value as a []complex64.\n+//\n+// Panics if the object is not a []complex64.\n+func (v *Value) MustComplex64Slice() []complex64 {\n+\treturn v.data.([]complex64)\n+}\n+\n+// IsComplex64 gets whether the object contained is a complex64 or not.\n+func (v *Value) IsComplex64() bool {\n+\t_, ok := v.data.(complex64)\n+\treturn ok\n+}\n+\n+// IsComplex64Slice gets whether the object contained is a []complex64 or not.\n+func (v *Value) IsComplex64Slice() bool {\n+\t_, ok := v.data.([]complex64)\n+\treturn ok\n+}\n+\n+// EachComplex64 calls the specified callback for each object\n+// in the []complex64.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachComplex64(callback func(int, complex64) bool) *Value {\n+\tfor index, val := range v.MustComplex64Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereComplex64 uses the specified decider function to select items\n+// from the []complex64.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereComplex64(decider func(int, complex64) bool) *Value {\n+\tvar selected []complex64\n+\tv.EachComplex64(func(index int, val complex64) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupComplex64 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]complex64.\n+func (v *Value) GroupComplex64(grouper func(int, complex64) string) *Value {\n+\tgroups := make(map[string][]complex64)\n+\tv.EachComplex64(func(index int, val complex64) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]complex64, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceComplex64 uses the specified function to replace each complex64s\n+// by iterating each item.  The data in the returned result will be a\n+// []complex64 containing the replaced items.\n+func (v *Value) ReplaceComplex64(replacer func(int, complex64) complex64) *Value {\n+\tarr := v.MustComplex64Slice()\n+\treplaced := make([]complex64, len(arr))\n+\tv.EachComplex64(func(index int, val complex64) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectComplex64 uses the specified collector function to collect a value\n+// for each of the complex64s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectComplex64(collector func(int, complex64) interface{}) *Value {\n+\tarr := v.MustComplex64Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachComplex64(func(index int, val complex64) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}\n+\n+/*\n+\tComplex128 (complex128 and []complex128)\n+*/\n+\n+// Complex128 gets the value as a complex128, returns the optionalDefault\n+// value or a system default object if the value is the wrong type.\n+func (v *Value) Complex128(optionalDefault ...complex128) complex128 {\n+\tif s, ok := v.data.(complex128); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn 0\n+}\n+\n+// MustComplex128 gets the value as a complex128.\n+//\n+// Panics if the object is not a complex128.\n+func (v *Value) MustComplex128() complex128 {\n+\treturn v.data.(complex128)\n+}\n+\n+// Complex128Slice gets the value as a []complex128, returns the optionalDefault\n+// value or nil if the value is not a []complex128.\n+func (v *Value) Complex128Slice(optionalDefault ...[]complex128) []complex128 {\n+\tif s, ok := v.data.([]complex128); ok {\n+\t\treturn s\n+\t}\n+\tif len(optionalDefault) == 1 {\n+\t\treturn optionalDefault[0]\n+\t}\n+\treturn nil\n+}\n+\n+// MustComplex128Slice gets the value as a []complex128.\n+//\n+// Panics if the object is not a []complex128.\n+func (v *Value) MustComplex128Slice() []complex128 {\n+\treturn v.data.([]complex128)\n+}\n+\n+// IsComplex128 gets whether the object contained is a complex128 or not.\n+func (v *Value) IsComplex128() bool {\n+\t_, ok := v.data.(complex128)\n+\treturn ok\n+}\n+\n+// IsComplex128Slice gets whether the object contained is a []complex128 or not.\n+func (v *Value) IsComplex128Slice() bool {\n+\t_, ok := v.data.([]complex128)\n+\treturn ok\n+}\n+\n+// EachComplex128 calls the specified callback for each object\n+// in the []complex128.\n+//\n+// Panics if the object is the wrong type.\n+func (v *Value) EachComplex128(callback func(int, complex128) bool) *Value {\n+\tfor index, val := range v.MustComplex128Slice() {\n+\t\tcarryon := callback(index, val)\n+\t\tif !carryon {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn v\n+}\n+\n+// WhereComplex128 uses the specified decider function to select items\n+// from the []complex128.  The object contained in the result will contain\n+// only the selected items.\n+func (v *Value) WhereComplex128(decider func(int, complex128) bool) *Value {\n+\tvar selected []complex128\n+\tv.EachComplex128(func(index int, val complex128) bool {\n+\t\tshouldSelect := decider(index, val)\n+\t\tif !shouldSelect {\n+\t\t\tselected = append(selected, val)\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn &Value{data: selected}\n+}\n+\n+// GroupComplex128 uses the specified grouper function to group the items\n+// keyed by the return of the grouper.  The object contained in the\n+// result will contain a map[string][]complex128.\n+func (v *Value) GroupComplex128(grouper func(int, complex128) string) *Value {\n+\tgroups := make(map[string][]complex128)\n+\tv.EachComplex128(func(index int, val complex128) bool {\n+\t\tgroup := grouper(index, val)\n+\t\tif _, ok := groups[group]; !ok {\n+\t\t\tgroups[group] = make([]complex128, 0)\n+\t\t}\n+\t\tgroups[group] = append(groups[group], val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: groups}\n+}\n+\n+// ReplaceComplex128 uses the specified function to replace each complex128s\n+// by iterating each item.  The data in the returned result will be a\n+// []complex128 containing the replaced items.\n+func (v *Value) ReplaceComplex128(replacer func(int, complex128) complex128) *Value {\n+\tarr := v.MustComplex128Slice()\n+\treplaced := make([]complex128, len(arr))\n+\tv.EachComplex128(func(index int, val complex128) bool {\n+\t\treplaced[index] = replacer(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: replaced}\n+}\n+\n+// CollectComplex128 uses the specified collector function to collect a value\n+// for each of the complex128s in the slice.  The data returned will be a\n+// []interface{}.\n+func (v *Value) CollectComplex128(collector func(int, complex128) interface{}) *Value {\n+\tarr := v.MustComplex128Slice()\n+\tcollected := make([]interface{}, len(arr))\n+\tv.EachComplex128(func(index int, val complex128) bool {\n+\t\tcollected[index] = collector(index, val)\n+\t\treturn true\n+\t})\n+\treturn &Value{data: collected}\n+}"
    },
    {
      "sha": "e4b4a14335d741c33843c698bb47bd15d3cedd84",
      "filename": "backend/vendor/github.com/stretchr/objx/value.go",
      "status": "added",
      "additions": 53,
      "deletions": 0,
      "changes": 53,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/value.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/objx/value.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/objx/value.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,53 @@\n+package objx\n+\n+import (\n+\t\"fmt\"\n+\t\"strconv\"\n+)\n+\n+// Value provides methods for extracting interface{} data in various\n+// types.\n+type Value struct {\n+\t// data contains the raw data being managed by this Value\n+\tdata interface{}\n+}\n+\n+// Data returns the raw data contained by this Value\n+func (v *Value) Data() interface{} {\n+\treturn v.data\n+}\n+\n+// String returns the value always as a string\n+func (v *Value) String() string {\n+\tswitch {\n+\tcase v.IsStr():\n+\t\treturn v.Str()\n+\tcase v.IsBool():\n+\t\treturn strconv.FormatBool(v.Bool())\n+\tcase v.IsFloat32():\n+\t\treturn strconv.FormatFloat(float64(v.Float32()), 'f', -1, 32)\n+\tcase v.IsFloat64():\n+\t\treturn strconv.FormatFloat(v.Float64(), 'f', -1, 64)\n+\tcase v.IsInt():\n+\t\treturn strconv.FormatInt(int64(v.Int()), 10)\n+\tcase v.IsInt8():\n+\t\treturn strconv.FormatInt(int64(v.Int8()), 10)\n+\tcase v.IsInt16():\n+\t\treturn strconv.FormatInt(int64(v.Int16()), 10)\n+\tcase v.IsInt32():\n+\t\treturn strconv.FormatInt(int64(v.Int32()), 10)\n+\tcase v.IsInt64():\n+\t\treturn strconv.FormatInt(v.Int64(), 10)\n+\tcase v.IsUint():\n+\t\treturn strconv.FormatUint(uint64(v.Uint()), 10)\n+\tcase v.IsUint8():\n+\t\treturn strconv.FormatUint(uint64(v.Uint8()), 10)\n+\tcase v.IsUint16():\n+\t\treturn strconv.FormatUint(uint64(v.Uint16()), 10)\n+\tcase v.IsUint32():\n+\t\treturn strconv.FormatUint(uint64(v.Uint32()), 10)\n+\tcase v.IsUint64():\n+\t\treturn strconv.FormatUint(v.Uint64(), 10)\n+\t}\n+\treturn fmt.Sprintf(\"%#v\", v.Data())\n+}"
    },
    {
      "sha": "7324128ef19c51d1cc74cd2cae8c886b2a71e7df",
      "filename": "backend/vendor/github.com/stretchr/testify/mock/doc.go",
      "status": "added",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/testify/mock/doc.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/testify/mock/doc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/mock/doc.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,44 @@\n+// Package mock provides a system by which it is possible to mock your objects\n+// and verify calls are happening as expected.\n+//\n+// Example Usage\n+//\n+// The mock package provides an object, Mock, that tracks activity on another object.  It is usually\n+// embedded into a test object as shown below:\n+//\n+//   type MyTestObject struct {\n+//     // add a Mock object instance\n+//     mock.Mock\n+//\n+//     // other fields go here as normal\n+//   }\n+//\n+// When implementing the methods of an interface, you wire your functions up\n+// to call the Mock.Called(args...) method, and return the appropriate values.\n+//\n+// For example, to mock a method that saves the name and age of a person and returns\n+// the year of their birth or an error, you might write this:\n+//\n+//     func (o *MyTestObject) SavePersonDetails(firstname, lastname string, age int) (int, error) {\n+//       args := o.Called(firstname, lastname, age)\n+//       return args.Int(0), args.Error(1)\n+//     }\n+//\n+// The Int, Error and Bool methods are examples of strongly typed getters that take the argument\n+// index position. Given this argument list:\n+//\n+//     (12, true, \"Something\")\n+//\n+// You could read them out strongly typed like this:\n+//\n+//     args.Int(0)\n+//     args.Bool(1)\n+//     args.String(2)\n+//\n+// For objects of your own type, use the generic Arguments.Get(index) method and make a type assertion:\n+//\n+//     return args.Get(0).(*MyObject), args.Get(1).(*AnotherObjectOfMine)\n+//\n+// This may cause a panic if the object you are getting is nil (the type assertion will fail), in those\n+// cases you should check for nil first.\n+package mock"
    },
    {
      "sha": "d6694ed78a1010668ddeb58c51f61a2c7edbc065",
      "filename": "backend/vendor/github.com/stretchr/testify/mock/mock.go",
      "status": "added",
      "additions": 886,
      "deletions": 0,
      "changes": 886,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/testify/mock/mock.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/github.com/stretchr/testify/mock/mock.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/mock/mock.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,886 @@\n+package mock\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/davecgh/go-spew/spew\"\n+\t\"github.com/pmezard/go-difflib/difflib\"\n+\t\"github.com/stretchr/objx\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+// TestingT is an interface wrapper around *testing.T\n+type TestingT interface {\n+\tLogf(format string, args ...interface{})\n+\tErrorf(format string, args ...interface{})\n+\tFailNow()\n+}\n+\n+/*\n+\tCall\n+*/\n+\n+// Call represents a method call and is used for setting expectations,\n+// as well as recording activity.\n+type Call struct {\n+\tParent *Mock\n+\n+\t// The name of the method that was or will be called.\n+\tMethod string\n+\n+\t// Holds the arguments of the method.\n+\tArguments Arguments\n+\n+\t// Holds the arguments that should be returned when\n+\t// this method is called.\n+\tReturnArguments Arguments\n+\n+\t// Holds the caller info for the On() call\n+\tcallerInfo []string\n+\n+\t// The number of times to return the return arguments when setting\n+\t// expectations. 0 means to always return the value.\n+\tRepeatability int\n+\n+\t// Amount of times this call has been called\n+\ttotalCalls int\n+\n+\t// Call to this method can be optional\n+\toptional bool\n+\n+\t// Holds a channel that will be used to block the Return until it either\n+\t// receives a message or is closed. nil means it returns immediately.\n+\tWaitFor <-chan time.Time\n+\n+\twaitTime time.Duration\n+\n+\t// Holds a handler used to manipulate arguments content that are passed by\n+\t// reference. It's useful when mocking methods such as unmarshalers or\n+\t// decoders.\n+\tRunFn func(Arguments)\n+}\n+\n+func newCall(parent *Mock, methodName string, callerInfo []string, methodArguments ...interface{}) *Call {\n+\treturn &Call{\n+\t\tParent:          parent,\n+\t\tMethod:          methodName,\n+\t\tArguments:       methodArguments,\n+\t\tReturnArguments: make([]interface{}, 0),\n+\t\tcallerInfo:      callerInfo,\n+\t\tRepeatability:   0,\n+\t\tWaitFor:         nil,\n+\t\tRunFn:           nil,\n+\t}\n+}\n+\n+func (c *Call) lock() {\n+\tc.Parent.mutex.Lock()\n+}\n+\n+func (c *Call) unlock() {\n+\tc.Parent.mutex.Unlock()\n+}\n+\n+// Return specifies the return arguments for the expectation.\n+//\n+//    Mock.On(\"DoSomething\").Return(errors.New(\"failed\"))\n+func (c *Call) Return(returnArguments ...interface{}) *Call {\n+\tc.lock()\n+\tdefer c.unlock()\n+\n+\tc.ReturnArguments = returnArguments\n+\n+\treturn c\n+}\n+\n+// Once indicates that that the mock should only return the value once.\n+//\n+//    Mock.On(\"MyMethod\", arg1, arg2).Return(returnArg1, returnArg2).Once()\n+func (c *Call) Once() *Call {\n+\treturn c.Times(1)\n+}\n+\n+// Twice indicates that that the mock should only return the value twice.\n+//\n+//    Mock.On(\"MyMethod\", arg1, arg2).Return(returnArg1, returnArg2).Twice()\n+func (c *Call) Twice() *Call {\n+\treturn c.Times(2)\n+}\n+\n+// Times indicates that that the mock should only return the indicated number\n+// of times.\n+//\n+//    Mock.On(\"MyMethod\", arg1, arg2).Return(returnArg1, returnArg2).Times(5)\n+func (c *Call) Times(i int) *Call {\n+\tc.lock()\n+\tdefer c.unlock()\n+\tc.Repeatability = i\n+\treturn c\n+}\n+\n+// WaitUntil sets the channel that will block the mock's return until its closed\n+// or a message is received.\n+//\n+//    Mock.On(\"MyMethod\", arg1, arg2).WaitUntil(time.After(time.Second))\n+func (c *Call) WaitUntil(w <-chan time.Time) *Call {\n+\tc.lock()\n+\tdefer c.unlock()\n+\tc.WaitFor = w\n+\treturn c\n+}\n+\n+// After sets how long to block until the call returns\n+//\n+//    Mock.On(\"MyMethod\", arg1, arg2).After(time.Second)\n+func (c *Call) After(d time.Duration) *Call {\n+\tc.lock()\n+\tdefer c.unlock()\n+\tc.waitTime = d\n+\treturn c\n+}\n+\n+// Run sets a handler to be called before returning. It can be used when\n+// mocking a method such as unmarshalers that takes a pointer to a struct and\n+// sets properties in such struct\n+//\n+//    Mock.On(\"Unmarshal\", AnythingOfType(\"*map[string]interface{}\").Return().Run(func(args Arguments) {\n+//    \targ := args.Get(0).(*map[string]interface{})\n+//    \targ[\"foo\"] = \"bar\"\n+//    })\n+func (c *Call) Run(fn func(args Arguments)) *Call {\n+\tc.lock()\n+\tdefer c.unlock()\n+\tc.RunFn = fn\n+\treturn c\n+}\n+\n+// Maybe allows the method call to be optional. Not calling an optional method\n+// will not cause an error while asserting expectations\n+func (c *Call) Maybe() *Call {\n+\tc.lock()\n+\tdefer c.unlock()\n+\tc.optional = true\n+\treturn c\n+}\n+\n+// On chains a new expectation description onto the mocked interface. This\n+// allows syntax like.\n+//\n+//    Mock.\n+//       On(\"MyMethod\", 1).Return(nil).\n+//       On(\"MyOtherMethod\", 'a', 'b', 'c').Return(errors.New(\"Some Error\"))\n+//go:noinline\n+func (c *Call) On(methodName string, arguments ...interface{}) *Call {\n+\treturn c.Parent.On(methodName, arguments...)\n+}\n+\n+// Mock is the workhorse used to track activity on another object.\n+// For an example of its usage, refer to the \"Example Usage\" section at the top\n+// of this document.\n+type Mock struct {\n+\t// Represents the calls that are expected of\n+\t// an object.\n+\tExpectedCalls []*Call\n+\n+\t// Holds the calls that were made to this mocked object.\n+\tCalls []Call\n+\n+\t// test is An optional variable that holds the test struct, to be used when an\n+\t// invalid mock call was made.\n+\ttest TestingT\n+\n+\t// TestData holds any data that might be useful for testing.  Testify ignores\n+\t// this data completely allowing you to do whatever you like with it.\n+\ttestData objx.Map\n+\n+\tmutex sync.Mutex\n+}\n+\n+// TestData holds any data that might be useful for testing.  Testify ignores\n+// this data completely allowing you to do whatever you like with it.\n+func (m *Mock) TestData() objx.Map {\n+\n+\tif m.testData == nil {\n+\t\tm.testData = make(objx.Map)\n+\t}\n+\n+\treturn m.testData\n+}\n+\n+/*\n+\tSetting expectations\n+*/\n+\n+// Test sets the test struct variable of the mock object\n+func (m *Mock) Test(t TestingT) {\n+\tm.mutex.Lock()\n+\tdefer m.mutex.Unlock()\n+\tm.test = t\n+}\n+\n+// fail fails the current test with the given formatted format and args.\n+// In case that a test was defined, it uses the test APIs for failing a test,\n+// otherwise it uses panic.\n+func (m *Mock) fail(format string, args ...interface{}) {\n+\tm.mutex.Lock()\n+\tdefer m.mutex.Unlock()\n+\n+\tif m.test == nil {\n+\t\tpanic(fmt.Sprintf(format, args...))\n+\t}\n+\tm.test.Errorf(format, args...)\n+\tm.test.FailNow()\n+}\n+\n+// On starts a description of an expectation of the specified method\n+// being called.\n+//\n+//     Mock.On(\"MyMethod\", arg1, arg2)\n+func (m *Mock) On(methodName string, arguments ...interface{}) *Call {\n+\tfor _, arg := range arguments {\n+\t\tif v := reflect.ValueOf(arg); v.Kind() == reflect.Func {\n+\t\t\tpanic(fmt.Sprintf(\"cannot use Func in expectations. Use mock.AnythingOfType(\\\"%T\\\")\", arg))\n+\t\t}\n+\t}\n+\n+\tm.mutex.Lock()\n+\tdefer m.mutex.Unlock()\n+\tc := newCall(m, methodName, assert.CallerInfo(), arguments...)\n+\tm.ExpectedCalls = append(m.ExpectedCalls, c)\n+\treturn c\n+}\n+\n+// /*\n+// \tRecording and responding to activity\n+// */\n+\n+func (m *Mock) findExpectedCall(method string, arguments ...interface{}) (int, *Call) {\n+\tfor i, call := range m.ExpectedCalls {\n+\t\tif call.Method == method && call.Repeatability > -1 {\n+\n+\t\t\t_, diffCount := call.Arguments.Diff(arguments)\n+\t\t\tif diffCount == 0 {\n+\t\t\t\treturn i, call\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\treturn -1, nil\n+}\n+\n+func (m *Mock) findClosestCall(method string, arguments ...interface{}) (*Call, string) {\n+\tvar diffCount int\n+\tvar closestCall *Call\n+\tvar err string\n+\n+\tfor _, call := range m.expectedCalls() {\n+\t\tif call.Method == method {\n+\n+\t\t\terrInfo, tempDiffCount := call.Arguments.Diff(arguments)\n+\t\t\tif tempDiffCount < diffCount || diffCount == 0 {\n+\t\t\t\tdiffCount = tempDiffCount\n+\t\t\t\tclosestCall = call\n+\t\t\t\terr = errInfo\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\n+\treturn closestCall, err\n+}\n+\n+func callString(method string, arguments Arguments, includeArgumentValues bool) string {\n+\n+\tvar argValsString string\n+\tif includeArgumentValues {\n+\t\tvar argVals []string\n+\t\tfor argIndex, arg := range arguments {\n+\t\t\targVals = append(argVals, fmt.Sprintf(\"%d: %#v\", argIndex, arg))\n+\t\t}\n+\t\targValsString = fmt.Sprintf(\"\\n\\t\\t%s\", strings.Join(argVals, \"\\n\\t\\t\"))\n+\t}\n+\n+\treturn fmt.Sprintf(\"%s(%s)%s\", method, arguments.String(), argValsString)\n+}\n+\n+// Called tells the mock object that a method has been called, and gets an array\n+// of arguments to return.  Panics if the call is unexpected (i.e. not preceded by\n+// appropriate .On .Return() calls)\n+// If Call.WaitFor is set, blocks until the channel is closed or receives a message.\n+func (m *Mock) Called(arguments ...interface{}) Arguments {\n+\t// get the calling function's name\n+\tpc, _, _, ok := runtime.Caller(1)\n+\tif !ok {\n+\t\tpanic(\"Couldn't get the caller information\")\n+\t}\n+\tfunctionPath := runtime.FuncForPC(pc).Name()\n+\t//Next four lines are required to use GCCGO function naming conventions.\n+\t//For Ex:  github_com_docker_libkv_store_mock.WatchTree.pN39_github_com_docker_libkv_store_mock.Mock\n+\t//uses interface information unlike golang github.com/docker/libkv/store/mock.(*Mock).WatchTree\n+\t//With GCCGO we need to remove interface information starting from pN<dd>.\n+\tre := regexp.MustCompile(\"\\\\.pN\\\\d+_\")\n+\tif re.MatchString(functionPath) {\n+\t\tfunctionPath = re.Split(functionPath, -1)[0]\n+\t}\n+\tparts := strings.Split(functionPath, \".\")\n+\tfunctionName := parts[len(parts)-1]\n+\treturn m.MethodCalled(functionName, arguments...)\n+}\n+\n+// MethodCalled tells the mock object that the given method has been called, and gets\n+// an array of arguments to return. Panics if the call is unexpected (i.e. not preceded\n+// by appropriate .On .Return() calls)\n+// If Call.WaitFor is set, blocks until the channel is closed or receives a message.\n+func (m *Mock) MethodCalled(methodName string, arguments ...interface{}) Arguments {\n+\tm.mutex.Lock()\n+\t//TODO: could combine expected and closes in single loop\n+\tfound, call := m.findExpectedCall(methodName, arguments...)\n+\n+\tif found < 0 {\n+\t\t// we have to fail here - because we don't know what to do\n+\t\t// as the return arguments.  This is because:\n+\t\t//\n+\t\t//   a) this is a totally unexpected call to this method,\n+\t\t//   b) the arguments are not what was expected, or\n+\t\t//   c) the developer has forgotten to add an accompanying On...Return pair.\n+\n+\t\tclosestCall, mismatch := m.findClosestCall(methodName, arguments...)\n+\t\tm.mutex.Unlock()\n+\n+\t\tif closestCall != nil {\n+\t\t\tm.fail(\"\\n\\nmock: Unexpected Method Call\\n-----------------------------\\n\\n%s\\n\\nThe closest call I have is: \\n\\n%s\\n\\n%s\\nDiff: %s\",\n+\t\t\t\tcallString(methodName, arguments, true),\n+\t\t\t\tcallString(methodName, closestCall.Arguments, true),\n+\t\t\t\tdiffArguments(closestCall.Arguments, arguments),\n+\t\t\t\tstrings.TrimSpace(mismatch),\n+\t\t\t)\n+\t\t} else {\n+\t\t\tm.fail(\"\\nassert: mock: I don't know what to return because the method call was unexpected.\\n\\tEither do Mock.On(\\\"%s\\\").Return(...) first, or remove the %s() call.\\n\\tThis method was unexpected:\\n\\t\\t%s\\n\\tat: %s\", methodName, methodName, callString(methodName, arguments, true), assert.CallerInfo())\n+\t\t}\n+\t}\n+\n+\tif call.Repeatability == 1 {\n+\t\tcall.Repeatability = -1\n+\t} else if call.Repeatability > 1 {\n+\t\tcall.Repeatability--\n+\t}\n+\tcall.totalCalls++\n+\n+\t// add the call\n+\tm.Calls = append(m.Calls, *newCall(m, methodName, assert.CallerInfo(), arguments...))\n+\tm.mutex.Unlock()\n+\n+\t// block if specified\n+\tif call.WaitFor != nil {\n+\t\t<-call.WaitFor\n+\t} else {\n+\t\ttime.Sleep(call.waitTime)\n+\t}\n+\n+\tm.mutex.Lock()\n+\trunFn := call.RunFn\n+\tm.mutex.Unlock()\n+\n+\tif runFn != nil {\n+\t\trunFn(arguments)\n+\t}\n+\n+\tm.mutex.Lock()\n+\treturnArgs := call.ReturnArguments\n+\tm.mutex.Unlock()\n+\n+\treturn returnArgs\n+}\n+\n+/*\n+\tAssertions\n+*/\n+\n+type assertExpectationser interface {\n+\tAssertExpectations(TestingT) bool\n+}\n+\n+// AssertExpectationsForObjects asserts that everything specified with On and Return\n+// of the specified objects was in fact called as expected.\n+//\n+// Calls may have occurred in any order.\n+func AssertExpectationsForObjects(t TestingT, testObjects ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tfor _, obj := range testObjects {\n+\t\tif m, ok := obj.(Mock); ok {\n+\t\t\tt.Logf(\"Deprecated mock.AssertExpectationsForObjects(myMock.Mock) use mock.AssertExpectationsForObjects(myMock)\")\n+\t\t\tobj = &m\n+\t\t}\n+\t\tm := obj.(assertExpectationser)\n+\t\tif !m.AssertExpectations(t) {\n+\t\t\tt.Logf(\"Expectations didn't match for Mock: %+v\", reflect.TypeOf(m))\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// AssertExpectations asserts that everything specified with On and Return was\n+// in fact called as expected.  Calls may have occurred in any order.\n+func (m *Mock) AssertExpectations(t TestingT) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tm.mutex.Lock()\n+\tdefer m.mutex.Unlock()\n+\tvar somethingMissing bool\n+\tvar failedExpectations int\n+\n+\t// iterate through each expectation\n+\texpectedCalls := m.expectedCalls()\n+\tfor _, expectedCall := range expectedCalls {\n+\t\tif !expectedCall.optional && !m.methodWasCalled(expectedCall.Method, expectedCall.Arguments) && expectedCall.totalCalls == 0 {\n+\t\t\tsomethingMissing = true\n+\t\t\tfailedExpectations++\n+\t\t\tt.Logf(\"FAIL:\\t%s(%s)\\n\\t\\tat: %s\", expectedCall.Method, expectedCall.Arguments.String(), expectedCall.callerInfo)\n+\t\t} else {\n+\t\t\tif expectedCall.Repeatability > 0 {\n+\t\t\t\tsomethingMissing = true\n+\t\t\t\tfailedExpectations++\n+\t\t\t\tt.Logf(\"FAIL:\\t%s(%s)\\n\\t\\tat: %s\", expectedCall.Method, expectedCall.Arguments.String(), expectedCall.callerInfo)\n+\t\t\t} else {\n+\t\t\t\tt.Logf(\"PASS:\\t%s(%s)\", expectedCall.Method, expectedCall.Arguments.String())\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif somethingMissing {\n+\t\tt.Errorf(\"FAIL: %d out of %d expectation(s) were met.\\n\\tThe code you are testing needs to make %d more call(s).\\n\\tat: %s\", len(expectedCalls)-failedExpectations, len(expectedCalls), failedExpectations, assert.CallerInfo())\n+\t}\n+\n+\treturn !somethingMissing\n+}\n+\n+// AssertNumberOfCalls asserts that the method was called expectedCalls times.\n+func (m *Mock) AssertNumberOfCalls(t TestingT, methodName string, expectedCalls int) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tm.mutex.Lock()\n+\tdefer m.mutex.Unlock()\n+\tvar actualCalls int\n+\tfor _, call := range m.calls() {\n+\t\tif call.Method == methodName {\n+\t\t\tactualCalls++\n+\t\t}\n+\t}\n+\treturn assert.Equal(t, expectedCalls, actualCalls, fmt.Sprintf(\"Expected number of calls (%d) does not match the actual number of calls (%d).\", expectedCalls, actualCalls))\n+}\n+\n+// AssertCalled asserts that the method was called.\n+// It can produce a false result when an argument is a pointer type and the underlying value changed after calling the mocked method.\n+func (m *Mock) AssertCalled(t TestingT, methodName string, arguments ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tm.mutex.Lock()\n+\tdefer m.mutex.Unlock()\n+\tif !m.methodWasCalled(methodName, arguments) {\n+\t\tvar calledWithArgs []string\n+\t\tfor _, call := range m.calls() {\n+\t\t\tcalledWithArgs = append(calledWithArgs, fmt.Sprintf(\"%v\", call.Arguments))\n+\t\t}\n+\t\tif len(calledWithArgs) == 0 {\n+\t\t\treturn assert.Fail(t, \"Should have called with given arguments\",\n+\t\t\t\tfmt.Sprintf(\"Expected %q to have been called with:\\n%v\\nbut no actual calls happened\", methodName, arguments))\n+\t\t}\n+\t\treturn assert.Fail(t, \"Should have called with given arguments\",\n+\t\t\tfmt.Sprintf(\"Expected %q to have been called with:\\n%v\\nbut actual calls were:\\n        %v\", methodName, arguments, strings.Join(calledWithArgs, \"\\n\")))\n+\t}\n+\treturn true\n+}\n+\n+// AssertNotCalled asserts that the method was not called.\n+// It can produce a false result when an argument is a pointer type and the underlying value changed after calling the mocked method.\n+func (m *Mock) AssertNotCalled(t TestingT, methodName string, arguments ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tm.mutex.Lock()\n+\tdefer m.mutex.Unlock()\n+\tif m.methodWasCalled(methodName, arguments) {\n+\t\treturn assert.Fail(t, \"Should not have called with given arguments\",\n+\t\t\tfmt.Sprintf(\"Expected %q to not have been called with:\\n%v\\nbut actually it was.\", methodName, arguments))\n+\t}\n+\treturn true\n+}\n+\n+func (m *Mock) methodWasCalled(methodName string, expected []interface{}) bool {\n+\tfor _, call := range m.calls() {\n+\t\tif call.Method == methodName {\n+\n+\t\t\t_, differences := Arguments(expected).Diff(call.Arguments)\n+\n+\t\t\tif differences == 0 {\n+\t\t\t\t// found the expected call\n+\t\t\t\treturn true\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\t// we didn't find the expected call\n+\treturn false\n+}\n+\n+func (m *Mock) expectedCalls() []*Call {\n+\treturn append([]*Call{}, m.ExpectedCalls...)\n+}\n+\n+func (m *Mock) calls() []Call {\n+\treturn append([]Call{}, m.Calls...)\n+}\n+\n+/*\n+\tArguments\n+*/\n+\n+// Arguments holds an array of method arguments or return values.\n+type Arguments []interface{}\n+\n+const (\n+\t// Anything is used in Diff and Assert when the argument being tested\n+\t// shouldn't be taken into consideration.\n+\tAnything = \"mock.Anything\"\n+)\n+\n+// AnythingOfTypeArgument is a string that contains the type of an argument\n+// for use when type checking.  Used in Diff and Assert.\n+type AnythingOfTypeArgument string\n+\n+// AnythingOfType returns an AnythingOfTypeArgument object containing the\n+// name of the type to check for.  Used in Diff and Assert.\n+//\n+// For example:\n+//\tAssert(t, AnythingOfType(\"string\"), AnythingOfType(\"int\"))\n+func AnythingOfType(t string) AnythingOfTypeArgument {\n+\treturn AnythingOfTypeArgument(t)\n+}\n+\n+// argumentMatcher performs custom argument matching, returning whether or\n+// not the argument is matched by the expectation fixture function.\n+type argumentMatcher struct {\n+\t// fn is a function which accepts one argument, and returns a bool.\n+\tfn reflect.Value\n+}\n+\n+func (f argumentMatcher) Matches(argument interface{}) bool {\n+\texpectType := f.fn.Type().In(0)\n+\texpectTypeNilSupported := false\n+\tswitch expectType.Kind() {\n+\tcase reflect.Interface, reflect.Chan, reflect.Func, reflect.Map, reflect.Slice, reflect.Ptr:\n+\t\texpectTypeNilSupported = true\n+\t}\n+\n+\targType := reflect.TypeOf(argument)\n+\tvar arg reflect.Value\n+\tif argType == nil {\n+\t\targ = reflect.New(expectType).Elem()\n+\t} else {\n+\t\targ = reflect.ValueOf(argument)\n+\t}\n+\n+\tif argType == nil && !expectTypeNilSupported {\n+\t\tpanic(errors.New(\"attempting to call matcher with nil for non-nil expected type\"))\n+\t}\n+\tif argType == nil || argType.AssignableTo(expectType) {\n+\t\tresult := f.fn.Call([]reflect.Value{arg})\n+\t\treturn result[0].Bool()\n+\t}\n+\treturn false\n+}\n+\n+func (f argumentMatcher) String() string {\n+\treturn fmt.Sprintf(\"func(%s) bool\", f.fn.Type().In(0).Name())\n+}\n+\n+// MatchedBy can be used to match a mock call based on only certain properties\n+// from a complex struct or some calculation. It takes a function that will be\n+// evaluated with the called argument and will return true when there's a match\n+// and false otherwise.\n+//\n+// Example:\n+// m.On(\"Do\", MatchedBy(func(req *http.Request) bool { return req.Host == \"example.com\" }))\n+//\n+// |fn|, must be a function accepting a single argument (of the expected type)\n+// which returns a bool. If |fn| doesn't match the required signature,\n+// MatchedBy() panics.\n+func MatchedBy(fn interface{}) argumentMatcher {\n+\tfnType := reflect.TypeOf(fn)\n+\n+\tif fnType.Kind() != reflect.Func {\n+\t\tpanic(fmt.Sprintf(\"assert: arguments: %s is not a func\", fn))\n+\t}\n+\tif fnType.NumIn() != 1 {\n+\t\tpanic(fmt.Sprintf(\"assert: arguments: %s does not take exactly one argument\", fn))\n+\t}\n+\tif fnType.NumOut() != 1 || fnType.Out(0).Kind() != reflect.Bool {\n+\t\tpanic(fmt.Sprintf(\"assert: arguments: %s does not return a bool\", fn))\n+\t}\n+\n+\treturn argumentMatcher{fn: reflect.ValueOf(fn)}\n+}\n+\n+// Get Returns the argument at the specified index.\n+func (args Arguments) Get(index int) interface{} {\n+\tif index+1 > len(args) {\n+\t\tpanic(fmt.Sprintf(\"assert: arguments: Cannot call Get(%d) because there are %d argument(s).\", index, len(args)))\n+\t}\n+\treturn args[index]\n+}\n+\n+// Is gets whether the objects match the arguments specified.\n+func (args Arguments) Is(objects ...interface{}) bool {\n+\tfor i, obj := range args {\n+\t\tif obj != objects[i] {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// Diff gets a string describing the differences between the arguments\n+// and the specified objects.\n+//\n+// Returns the diff string and number of differences found.\n+func (args Arguments) Diff(objects []interface{}) (string, int) {\n+\t//TODO: could return string as error and nil for No difference\n+\n+\tvar output = \"\\n\"\n+\tvar differences int\n+\n+\tvar maxArgCount = len(args)\n+\tif len(objects) > maxArgCount {\n+\t\tmaxArgCount = len(objects)\n+\t}\n+\n+\tfor i := 0; i < maxArgCount; i++ {\n+\t\tvar actual, expected interface{}\n+\t\tvar actualFmt, expectedFmt string\n+\n+\t\tif len(objects) <= i {\n+\t\t\tactual = \"(Missing)\"\n+\t\t\tactualFmt = \"(Missing)\"\n+\t\t} else {\n+\t\t\tactual = objects[i]\n+\t\t\tactualFmt = fmt.Sprintf(\"(%[1]T=%[1]v)\", actual)\n+\t\t}\n+\n+\t\tif len(args) <= i {\n+\t\t\texpected = \"(Missing)\"\n+\t\t\texpectedFmt = \"(Missing)\"\n+\t\t} else {\n+\t\t\texpected = args[i]\n+\t\t\texpectedFmt = fmt.Sprintf(\"(%[1]T=%[1]v)\", expected)\n+\t\t}\n+\n+\t\tif matcher, ok := expected.(argumentMatcher); ok {\n+\t\t\tif matcher.Matches(actual) {\n+\t\t\t\toutput = fmt.Sprintf(\"%s\\t%d: PASS:  %s matched by %s\\n\", output, i, actualFmt, matcher)\n+\t\t\t} else {\n+\t\t\t\tdifferences++\n+\t\t\t\toutput = fmt.Sprintf(\"%s\\t%d: FAIL:  %s not matched by %s\\n\", output, i, actualFmt, matcher)\n+\t\t\t}\n+\t\t} else if reflect.TypeOf(expected) == reflect.TypeOf((*AnythingOfTypeArgument)(nil)).Elem() {\n+\n+\t\t\t// type checking\n+\t\t\tif reflect.TypeOf(actual).Name() != string(expected.(AnythingOfTypeArgument)) && reflect.TypeOf(actual).String() != string(expected.(AnythingOfTypeArgument)) {\n+\t\t\t\t// not match\n+\t\t\t\tdifferences++\n+\t\t\t\toutput = fmt.Sprintf(\"%s\\t%d: FAIL:  type %s != type %s - %s\\n\", output, i, expected, reflect.TypeOf(actual).Name(), actualFmt)\n+\t\t\t}\n+\n+\t\t} else {\n+\n+\t\t\t// normal checking\n+\n+\t\t\tif assert.ObjectsAreEqual(expected, Anything) || assert.ObjectsAreEqual(actual, Anything) || assert.ObjectsAreEqual(actual, expected) {\n+\t\t\t\t// match\n+\t\t\t\toutput = fmt.Sprintf(\"%s\\t%d: PASS:  %s == %s\\n\", output, i, actualFmt, expectedFmt)\n+\t\t\t} else {\n+\t\t\t\t// not match\n+\t\t\t\tdifferences++\n+\t\t\t\toutput = fmt.Sprintf(\"%s\\t%d: FAIL:  %s != %s\\n\", output, i, actualFmt, expectedFmt)\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n+\tif differences == 0 {\n+\t\treturn \"No differences.\", differences\n+\t}\n+\n+\treturn output, differences\n+\n+}\n+\n+// Assert compares the arguments with the specified objects and fails if\n+// they do not exactly match.\n+func (args Arguments) Assert(t TestingT, objects ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\n+\t// get the differences\n+\tdiff, diffCount := args.Diff(objects)\n+\n+\tif diffCount == 0 {\n+\t\treturn true\n+\t}\n+\n+\t// there are differences... report them...\n+\tt.Logf(diff)\n+\tt.Errorf(\"%sArguments do not match.\", assert.CallerInfo())\n+\n+\treturn false\n+\n+}\n+\n+// String gets the argument at the specified index. Panics if there is no argument, or\n+// if the argument is of the wrong type.\n+//\n+// If no index is provided, String() returns a complete string representation\n+// of the arguments.\n+func (args Arguments) String(indexOrNil ...int) string {\n+\n+\tif len(indexOrNil) == 0 {\n+\t\t// normal String() method - return a string representation of the args\n+\t\tvar argsStr []string\n+\t\tfor _, arg := range args {\n+\t\t\targsStr = append(argsStr, fmt.Sprintf(\"%s\", reflect.TypeOf(arg)))\n+\t\t}\n+\t\treturn strings.Join(argsStr, \",\")\n+\t} else if len(indexOrNil) == 1 {\n+\t\t// Index has been specified - get the argument at that index\n+\t\tvar index = indexOrNil[0]\n+\t\tvar s string\n+\t\tvar ok bool\n+\t\tif s, ok = args.Get(index).(string); !ok {\n+\t\t\tpanic(fmt.Sprintf(\"assert: arguments: String(%d) failed because object wasn't correct type: %s\", index, args.Get(index)))\n+\t\t}\n+\t\treturn s\n+\t}\n+\n+\tpanic(fmt.Sprintf(\"assert: arguments: Wrong number of arguments passed to String.  Must be 0 or 1, not %d\", len(indexOrNil)))\n+\n+}\n+\n+// Int gets the argument at the specified index. Panics if there is no argument, or\n+// if the argument is of the wrong type.\n+func (args Arguments) Int(index int) int {\n+\tvar s int\n+\tvar ok bool\n+\tif s, ok = args.Get(index).(int); !ok {\n+\t\tpanic(fmt.Sprintf(\"assert: arguments: Int(%d) failed because object wasn't correct type: %v\", index, args.Get(index)))\n+\t}\n+\treturn s\n+}\n+\n+// Error gets the argument at the specified index. Panics if there is no argument, or\n+// if the argument is of the wrong type.\n+func (args Arguments) Error(index int) error {\n+\tobj := args.Get(index)\n+\tvar s error\n+\tvar ok bool\n+\tif obj == nil {\n+\t\treturn nil\n+\t}\n+\tif s, ok = obj.(error); !ok {\n+\t\tpanic(fmt.Sprintf(\"assert: arguments: Error(%d) failed because object wasn't correct type: %v\", index, args.Get(index)))\n+\t}\n+\treturn s\n+}\n+\n+// Bool gets the argument at the specified index. Panics if there is no argument, or\n+// if the argument is of the wrong type.\n+func (args Arguments) Bool(index int) bool {\n+\tvar s bool\n+\tvar ok bool\n+\tif s, ok = args.Get(index).(bool); !ok {\n+\t\tpanic(fmt.Sprintf(\"assert: arguments: Bool(%d) failed because object wasn't correct type: %v\", index, args.Get(index)))\n+\t}\n+\treturn s\n+}\n+\n+func typeAndKind(v interface{}) (reflect.Type, reflect.Kind) {\n+\tt := reflect.TypeOf(v)\n+\tk := t.Kind()\n+\n+\tif k == reflect.Ptr {\n+\t\tt = t.Elem()\n+\t\tk = t.Kind()\n+\t}\n+\treturn t, k\n+}\n+\n+func diffArguments(expected Arguments, actual Arguments) string {\n+\tif len(expected) != len(actual) {\n+\t\treturn fmt.Sprintf(\"Provided %v arguments, mocked for %v arguments\", len(expected), len(actual))\n+\t}\n+\n+\tfor x := range expected {\n+\t\tif diffString := diff(expected[x], actual[x]); diffString != \"\" {\n+\t\t\treturn fmt.Sprintf(\"Difference found in argument %v:\\n\\n%s\", x, diffString)\n+\t\t}\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// diff returns a diff of both values as long as both are of the same type and\n+// are a struct, map, slice or array. Otherwise it returns an empty string.\n+func diff(expected interface{}, actual interface{}) string {\n+\tif expected == nil || actual == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\tet, ek := typeAndKind(expected)\n+\tat, _ := typeAndKind(actual)\n+\n+\tif et != at {\n+\t\treturn \"\"\n+\t}\n+\n+\tif ek != reflect.Struct && ek != reflect.Map && ek != reflect.Slice && ek != reflect.Array {\n+\t\treturn \"\"\n+\t}\n+\n+\te := spewConfig.Sdump(expected)\n+\ta := spewConfig.Sdump(actual)\n+\n+\tdiff, _ := difflib.GetUnifiedDiffString(difflib.UnifiedDiff{\n+\t\tA:        difflib.SplitLines(e),\n+\t\tB:        difflib.SplitLines(a),\n+\t\tFromFile: \"Expected\",\n+\t\tFromDate: \"\",\n+\t\tToFile:   \"Actual\",\n+\t\tToDate:   \"\",\n+\t\tContext:  1,\n+\t})\n+\n+\treturn diff\n+}\n+\n+var spewConfig = spew.ConfigState{\n+\tIndent:                  \" \",\n+\tDisablePointerAddresses: true,\n+\tDisableCapacities:       true,\n+\tSortKeys:                true,\n+}\n+\n+type tHelper interface {\n+\tHelper()\n+}"
    },
    {
      "sha": "00ee9555036d04b8d9685b93ecee6bcc84b6563a",
      "filename": "backend/vendor/golang.org/x/crypto/acme/acme.go",
      "status": "modified",
      "additions": 35,
      "deletions": 8,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/crypto/acme/acme.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/crypto/acme/acme.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/crypto/acme/acme.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -77,6 +77,10 @@ const (\n type Client struct {\n \t// Key is the account key used to register with a CA and sign requests.\n \t// Key.Public() must return a *rsa.PublicKey or *ecdsa.PublicKey.\n+\t//\n+\t// The following algorithms are supported:\n+\t// RS256, ES256, ES384 and ES512.\n+\t// See RFC7518 for more details about the algorithms.\n \tKey crypto.Signer\n \n \t// HTTPClient optionally specifies an HTTP client to use\n@@ -124,11 +128,7 @@ func (c *Client) Discover(ctx context.Context) (Directory, error) {\n \t\treturn *c.dir, nil\n \t}\n \n-\tdirURL := c.DirectoryURL\n-\tif dirURL == \"\" {\n-\t\tdirURL = LetsEncryptURL\n-\t}\n-\tres, err := c.get(ctx, dirURL, wantStatus(http.StatusOK))\n+\tres, err := c.get(ctx, c.directoryURL(), wantStatus(http.StatusOK))\n \tif err != nil {\n \t\treturn Directory{}, err\n \t}\n@@ -161,6 +161,13 @@ func (c *Client) Discover(ctx context.Context) (Directory, error) {\n \treturn *c.dir, nil\n }\n \n+func (c *Client) directoryURL() string {\n+\tif c.DirectoryURL != \"\" {\n+\t\treturn c.DirectoryURL\n+\t}\n+\treturn LetsEncryptURL\n+}\n+\n // CreateCert requests a new certificate using the Certificate Signing Request csr encoded in DER format.\n // The exp argument indicates the desired certificate validity duration. CA may issue a certificate\n // with a different duration.\n@@ -319,6 +326,20 @@ func (c *Client) UpdateReg(ctx context.Context, a *Account) (*Account, error) {\n // a valid authorization (Authorization.Status is StatusValid). If so, the caller\n // need not fulfill any challenge and can proceed to requesting a certificate.\n func (c *Client) Authorize(ctx context.Context, domain string) (*Authorization, error) {\n+\treturn c.authorize(ctx, \"dns\", domain)\n+}\n+\n+// AuthorizeIP is the same as Authorize but requests IP address authorization.\n+// Clients which successfully obtain such authorization may request to issue\n+// a certificate for IP addresses.\n+//\n+// See the ACME spec extension for more details about IP address identifiers:\n+// https://tools.ietf.org/html/draft-ietf-acme-ip.\n+func (c *Client) AuthorizeIP(ctx context.Context, ipaddr string) (*Authorization, error) {\n+\treturn c.authorize(ctx, \"ip\", ipaddr)\n+}\n+\n+func (c *Client) authorize(ctx context.Context, typ, val string) (*Authorization, error) {\n \tif _, err := c.Discover(ctx); err != nil {\n \t\treturn nil, err\n \t}\n@@ -332,7 +353,7 @@ func (c *Client) Authorize(ctx context.Context, domain string) (*Authorization,\n \t\tIdentifier authzID `json:\"identifier\"`\n \t}{\n \t\tResource:   \"new-authz\",\n-\t\tIdentifier: authzID{Type: \"dns\", Value: domain},\n+\t\tIdentifier: authzID{Type: typ, Value: val},\n \t}\n \tres, err := c.post(ctx, c.Key, c.dir.AuthzURL, req, wantStatus(http.StatusCreated))\n \tif err != nil {\n@@ -693,12 +714,18 @@ func (c *Client) doReg(ctx context.Context, url string, typ string, acct *Accoun\n }\n \n // popNonce returns a nonce value previously stored with c.addNonce\n-// or fetches a fresh one from the given URL.\n+// or fetches a fresh one from a URL by issuing a HEAD request.\n+// It first tries c.directoryURL() and then the provided url if the former fails.\n func (c *Client) popNonce(ctx context.Context, url string) (string, error) {\n \tc.noncesMu.Lock()\n \tdefer c.noncesMu.Unlock()\n \tif len(c.nonces) == 0 {\n-\t\treturn c.fetchNonce(ctx, url)\n+\t\tdirURL := c.directoryURL()\n+\t\tv, err := c.fetchNonce(ctx, dirURL)\n+\t\tif err != nil && url != dirURL {\n+\t\t\tv, err = c.fetchNonce(ctx, url)\n+\t\t}\n+\t\treturn v, err\n \t}\n \tvar nonce string\n \tfor nonce = range c.nonces {"
    },
    {
      "sha": "1093b50390144c099611e12cff099f68b60050e9",
      "filename": "backend/vendor/golang.org/x/crypto/acme/jws.go",
      "status": "modified",
      "additions": 16,
      "deletions": 13,
      "changes": 29,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/crypto/acme/jws.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/crypto/acme/jws.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/crypto/acme/jws.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -25,7 +25,7 @@ func jwsEncodeJSON(claimset interface{}, key crypto.Signer, nonce string) ([]byt\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\talg, sha := jwsHasher(key)\n+\talg, sha := jwsHasher(key.Public())\n \tif alg == \"\" || !sha.Available() {\n \t\treturn nil, ErrUnsupportedKey\n \t}\n@@ -97,13 +97,16 @@ func jwkEncode(pub crypto.PublicKey) (string, error) {\n }\n \n // jwsSign signs the digest using the given key.\n-// It returns ErrUnsupportedKey if the key type is unknown.\n-// The hash is used only for RSA keys.\n+// The hash is unused for ECDSA keys.\n+//\n+// Note: non-stdlib crypto.Signer implementations are expected to return\n+// the signature in the format as specified in RFC7518.\n+// See https://tools.ietf.org/html/rfc7518 for more details.\n func jwsSign(key crypto.Signer, hash crypto.Hash, digest []byte) ([]byte, error) {\n-\tswitch key := key.(type) {\n-\tcase *rsa.PrivateKey:\n-\t\treturn key.Sign(rand.Reader, digest, hash)\n-\tcase *ecdsa.PrivateKey:\n+\tif key, ok := key.(*ecdsa.PrivateKey); ok {\n+\t\t// The key.Sign method of ecdsa returns ASN1-encoded signature.\n+\t\t// So, we use the package Sign function instead\n+\t\t// to get R and S values directly and format the result accordingly.\n \t\tr, s, err := ecdsa.Sign(rand.Reader, key, digest)\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -118,18 +121,18 @@ func jwsSign(key crypto.Signer, hash crypto.Hash, digest []byte) ([]byte, error)\n \t\tcopy(sig[size*2-len(sb):], sb)\n \t\treturn sig, nil\n \t}\n-\treturn nil, ErrUnsupportedKey\n+\treturn key.Sign(rand.Reader, digest, hash)\n }\n \n // jwsHasher indicates suitable JWS algorithm name and a hash function\n // to use for signing a digest with the provided key.\n // It returns (\"\", 0) if the key is not supported.\n-func jwsHasher(key crypto.Signer) (string, crypto.Hash) {\n-\tswitch key := key.(type) {\n-\tcase *rsa.PrivateKey:\n+func jwsHasher(pub crypto.PublicKey) (string, crypto.Hash) {\n+\tswitch pub := pub.(type) {\n+\tcase *rsa.PublicKey:\n \t\treturn \"RS256\", crypto.SHA256\n-\tcase *ecdsa.PrivateKey:\n-\t\tswitch key.Params().Name {\n+\tcase *ecdsa.PublicKey:\n+\t\tswitch pub.Params().Name {\n \t\tcase \"P-256\":\n \t\t\treturn \"ES256\", crypto.SHA256\n \t\tcase \"P-384\":"
    },
    {
      "sha": "633ee15dc55b53ebbabfc73870c8e66a1c1b0e29",
      "filename": "backend/vendor/golang.org/x/net/html/node.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/net/html/node.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/net/html/node.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/node.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -177,7 +177,7 @@ func (s *nodeStack) index(n *Node) int {\n // contains returns whether a is within s.\n func (s *nodeStack) contains(a atom.Atom) bool {\n \tfor _, n := range *s {\n-\t\tif n.DataAtom == a {\n+\t\tif n.DataAtom == a && n.Namespace == \"\" {\n \t\t\treturn true\n \t\t}\n \t}"
    },
    {
      "sha": "1d3c198ae7d2637b89c1ce5e970d0f118436989a",
      "filename": "backend/vendor/golang.org/x/net/html/parse.go",
      "status": "modified",
      "additions": 38,
      "deletions": 17,
      "changes": 55,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/net/html/parse.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/net/html/parse.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/parse.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -439,9 +439,6 @@ func (p *parser) resetInsertionMode() {\n \t\tcase a.Select:\n \t\t\tif !last {\n \t\t\t\tfor ancestor, first := n, p.oe[0]; ancestor != first; {\n-\t\t\t\t\tif ancestor == first {\n-\t\t\t\t\t\tbreak\n-\t\t\t\t\t}\n \t\t\t\t\tancestor = p.oe[p.oe.index(ancestor)-1]\n \t\t\t\t\tswitch ancestor.DataAtom {\n \t\t\t\t\tcase a.Template:\n@@ -904,7 +901,7 @@ func inBodyIM(p *parser) bool {\n \t\tcase a.A:\n \t\t\tfor i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {\n \t\t\t\tif n := p.afe[i]; n.Type == ElementNode && n.DataAtom == a.A {\n-\t\t\t\t\tp.inBodyEndTagFormatting(a.A)\n+\t\t\t\t\tp.inBodyEndTagFormatting(a.A, \"a\")\n \t\t\t\t\tp.oe.remove(n)\n \t\t\t\t\tp.afe.remove(n)\n \t\t\t\t\tbreak\n@@ -918,7 +915,7 @@ func inBodyIM(p *parser) bool {\n \t\tcase a.Nobr:\n \t\t\tp.reconstructActiveFormattingElements()\n \t\t\tif p.elementInScope(defaultScope, a.Nobr) {\n-\t\t\t\tp.inBodyEndTagFormatting(a.Nobr)\n+\t\t\t\tp.inBodyEndTagFormatting(a.Nobr, \"nobr\")\n \t\t\t\tp.reconstructActiveFormattingElements()\n \t\t\t}\n \t\t\tp.addFormattingElement()\n@@ -1126,7 +1123,7 @@ func inBodyIM(p *parser) bool {\n \t\tcase a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:\n \t\t\tp.popUntil(defaultScope, a.H1, a.H2, a.H3, a.H4, a.H5, a.H6)\n \t\tcase a.A, a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.Nobr, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:\n-\t\t\tp.inBodyEndTagFormatting(p.tok.DataAtom)\n+\t\t\tp.inBodyEndTagFormatting(p.tok.DataAtom, p.tok.Data)\n \t\tcase a.Applet, a.Marquee, a.Object:\n \t\t\tif p.popUntil(defaultScope, p.tok.DataAtom) {\n \t\t\t\tp.clearActiveFormattingElements()\n@@ -1137,7 +1134,7 @@ func inBodyIM(p *parser) bool {\n \t\tcase a.Template:\n \t\t\treturn inHeadIM(p)\n \t\tdefault:\n-\t\t\tp.inBodyEndTagOther(p.tok.DataAtom)\n+\t\t\tp.inBodyEndTagOther(p.tok.DataAtom, p.tok.Data)\n \t\t}\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n@@ -1164,7 +1161,7 @@ func inBodyIM(p *parser) bool {\n \treturn true\n }\n \n-func (p *parser) inBodyEndTagFormatting(tagAtom a.Atom) {\n+func (p *parser) inBodyEndTagFormatting(tagAtom a.Atom, tagName string) {\n \t// This is the \"adoption agency\" algorithm, described at\n \t// https://html.spec.whatwg.org/multipage/syntax.html#adoptionAgency\n \n@@ -1186,7 +1183,7 @@ func (p *parser) inBodyEndTagFormatting(tagAtom a.Atom) {\n \t\t\t}\n \t\t}\n \t\tif formattingElement == nil {\n-\t\t\tp.inBodyEndTagOther(tagAtom)\n+\t\t\tp.inBodyEndTagOther(tagAtom, tagName)\n \t\t\treturn\n \t\t}\n \t\tfeIndex := p.oe.index(formattingElement)\n@@ -1291,9 +1288,17 @@ func (p *parser) inBodyEndTagFormatting(tagAtom a.Atom) {\n // inBodyEndTagOther performs the \"any other end tag\" algorithm for inBodyIM.\n // \"Any other end tag\" handling from 12.2.6.5 The rules for parsing tokens in foreign content\n // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inforeign\n-func (p *parser) inBodyEndTagOther(tagAtom a.Atom) {\n+func (p *parser) inBodyEndTagOther(tagAtom a.Atom, tagName string) {\n \tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\tif p.oe[i].DataAtom == tagAtom {\n+\t\t// Two element nodes have the same tag if they have the same Data (a\n+\t\t// string-typed field). As an optimization, for common HTML tags, each\n+\t\t// Data string is assigned a unique, non-zero DataAtom (a uint32-typed\n+\t\t// field), since integer comparison is faster than string comparison.\n+\t\t// Uncommon (custom) tags get a zero DataAtom.\n+\t\t//\n+\t\t// The if condition here is equivalent to (p.oe[i].Data == tagName).\n+\t\tif (p.oe[i].DataAtom == tagAtom) &&\n+\t\t\t((tagAtom != 0) || (p.oe[i].Data == tagName)) {\n \t\t\tp.oe = p.oe[:i]\n \t\t\tbreak\n \t\t}\n@@ -1719,8 +1724,12 @@ func inSelectIM(p *parser) bool {\n \t\t\t}\n \t\t\tp.addElement()\n \t\tcase a.Select:\n-\t\t\tp.tok.Type = EndTagToken\n-\t\t\treturn false\n+\t\t\tif p.popUntil(selectScope, a.Select) {\n+\t\t\t\tp.resetInsertionMode()\n+\t\t\t} else {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n \t\tcase a.Input, a.Keygen, a.Textarea:\n \t\t\tif p.elementInScope(selectScope, a.Select) {\n \t\t\t\tp.parseImpliedToken(EndTagToken, a.Select, a.Select.String())\n@@ -1750,6 +1759,9 @@ func inSelectIM(p *parser) bool {\n \t\tcase a.Select:\n \t\t\tif p.popUntil(selectScope, a.Select) {\n \t\t\t\tp.resetInsertionMode()\n+\t\t\t} else {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n \t\t\t}\n \t\tcase a.Template:\n \t\t\treturn inHeadIM(p)\n@@ -1775,13 +1787,22 @@ func inSelectInTableIM(p *parser) bool {\n \tcase StartTagToken, EndTagToken:\n \t\tswitch p.tok.DataAtom {\n \t\tcase a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:\n-\t\t\tif p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.DataAtom) {\n-\t\t\t\tp.parseImpliedToken(EndTagToken, a.Select, a.Select.String())\n-\t\t\t\treturn false\n-\t\t\t} else {\n+\t\t\tif p.tok.Type == EndTagToken && !p.elementInScope(tableScope, p.tok.DataAtom) {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n+\t\t\t// This is like p.popUntil(selectScope, a.Select), but it also\n+\t\t\t// matches <math select>, not just <select>. Matching the MathML\n+\t\t\t// tag is arguably incorrect (conceptually), but it mimics what\n+\t\t\t// Chromium does.\n+\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\t\t\tif n := p.oe[i]; n.DataAtom == a.Select {\n+\t\t\t\t\tp.oe = p.oe[:i]\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tp.resetInsertionMode()\n+\t\t\treturn false\n \t\t}\n \t}\n \treturn inSelectIM(p)"
    },
    {
      "sha": "eb2f78ae295baf4c42d95755de761285788108fa",
      "filename": "backend/vendor/golang.org/x/sys/unix/README.md",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/README.md?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -32,7 +32,7 @@ To build the files for your current OS and architecture, make sure GOOS and\n GOARCH are set correctly and run `mkall.sh`. This will generate the files for\n your specific system. Running `mkall.sh -n` shows the commands that will be run.\n \n-Requirements: bash, perl, go\n+Requirements: bash, go\n \n ### New Build System (currently for `GOOS == \"linux\"`)\n \n@@ -52,14 +52,14 @@ system and have your GOOS and GOARCH set accordingly. Running `mkall.sh` will\n then generate all of the files for all of the GOOS/GOARCH pairs in the new build\n system. Running `mkall.sh -n` shows the commands that will be run.\n \n-Requirements: bash, perl, go, docker\n+Requirements: bash, go, docker\n \n ## Component files\n \n This section describes the various files used in the code generation process.\n It also contains instructions on how to modify these files to add a new\n architecture/OS or to add additional syscalls, types, or constants. Note that\n-if you are using the new build system, the scripts cannot be called normally.\n+if you are using the new build system, the scripts/programs cannot be called normally.\n They must be called from within the docker container.\n \n ### asm files\n@@ -81,8 +81,8 @@ each GOOS/GOARCH pair.\n \n ### mksysnum\n \n-Mksysnum is a script located at `${GOOS}/mksysnum.pl` (or `mksysnum_${GOOS}.pl`\n-for the old system). This script takes in a list of header files containing the\n+Mksysnum is a Go program located at `${GOOS}/mksysnum.go` (or `mksysnum_${GOOS}.go`\n+for the old system). This program takes in a list of header files containing the\n syscall number declarations and parses them to produce the corresponding list of\n Go numeric constants. See `zsysnum_${GOOS}_${GOARCH}.go` for the generated\n constants.\n@@ -92,14 +92,14 @@ new installation of the target OS (or updating the source checkouts for the\n new build system). However, depending on the OS, you make need to update the\n parsing in mksysnum.\n \n-### mksyscall.pl\n+### mksyscall.go\n \n The `syscall.go`, `syscall_${GOOS}.go`, `syscall_${GOOS}_${GOARCH}.go` are\n hand-written Go files which implement system calls (for unix, the specific OS,\n or the specific OS/Architecture pair respectively) that need special handling\n and list `//sys` comments giving prototypes for ones that can be generated.\n \n-The mksyscall.pl script takes the `//sys` and `//sysnb` comments and converts\n+The mksyscall.go program takes the `//sys` and `//sysnb` comments and converts\n them into syscalls. This requires the name of the prototype in the comment to\n match a syscall number in the `zsysnum_${GOOS}_${GOARCH}.go` file. The function\n prototype can be exported (capitalized) or not.\n@@ -160,7 +160,7 @@ signal numbers, and constants. Generated by `mkerrors.sh` (see above).\n ### `zsyscall_${GOOS}_${GOARCH}.go`\n \n A file containing all the generated syscalls for a specific GOOS and GOARCH.\n-Generated by `mksyscall.pl` (see above).\n+Generated by `mksyscall.go` (see above).\n \n ### `zsysnum_${GOOS}_${GOARCH}.go`\n "
    },
    {
      "sha": "6f98ba5a370a21762405dcae65f9200cc8fa26b5",
      "filename": "backend/vendor/golang.org/x/sys/unix/asm_netbsd_arm64.s",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/asm_netbsd_arm64.s",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/asm_netbsd_arm64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/asm_netbsd_arm64.s?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+//\n+// System call support for ARM64, NetBSD\n+//\n+\n+// Just jump to package syscall's implementation for all these functions.\n+// The runtime may know about them.\n+\n+TEXT\tSyscall(SB),NOSPLIT,$0-56\n+\tB\tsyscallSyscall(SB)\n+\n+TEXT\tSyscall6(SB),NOSPLIT,$0-80\n+\tB\tsyscallSyscall6(SB)\n+\n+TEXT\tSyscall9(SB),NOSPLIT,$0-104\n+\tB\tsyscallSyscall9(SB)\n+\n+TEXT\tRawSyscall(SB),NOSPLIT,$0-56\n+\tB\tsyscallRawSyscall(SB)\n+\n+TEXT\tRawSyscall6(SB),NOSPLIT,$0-80\n+\tB\tsyscallRawSyscall6(SB)"
    },
    {
      "sha": "75152f99b20b4c8a4ea16752bba82834122fdcc1",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkall.sh",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mkall.sh",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mkall.sh",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkall.sh?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -67,7 +67,7 @@ aix_ppc)\n \t;;\n aix_ppc64)\n \tmkerrors=\"$mkerrors -maix64\"\n-\tmksyscall=\"./mksyscall_aix_ppc64.pl -aix\"\n+\tmksyscall=\"go run mksyscall_aix_ppc64.go -aix\"\n \tmktypes=\"GOARCH=$GOARCH go tool cgo -godefs\"\n \t;;\n darwin_386)\n@@ -170,7 +170,7 @@ openbsd_arm)\n \tmktypes=\"GOARCH=$GOARCH go tool cgo -godefs -- -fsigned-char\"\n \t;;\n solaris_amd64)\n-\tmksyscall=\"./mksyscall_solaris.pl\"\n+\tmksyscall=\"go run mksyscall_solaris.go\"\n \tmkerrors=\"$mkerrors -m64\"\n \tmksysnum=\n \tmktypes=\"GOARCH=$GOARCH go tool cgo -godefs\""
    },
    {
      "sha": "6a23484e5b5b6d650ea6a9db1777145f4a7cf8b1",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkerrors.sh",
      "status": "modified",
      "additions": 5,
      "deletions": 12,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mkerrors.sh",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mkerrors.sh",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkerrors.sh?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -179,8 +179,10 @@ struct ltchars {\n #include <sys/stat.h>\n #include <sys/types.h>\n #include <sys/time.h>\n+#include <sys/signalfd.h>\n #include <sys/socket.h>\n #include <sys/xattr.h>\n+#include <linux/errqueue.h>\n #include <linux/if.h>\n #include <linux/if_alg.h>\n #include <linux/if_arp.h>\n@@ -257,16 +259,6 @@ struct ltchars {\n #define FS_KEY_DESC_PREFIX              \"fscrypt:\"\n #define FS_KEY_DESC_PREFIX_SIZE         8\n #define FS_MAX_KEY_SIZE                 64\n-\n-// XDP socket constants do not appear to be picked up otherwise.\n-// Copied from samples/bpf/xdpsock_user.c.\n-#ifndef SOL_XDP\n-#define SOL_XDP 283\n-#endif\n-\n-#ifndef AF_XDP\n-#define AF_XDP 44\n-#endif\n '\n \n includes_NetBSD='\n@@ -453,7 +445,7 @@ ccflags=\"$@\"\n \t\t$2 !~ \"MNT_BITS\" &&\n \t\t$2 ~ /^(MS|MNT|UMOUNT)_/ ||\n \t\t$2 ~ /^TUN(SET|GET|ATTACH|DETACH)/ ||\n-\t\t$2 ~ /^(O|F|E?FD|NAME|S|PTRACE|PT)_/ ||\n+\t\t$2 ~ /^(O|F|[ES]?FD|NAME|S|PTRACE|PT)_/ ||\n \t\t$2 ~ /^KEXEC_/ ||\n \t\t$2 ~ /^LINUX_REBOOT_CMD_/ ||\n \t\t$2 ~ /^LINUX_REBOOT_MAGIC[12]$/ ||\n@@ -474,12 +466,13 @@ ccflags=\"$@\"\n \t\t$2 ~ /^CLONE_[A-Z_]+/ ||\n \t\t$2 !~ /^(BPF_TIMEVAL)$/ &&\n \t\t$2 ~ /^(BPF|DLT)_/ ||\n-\t\t$2 ~ /^CLOCK_/ ||\n+\t\t$2 ~ /^(CLOCK|TIMER)_/ ||\n \t\t$2 ~ /^CAN_/ ||\n \t\t$2 ~ /^CAP_/ ||\n \t\t$2 ~ /^ALG_/ ||\n \t\t$2 ~ /^FS_(POLICY_FLAGS|KEY_DESC|ENCRYPTION_MODE|[A-Z0-9_]+_KEY_SIZE|IOC_(GET|SET)_ENCRYPTION)/ ||\n \t\t$2 ~ /^GRND_/ ||\n+\t\t$2 ~ /^RND/ ||\n \t\t$2 ~ /^KEY_(SPEC|REQKEY_DEFL)_/ ||\n \t\t$2 ~ /^KEYCTL_/ ||\n \t\t$2 ~ /^PERF_EVENT_IOC_/ ||"
    },
    {
      "sha": "e06e4253ea3c3a7f03f49eb0662806808cb4e4c5",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -88,6 +88,10 @@ func parseParam(p string) Param {\n func main() {\n \t// Get the OS and architecture (using GOARCH_TARGET if it exists)\n \tgoos := os.Getenv(\"GOOS\")\n+\tif goos == \"\" {\n+\t\tfmt.Fprintln(os.Stderr, \"GOOS not defined in environment\")\n+\t\tos.Exit(1)\n+\t}\n \tgoarch := os.Getenv(\"GOARCH_TARGET\")\n \tif goarch == \"\" {\n \t\tgoarch = os.Getenv(\"GOARCH\")"
    },
    {
      "sha": "45b4429088fea0f4e71e4bf7bfccdb71b6c64704",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go",
      "status": "added",
      "additions": 602,
      "deletions": 0,
      "changes": 602,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,602 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+/*\n+This program reads a file containing function prototypes\n+(like syscall_aix.go) and generates system call bodies.\n+The prototypes are marked by lines beginning with \"//sys\"\n+and read like func declarations if //sys is replaced by func, but:\n+\t* The parameter lists must give a name for each argument.\n+\t  This includes return parameters.\n+\t* The parameter lists must give a type for each argument:\n+\t  the (x, y, z int) shorthand is not allowed.\n+\t* If the return parameter is an error number, it must be named err.\n+\t* If go func name needs to be different than its libc name,\n+\t* or the function is not in libc, name could be specified\n+\t* at the end, after \"=\" sign, like\n+\t  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt\n+\n+\n+This program will generate three files and handle both gc and gccgo implementation:\n+  - zsyscall_aix_ppc64.go: the common part of each implementation (error handler, pointer creation)\n+  - zsyscall_aix_ppc64_gc.go: gc part with //go_cgo_import_dynamic and a call to syscall6\n+  - zsyscall_aix_ppc64_gccgo.go: gccgo part with C function and conversion to C type.\n+\n+ The generated code looks like this\n+\n+zsyscall_aix_ppc64.go\n+func asyscall(...) (n int, err error) {\n+\t // Pointer Creation\n+\t r1, e1 := callasyscall(...)\n+\t // Type Conversion\n+\t // Error Handler\n+\t return\n+}\n+\n+zsyscall_aix_ppc64_gc.go\n+//go:cgo_import_dynamic libc_asyscall asyscall \"libc.a/shr_64.o\"\n+//go:linkname libc_asyscall libc_asyscall\n+var asyscall syscallFunc\n+\n+func callasyscall(...) (r1 uintptr, e1 Errno) {\n+\t r1, _, e1 = syscall6(uintptr(unsafe.Pointer(&libc_asyscall)), \"nb_args\", ... )\n+\t return\n+}\n+\n+zsyscall_aix_ppc64_ggcgo.go\n+\n+// int asyscall(...)\n+\n+import \"C\"\n+\n+func callasyscall(...) (r1 uintptr, e1 Errno) {\n+\t r1 = uintptr(C.asyscall(...))\n+\t e1 = syscall.GetErrno()\n+\t return\n+}\n+*/\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"strings\"\n+)\n+\n+var (\n+\tb32  = flag.Bool(\"b32\", false, \"32bit big-endian\")\n+\tl32  = flag.Bool(\"l32\", false, \"32bit little-endian\")\n+\taix  = flag.Bool(\"aix\", false, \"aix\")\n+\ttags = flag.String(\"tags\", \"\", \"build tags\")\n+)\n+\n+// cmdLine returns this programs's commandline arguments\n+func cmdLine() string {\n+\treturn \"go run mksyscall_aix_ppc64.go \" + strings.Join(os.Args[1:], \" \")\n+}\n+\n+// buildTags returns build tags\n+func buildTags() string {\n+\treturn *tags\n+}\n+\n+// Param is function parameter\n+type Param struct {\n+\tName string\n+\tType string\n+}\n+\n+// usage prints the program usage\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: go run mksyscall_aix_ppc64.go [-b32 | -l32] [-tags x,y] [file ...]\\n\")\n+\tos.Exit(1)\n+}\n+\n+// parseParamList parses parameter list and returns a slice of parameters\n+func parseParamList(list string) []string {\n+\tlist = strings.TrimSpace(list)\n+\tif list == \"\" {\n+\t\treturn []string{}\n+\t}\n+\treturn regexp.MustCompile(`\\s*,\\s*`).Split(list, -1)\n+}\n+\n+// parseParam splits a parameter into name and type\n+func parseParam(p string) Param {\n+\tps := regexp.MustCompile(`^(\\S*) (\\S*)$`).FindStringSubmatch(p)\n+\tif ps == nil {\n+\t\tfmt.Fprintf(os.Stderr, \"malformed parameter: %s\\n\", p)\n+\t\tos.Exit(1)\n+\t}\n+\treturn Param{ps[1], ps[2]}\n+}\n+\n+func main() {\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\tif len(flag.Args()) <= 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"no files to parse provided\\n\")\n+\t\tusage()\n+\t}\n+\n+\tendianness := \"\"\n+\tif *b32 {\n+\t\tendianness = \"big-endian\"\n+\t} else if *l32 {\n+\t\tendianness = \"little-endian\"\n+\t}\n+\n+\tpack := \"\"\n+\t// GCCGO\n+\ttextgccgo := \"\"\n+\tcExtern := \"/*\\n#include <stdint.h>\\n\"\n+\t// GC\n+\ttextgc := \"\"\n+\tdynimports := \"\"\n+\tlinknames := \"\"\n+\tvar vars []string\n+\t// COMMON\n+\ttextcommon := \"\"\n+\tfor _, path := range flag.Args() {\n+\t\tfile, err := os.Open(path)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\ts := bufio.NewScanner(file)\n+\t\tfor s.Scan() {\n+\t\t\tt := s.Text()\n+\t\t\tt = strings.TrimSpace(t)\n+\t\t\tt = regexp.MustCompile(`\\s+`).ReplaceAllString(t, ` `)\n+\t\t\tif p := regexp.MustCompile(`^package (\\S+)$`).FindStringSubmatch(t); p != nil && pack == \"\" {\n+\t\t\t\tpack = p[1]\n+\t\t\t}\n+\t\t\tnonblock := regexp.MustCompile(`^\\/\\/sysnb `).FindStringSubmatch(t)\n+\t\t\tif regexp.MustCompile(`^\\/\\/sys `).FindStringSubmatch(t) == nil && nonblock == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Line must be of the form\n+\t\t\t//\tfunc Open(path string, mode int, perm int) (fd int, err error)\n+\t\t\t// Split into name, in params, out params.\n+\t\t\tf := regexp.MustCompile(`^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*(?:(\\w*)\\.)?(\\w*))?$`).FindStringSubmatch(t)\n+\t\t\tif f == nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s\\nmalformed //sys declaration\\n\", path, t)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tfunct, inps, outps, modname, sysname := f[2], f[3], f[4], f[5], f[6]\n+\n+\t\t\t// Split argument lists on comma.\n+\t\t\tin := parseParamList(inps)\n+\t\t\tout := parseParamList(outps)\n+\n+\t\t\tinps = strings.Join(in, \", \")\n+\t\t\toutps = strings.Join(out, \", \")\n+\n+\t\t\tif sysname == \"\" {\n+\t\t\t\tsysname = funct\n+\t\t\t}\n+\n+\t\t\tonlyCommon := false\n+\t\t\tif funct == \"readlen\" || funct == \"writelen\" || funct == \"FcntlInt\" || funct == \"FcntlFlock\" {\n+\t\t\t\t// This function call another syscall which is already implemented.\n+\t\t\t\t// Therefore, the gc and gccgo part must not be generated.\n+\t\t\t\tonlyCommon = true\n+\t\t\t}\n+\n+\t\t\t// Try in vain to keep people from editing this file.\n+\t\t\t// The theory is that they jump into the middle of the file\n+\t\t\t// without reading the header.\n+\n+\t\t\ttextcommon += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n+\t\t\tif !onlyCommon {\n+\t\t\t\ttextgccgo += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n+\t\t\t\ttextgc += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n+\t\t\t}\n+\n+\t\t\t// Check if value return, err return available\n+\t\t\terrvar := \"\"\n+\t\t\trettype := \"\"\n+\t\t\tfor _, param := range out {\n+\t\t\t\tp := parseParam(param)\n+\t\t\t\tif p.Type == \"error\" {\n+\t\t\t\t\terrvar = p.Name\n+\t\t\t\t} else {\n+\t\t\t\t\trettype = p.Type\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tsysname = regexp.MustCompile(`([a-z])([A-Z])`).ReplaceAllString(sysname, `${1}_$2`)\n+\t\t\tsysname = strings.ToLower(sysname) // All libc functions are lowercase.\n+\n+\t\t\t// GCCGO Prototype return type\n+\t\t\tcRettype := \"\"\n+\t\t\tif rettype == \"unsafe.Pointer\" {\n+\t\t\t\tcRettype = \"uintptr_t\"\n+\t\t\t} else if rettype == \"uintptr\" {\n+\t\t\t\tcRettype = \"uintptr_t\"\n+\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(rettype) != nil {\n+\t\t\t\tcRettype = \"uintptr_t\"\n+\t\t\t} else if rettype == \"int\" {\n+\t\t\t\tcRettype = \"int\"\n+\t\t\t} else if rettype == \"int32\" {\n+\t\t\t\tcRettype = \"int\"\n+\t\t\t} else if rettype == \"int64\" {\n+\t\t\t\tcRettype = \"long long\"\n+\t\t\t} else if rettype == \"uint32\" {\n+\t\t\t\tcRettype = \"unsigned int\"\n+\t\t\t} else if rettype == \"uint64\" {\n+\t\t\t\tcRettype = \"unsigned long long\"\n+\t\t\t} else {\n+\t\t\t\tcRettype = \"int\"\n+\t\t\t}\n+\t\t\tif sysname == \"exit\" {\n+\t\t\t\tcRettype = \"void\"\n+\t\t\t}\n+\n+\t\t\t// GCCGO Prototype arguments type\n+\t\t\tvar cIn []string\n+\t\t\tfor i, param := range in {\n+\t\t\t\tp := parseParam(param)\n+\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n+\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n+\t\t\t\t} else if p.Type == \"string\" {\n+\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n+\t\t\t\t} else if regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type) != nil {\n+\t\t\t\t\tcIn = append(cIn, \"uintptr_t\", \"size_t\")\n+\t\t\t\t} else if p.Type == \"unsafe.Pointer\" {\n+\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n+\t\t\t\t} else if p.Type == \"uintptr\" {\n+\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n+\t\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(p.Type) != nil {\n+\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n+\t\t\t\t} else if p.Type == \"int\" {\n+\t\t\t\t\tif (i == 0 || i == 2) && funct == \"fcntl\" {\n+\t\t\t\t\t\t// These fcntl arguments needs to be uintptr to be able to call FcntlInt and FcntlFlock\n+\t\t\t\t\t\tcIn = append(cIn, \"uintptr_t\")\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tcIn = append(cIn, \"int\")\n+\t\t\t\t\t}\n+\n+\t\t\t\t} else if p.Type == \"int32\" {\n+\t\t\t\t\tcIn = append(cIn, \"int\")\n+\t\t\t\t} else if p.Type == \"int64\" {\n+\t\t\t\t\tcIn = append(cIn, \"long long\")\n+\t\t\t\t} else if p.Type == \"uint32\" {\n+\t\t\t\t\tcIn = append(cIn, \"unsigned int\")\n+\t\t\t\t} else if p.Type == \"uint64\" {\n+\t\t\t\t\tcIn = append(cIn, \"unsigned long long\")\n+\t\t\t\t} else {\n+\t\t\t\t\tcIn = append(cIn, \"int\")\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif !onlyCommon {\n+\t\t\t\t// GCCGO Prototype Generation\n+\t\t\t\t// Imports of system calls from libc\n+\t\t\t\tcExtern += fmt.Sprintf(\"%s %s\", cRettype, sysname)\n+\t\t\t\tcIn := strings.Join(cIn, \", \")\n+\t\t\t\tcExtern += fmt.Sprintf(\"(%s);\\n\", cIn)\n+\t\t\t}\n+\t\t\t// GC Library name\n+\t\t\tif modname == \"\" {\n+\t\t\t\tmodname = \"libc.a/shr_64.o\"\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: only syscall using libc are available\\n\", funct)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tsysvarname := fmt.Sprintf(\"libc_%s\", sysname)\n+\n+\t\t\tif !onlyCommon {\n+\t\t\t\t// GC Runtime import of function to allow cross-platform builds.\n+\t\t\t\tdynimports += fmt.Sprintf(\"//go:cgo_import_dynamic %s %s \\\"%s\\\"\\n\", sysvarname, sysname, modname)\n+\t\t\t\t// GC Link symbol to proc address variable.\n+\t\t\t\tlinknames += fmt.Sprintf(\"//go:linkname %s %s\\n\", sysvarname, sysvarname)\n+\t\t\t\t// GC Library proc address variable.\n+\t\t\t\tvars = append(vars, sysvarname)\n+\t\t\t}\n+\n+\t\t\tstrconvfunc := \"BytePtrFromString\"\n+\t\t\tstrconvtype := \"*byte\"\n+\n+\t\t\t// Go function header.\n+\t\t\tif outps != \"\" {\n+\t\t\t\toutps = fmt.Sprintf(\" (%s)\", outps)\n+\t\t\t}\n+\t\t\tif textcommon != \"\" {\n+\t\t\t\ttextcommon += \"\\n\"\n+\t\t\t}\n+\n+\t\t\ttextcommon += fmt.Sprintf(\"func %s(%s)%s {\\n\", funct, strings.Join(in, \", \"), outps)\n+\n+\t\t\t// Prepare arguments tocall.\n+\t\t\tvar argscommon []string // Arguments in the common part\n+\t\t\tvar argscall []string   // Arguments for call prototype\n+\t\t\tvar argsgc []string     // Arguments for gc call (with syscall6)\n+\t\t\tvar argsgccgo []string  // Arguments for gccgo call (with C.name_of_syscall)\n+\t\t\tn := 0\n+\t\t\targN := 0\n+\t\t\tfor _, param := range in {\n+\t\t\t\tp := parseParam(param)\n+\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n+\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(%s))\", p.Name))\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, p.Name)\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n+\t\t\t\t} else if p.Type == \"string\" && errvar != \"\" {\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\t_p%d, %s = %s(%s)\\n\", n, errvar, strconvfunc, p.Name)\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tif %s != nil {\\n\\t\\treturn\\n\\t}\\n\", errvar)\n+\n+\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"_p%d uintptr \", n))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"_p%d\", n))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n))\n+\t\t\t\t\tn++\n+\t\t\t\t} else if p.Type == \"string\" {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses string arguments, but has no error return\\n\")\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\t_p%d, %s = %s(%s)\\n\", n, errvar, strconvfunc, p.Name)\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tif %s != nil {\\n\\t\\treturn\\n\\t}\\n\", errvar)\n+\n+\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"_p%d uintptr\", n))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"_p%d\", n))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n))\n+\t\t\t\t\tn++\n+\t\t\t\t} else if m := regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type); m != nil {\n+\t\t\t\t\t// Convert slice into pointer, length.\n+\t\t\t\t\t// Have to be careful not to take address of &a[0] if len == 0:\n+\t\t\t\t\t// pass nil in that case.\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tvar _p%d *%s\\n\", n, m[1])\n+\t\t\t\t\ttextcommon += fmt.Sprintf(\"\\tif len(%s) > 0 {\\n\\t\\t_p%d = &%s[0]\\n\\t}\\n\", p.Name, n, p.Name)\n+\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n), fmt.Sprintf(\"len(%s)\", p.Name))\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"_p%d uintptr\", n), fmt.Sprintf(\"_lenp%d int\", n))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"_p%d\", n), fmt.Sprintf(\"uintptr(_lenp%d)\", n))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(_p%d)\", n), fmt.Sprintf(\"C.size_t(_lenp%d)\", n))\n+\t\t\t\t\tn++\n+\t\t\t\t} else if p.Type == \"int64\" && endianness != \"\" {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses int64 with 32 bits mode. Case not yet implemented\\n\")\n+\t\t\t\t} else if p.Type == \"bool\" {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses bool. Case not yet implemented\\n\")\n+\t\t\t\t} else if regexp.MustCompile(`^_`).FindStringSubmatch(p.Type) != nil || p.Type == \"unsafe.Pointer\" {\n+\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, p.Name)\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n+\t\t\t\t} else if p.Type == \"int\" {\n+\t\t\t\t\tif (argN == 0 || argN == 2) && ((funct == \"fcntl\") || (funct == \"FcntlInt\") || (funct == \"FcntlFlock\")) {\n+\t\t\t\t\t\t// These fcntl arguments need to be uintptr to be able to call FcntlInt and FcntlFlock\n+\t\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n+\t\t\t\t\t\targsgc = append(argsgc, p.Name)\n+\t\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n+\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\targscommon = append(argscommon, p.Name)\n+\t\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int\", p.Name))\n+\t\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.int(%s)\", p.Name))\n+\t\t\t\t\t}\n+\t\t\t\t} else if p.Type == \"int32\" {\n+\t\t\t\t\targscommon = append(argscommon, p.Name)\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int32\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.int(%s)\", p.Name))\n+\t\t\t\t} else if p.Type == \"int64\" {\n+\t\t\t\t\targscommon = append(argscommon, p.Name)\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int64\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.longlong(%s)\", p.Name))\n+\t\t\t\t} else if p.Type == \"uint32\" {\n+\t\t\t\t\targscommon = append(argscommon, p.Name)\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uint32\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uint(%s)\", p.Name))\n+\t\t\t\t} else if p.Type == \"uint64\" {\n+\t\t\t\t\targscommon = append(argscommon, p.Name)\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uint64\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.ulonglong(%s)\", p.Name))\n+\t\t\t\t} else if p.Type == \"uintptr\" {\n+\t\t\t\t\targscommon = append(argscommon, p.Name)\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s uintptr\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, p.Name)\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.uintptr_t(%s)\", p.Name))\n+\t\t\t\t} else {\n+\t\t\t\t\targscommon = append(argscommon, fmt.Sprintf(\"int(%s)\", p.Name))\n+\t\t\t\t\targscall = append(argscall, fmt.Sprintf(\"%s int\", p.Name))\n+\t\t\t\t\targsgc = append(argsgc, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\targsgccgo = append(argsgccgo, fmt.Sprintf(\"C.int(%s)\", p.Name))\n+\t\t\t\t}\n+\t\t\t\targN++\n+\t\t\t}\n+\t\t\tnargs := len(argsgc)\n+\n+\t\t\t// COMMON function generation\n+\t\t\targscommonlist := strings.Join(argscommon, \", \")\n+\t\t\tcallcommon := fmt.Sprintf(\"call%s(%s)\", sysname, argscommonlist)\n+\t\t\tret := []string{\"_\", \"_\"}\n+\t\t\tbody := \"\"\n+\t\t\tdoErrno := false\n+\t\t\tfor i := 0; i < len(out); i++ {\n+\t\t\t\tp := parseParam(out[i])\n+\t\t\t\treg := \"\"\n+\t\t\t\tif p.Name == \"err\" {\n+\t\t\t\t\treg = \"e1\"\n+\t\t\t\t\tret[1] = reg\n+\t\t\t\t\tdoErrno = true\n+\t\t\t\t} else {\n+\t\t\t\t\treg = \"r0\"\n+\t\t\t\t\tret[0] = reg\n+\t\t\t\t}\n+\t\t\t\tif p.Type == \"bool\" {\n+\t\t\t\t\treg = fmt.Sprintf(\"%s != 0\", reg)\n+\t\t\t\t}\n+\t\t\t\tif reg != \"e1\" {\n+\t\t\t\t\tbody += fmt.Sprintf(\"\\t%s = %s(%s)\\n\", p.Name, p.Type, reg)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif ret[0] == \"_\" && ret[1] == \"_\" {\n+\t\t\t\ttextcommon += fmt.Sprintf(\"\\t%s\\n\", callcommon)\n+\t\t\t} else {\n+\t\t\t\ttextcommon += fmt.Sprintf(\"\\t%s, %s := %s\\n\", ret[0], ret[1], callcommon)\n+\t\t\t}\n+\t\t\ttextcommon += body\n+\n+\t\t\tif doErrno {\n+\t\t\t\ttextcommon += \"\\tif e1 != 0 {\\n\"\n+\t\t\t\ttextcommon += \"\\t\\terr = errnoErr(e1)\\n\"\n+\t\t\t\ttextcommon += \"\\t}\\n\"\n+\t\t\t}\n+\t\t\ttextcommon += \"\\treturn\\n\"\n+\t\t\ttextcommon += \"}\\n\"\n+\n+\t\t\tif onlyCommon {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// CALL Prototype\n+\t\t\tcallProto := fmt.Sprintf(\"func call%s(%s) (r1 uintptr, e1 Errno) {\\n\", sysname, strings.Join(argscall, \", \"))\n+\n+\t\t\t// GC function generation\n+\t\t\tasm := \"syscall6\"\n+\t\t\tif nonblock != nil {\n+\t\t\t\tasm = \"rawSyscall6\"\n+\t\t\t}\n+\n+\t\t\tif len(argsgc) <= 6 {\n+\t\t\t\tfor len(argsgc) < 6 {\n+\t\t\t\t\targsgc = append(argsgc, \"0\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: too many arguments to system call\", funct)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\targsgclist := strings.Join(argsgc, \", \")\n+\t\t\tcallgc := fmt.Sprintf(\"%s(uintptr(unsafe.Pointer(&%s)), %d, %s)\", asm, sysvarname, nargs, argsgclist)\n+\n+\t\t\ttextgc += callProto\n+\t\t\ttextgc += fmt.Sprintf(\"\\tr1, _, e1 = %s\\n\", callgc)\n+\t\t\ttextgc += \"\\treturn\\n}\\n\"\n+\n+\t\t\t// GCCGO function generation\n+\t\t\targsgccgolist := strings.Join(argsgccgo, \", \")\n+\t\t\tcallgccgo := fmt.Sprintf(\"C.%s(%s)\", sysname, argsgccgolist)\n+\t\t\ttextgccgo += callProto\n+\t\t\ttextgccgo += fmt.Sprintf(\"\\tr1 = uintptr(%s)\\n\", callgccgo)\n+\t\t\ttextgccgo += \"\\te1 = syscall.GetErrno()\\n\"\n+\t\t\ttextgccgo += \"\\treturn\\n}\\n\"\n+\t\t}\n+\t\tif err := s.Err(); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tfile.Close()\n+\t}\n+\timp := \"\"\n+\tif pack != \"unix\" {\n+\t\timp = \"import \\\"golang.org/x/sys/unix\\\"\\n\"\n+\n+\t}\n+\n+\t// Print zsyscall_aix_ppc64.go\n+\terr := ioutil.WriteFile(\"zsyscall_aix_ppc64.go\",\n+\t\t[]byte(fmt.Sprintf(srcTemplate1, cmdLine(), buildTags(), pack, imp, textcommon)),\n+\t\t0644)\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\tos.Exit(1)\n+\t}\n+\n+\t// Print zsyscall_aix_ppc64_gc.go\n+\tvardecls := \"\\t\" + strings.Join(vars, \",\\n\\t\")\n+\tvardecls += \" syscallFunc\"\n+\terr = ioutil.WriteFile(\"zsyscall_aix_ppc64_gc.go\",\n+\t\t[]byte(fmt.Sprintf(srcTemplate2, cmdLine(), buildTags(), pack, imp, dynimports, linknames, vardecls, textgc)),\n+\t\t0644)\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\tos.Exit(1)\n+\t}\n+\n+\t// Print zsyscall_aix_ppc64_gccgo.go\n+\terr = ioutil.WriteFile(\"zsyscall_aix_ppc64_gccgo.go\",\n+\t\t[]byte(fmt.Sprintf(srcTemplate3, cmdLine(), buildTags(), pack, cExtern, imp, textgccgo)),\n+\t\t0644)\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\tos.Exit(1)\n+\t}\n+}\n+\n+const srcTemplate1 = `// %s\n+// Code generated by the command above; see README.md. DO NOT EDIT.\n+\n+// +build %s\n+\n+package %s\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+\n+%s\n+\n+%s\n+`\n+const srcTemplate2 = `// %s\n+// Code generated by the command above; see README.md. DO NOT EDIT.\n+\n+// +build %s\n+// +build !gccgo\n+\n+package %s\n+\n+import (\n+\t\"unsafe\"\n+)\n+%s\n+%s\n+%s\n+type syscallFunc uintptr\n+\n+var (\n+%s\n+)\n+\n+// Implemented in runtime/syscall_aix.go.\n+func rawSyscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n+func syscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n+\n+%s\n+`\n+const srcTemplate3 = `// %s\n+// Code generated by the command above; see README.md. DO NOT EDIT.\n+\n+// +build %s\n+// +build gccgo\n+\n+package %s\n+\n+%s\n+*/\n+import \"C\"\n+import (\n+\t\"syscall\"\n+)\n+\n+\n+%s\n+\n+%s\n+`"
    },
    {
      "sha": "53df26bb93acbd6b9841e36ac47ef73f4654b7ad",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 579,
      "changes": 579,
      "blob_url": "https://github.com/umputun/remark/blob/24606e46bff1e4e06da449ecf149f4702ff9d36a/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl",
      "raw_url": "https://github.com/umputun/remark/raw/24606e46bff1e4e06da449ecf149f4702ff9d36a/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl?ref=24606e46bff1e4e06da449ecf149f4702ff9d36a",
      "patch": "@@ -1,579 +0,0 @@\n-#!/usr/bin/env perl\n-# Copyright 2018 The Go Authors. All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-# This program reads a file containing function prototypes\n-# (like syscall_aix.go) and generates system call bodies.\n-# The prototypes are marked by lines beginning with \"//sys\"\n-# and read like func declarations if //sys is replaced by func, but:\n-#\t* The parameter lists must give a name for each argument.\n-#\t  This includes return parameters.\n-#\t* The parameter lists must give a type for each argument:\n-#\t  the (x, y, z int) shorthand is not allowed.\n-#\t* If the return parameter is an error number, it must be named err.\n-#\t* If go func name needs to be different than its libc name,\n-#\t* or the function is not in libc, name could be specified\n-#\t* at the end, after \"=\" sign, like\n-#\t  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt\n-\n-# This program will generate three files and handle both gc and gccgo implementation:\n-#   - zsyscall_aix_ppc64.go: the common part of each implementation (error handler, pointer creation)\n-#   - zsyscall_aix_ppc64_gc.go: gc part with //go_cgo_import_dynamic and a call to syscall6\n-#   - zsyscall_aix_ppc64_gccgo.go: gccgo part with C function and conversion to C type.\n-\n-# The generated code looks like this\n-#\n-# zsyscall_aix_ppc64.go\n-# func asyscall(...) (n int, err error) {\n-#\t  // Pointer Creation\n-#\t  r1, e1 := callasyscall(...)\n-#\t  // Type Conversion\n-#\t  // Error Handler\n-#\t  return\n-# }\n-#\n-# zsyscall_aix_ppc64_gc.go\n-# //go:cgo_import_dynamic libc_asyscall asyscall \"libc.a/shr_64.o\"\n-# //go:linkname libc_asyscall libc_asyscall\n-# var asyscall syscallFunc\n-#\n-# func callasyscall(...) (r1 uintptr, e1 Errno) {\n-#\t  r1, _, e1 = syscall6(uintptr(unsafe.Pointer(&libc_asyscall)), \"nb_args\", ... )\n-#\t  return\n-# }\n-#\n-# zsyscall_aix_ppc64_ggcgo.go\n-# /*\n-#  int asyscall(...)\n-#\n-# */\n-# import \"C\"\n-#\n-# func callasyscall(...) (r1 uintptr, e1 Errno) {\n-#\t  r1 = uintptr(C.asyscall(...))\n-#\t  e1 = syscall.GetErrno()\n-#\t  return\n-# }\n-\n-\n-\n-use strict;\n-\n-my $cmdline = \"mksyscall_aix_ppc64.pl \" . join(' ', @ARGV);\n-my $errors = 0;\n-my $_32bit = \"\";\n-my $tags = \"\";  # build tags\n-my $aix = 0;\n-my $solaris = 0;\n-\n-binmode STDOUT;\n-\n-if($ARGV[0] eq \"-b32\") {\n-\t$_32bit = \"big-endian\";\n-\tshift;\n-} elsif($ARGV[0] eq \"-l32\") {\n-\t$_32bit = \"little-endian\";\n-\tshift;\n-}\n-if($ARGV[0] eq \"-aix\") {\n-\t$aix = 1;\n-\tshift;\n-}\n-if($ARGV[0] eq \"-tags\") {\n-\tshift;\n-\t$tags = $ARGV[0];\n-\tshift;\n-}\n-\n-if($ARGV[0] =~ /^-/) {\n-\tprint STDERR \"usage: mksyscall_aix.pl [-b32 | -l32] [-tags x,y] [file ...]\\n\";\n-\texit 1;\n-}\n-\n-sub parseparamlist($) {\n-\tmy ($list) = @_;\n-\t$list =~ s/^\\s*//;\n-\t$list =~ s/\\s*$//;\n-\tif($list eq \"\") {\n-\t\treturn ();\n-\t}\n-\treturn split(/\\s*,\\s*/, $list);\n-}\n-\n-sub parseparam($) {\n-\tmy ($p) = @_;\n-\tif($p !~ /^(\\S*) (\\S*)$/) {\n-\t\tprint STDERR \"$ARGV:$.: malformed parameter: $p\\n\";\n-\t\t$errors = 1;\n-\t\treturn (\"xx\", \"int\");\n-\t}\n-\treturn ($1, $2);\n-}\n-\n-my $package = \"\";\n-# GCCGO\n-my $textgccgo = \"\";\n-my $c_extern = \"/*\\n#include <stdint.h>\\n\";\n-# GC\n-my $textgc = \"\";\n-my $dynimports = \"\";\n-my $linknames = \"\";\n-my @vars = ();\n-# COMMUN\n-my $textcommon = \"\";\n-\n-while(<>) {\n-\tchomp;\n-\ts/\\s+/ /g;\n-\ts/^\\s+//;\n-\ts/\\s+$//;\n-\t$package = $1 if !$package && /^package (\\S+)$/;\n-\tmy $nonblock = /^\\/\\/sysnb /;\n-\tnext if !/^\\/\\/sys / && !$nonblock;\n-\n-\t# Line must be of the form\n-\t# func Open(path string, mode int, perm int) (fd int, err error)\n-\t# Split into name, in params, out params.\n-\tif(!/^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*(?:(\\w*)\\.)?(\\w*))?$/) {\n-\t\tprint STDERR \"$ARGV:$.: malformed //sys declaration\\n\";\n-\t\t$errors = 1;\n-\t\tnext;\n-\t}\n-\tmy ($nb, $func, $in, $out, $modname, $sysname) = ($1, $2, $3, $4, $5, $6);\n-\n-\t# Split argument lists on comma.\n-\tmy @in = parseparamlist($in);\n-\tmy @out = parseparamlist($out);\n-\n-\t$in = join(', ', @in);\n-\t$out = join(', ', @out);\n-\n-\tif($sysname eq \"\") {\n-\t\t$sysname = \"$func\";\n-\t}\n-\n-\tmy $onlyCommon = 0;\n-\tif ($func eq \"readlen\" || $func eq \"writelen\" || $func eq \"FcntlInt\" || $func eq \"FcntlFlock\") {\n-\t\t# This function call another syscall which is already implemented.\n-\t\t# Therefore, the gc and gccgo part must not be generated.\n-\t\t$onlyCommon = 1\n-\t}\n-\n-\t# Try in vain to keep people from editing this file.\n-\t# The theory is that they jump into the middle of the file\n-\t# without reading the header.\n-\n-\t$textcommon .= \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\";\n-\tif (!$onlyCommon) {\n-\t\t$textgccgo .= \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\";\n-\t\t$textgc .= \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\";\n-\t}\n-\n-\n-\t# Check if value return, err return available\n-\tmy $errvar = \"\";\n-\tmy $retvar = \"\";\n-\tmy $rettype = \"\";\n-\tforeach my $p (@out) {\n-\t\tmy ($name, $type) = parseparam($p);\n-\t\tif($type eq \"error\") {\n-\t\t\t$errvar = $name;\n-\t\t} else {\n-\t\t\t$retvar = $name;\n-\t\t\t$rettype = $type;\n-\t\t}\n-\t}\n-\n-\n-\t$sysname =~ s/([a-z])([A-Z])/${1}_$2/g;\n-\t$sysname =~ y/A-Z/a-z/; # All libc functions are lowercase.\n-\n-\t# GCCGO Prototype return type\n-\tmy $C_rettype = \"\";\n-\tif($rettype eq \"unsafe.Pointer\") {\n-\t\t$C_rettype = \"uintptr_t\";\n-\t} elsif($rettype eq \"uintptr\") {\n-\t\t$C_rettype = \"uintptr_t\";\n-\t} elsif($rettype =~ /^_/) {\n-\t\t$C_rettype = \"uintptr_t\";\n-\t} elsif($rettype eq \"int\") {\n-\t\t$C_rettype = \"int\";\n-\t} elsif($rettype eq \"int32\") {\n-\t\t$C_rettype = \"int\";\n-\t} elsif($rettype eq \"int64\") {\n-\t\t$C_rettype = \"long long\";\n-\t} elsif($rettype eq \"uint32\") {\n-\t\t$C_rettype = \"unsigned int\";\n-\t} elsif($rettype eq \"uint64\") {\n-\t\t$C_rettype = \"unsigned long long\";\n-\t} else {\n-\t\t$C_rettype = \"int\";\n-\t}\n-\tif($sysname eq \"exit\") {\n-\t\t$C_rettype = \"void\";\n-\t}\n-\n-\t# GCCGO Prototype arguments type\n-\tmy @c_in = ();\n-\tforeach my $i (0 .. $#in) {\n-\t\tmy ($name, $type) = parseparam($in[$i]);\n-\t\tif($type =~ /^\\*/) {\n-\t\t\tpush @c_in, \"uintptr_t\";\n-\t\t\t} elsif($type eq \"string\") {\n-\t\t\tpush @c_in, \"uintptr_t\";\n-\t\t} elsif($type =~ /^\\[\\](.*)/) {\n-\t\t\tpush @c_in, \"uintptr_t\", \"size_t\";\n-\t\t} elsif($type eq \"unsafe.Pointer\") {\n-\t\t\tpush @c_in, \"uintptr_t\";\n-\t\t} elsif($type eq \"uintptr\") {\n-\t\t\tpush @c_in, \"uintptr_t\";\n-\t\t} elsif($type =~ /^_/) {\n-\t\t\tpush @c_in, \"uintptr_t\";\n-\t\t} elsif($type eq \"int\") {\n-\t\t\tif (($i == 0 || $i == 2) && $func eq \"fcntl\"){\n-\t\t\t\t# These fcntl arguments needs to be uintptr to be able to call FcntlInt and FcntlFlock\n-\t\t\t\tpush @c_in, \"uintptr_t\";\n-\t\t\t} else {\n-\t\t\t\tpush @c_in, \"int\";\n-\t\t\t}\n-\t\t} elsif($type eq \"int32\") {\n-\t\t\tpush @c_in, \"int\";\n-\t\t} elsif($type eq \"int64\") {\n-\t\t\tpush @c_in, \"long long\";\n-\t\t} elsif($type eq \"uint32\") {\n-\t\t\tpush @c_in, \"unsigned int\";\n-\t\t} elsif($type eq \"uint64\") {\n-\t\t\tpush @c_in, \"unsigned long long\";\n-\t\t} else {\n-\t\t\tpush @c_in, \"int\";\n-\t\t}\n-\t}\n-\n-\tif (!$onlyCommon){\n-\t\t# GCCGO Prototype Generation\n-\t\t# Imports of system calls from libc\n-\t\t$c_extern .= \"$C_rettype $sysname\";\n-\t\tmy $c_in = join(', ', @c_in);\n-\t\t$c_extern .= \"($c_in);\\n\";\n-\t}\n-\n-\t# GC Library name\n-\tif($modname eq \"\") {\n-\t\t$modname = \"libc.a/shr_64.o\";\n-\t} else {\n-\t\tprint STDERR \"$func: only syscall using libc are available\\n\";\n-\t\t$errors = 1;\n-\t\tnext;\n-\t}\n-\tmy $sysvarname = \"libc_${sysname}\";\n-\n-\tif (!$onlyCommon){\n-\t\t# GC Runtime import of function to allow cross-platform builds.\n-\t\t$dynimports .= \"//go:cgo_import_dynamic ${sysvarname} ${sysname} \\\"$modname\\\"\\n\";\n-\t\t# GC Link symbol to proc address variable.\n-\t\t$linknames .= \"//go:linkname ${sysvarname} ${sysvarname}\\n\";\n-\t\t# GC Library proc address variable.\n-\t\tpush @vars, $sysvarname;\n-\t}\n-\n-\tmy $strconvfunc =\"BytePtrFromString\";\n-\tmy $strconvtype = \"*byte\";\n-\n-\t# Go function header.\n-\tif($out ne \"\") {\n-\t\t$out = \" ($out)\";\n-\t}\n-\tif($textcommon ne \"\") {\n-\t\t$textcommon .= \"\\n\"\n-\t}\n-\n-\t$textcommon .= sprintf \"func %s(%s)%s {\\n\", $func, join(', ', @in), $out ;\n-\n-\t# Prepare arguments to call.\n-\tmy @argscommun = (); # Arguments in the commun part\n-\tmy @argscall = ();   # Arguments for call prototype\n-\tmy @argsgc = ();     # Arguments for gc call (with syscall6)\n-\tmy @argsgccgo = ();  # Arguments for gccgo call (with C.name_of_syscall)\n-\tmy $n = 0;\n-\tmy $arg_n = 0;\n-\tforeach my $p (@in) {\n-\t\tmy ($name, $type) = parseparam($p);\n-\t\tif($type =~ /^\\*/) {\n-\t\t\tpush @argscommun, \"uintptr(unsafe.Pointer($name))\";\n-\t\t\tpush @argscall, \"$name uintptr\";\n-\t\t\tpush @argsgc, \"$name\";\n-\t\t\tpush @argsgccgo, \"C.uintptr_t($name)\";\n-\t\t} elsif($type eq \"string\" && $errvar ne \"\") {\n-\t\t\t$textcommon .= \"\\tvar _p$n $strconvtype\\n\";\n-\t\t\t$textcommon .= \"\\t_p$n, $errvar = $strconvfunc($name)\\n\";\n-\t\t\t$textcommon .= \"\\tif $errvar != nil {\\n\\t\\treturn\\n\\t}\\n\";\n-\n-\t\t\tpush @argscommun, \"uintptr(unsafe.Pointer(_p$n))\";\n-\t\t\tpush @argscall, \"_p$n uintptr \";\n-\t\t\tpush @argsgc, \"_p$n\";\n-\t\t\tpush @argsgccgo, \"C.uintptr_t(_p$n)\";\n-\t\t\t$n++;\n-\t\t} elsif($type eq \"string\") {\n-\t\t\tprint STDERR \"$ARGV:$.: $func uses string arguments, but has no error return\\n\";\n-\t\t\t$textcommon .= \"\\tvar _p$n $strconvtype\\n\";\n-\t\t\t$textcommon .= \"\\t_p$n, $errvar = $strconvfunc($name)\\n\";\n-\t\t\t$textcommon .= \"\\tif $errvar != nil {\\n\\t\\treturn\\n\\t}\\n\";\n-\n-\t\t\tpush @argscommun, \"uintptr(unsafe.Pointer(_p$n))\";\n-\t\t\tpush @argscall, \"_p$n uintptr\";\n-\t\t\tpush @argsgc, \"_p$n\";\n-\t\t\tpush @argsgccgo, \"C.uintptr_t(_p$n)\";\n-\t\t\t$n++;\n-\t\t} elsif($type =~ /^\\[\\](.*)/) {\n-\t\t\t# Convert slice into pointer, length.\n-\t\t\t# Have to be careful not to take address of &a[0] if len == 0:\n-\t\t\t# pass nil in that case.\n-\t\t\t$textcommon .= \"\\tvar _p$n *$1\\n\";\n-\t\t\t$textcommon .= \"\\tif len($name) > 0 {\\n\\t\\t_p$n = \\&$name\\[0]\\n\\t}\\n\";\n-\t\t\tpush @argscommun, \"uintptr(unsafe.Pointer(_p$n))\", \"len($name)\";\n-\t\t\tpush @argscall, \"_p$n uintptr\", \"_lenp$n int\";\n-\t\t\tpush @argsgc, \"_p$n\", \"uintptr(_lenp$n)\";\n-\t\t\tpush @argsgccgo, \"C.uintptr_t(_p$n)\", \"C.size_t(_lenp$n)\";\n-\t\t\t$n++;\n-\t\t} elsif($type eq \"int64\" && $_32bit ne \"\") {\n-\t\t\tprint STDERR \"$ARGV:$.: $func uses int64 with 32 bits mode. Case not yet implemented\\n\";\n-\t\t\t# if($_32bit eq \"big-endian\") {\n-\t\t\t# \tpush @args, \"uintptr($name >> 32)\", \"uintptr($name)\";\n-\t\t\t# } else {\n-\t\t\t# \tpush @args, \"uintptr($name)\", \"uintptr($name >> 32)\";\n-\t\t\t# }\n-\t\t\t# $n++;\n-\t\t} elsif($type eq \"bool\") {\n-\t\t\tprint STDERR \"$ARGV:$.: $func uses bool. Case not yet implemented\\n\";\n-\t\t\t# $text .= \"\\tvar _p$n uint32\\n\";\n-\t\t\t# $text .= \"\\tif $name {\\n\\t\\t_p$n = 1\\n\\t} else {\\n\\t\\t_p$n = 0\\n\\t}\\n\";\n-\t\t\t# push @args, \"_p$n\";\n-\t\t\t# $n++;\n-\t\t} elsif($type =~ /^_/ ||$type eq \"unsafe.Pointer\") {\n-\t\t\tpush @argscommun, \"uintptr($name)\";\n-\t\t\tpush @argscall, \"$name uintptr\";\n-\t\t\tpush @argsgc, \"$name\";\n-\t\t\tpush @argsgccgo, \"C.uintptr_t($name)\";\n-\t\t} elsif($type eq \"int\") {\n-\t\t\tif (($arg_n == 0 || $arg_n == 2) && ($func eq \"fcntl\" || $func eq \"FcntlInt\" || $func eq \"FcntlFlock\")) {\n-\t\t\t\t# These fcntl arguments need to be uintptr to be able to call FcntlInt and FcntlFlock\n-\t\t\t\tpush @argscommun, \"uintptr($name)\";\n-\t\t\t\tpush @argscall, \"$name uintptr\";\n-\t\t\t\tpush @argsgc, \"$name\";\n-\t\t\t\tpush @argsgccgo, \"C.uintptr_t($name)\";\n-\t\t\t} else {\n-\t\t\t\tpush @argscommun, \"$name\";\n-\t\t\t\tpush @argscall, \"$name int\";\n-\t\t\t\tpush @argsgc, \"uintptr($name)\";\n-\t\t\t\tpush @argsgccgo, \"C.int($name)\";\n-\t\t\t}\n-\t\t} elsif($type eq \"int32\") {\n-\t\t\tpush @argscommun, \"$name\";\n-\t\t\tpush @argscall, \"$name int32\";\n-\t\t\tpush @argsgc, \"uintptr($name)\";\n-\t\t\tpush @argsgccgo, \"C.int($name)\";\n-\t\t} elsif($type eq \"int64\") {\n-\t\t\tpush @argscommun, \"$name\";\n-\t\t\tpush @argscall, \"$name int64\";\n-\t\t\tpush @argsgc, \"uintptr($name)\";\n-\t\t\tpush @argsgccgo, \"C.longlong($name)\";\n-\t\t} elsif($type eq \"uint32\") {\n-\t\t\tpush @argscommun, \"$name\";\n-\t\t\tpush @argscall, \"$name uint32\";\n-\t\t\tpush @argsgc, \"uintptr($name)\";\n-\t\t\tpush @argsgccgo, \"C.uint($name)\";\n-\t\t} elsif($type eq \"uint64\") {\n-\t\t\tpush @argscommun, \"$name\";\n-\t\t\tpush @argscall, \"$name uint64\";\n-\t\t\tpush @argsgc, \"uintptr($name)\";\n-\t\t\tpush @argsgccgo, \"C.ulonglong($name)\";\n-\t\t} elsif($type eq \"uintptr\") {\n-\t\t\tpush @argscommun, \"$name\";\n-\t\t\tpush @argscall, \"$name uintptr\";\n-\t\t\tpush @argsgc, \"$name\";\n-\t\t\tpush @argsgccgo, \"C.uintptr_t($name)\";\n-\t\t} else {\n-\t\t\tpush @argscommun, \"int($name)\";\n-\t\t\tpush @argscall, \"$name int\";\n-\t\t\tpush @argsgc, \"uintptr($name)\";\n-\t\t\tpush @argsgccgo, \"C.int($name)\";\n-\t\t}\n-\t\t$arg_n++;\n-\t}\n-\tmy $nargs = @argsgc;\n-\n-\t# COMMUN function generation\n-\tmy $argscommun = join(', ', @argscommun);\n-\tmy $callcommun = \"call$sysname($argscommun)\";\n-\tmy @ret = (\"_\", \"_\");\n-\tmy $body = \"\";\n-\tmy $do_errno = 0;\n-\tfor(my $i=0; $i<@out; $i++) {\n-\t\tmy $p = $out[$i];\n-\t\tmy ($name, $type) = parseparam($p);\n-\t\tmy $reg = \"\";\n-\t\tif($name eq \"err\") {\n-\t\t\t$reg = \"e1\";\n-\t\t\t$ret[1] = $reg;\n-\t\t\t$do_errno = 1;\n-\t\t} else {\n-\t\t\t$reg = \"r0\";\n-\t\t\t$ret[0] = $reg;\n-\t\t}\n-\t\tif($type eq \"bool\") {\n-\t\t\t$reg = \"$reg != 0\";\n-\t\t}\n-\t\tif($reg ne \"e1\") {\n-\t\t\t$body .= \"\\t$name = $type($reg)\\n\";\n-\t\t}\n-\t}\n-\tif ($ret[0] eq \"_\"  && $ret[1] eq \"_\") {\n-\t\t$textcommon .= \"\\t$callcommun\\n\";\n-\t} else {\n-\t\t$textcommon .= \"\\t$ret[0], $ret[1] := $callcommun\\n\";\n-\t}\n-\t$textcommon .= $body;\n-\n-\tif ($do_errno) {\n-\t\t$textcommon .= \"\\tif e1 != 0 {\\n\";\n-\t\t$textcommon .= \"\\t\\terr = errnoErr(e1)\\n\";\n-\t\t$textcommon .= \"\\t}\\n\";\n-\t}\n-\t$textcommon .= \"\\treturn\\n\";\n-\t$textcommon .= \"}\\n\";\n-\n-\tif ($onlyCommon){\n-\t\tnext\n-\t}\n-\t# CALL Prototype\n-\tmy $callProto = sprintf \"func call%s(%s) (r1 uintptr, e1 Errno) {\\n\", $sysname, join(', ', @argscall);\n-\n-\t# GC function generation\n-\tmy $asm = \"syscall6\";\n-\tif ($nonblock) {\n-\t\t$asm = \"rawSyscall6\";\n-\t}\n-\n-\tif(@argsgc <= 6) {\n-\t\twhile(@argsgc < 6) {\n-\t\t\tpush @argsgc, \"0\";\n-\t\t}\n-\t} else {\n-\t\tprint STDERR \"$ARGV:$.: too many arguments to system call\\n\";\n-\t}\n-\tmy $argsgc = join(', ', @argsgc);\n-\tmy $callgc = \"$asm(uintptr(unsafe.Pointer(&$sysvarname)), $nargs, $argsgc)\";\n-\n-\t$textgc .= $callProto;\n-\t$textgc .= \"\\tr1, _, e1 = $callgc\\n\";\n-\t$textgc .= \"\\treturn\\n}\\n\";\n-\n-\t# GCCGO function generation\n-\tmy $argsgccgo = join(', ', @argsgccgo);\n-\tmy $callgccgo = \"C.$sysname($argsgccgo)\";\n-\t$textgccgo .= $callProto;\n-\t$textgccgo .= \"\\tr1 = uintptr($callgccgo)\\n\";\n-\t$textgccgo .= \"\\te1 = syscall.GetErrno()\\n\";\n-\t$textgccgo .= \"\\treturn\\n}\\n\";\n-}\n-\n-if($errors) {\n-\texit 1;\n-}\n-\n-# Print zsyscall_aix_ppc64.go\n-open(my $fcommun, '>', 'zsyscall_aix_ppc64.go');\n-my $tofcommun = <<EOF;\n-// $cmdline\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build $tags\n-\n-package $package\n-\n-import (\n-\t\"unsafe\"\n-)\n-\n-EOF\n-\n-$tofcommun .= \"import \\\"golang.org/x/sys/unix\\\"\\n\" if $package ne \"unix\";\n-\n-$tofcommun .=<<EOF;\n-\n-$textcommon\n-EOF\n-print $fcommun $tofcommun;\n-\n-\n-# Print zsyscall_aix_ppc64_gc.go\n-open(my $fgc, '>', 'zsyscall_aix_ppc64_gc.go');\n-my $tofgc = <<EOF;\n-// $cmdline\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build $tags\n-// +build !gccgo\n-\n-package $package\n-\n-import (\n-\t\"unsafe\"\n-)\n-\n-\n-EOF\n-\n-$tofgc .= \"import \\\"golang.org/x/sys/unix\\\"\\n\" if $package ne \"unix\";\n-\n-my $vardecls = \"\\t\" . join(\",\\n\\t\", @vars);\n-$vardecls .= \" syscallFunc\";\n-\n-$tofgc .=<<EOF;\n-$dynimports\n-$linknames\n-type syscallFunc uintptr\n-\n-var (\n-$vardecls\n-)\n-\n-// Implemented in runtime/syscall_aix.go.\n-func rawSyscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n-func syscall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n-\n-$textgc\n-EOF\n-print $fgc $tofgc;\n-\n-# Print zsyscall_aix_ppc64_gc.go\n-open(my $fgccgo, '>', 'zsyscall_aix_ppc64_gccgo.go');\n-my $tofgccgo = <<EOF;\n-// $cmdline\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build $tags\n-// +build gccgo\n-\n-package $package\n-\n-\n-$c_extern\n-*/\n-import \"C\"\n-import (\n-\t\"syscall\"\n-)\n-\n-\n-EOF\n-\n-$tofgccgo .= \"import \\\"golang.org/x/sys/unix\\\"\\n\" if $package ne \"unix\";\n-\n-$tofgccgo .=<<EOF;\n-\n-$textgccgo\n-EOF\n-print $fgccgo $tofgccgo;\n-exit 0;"
    },
    {
      "sha": "3d864738b69594aaf1b7e60e6c191ac9168039b2",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go",
      "status": "added",
      "additions": 335,
      "deletions": 0,
      "changes": 335,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,335 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+/*\n+ This program reads a file containing function prototypes\n+ (like syscall_solaris.go) and generates system call bodies.\n+ The prototypes are marked by lines beginning with \"//sys\"\n+ and read like func declarations if //sys is replaced by func, but:\n+\t* The parameter lists must give a name for each argument.\n+\t  This includes return parameters.\n+\t* The parameter lists must give a type for each argument:\n+\t  the (x, y, z int) shorthand is not allowed.\n+\t* If the return parameter is an error number, it must be named err.\n+\t* If go func name needs to be different than its libc name,\n+\t* or the function is not in libc, name could be specified\n+\t* at the end, after \"=\" sign, like\n+\t  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt\n+*/\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"strings\"\n+)\n+\n+var (\n+\tb32  = flag.Bool(\"b32\", false, \"32bit big-endian\")\n+\tl32  = flag.Bool(\"l32\", false, \"32bit little-endian\")\n+\ttags = flag.String(\"tags\", \"\", \"build tags\")\n+)\n+\n+// cmdLine returns this programs's commandline arguments\n+func cmdLine() string {\n+\treturn \"go run mksyscall_solaris.go \" + strings.Join(os.Args[1:], \" \")\n+}\n+\n+// buildTags returns build tags\n+func buildTags() string {\n+\treturn *tags\n+}\n+\n+// Param is function parameter\n+type Param struct {\n+\tName string\n+\tType string\n+}\n+\n+// usage prints the program usage\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: go run mksyscall_solaris.go [-b32 | -l32] [-tags x,y] [file ...]\\n\")\n+\tos.Exit(1)\n+}\n+\n+// parseParamList parses parameter list and returns a slice of parameters\n+func parseParamList(list string) []string {\n+\tlist = strings.TrimSpace(list)\n+\tif list == \"\" {\n+\t\treturn []string{}\n+\t}\n+\treturn regexp.MustCompile(`\\s*,\\s*`).Split(list, -1)\n+}\n+\n+// parseParam splits a parameter into name and type\n+func parseParam(p string) Param {\n+\tps := regexp.MustCompile(`^(\\S*) (\\S*)$`).FindStringSubmatch(p)\n+\tif ps == nil {\n+\t\tfmt.Fprintf(os.Stderr, \"malformed parameter: %s\\n\", p)\n+\t\tos.Exit(1)\n+\t}\n+\treturn Param{ps[1], ps[2]}\n+}\n+\n+func main() {\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\tif len(flag.Args()) <= 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"no files to parse provided\\n\")\n+\t\tusage()\n+\t}\n+\n+\tendianness := \"\"\n+\tif *b32 {\n+\t\tendianness = \"big-endian\"\n+\t} else if *l32 {\n+\t\tendianness = \"little-endian\"\n+\t}\n+\n+\tpack := \"\"\n+\ttext := \"\"\n+\tdynimports := \"\"\n+\tlinknames := \"\"\n+\tvar vars []string\n+\tfor _, path := range flag.Args() {\n+\t\tfile, err := os.Open(path)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\ts := bufio.NewScanner(file)\n+\t\tfor s.Scan() {\n+\t\t\tt := s.Text()\n+\t\t\tt = strings.TrimSpace(t)\n+\t\t\tt = regexp.MustCompile(`\\s+`).ReplaceAllString(t, ` `)\n+\t\t\tif p := regexp.MustCompile(`^package (\\S+)$`).FindStringSubmatch(t); p != nil && pack == \"\" {\n+\t\t\t\tpack = p[1]\n+\t\t\t}\n+\t\t\tnonblock := regexp.MustCompile(`^\\/\\/sysnb `).FindStringSubmatch(t)\n+\t\t\tif regexp.MustCompile(`^\\/\\/sys `).FindStringSubmatch(t) == nil && nonblock == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Line must be of the form\n+\t\t\t//\tfunc Open(path string, mode int, perm int) (fd int, err error)\n+\t\t\t// Split into name, in params, out params.\n+\t\t\tf := regexp.MustCompile(`^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*(?:(\\w*)\\.)?(\\w*))?$`).FindStringSubmatch(t)\n+\t\t\tif f == nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%s:%s\\nmalformed //sys declaration\\n\", path, t)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tfunct, inps, outps, modname, sysname := f[2], f[3], f[4], f[5], f[6]\n+\n+\t\t\t// Split argument lists on comma.\n+\t\t\tin := parseParamList(inps)\n+\t\t\tout := parseParamList(outps)\n+\n+\t\t\tinps = strings.Join(in, \", \")\n+\t\t\toutps = strings.Join(out, \", \")\n+\n+\t\t\t// Try in vain to keep people from editing this file.\n+\t\t\t// The theory is that they jump into the middle of the file\n+\t\t\t// without reading the header.\n+\t\t\ttext += \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\"\n+\n+\t\t\t// So file name.\n+\t\t\tif modname == \"\" {\n+\t\t\t\tmodname = \"libc\"\n+\t\t\t}\n+\n+\t\t\t// System call name.\n+\t\t\tif sysname == \"\" {\n+\t\t\t\tsysname = funct\n+\t\t\t}\n+\n+\t\t\t// System call pointer variable name.\n+\t\t\tsysvarname := fmt.Sprintf(\"proc%s\", sysname)\n+\n+\t\t\tstrconvfunc := \"BytePtrFromString\"\n+\t\t\tstrconvtype := \"*byte\"\n+\n+\t\t\tsysname = strings.ToLower(sysname) // All libc functions are lowercase.\n+\n+\t\t\t// Runtime import of function to allow cross-platform builds.\n+\t\t\tdynimports += fmt.Sprintf(\"//go:cgo_import_dynamic libc_%s %s \\\"%s.so\\\"\\n\", sysname, sysname, modname)\n+\t\t\t// Link symbol to proc address variable.\n+\t\t\tlinknames += fmt.Sprintf(\"//go:linkname %s libc_%s\\n\", sysvarname, sysname)\n+\t\t\t// Library proc address variable.\n+\t\t\tvars = append(vars, sysvarname)\n+\n+\t\t\t// Go function header.\n+\t\t\toutlist := strings.Join(out, \", \")\n+\t\t\tif outlist != \"\" {\n+\t\t\t\toutlist = fmt.Sprintf(\" (%s)\", outlist)\n+\t\t\t}\n+\t\t\tif text != \"\" {\n+\t\t\t\ttext += \"\\n\"\n+\t\t\t}\n+\t\t\ttext += fmt.Sprintf(\"func %s(%s)%s {\\n\", funct, strings.Join(in, \", \"), outlist)\n+\n+\t\t\t// Check if err return available\n+\t\t\terrvar := \"\"\n+\t\t\tfor _, param := range out {\n+\t\t\t\tp := parseParam(param)\n+\t\t\t\tif p.Type == \"error\" {\n+\t\t\t\t\terrvar = p.Name\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Prepare arguments to Syscall.\n+\t\t\tvar args []string\n+\t\t\tn := 0\n+\t\t\tfor _, param := range in {\n+\t\t\t\tp := parseParam(param)\n+\t\t\t\tif regexp.MustCompile(`^\\*`).FindStringSubmatch(p.Type) != nil {\n+\t\t\t\t\targs = append(args, \"uintptr(unsafe.Pointer(\"+p.Name+\"))\")\n+\t\t\t\t} else if p.Type == \"string\" && errvar != \"\" {\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d, %s = %s(%s)\\n\", n, errvar, strconvfunc, p.Name)\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\tif %s != nil {\\n\\t\\treturn\\n\\t}\\n\", errvar)\n+\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n+\t\t\t\t\tn++\n+\t\t\t\t} else if p.Type == \"string\" {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, path+\":\"+funct+\" uses string arguments, but has no error return\\n\")\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d %s\\n\", n, strconvtype)\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\t_p%d, _ = %s(%s)\\n\", n, strconvfunc, p.Name)\n+\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n))\n+\t\t\t\t\tn++\n+\t\t\t\t} else if s := regexp.MustCompile(`^\\[\\](.*)`).FindStringSubmatch(p.Type); s != nil {\n+\t\t\t\t\t// Convert slice into pointer, length.\n+\t\t\t\t\t// Have to be careful not to take address of &a[0] if len == 0:\n+\t\t\t\t\t// pass nil in that case.\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d *%s\\n\", n, s[1])\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\tif len(%s) > 0 {\\n\\t\\t_p%d = &%s[0]\\n\\t}\\n\", p.Name, n, p.Name)\n+\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(unsafe.Pointer(_p%d))\", n), fmt.Sprintf(\"uintptr(len(%s))\", p.Name))\n+\t\t\t\t\tn++\n+\t\t\t\t} else if p.Type == \"int64\" && endianness != \"\" {\n+\t\t\t\t\tif endianness == \"big-endian\" {\n+\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s>>32)\", p.Name), fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name), fmt.Sprintf(\"uintptr(%s>>32)\", p.Name))\n+\t\t\t\t\t}\n+\t\t\t\t} else if p.Type == \"bool\" {\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\tvar _p%d uint32\\n\", n)\n+\t\t\t\t\ttext += fmt.Sprintf(\"\\tif %s {\\n\\t\\t_p%d = 1\\n\\t} else {\\n\\t\\t_p%d = 0\\n\\t}\\n\", p.Name, n, n)\n+\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(_p%d)\", n))\n+\t\t\t\t\tn++\n+\t\t\t\t} else {\n+\t\t\t\t\targs = append(args, fmt.Sprintf(\"uintptr(%s)\", p.Name))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tnargs := len(args)\n+\n+\t\t\t// Determine which form to use; pad args with zeros.\n+\t\t\tasm := \"sysvicall6\"\n+\t\t\tif nonblock != nil {\n+\t\t\t\tasm = \"rawSysvicall6\"\n+\t\t\t}\n+\t\t\tif len(args) <= 6 {\n+\t\t\t\tfor len(args) < 6 {\n+\t\t\t\t\targs = append(args, \"0\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: too many arguments to system call\\n\", path)\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\n+\t\t\t// Actual call.\n+\t\t\targlist := strings.Join(args, \", \")\n+\t\t\tcall := fmt.Sprintf(\"%s(uintptr(unsafe.Pointer(&%s)), %d, %s)\", asm, sysvarname, nargs, arglist)\n+\n+\t\t\t// Assign return values.\n+\t\t\tbody := \"\"\n+\t\t\tret := []string{\"_\", \"_\", \"_\"}\n+\t\t\tdoErrno := false\n+\t\t\tfor i := 0; i < len(out); i++ {\n+\t\t\t\tp := parseParam(out[i])\n+\t\t\t\treg := \"\"\n+\t\t\t\tif p.Name == \"err\" {\n+\t\t\t\t\treg = \"e1\"\n+\t\t\t\t\tret[2] = reg\n+\t\t\t\t\tdoErrno = true\n+\t\t\t\t} else {\n+\t\t\t\t\treg = fmt.Sprintf(\"r%d\", i)\n+\t\t\t\t\tret[i] = reg\n+\t\t\t\t}\n+\t\t\t\tif p.Type == \"bool\" {\n+\t\t\t\t\treg = fmt.Sprintf(\"%d != 0\", reg)\n+\t\t\t\t}\n+\t\t\t\tif p.Type == \"int64\" && endianness != \"\" {\n+\t\t\t\t\t// 64-bit number in r1:r0 or r0:r1.\n+\t\t\t\t\tif i+2 > len(out) {\n+\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: not enough registers for int64 return\\n\", path)\n+\t\t\t\t\t\tos.Exit(1)\n+\t\t\t\t\t}\n+\t\t\t\t\tif endianness == \"big-endian\" {\n+\t\t\t\t\t\treg = fmt.Sprintf(\"int64(r%d)<<32 | int64(r%d)\", i, i+1)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treg = fmt.Sprintf(\"int64(r%d)<<32 | int64(r%d)\", i+1, i)\n+\t\t\t\t\t}\n+\t\t\t\t\tret[i] = fmt.Sprintf(\"r%d\", i)\n+\t\t\t\t\tret[i+1] = fmt.Sprintf(\"r%d\", i+1)\n+\t\t\t\t}\n+\t\t\t\tif reg != \"e1\" {\n+\t\t\t\t\tbody += fmt.Sprintf(\"\\t%s = %s(%s)\\n\", p.Name, p.Type, reg)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif ret[0] == \"_\" && ret[1] == \"_\" && ret[2] == \"_\" {\n+\t\t\t\ttext += fmt.Sprintf(\"\\t%s\\n\", call)\n+\t\t\t} else {\n+\t\t\t\ttext += fmt.Sprintf(\"\\t%s, %s, %s := %s\\n\", ret[0], ret[1], ret[2], call)\n+\t\t\t}\n+\t\t\ttext += body\n+\n+\t\t\tif doErrno {\n+\t\t\t\ttext += \"\\tif e1 != 0 {\\n\"\n+\t\t\t\ttext += \"\\t\\terr = e1\\n\"\n+\t\t\t\ttext += \"\\t}\\n\"\n+\t\t\t}\n+\t\t\ttext += \"\\treturn\\n\"\n+\t\t\ttext += \"}\\n\"\n+\t\t}\n+\t\tif err := s.Err(); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, err.Error())\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tfile.Close()\n+\t}\n+\timp := \"\"\n+\tif pack != \"unix\" {\n+\t\timp = \"import \\\"golang.org/x/sys/unix\\\"\\n\"\n+\n+\t}\n+\tvardecls := \"\\t\" + strings.Join(vars, \",\\n\\t\")\n+\tvardecls += \" syscallFunc\"\n+\tfmt.Printf(srcTemplate, cmdLine(), buildTags(), pack, imp, dynimports, linknames, vardecls, text)\n+}\n+\n+const srcTemplate = `// %s\n+// Code generated by the command above; see README.md. DO NOT EDIT.\n+\n+// +build %s\n+\n+package %s\n+\n+import (\n+\t\"syscall\"\n+\t\"unsafe\"\n+)\n+%s\n+%s\n+%s\n+var (\n+%s\t\n+)\n+\n+%s\n+`"
    },
    {
      "sha": "a354df5a6bfd678cb722ccd7ed0795f7c94ac4c2",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 294,
      "changes": 294,
      "blob_url": "https://github.com/umputun/remark/blob/24606e46bff1e4e06da449ecf149f4702ff9d36a/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl",
      "raw_url": "https://github.com/umputun/remark/raw/24606e46bff1e4e06da449ecf149f4702ff9d36a/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl?ref=24606e46bff1e4e06da449ecf149f4702ff9d36a",
      "patch": "@@ -1,294 +0,0 @@\n-#!/usr/bin/env perl\n-# Copyright 2009 The Go Authors. All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-# This program reads a file containing function prototypes\n-# (like syscall_solaris.go) and generates system call bodies.\n-# The prototypes are marked by lines beginning with \"//sys\"\n-# and read like func declarations if //sys is replaced by func, but:\n-#\t* The parameter lists must give a name for each argument.\n-#\t  This includes return parameters.\n-#\t* The parameter lists must give a type for each argument:\n-#\t  the (x, y, z int) shorthand is not allowed.\n-#\t* If the return parameter is an error number, it must be named err.\n-#\t* If go func name needs to be different than its libc name,\n-#\t* or the function is not in libc, name could be specified\n-#\t* at the end, after \"=\" sign, like\n-#\t  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt\n-\n-use strict;\n-\n-my $cmdline = \"mksyscall_solaris.pl \" . join(' ', @ARGV);\n-my $errors = 0;\n-my $_32bit = \"\";\n-my $tags = \"\";  # build tags\n-\n-binmode STDOUT;\n-\n-if($ARGV[0] eq \"-b32\") {\n-\t$_32bit = \"big-endian\";\n-\tshift;\n-} elsif($ARGV[0] eq \"-l32\") {\n-\t$_32bit = \"little-endian\";\n-\tshift;\n-}\n-if($ARGV[0] eq \"-tags\") {\n-\tshift;\n-\t$tags = $ARGV[0];\n-\tshift;\n-}\n-\n-if($ARGV[0] =~ /^-/) {\n-\tprint STDERR \"usage: mksyscall_solaris.pl [-b32 | -l32] [-tags x,y] [file ...]\\n\";\n-\texit 1;\n-}\n-\n-sub parseparamlist($) {\n-\tmy ($list) = @_;\n-\t$list =~ s/^\\s*//;\n-\t$list =~ s/\\s*$//;\n-\tif($list eq \"\") {\n-\t\treturn ();\n-\t}\n-\treturn split(/\\s*,\\s*/, $list);\n-}\n-\n-sub parseparam($) {\n-\tmy ($p) = @_;\n-\tif($p !~ /^(\\S*) (\\S*)$/) {\n-\t\tprint STDERR \"$ARGV:$.: malformed parameter: $p\\n\";\n-\t\t$errors = 1;\n-\t\treturn (\"xx\", \"int\");\n-\t}\n-\treturn ($1, $2);\n-}\n-\n-my $package = \"\";\n-my $text = \"\";\n-my $dynimports = \"\";\n-my $linknames = \"\";\n-my @vars = ();\n-while(<>) {\n-\tchomp;\n-\ts/\\s+/ /g;\n-\ts/^\\s+//;\n-\ts/\\s+$//;\n-\t$package = $1 if !$package && /^package (\\S+)$/;\n-\tmy $nonblock = /^\\/\\/sysnb /;\n-\tnext if !/^\\/\\/sys / && !$nonblock;\n-\n-\t# Line must be of the form\n-\t#\tfunc Open(path string, mode int, perm int) (fd int, err error)\n-\t# Split into name, in params, out params.\n-\tif(!/^\\/\\/sys(nb)? (\\w+)\\(([^()]*)\\)\\s*(?:\\(([^()]+)\\))?\\s*(?:=\\s*(?:(\\w*)\\.)?(\\w*))?$/) {\n-\t\tprint STDERR \"$ARGV:$.: malformed //sys declaration\\n\";\n-\t\t$errors = 1;\n-\t\tnext;\n-\t}\n-\tmy ($nb, $func, $in, $out, $modname, $sysname) = ($1, $2, $3, $4, $5, $6);\n-\n-\t# Split argument lists on comma.\n-\tmy @in = parseparamlist($in);\n-\tmy @out = parseparamlist($out);\n-\n-\t# Try in vain to keep people from editing this file.\n-\t# The theory is that they jump into the middle of the file\n-\t# without reading the header.\n-\t$text .= \"// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\\n\\n\";\n-\n-\t# So file name.\n-\tif($modname eq \"\") {\n-\t\t$modname = \"libc\";\n-\t}\n-\n-\t# System call name.\n-\tif($sysname eq \"\") {\n-\t\t$sysname = \"$func\";\n-\t}\n-\n-\t# System call pointer variable name.\n-\tmy $sysvarname = \"proc$sysname\";\n-\n-\tmy $strconvfunc = \"BytePtrFromString\";\n-\tmy $strconvtype = \"*byte\";\n-\n-\t$sysname =~ y/A-Z/a-z/; # All libc functions are lowercase.\n-\n-\t# Runtime import of function to allow cross-platform builds.\n-\t$dynimports .= \"//go:cgo_import_dynamic libc_${sysname} ${sysname} \\\"$modname.so\\\"\\n\";\n-\t# Link symbol to proc address variable.\n-\t$linknames .= \"//go:linkname ${sysvarname} libc_${sysname}\\n\";\n-\t# Library proc address variable.\n-\tpush @vars, $sysvarname;\n-\n-\t# Go function header.\n-\t$out = join(', ', @out);\n-\tif($out ne \"\") {\n-\t\t$out = \" ($out)\";\n-\t}\n-\tif($text ne \"\") {\n-\t\t$text .= \"\\n\"\n-\t}\n-\t$text .= sprintf \"func %s(%s)%s {\\n\", $func, join(', ', @in), $out;\n-\n-\t# Check if err return available\n-\tmy $errvar = \"\";\n-\tforeach my $p (@out) {\n-\t\tmy ($name, $type) = parseparam($p);\n-\t\tif($type eq \"error\") {\n-\t\t\t$errvar = $name;\n-\t\t\tlast;\n-\t\t}\n-\t}\n-\n-\t# Prepare arguments to Syscall.\n-\tmy @args = ();\n-\tmy $n = 0;\n-\tforeach my $p (@in) {\n-\t\tmy ($name, $type) = parseparam($p);\n-\t\tif($type =~ /^\\*/) {\n-\t\t\tpush @args, \"uintptr(unsafe.Pointer($name))\";\n-\t\t} elsif($type eq \"string\" && $errvar ne \"\") {\n-\t\t\t$text .= \"\\tvar _p$n $strconvtype\\n\";\n-\t\t\t$text .= \"\\t_p$n, $errvar = $strconvfunc($name)\\n\";\n-\t\t\t$text .= \"\\tif $errvar != nil {\\n\\t\\treturn\\n\\t}\\n\";\n-\t\t\tpush @args, \"uintptr(unsafe.Pointer(_p$n))\";\n-\t\t\t$n++;\n-\t\t} elsif($type eq \"string\") {\n-\t\t\tprint STDERR \"$ARGV:$.: $func uses string arguments, but has no error return\\n\";\n-\t\t\t$text .= \"\\tvar _p$n $strconvtype\\n\";\n-\t\t\t$text .= \"\\t_p$n, _ = $strconvfunc($name)\\n\";\n-\t\t\tpush @args, \"uintptr(unsafe.Pointer(_p$n))\";\n-\t\t\t$n++;\n-\t\t} elsif($type =~ /^\\[\\](.*)/) {\n-\t\t\t# Convert slice into pointer, length.\n-\t\t\t# Have to be careful not to take address of &a[0] if len == 0:\n-\t\t\t# pass nil in that case.\n-\t\t\t$text .= \"\\tvar _p$n *$1\\n\";\n-\t\t\t$text .= \"\\tif len($name) > 0 {\\n\\t\\t_p$n = \\&$name\\[0]\\n\\t}\\n\";\n-\t\t\tpush @args, \"uintptr(unsafe.Pointer(_p$n))\", \"uintptr(len($name))\";\n-\t\t\t$n++;\n-\t\t} elsif($type eq \"int64\" && $_32bit ne \"\") {\n-\t\t\tif($_32bit eq \"big-endian\") {\n-\t\t\t\tpush @args, \"uintptr($name >> 32)\", \"uintptr($name)\";\n-\t\t\t} else {\n-\t\t\t\tpush @args, \"uintptr($name)\", \"uintptr($name >> 32)\";\n-\t\t\t}\n-\t\t} elsif($type eq \"bool\") {\n- \t\t\t$text .= \"\\tvar _p$n uint32\\n\";\n-\t\t\t$text .= \"\\tif $name {\\n\\t\\t_p$n = 1\\n\\t} else {\\n\\t\\t_p$n = 0\\n\\t}\\n\";\n-\t\t\tpush @args, \"uintptr(_p$n)\";\n-\t\t\t$n++;\n-\t\t} else {\n-\t\t\tpush @args, \"uintptr($name)\";\n-\t\t}\n-\t}\n-\tmy $nargs = @args;\n-\n-\t# Determine which form to use; pad args with zeros.\n-\tmy $asm = \"sysvicall6\";\n-\tif ($nonblock) {\n-\t\t$asm = \"rawSysvicall6\";\n-\t}\n-\tif(@args <= 6) {\n-\t\twhile(@args < 6) {\n-\t\t\tpush @args, \"0\";\n-\t\t}\n-\t} else {\n-\t\tprint STDERR \"$ARGV:$.: too many arguments to system call\\n\";\n-\t}\n-\n-\t# Actual call.\n-\tmy $args = join(', ', @args);\n-\tmy $call = \"$asm(uintptr(unsafe.Pointer(&$sysvarname)), $nargs, $args)\";\n-\n-\t# Assign return values.\n-\tmy $body = \"\";\n-\tmy $failexpr = \"\";\n-\tmy @ret = (\"_\", \"_\", \"_\");\n-\tmy @pout= ();\n-\tmy $do_errno = 0;\n-\tfor(my $i=0; $i<@out; $i++) {\n-\t\tmy $p = $out[$i];\n-\t\tmy ($name, $type) = parseparam($p);\n-\t\tmy $reg = \"\";\n-\t\tif($name eq \"err\") {\n-\t\t\t$reg = \"e1\";\n-\t\t\t$ret[2] = $reg;\n-\t\t\t$do_errno = 1;\n-\t\t} else {\n-\t\t\t$reg = sprintf(\"r%d\", $i);\n-\t\t\t$ret[$i] = $reg;\n-\t\t}\n-\t\tif($type eq \"bool\") {\n-\t\t\t$reg = \"$reg != 0\";\n-\t\t}\n-\t\tif($type eq \"int64\" && $_32bit ne \"\") {\n-\t\t\t# 64-bit number in r1:r0 or r0:r1.\n-\t\t\tif($i+2 > @out) {\n-\t\t\t\tprint STDERR \"$ARGV:$.: not enough registers for int64 return\\n\";\n-\t\t\t}\n-\t\t\tif($_32bit eq \"big-endian\") {\n-\t\t\t\t$reg = sprintf(\"int64(r%d)<<32 | int64(r%d)\", $i, $i+1);\n-\t\t\t} else {\n-\t\t\t\t$reg = sprintf(\"int64(r%d)<<32 | int64(r%d)\", $i+1, $i);\n-\t\t\t}\n-\t\t\t$ret[$i] = sprintf(\"r%d\", $i);\n-\t\t\t$ret[$i+1] = sprintf(\"r%d\", $i+1);\n-\t\t}\n-\t\tif($reg ne \"e1\") {\n-\t\t\t$body .= \"\\t$name = $type($reg)\\n\";\n-\t\t}\n-\t}\n-\tif ($ret[0] eq \"_\" && $ret[1] eq \"_\" && $ret[2] eq \"_\") {\n-\t\t$text .= \"\\t$call\\n\";\n-\t} else {\n-\t\t$text .= \"\\t$ret[0], $ret[1], $ret[2] := $call\\n\";\n-\t}\n-\t$text .= $body;\n-\n-\tif ($do_errno) {\n-\t\t$text .= \"\\tif e1 != 0 {\\n\";\n-\t\t$text .= \"\\t\\terr = e1\\n\";\n-\t\t$text .= \"\\t}\\n\";\n-\t}\n-\t$text .= \"\\treturn\\n\";\n-\t$text .= \"}\\n\";\n-}\n-\n-if($errors) {\n-\texit 1;\n-}\n-\n-print <<EOF;\n-// $cmdline\n-// Code generated by the command above; see README.md. DO NOT EDIT.\n-\n-// +build $tags\n-\n-package $package\n-\n-import (\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-EOF\n-\n-print \"import \\\"golang.org/x/sys/unix\\\"\\n\" if $package ne \"unix\";\n-\n-my $vardecls = \"\\t\" . join(\",\\n\\t\", @vars);\n-$vardecls .= \" syscallFunc\";\n-\n-chomp($_=<<EOF);\n-\n-$dynimports\n-$linknames\n-var (\n-$vardecls\n-)\n-\n-$text\n-EOF\n-print $_;\n-exit 0;"
    },
    {
      "sha": "a76826f443616dfc008d50696dd14a98fbb113dd",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_aix.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_aix.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_aix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_aix.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -227,7 +227,7 @@ func anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) {\n \n \t\t// Some versions of AIX have a bug in getsockname (see IV78655).\n \t\t// We can't rely on sa.Len being set correctly.\n-\t\tn := SizeofSockaddrUnix - 3 // substract leading Family, Len, terminating NUL.\n+\t\tn := SizeofSockaddrUnix - 3 // subtract leading Family, Len, terminating NUL.\n \t\tfor i := 0; i < n; i++ {\n \t\t\tif pp.Path[i] == 0 {\n \t\t\t\tn = i"
    },
    {
      "sha": "a2e3688822262513982f64b9654468778514f649",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_darwin.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_darwin.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_darwin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_darwin.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -416,6 +416,7 @@ func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err e\n //sys\tChmod(path string, mode uint32) (err error)\n //sys\tChown(path string, uid int, gid int) (err error)\n //sys\tChroot(path string) (err error)\n+//sys\tClockGettime(clockid int32, time *Timespec) (err error)\n //sys\tClose(fd int) (err error)\n //sys\tDup(fd int) (nfd int, err error)\n //sys\tDup2(from int, to int) (err error)"
    },
    {
      "sha": "962eee3046424319234be1e712e20b16c0dc2821",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -304,6 +304,7 @@ func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err e\n //sys\tread(fd int, p []byte) (n int, err error)\n //sys\tReadlink(path string, buf []byte) (n int, err error)\n //sys\tRename(from string, to string) (err error)\n+//sys\tRenameat(fromfd int, from string, tofd int, to string) (err error)\n //sys\tRevoke(path string) (err error)\n //sys\tRmdir(path string) (err error)\n //sys\tSeek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK"
    },
    {
      "sha": "a07ee49ea393b9211e4744a14dfc8d79096ea9dd",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux.go",
      "status": "modified",
      "additions": 15,
      "deletions": 2,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -14,6 +14,7 @@ package unix\n import (\n \t\"encoding/binary\"\n \t\"net\"\n+\t\"runtime\"\n \t\"syscall\"\n \t\"unsafe\"\n )\n@@ -80,6 +81,12 @@ func ioctlSetTermios(fd int, req uint, value *Termios) error {\n \treturn ioctl(fd, req, uintptr(unsafe.Pointer(value)))\n }\n \n+func IoctlSetRTCTime(fd int, value *RTCTime) error {\n+\terr := ioctl(fd, RTC_SET_TIME, uintptr(unsafe.Pointer(value)))\n+\truntime.KeepAlive(value)\n+\treturn err\n+}\n+\n // IoctlGetInt performs an ioctl operation which gets an integer value\n // from fd, using the specified request number.\n func IoctlGetInt(fd int, req uint) (int, error) {\n@@ -100,6 +107,12 @@ func IoctlGetTermios(fd int, req uint) (*Termios, error) {\n \treturn &value, err\n }\n \n+func IoctlGetRTCTime(fd int) (*RTCTime, error) {\n+\tvar value RTCTime\n+\terr := ioctl(fd, RTC_RD_TIME, uintptr(unsafe.Pointer(&value)))\n+\treturn &value, err\n+}\n+\n //sys\tLinkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error)\n \n func Link(oldpath string, newpath string) (err error) {\n@@ -1381,6 +1394,7 @@ func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err e\n //sys\tChroot(path string) (err error)\n //sys\tClockGetres(clockid int32, res *Timespec) (err error)\n //sys\tClockGettime(clockid int32, time *Timespec) (err error)\n+//sys\tClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error)\n //sys\tClose(fd int) (err error)\n //sys\tCopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)\n //sys\tDeleteModule(name string, flags int) (err error)\n@@ -1441,7 +1455,6 @@ func Getpgrp() (pid int) {\n //sys\tPselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) = SYS_PSELECT6\n //sys\tread(fd int, p []byte) (n int, err error)\n //sys\tRemovexattr(path string, attr string) (err error)\n-//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tRenameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error)\n //sys\tRequestKey(keyType string, description string, callback string, destRingid int) (id int, err error)\n //sys\tSetdomainname(p []byte) (err error)\n@@ -1466,6 +1479,7 @@ func Setgid(uid int) (err error) {\n \n //sys\tSetpriority(which int, who int, prio int) (err error)\n //sys\tSetxattr(path string, attr string, data []byte, flags int) (err error)\n+//sys\tSignalfd(fd int, mask *Sigset_t, flags int) = SYS_SIGNALFD4\n //sys\tStatx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error)\n //sys\tSync()\n //sys\tSyncfs(fd int) (err error)\n@@ -1682,7 +1696,6 @@ func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {\n // Shmdt\n // Shmget\n // Sigaltstack\n-// Signalfd\n // Swapoff\n // Swapon\n // Sysfs"
    },
    {
      "sha": "e2f8cf6e5ade8aab9ef8d812c0eab892f36242f5",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -68,6 +68,7 @@ func Pipe2(p []int, flags int) (err error) {\n //sys\tLstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tsendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64\n //sys\tSetfsgid(gid int) (err error) = SYS_SETFSGID32\n //sys\tSetfsuid(uid int) (err error) = SYS_SETFSUID32"
    },
    {
      "sha": "87a30744d6c9e7f2e08b7b5f99787cbce9f57581",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -43,6 +43,7 @@ func Lstat(path string, stat *Stat_t) (err error) {\n //sys\tPause() (err error)\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tSeek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK\n \n func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {"
    },
    {
      "sha": "cda3559419c027b47a60037e510a9d3149b6a08c",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -89,6 +89,7 @@ func Seek(fd int, offset int64, whence int) (newoffset int64, err error) {\n //sys\tListen(s int, n int) (err error)\n //sys\tLstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64\n //sys\tPause() (err error)\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tsendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64\n //sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT\n //sys\tSetfsgid(gid int) (err error) = SYS_SETFSGID32"
    },
    {
      "sha": "6d567224017fd302782887ab7f0a628b92c8702f",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -30,6 +30,7 @@ func EpollCreate(size int) (fd int, err error) {\n //sys\tListen(s int, n int) (err error)\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tSeek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK\n \n func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {"
    },
    {
      "sha": "b3b21ec1e2b074e6bae3b9cbb09298456221c829",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -24,6 +24,7 @@ package unix\n //sys\tPause() (err error)\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tSeek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK\n \n func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {"
    },
    {
      "sha": "5144d4e1330bfac84e920f2153836d579c545890",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -28,6 +28,7 @@ func Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr,\n //sys\tListen(s int, n int) (err error)\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT\n //sys\tsendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64\n //sys\tSetfsgid(gid int) (err error)"
    },
    {
      "sha": "0a100b66a3ab02d86b6b656c60926e1e83aae741",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -30,6 +30,7 @@ package unix\n //sys\tPause() (err error)\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tSeek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK\n //sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT\n //sys\tsendfile(outfd int, infd int, offset *int64, count int) (written int, err error)"
    },
    {
      "sha": "f23ca451c7d22ff29f5c893b6a166e645d0014db",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -207,3 +207,7 @@ func Poll(fds []PollFd, timeout int) (n int, err error) {\n \t}\n \treturn ppoll(&fds[0], len(fds), ts, nil)\n }\n+\n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\treturn Renameat2(olddirfd, oldpath, newdirfd, newpath, 0)\n+}"
    },
    {
      "sha": "f81dbdc9c831d97041f5c09efa0f4dc0a31ff939",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -30,6 +30,7 @@ import (\n //sys\tPause() (err error)\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tSeek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK\n //sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)\n //sys\tsendfile(outfd int, infd int, offset *int64, count int) (written int, err error)"
    },
    {
      "sha": "b69565616fc076709bfe21b3d92abcb0aee91ce6",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -26,6 +26,7 @@ package unix\n //sys\tPause() (err error)\n //sys\tPread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64\n //sys\tPwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //sys\tSeek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK\n //sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)\n //sys\tsendfile(outfd int, infd int, offset *int64, count int) (written int, err error)"
    },
    {
      "sha": "f3434465a17911e0bf1f78b3b4bfcf06836c57f2",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_netbsd_arm64.go",
      "status": "added",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_netbsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/syscall_netbsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_netbsd_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build arm64,netbsd\n+\n+package unix\n+\n+func setTimespec(sec, nsec int64) Timespec {\n+\treturn Timespec{Sec: sec, Nsec: nsec}\n+}\n+\n+func setTimeval(sec, usec int64) Timeval {\n+\treturn Timeval{Sec: sec, Usec: int32(usec)}\n+}\n+\n+func SetKevent(k *Kevent_t, fd, mode, flags int) {\n+\tk.Ident = uint64(fd)\n+\tk.Filter = uint32(mode)\n+\tk.Flags = uint32(flags)\n+}\n+\n+func (iov *Iovec) SetLen(length int) {\n+\tiov.Len = uint64(length)\n+}\n+\n+func (msghdr *Msghdr) SetControllen(length int) {\n+\tmsghdr.Controllen = uint32(length)\n+}\n+\n+func (cmsg *Cmsghdr) SetLen(length int) {\n+\tcmsg.Len = uint32(length)\n+}"
    },
    {
      "sha": "cb89df8f543ebd5d78d6181158f5fcf3d9af0093",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -707,6 +707,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -778,6 +779,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1537,6 +1539,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x40085203\n+\tRNDADDTOENTCNT                       = 0x40045201\n+\tRNDCLEARPOOL                         = 0x5206\n+\tRNDGETENTCNT                         = 0x80045200\n+\tRNDGETPOOL                           = 0x80085202\n+\tRNDRESEEDCRNG                        = 0x5207\n+\tRNDZAPENTCNT                         = 0x5204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1744,6 +1753,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1905,6 +1916,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2038,6 +2060,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2052,6 +2075,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2071,6 +2095,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2085,6 +2112,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x5409\n \tTCSBRKP                              = 0x5425\n@@ -2101,6 +2129,7 @@ const (\n \tTCSETXF                              = 0x5434\n \tTCSETXW                              = 0x5435\n \tTCXONC                               = 0x540a\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "73c9b88ca78ee352d7f71cdbf0bda00e56ca4953",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -707,6 +707,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -778,6 +779,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1538,6 +1540,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x40085203\n+\tRNDADDTOENTCNT                       = 0x40045201\n+\tRNDCLEARPOOL                         = 0x5206\n+\tRNDGETENTCNT                         = 0x80045200\n+\tRNDGETPOOL                           = 0x80085202\n+\tRNDRESEEDCRNG                        = 0x5207\n+\tRNDZAPENTCNT                         = 0x5204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1745,6 +1754,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1906,6 +1917,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2039,6 +2061,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2053,6 +2076,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2072,6 +2096,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2086,6 +2113,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x5409\n \tTCSBRKP                              = 0x5425\n@@ -2102,6 +2130,7 @@ const (\n \tTCSETXF                              = 0x5434\n \tTCSETXW                              = 0x5435\n \tTCXONC                               = 0x540a\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "f1ef82f57edd79531261faa55e56a2951f73b58e",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1544,6 +1546,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x40085203\n+\tRNDADDTOENTCNT                       = 0x40045201\n+\tRNDCLEARPOOL                         = 0x5206\n+\tRNDGETENTCNT                         = 0x80045200\n+\tRNDGETPOOL                           = 0x80085202\n+\tRNDRESEEDCRNG                        = 0x5207\n+\tRNDZAPENTCNT                         = 0x5204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1751,6 +1760,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1912,6 +1923,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2045,6 +2067,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2059,6 +2082,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2078,6 +2102,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2092,6 +2119,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x5409\n \tTCSBRKP                              = 0x5425\n@@ -2108,6 +2136,7 @@ const (\n \tTCSETXF                              = 0x5434\n \tTCSETXW                              = 0x5435\n \tTCXONC                               = 0x540a\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "cf17c99069440a25efc4726b92f7c2d733fb315e",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -709,6 +709,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -780,6 +781,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1528,6 +1530,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x40085203\n+\tRNDADDTOENTCNT                       = 0x40045201\n+\tRNDCLEARPOOL                         = 0x5206\n+\tRNDGETENTCNT                         = 0x80045200\n+\tRNDGETPOOL                           = 0x80085202\n+\tRNDRESEEDCRNG                        = 0x5207\n+\tRNDZAPENTCNT                         = 0x5204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1735,6 +1744,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1896,6 +1907,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2030,6 +2052,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2044,6 +2067,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2063,6 +2087,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2077,6 +2104,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x5409\n \tTCSBRKP                              = 0x5425\n@@ -2093,6 +2121,7 @@ const (\n \tTCSETXF                              = 0x5434\n \tTCSETXW                              = 0x5435\n \tTCXONC                               = 0x540a\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "380913c4fce1400ab0a81a1496c93bda132f2f84",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1537,6 +1539,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x80085203\n+\tRNDADDTOENTCNT                       = 0x80045201\n+\tRNDCLEARPOOL                         = 0x20005206\n+\tRNDGETENTCNT                         = 0x40045200\n+\tRNDGETPOOL                           = 0x40085202\n+\tRNDRESEEDCRNG                        = 0x20005207\n+\tRNDZAPENTCNT                         = 0x20005204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1744,6 +1753,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x80\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1905,6 +1916,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x1029\n \tSO_DONTROUTE                         = 0x10\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x1007\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2038,6 +2060,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2052,6 +2075,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2071,6 +2095,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2085,6 +2112,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x5410\n \tTCSBRK                               = 0x5405\n \tTCSBRKP                              = 0x5486\n@@ -2098,6 +2126,7 @@ const (\n \tTCSETSW                              = 0x540f\n \tTCSETSW2                             = 0x8030542c\n \tTCXONC                               = 0x5406\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x80047478\n \tTIOCEXCL                             = 0x740d"
    },
    {
      "sha": "fb82529ac93ca18d08a6cea1cc710fb809302311",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1537,6 +1539,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x80085203\n+\tRNDADDTOENTCNT                       = 0x80045201\n+\tRNDCLEARPOOL                         = 0x20005206\n+\tRNDGETENTCNT                         = 0x40045200\n+\tRNDGETPOOL                           = 0x40085202\n+\tRNDRESEEDCRNG                        = 0x20005207\n+\tRNDZAPENTCNT                         = 0x20005204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1744,6 +1753,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x80\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1905,6 +1916,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x1029\n \tSO_DONTROUTE                         = 0x10\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x1007\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2038,6 +2060,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2052,6 +2075,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2071,6 +2095,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2085,6 +2112,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x5410\n \tTCSBRK                               = 0x5405\n \tTCSBRKP                              = 0x5486\n@@ -2098,6 +2126,7 @@ const (\n \tTCSETSW                              = 0x540f\n \tTCSETSW2                             = 0x8030542c\n \tTCXONC                               = 0x5406\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x80047478\n \tTIOCEXCL                             = 0x740d"
    },
    {
      "sha": "677d9045624b0ac287d13b40c585cdb0b31022f6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1537,6 +1539,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x80085203\n+\tRNDADDTOENTCNT                       = 0x80045201\n+\tRNDCLEARPOOL                         = 0x20005206\n+\tRNDGETENTCNT                         = 0x40045200\n+\tRNDGETPOOL                           = 0x40085202\n+\tRNDRESEEDCRNG                        = 0x20005207\n+\tRNDZAPENTCNT                         = 0x20005204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1744,6 +1753,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x80\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1905,6 +1916,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x1029\n \tSO_DONTROUTE                         = 0x10\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x1007\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2038,6 +2060,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2052,6 +2075,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2071,6 +2095,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2085,6 +2112,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x5410\n \tTCSBRK                               = 0x5405\n \tTCSBRKP                              = 0x5486\n@@ -2098,6 +2126,7 @@ const (\n \tTCSETSW                              = 0x540f\n \tTCSETSW2                             = 0x8030542c\n \tTCXONC                               = 0x5406\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x80047478\n \tTIOCEXCL                             = 0x740d"
    },
    {
      "sha": "7ddd09d7824e904ce0f6c12e07be32dc43a80ea4",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1537,6 +1539,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x80085203\n+\tRNDADDTOENTCNT                       = 0x80045201\n+\tRNDCLEARPOOL                         = 0x20005206\n+\tRNDGETENTCNT                         = 0x40045200\n+\tRNDGETPOOL                           = 0x40085202\n+\tRNDRESEEDCRNG                        = 0x20005207\n+\tRNDZAPENTCNT                         = 0x20005204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1744,6 +1753,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x80\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1905,6 +1916,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x1029\n \tSO_DONTROUTE                         = 0x10\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x1007\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2038,6 +2060,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2052,6 +2075,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2071,6 +2095,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2085,6 +2112,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x5410\n \tTCSBRK                               = 0x5405\n \tTCSBRKP                              = 0x5486\n@@ -2098,6 +2126,7 @@ const (\n \tTCSETSW                              = 0x540f\n \tTCSETSW2                             = 0x8030542c\n \tTCXONC                               = 0x5406\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x80047478\n \tTIOCEXCL                             = 0x740d"
    },
    {
      "sha": "ebaca417b461308438f18904a1b6e08881ada125",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1595,6 +1597,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x80085203\n+\tRNDADDTOENTCNT                       = 0x80045201\n+\tRNDCLEARPOOL                         = 0x20005206\n+\tRNDGETENTCNT                         = 0x40045200\n+\tRNDGETPOOL                           = 0x40085202\n+\tRNDRESEEDCRNG                        = 0x20005207\n+\tRNDZAPENTCNT                         = 0x20005204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1802,6 +1811,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1963,6 +1974,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2094,6 +2116,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2108,6 +2131,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2127,6 +2151,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2141,6 +2168,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x2000741d\n \tTCSBRKP                              = 0x5425\n@@ -2151,6 +2179,7 @@ const (\n \tTCSETSF                              = 0x802c7416\n \tTCSETSW                              = 0x802c7415\n \tTCXONC                               = 0x2000741e\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "02938cb6ed45744f2ee4310d321c7b55795b8b7a",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1595,6 +1597,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x80085203\n+\tRNDADDTOENTCNT                       = 0x80045201\n+\tRNDCLEARPOOL                         = 0x20005206\n+\tRNDGETENTCNT                         = 0x40045200\n+\tRNDGETPOOL                           = 0x40085202\n+\tRNDRESEEDCRNG                        = 0x20005207\n+\tRNDZAPENTCNT                         = 0x20005204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1802,6 +1811,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1963,6 +1974,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2094,6 +2116,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2108,6 +2131,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2127,6 +2151,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2141,6 +2168,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x2000741d\n \tTCSBRKP                              = 0x5425\n@@ -2151,6 +2179,7 @@ const (\n \tTCSETSF                              = 0x802c7416\n \tTCSETSW                              = 0x802c7415\n \tTCXONC                               = 0x2000741e\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "5aea4b9093ade4e8ecd2cdbcf93929e664d0b560",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1525,6 +1527,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x40085203\n+\tRNDADDTOENTCNT                       = 0x40045201\n+\tRNDCLEARPOOL                         = 0x5206\n+\tRNDGETENTCNT                         = 0x80045200\n+\tRNDGETPOOL                           = 0x80085202\n+\tRNDRESEEDCRNG                        = 0x5207\n+\tRNDZAPENTCNT                         = 0x5204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1732,6 +1741,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1893,6 +1904,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2026,6 +2048,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2040,6 +2063,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2059,6 +2083,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2073,6 +2100,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x5409\n \tTCSBRKP                              = 0x5425\n@@ -2089,6 +2117,7 @@ const (\n \tTCSETXF                              = 0x5434\n \tTCSETXW                              = 0x5435\n \tTCXONC                               = 0x540a\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "7f7c2e3e2fe1b9a06a03ee567426a858c9f06017",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -706,6 +706,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -777,6 +778,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1598,6 +1600,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x40085203\n+\tRNDADDTOENTCNT                       = 0x40045201\n+\tRNDCLEARPOOL                         = 0x5206\n+\tRNDGETENTCNT                         = 0x80045200\n+\tRNDGETPOOL                           = 0x80085202\n+\tRNDRESEEDCRNG                        = 0x5207\n+\tRNDZAPENTCNT                         = 0x5204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1805,6 +1814,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x80000\n+\tSFD_NONBLOCK                         = 0x800\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1966,6 +1977,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x27\n \tSO_DONTROUTE                         = 0x5\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x4\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x31\n@@ -2099,6 +2121,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2113,6 +2136,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2132,6 +2156,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2146,6 +2173,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x5409\n \tTCSBRKP                              = 0x5425\n@@ -2162,6 +2190,7 @@ const (\n \tTCSETXF                              = 0x5434\n \tTCSETXW                              = 0x5435\n \tTCXONC                               = 0x540a\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x5428\n \tTIOCCONS                             = 0x541d\n \tTIOCEXCL                             = 0x540c"
    },
    {
      "sha": "968e21fd680b838f799e11d633ad38050b5db957",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -41,7 +41,7 @@ const (\n \tAF_KEY                               = 0xf\n \tAF_LLC                               = 0x1a\n \tAF_LOCAL                             = 0x1\n-\tAF_MAX                               = 0x2c\n+\tAF_MAX                               = 0x2d\n \tAF_MPLS                              = 0x1c\n \tAF_NETBEUI                           = 0xd\n \tAF_NETLINK                           = 0x10\n@@ -710,6 +710,7 @@ const (\n \tIN_ISDIR                             = 0x40000000\n \tIN_LOOPBACKNET                       = 0x7f\n \tIN_MASK_ADD                          = 0x20000000\n+\tIN_MASK_CREATE                       = 0x10000000\n \tIN_MODIFY                            = 0x2\n \tIN_MOVE                              = 0xc0\n \tIN_MOVED_FROM                        = 0x40\n@@ -781,6 +782,7 @@ const (\n \tIPV6_MINHOPCOUNT                     = 0x49\n \tIPV6_MTU                             = 0x18\n \tIPV6_MTU_DISCOVER                    = 0x17\n+\tIPV6_MULTICAST_ALL                   = 0x1d\n \tIPV6_MULTICAST_HOPS                  = 0x12\n \tIPV6_MULTICAST_IF                    = 0x11\n \tIPV6_MULTICAST_LOOP                  = 0x13\n@@ -1590,6 +1592,13 @@ const (\n \tRLIMIT_SIGPENDING                    = 0xb\n \tRLIMIT_STACK                         = 0x3\n \tRLIM_INFINITY                        = 0xffffffffffffffff\n+\tRNDADDENTROPY                        = 0x80085203\n+\tRNDADDTOENTCNT                       = 0x80045201\n+\tRNDCLEARPOOL                         = 0x20005206\n+\tRNDGETENTCNT                         = 0x40045200\n+\tRNDGETPOOL                           = 0x40085202\n+\tRNDRESEEDCRNG                        = 0x20005207\n+\tRNDZAPENTCNT                         = 0x20005204\n \tRTAX_ADVMSS                          = 0x8\n \tRTAX_CC_ALGO                         = 0x10\n \tRTAX_CWND                            = 0x7\n@@ -1797,6 +1806,8 @@ const (\n \tSECCOMP_MODE_STRICT                  = 0x1\n \tSECURITYFS_MAGIC                     = 0x73636673\n \tSELINUX_MAGIC                        = 0xf97cff8c\n+\tSFD_CLOEXEC                          = 0x400000\n+\tSFD_NONBLOCK                         = 0x4000\n \tSHUT_RD                              = 0x0\n \tSHUT_RDWR                            = 0x2\n \tSHUT_WR                              = 0x1\n@@ -1958,6 +1969,17 @@ const (\n \tSO_DETACH_FILTER                     = 0x1b\n \tSO_DOMAIN                            = 0x1029\n \tSO_DONTROUTE                         = 0x10\n+\tSO_EE_CODE_TXTIME_INVALID_PARAM      = 0x1\n+\tSO_EE_CODE_TXTIME_MISSED             = 0x2\n+\tSO_EE_CODE_ZEROCOPY_COPIED           = 0x1\n+\tSO_EE_ORIGIN_ICMP                    = 0x2\n+\tSO_EE_ORIGIN_ICMP6                   = 0x3\n+\tSO_EE_ORIGIN_LOCAL                   = 0x1\n+\tSO_EE_ORIGIN_NONE                    = 0x0\n+\tSO_EE_ORIGIN_TIMESTAMPING            = 0x4\n+\tSO_EE_ORIGIN_TXSTATUS                = 0x4\n+\tSO_EE_ORIGIN_TXTIME                  = 0x6\n+\tSO_EE_ORIGIN_ZEROCOPY                = 0x5\n \tSO_ERROR                             = 0x1007\n \tSO_GET_FILTER                        = 0x1a\n \tSO_INCOMING_CPU                      = 0x33\n@@ -2090,6 +2112,7 @@ const (\n \tTCOOFF                               = 0x0\n \tTCOON                                = 0x1\n \tTCP_CC_INFO                          = 0x1a\n+\tTCP_CM_INQ                           = 0x24\n \tTCP_CONGESTION                       = 0xd\n \tTCP_COOKIE_IN_ALWAYS                 = 0x1\n \tTCP_COOKIE_MAX                       = 0x10\n@@ -2104,6 +2127,7 @@ const (\n \tTCP_FASTOPEN_KEY                     = 0x21\n \tTCP_FASTOPEN_NO_COOKIE               = 0x22\n \tTCP_INFO                             = 0xb\n+\tTCP_INQ                              = 0x24\n \tTCP_KEEPCNT                          = 0x6\n \tTCP_KEEPIDLE                         = 0x4\n \tTCP_KEEPINTVL                        = 0x5\n@@ -2123,6 +2147,9 @@ const (\n \tTCP_QUEUE_SEQ                        = 0x15\n \tTCP_QUICKACK                         = 0xc\n \tTCP_REPAIR                           = 0x13\n+\tTCP_REPAIR_OFF                       = 0x0\n+\tTCP_REPAIR_OFF_NO_WP                 = -0x1\n+\tTCP_REPAIR_ON                        = 0x1\n \tTCP_REPAIR_OPTIONS                   = 0x16\n \tTCP_REPAIR_QUEUE                     = 0x14\n \tTCP_REPAIR_WINDOW                    = 0x1d\n@@ -2137,6 +2164,7 @@ const (\n \tTCP_ULP                              = 0x1f\n \tTCP_USER_TIMEOUT                     = 0x12\n \tTCP_WINDOW_CLAMP                     = 0xa\n+\tTCP_ZEROCOPY_RECEIVE                 = 0x23\n \tTCSAFLUSH                            = 0x2\n \tTCSBRK                               = 0x20005405\n \tTCSBRKP                              = 0x5425\n@@ -2150,6 +2178,7 @@ const (\n \tTCSETSW                              = 0x8024540a\n \tTCSETSW2                             = 0x802c540e\n \tTCXONC                               = 0x20005406\n+\tTIMER_ABSTIME                        = 0x1\n \tTIOCCBRK                             = 0x2000747a\n \tTIOCCONS                             = 0x20007424\n \tTIOCEXCL                             = 0x2000740d"
    },
    {
      "sha": "fb6c60441daa6007d9537f8be992f1806ee6d465",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm64.go",
      "status": "added",
      "additions": 1762,
      "deletions": 0,
      "changes": 1762,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,1762 @@\n+// mkerrors.sh -m64\n+// Code generated by the command above; see README.md. DO NOT EDIT.\n+\n+// +build arm64,netbsd\n+\n+// Created by cgo -godefs - DO NOT EDIT\n+// cgo -godefs -- -m64 _const.go\n+\n+package unix\n+\n+import \"syscall\"\n+\n+const (\n+\tAF_APPLETALK                      = 0x10\n+\tAF_ARP                            = 0x1c\n+\tAF_BLUETOOTH                      = 0x1f\n+\tAF_CCITT                          = 0xa\n+\tAF_CHAOS                          = 0x5\n+\tAF_CNT                            = 0x15\n+\tAF_COIP                           = 0x14\n+\tAF_DATAKIT                        = 0x9\n+\tAF_DECnet                         = 0xc\n+\tAF_DLI                            = 0xd\n+\tAF_E164                           = 0x1a\n+\tAF_ECMA                           = 0x8\n+\tAF_HYLINK                         = 0xf\n+\tAF_IEEE80211                      = 0x20\n+\tAF_IMPLINK                        = 0x3\n+\tAF_INET                           = 0x2\n+\tAF_INET6                          = 0x18\n+\tAF_IPX                            = 0x17\n+\tAF_ISDN                           = 0x1a\n+\tAF_ISO                            = 0x7\n+\tAF_LAT                            = 0xe\n+\tAF_LINK                           = 0x12\n+\tAF_LOCAL                          = 0x1\n+\tAF_MAX                            = 0x23\n+\tAF_MPLS                           = 0x21\n+\tAF_NATM                           = 0x1b\n+\tAF_NS                             = 0x6\n+\tAF_OROUTE                         = 0x11\n+\tAF_OSI                            = 0x7\n+\tAF_PUP                            = 0x4\n+\tAF_ROUTE                          = 0x22\n+\tAF_SNA                            = 0xb\n+\tAF_UNIX                           = 0x1\n+\tAF_UNSPEC                         = 0x0\n+\tARPHRD_ARCNET                     = 0x7\n+\tARPHRD_ETHER                      = 0x1\n+\tARPHRD_FRELAY                     = 0xf\n+\tARPHRD_IEEE1394                   = 0x18\n+\tARPHRD_IEEE802                    = 0x6\n+\tARPHRD_STRIP                      = 0x17\n+\tB0                                = 0x0\n+\tB110                              = 0x6e\n+\tB115200                           = 0x1c200\n+\tB1200                             = 0x4b0\n+\tB134                              = 0x86\n+\tB14400                            = 0x3840\n+\tB150                              = 0x96\n+\tB1800                             = 0x708\n+\tB19200                            = 0x4b00\n+\tB200                              = 0xc8\n+\tB230400                           = 0x38400\n+\tB2400                             = 0x960\n+\tB28800                            = 0x7080\n+\tB300                              = 0x12c\n+\tB38400                            = 0x9600\n+\tB460800                           = 0x70800\n+\tB4800                             = 0x12c0\n+\tB50                               = 0x32\n+\tB57600                            = 0xe100\n+\tB600                              = 0x258\n+\tB7200                             = 0x1c20\n+\tB75                               = 0x4b\n+\tB76800                            = 0x12c00\n+\tB921600                           = 0xe1000\n+\tB9600                             = 0x2580\n+\tBIOCFEEDBACK                      = 0x8004427d\n+\tBIOCFLUSH                         = 0x20004268\n+\tBIOCGBLEN                         = 0x40044266\n+\tBIOCGDLT                          = 0x4004426a\n+\tBIOCGDLTLIST                      = 0xc0104277\n+\tBIOCGETIF                         = 0x4090426b\n+\tBIOCGFEEDBACK                     = 0x4004427c\n+\tBIOCGHDRCMPLT                     = 0x40044274\n+\tBIOCGRTIMEOUT                     = 0x4010427b\n+\tBIOCGSEESENT                      = 0x40044278\n+\tBIOCGSTATS                        = 0x4080426f\n+\tBIOCGSTATSOLD                     = 0x4008426f\n+\tBIOCIMMEDIATE                     = 0x80044270\n+\tBIOCPROMISC                       = 0x20004269\n+\tBIOCSBLEN                         = 0xc0044266\n+\tBIOCSDLT                          = 0x80044276\n+\tBIOCSETF                          = 0x80104267\n+\tBIOCSETIF                         = 0x8090426c\n+\tBIOCSFEEDBACK                     = 0x8004427d\n+\tBIOCSHDRCMPLT                     = 0x80044275\n+\tBIOCSRTIMEOUT                     = 0x8010427a\n+\tBIOCSSEESENT                      = 0x80044279\n+\tBIOCSTCPF                         = 0x80104272\n+\tBIOCSUDPF                         = 0x80104273\n+\tBIOCVERSION                       = 0x40044271\n+\tBPF_A                             = 0x10\n+\tBPF_ABS                           = 0x20\n+\tBPF_ADD                           = 0x0\n+\tBPF_ALIGNMENT                     = 0x8\n+\tBPF_ALIGNMENT32                   = 0x4\n+\tBPF_ALU                           = 0x4\n+\tBPF_AND                           = 0x50\n+\tBPF_B                             = 0x10\n+\tBPF_DFLTBUFSIZE                   = 0x100000\n+\tBPF_DIV                           = 0x30\n+\tBPF_H                             = 0x8\n+\tBPF_IMM                           = 0x0\n+\tBPF_IND                           = 0x40\n+\tBPF_JA                            = 0x0\n+\tBPF_JEQ                           = 0x10\n+\tBPF_JGE                           = 0x30\n+\tBPF_JGT                           = 0x20\n+\tBPF_JMP                           = 0x5\n+\tBPF_JSET                          = 0x40\n+\tBPF_K                             = 0x0\n+\tBPF_LD                            = 0x0\n+\tBPF_LDX                           = 0x1\n+\tBPF_LEN                           = 0x80\n+\tBPF_LSH                           = 0x60\n+\tBPF_MAJOR_VERSION                 = 0x1\n+\tBPF_MAXBUFSIZE                    = 0x1000000\n+\tBPF_MAXINSNS                      = 0x200\n+\tBPF_MEM                           = 0x60\n+\tBPF_MEMWORDS                      = 0x10\n+\tBPF_MINBUFSIZE                    = 0x20\n+\tBPF_MINOR_VERSION                 = 0x1\n+\tBPF_MISC                          = 0x7\n+\tBPF_MSH                           = 0xa0\n+\tBPF_MUL                           = 0x20\n+\tBPF_NEG                           = 0x80\n+\tBPF_OR                            = 0x40\n+\tBPF_RELEASE                       = 0x30bb6\n+\tBPF_RET                           = 0x6\n+\tBPF_RSH                           = 0x70\n+\tBPF_ST                            = 0x2\n+\tBPF_STX                           = 0x3\n+\tBPF_SUB                           = 0x10\n+\tBPF_TAX                           = 0x0\n+\tBPF_TXA                           = 0x80\n+\tBPF_W                             = 0x0\n+\tBPF_X                             = 0x8\n+\tBRKINT                            = 0x2\n+\tCFLUSH                            = 0xf\n+\tCLOCAL                            = 0x8000\n+\tCLONE_CSIGNAL                     = 0xff\n+\tCLONE_FILES                       = 0x400\n+\tCLONE_FS                          = 0x200\n+\tCLONE_PID                         = 0x1000\n+\tCLONE_PTRACE                      = 0x2000\n+\tCLONE_SIGHAND                     = 0x800\n+\tCLONE_VFORK                       = 0x4000\n+\tCLONE_VM                          = 0x100\n+\tCREAD                             = 0x800\n+\tCRTSCTS                           = 0x10000\n+\tCS5                               = 0x0\n+\tCS6                               = 0x100\n+\tCS7                               = 0x200\n+\tCS8                               = 0x300\n+\tCSIZE                             = 0x300\n+\tCSTART                            = 0x11\n+\tCSTATUS                           = 0x14\n+\tCSTOP                             = 0x13\n+\tCSTOPB                            = 0x400\n+\tCSUSP                             = 0x1a\n+\tCTL_HW                            = 0x6\n+\tCTL_KERN                          = 0x1\n+\tCTL_MAXNAME                       = 0xc\n+\tCTL_NET                           = 0x4\n+\tCTL_QUERY                         = -0x2\n+\tDIOCBSFLUSH                       = 0x20006478\n+\tDLT_A429                          = 0xb8\n+\tDLT_A653_ICM                      = 0xb9\n+\tDLT_AIRONET_HEADER                = 0x78\n+\tDLT_AOS                           = 0xde\n+\tDLT_APPLE_IP_OVER_IEEE1394        = 0x8a\n+\tDLT_ARCNET                        = 0x7\n+\tDLT_ARCNET_LINUX                  = 0x81\n+\tDLT_ATM_CLIP                      = 0x13\n+\tDLT_ATM_RFC1483                   = 0xb\n+\tDLT_AURORA                        = 0x7e\n+\tDLT_AX25                          = 0x3\n+\tDLT_AX25_KISS                     = 0xca\n+\tDLT_BACNET_MS_TP                  = 0xa5\n+\tDLT_BLUETOOTH_HCI_H4              = 0xbb\n+\tDLT_BLUETOOTH_HCI_H4_WITH_PHDR    = 0xc9\n+\tDLT_CAN20B                        = 0xbe\n+\tDLT_CAN_SOCKETCAN                 = 0xe3\n+\tDLT_CHAOS                         = 0x5\n+\tDLT_CISCO_IOS                     = 0x76\n+\tDLT_C_HDLC                        = 0x68\n+\tDLT_C_HDLC_WITH_DIR               = 0xcd\n+\tDLT_DECT                          = 0xdd\n+\tDLT_DOCSIS                        = 0x8f\n+\tDLT_ECONET                        = 0x73\n+\tDLT_EN10MB                        = 0x1\n+\tDLT_EN3MB                         = 0x2\n+\tDLT_ENC                           = 0x6d\n+\tDLT_ERF                           = 0xc5\n+\tDLT_ERF_ETH                       = 0xaf\n+\tDLT_ERF_POS                       = 0xb0\n+\tDLT_FC_2                          = 0xe0\n+\tDLT_FC_2_WITH_FRAME_DELIMS        = 0xe1\n+\tDLT_FDDI                          = 0xa\n+\tDLT_FLEXRAY                       = 0xd2\n+\tDLT_FRELAY                        = 0x6b\n+\tDLT_FRELAY_WITH_DIR               = 0xce\n+\tDLT_GCOM_SERIAL                   = 0xad\n+\tDLT_GCOM_T1E1                     = 0xac\n+\tDLT_GPF_F                         = 0xab\n+\tDLT_GPF_T                         = 0xaa\n+\tDLT_GPRS_LLC                      = 0xa9\n+\tDLT_GSMTAP_ABIS                   = 0xda\n+\tDLT_GSMTAP_UM                     = 0xd9\n+\tDLT_HDLC                          = 0x10\n+\tDLT_HHDLC                         = 0x79\n+\tDLT_HIPPI                         = 0xf\n+\tDLT_IBM_SN                        = 0x92\n+\tDLT_IBM_SP                        = 0x91\n+\tDLT_IEEE802                       = 0x6\n+\tDLT_IEEE802_11                    = 0x69\n+\tDLT_IEEE802_11_RADIO              = 0x7f\n+\tDLT_IEEE802_11_RADIO_AVS          = 0xa3\n+\tDLT_IEEE802_15_4                  = 0xc3\n+\tDLT_IEEE802_15_4_LINUX            = 0xbf\n+\tDLT_IEEE802_15_4_NONASK_PHY       = 0xd7\n+\tDLT_IEEE802_16_MAC_CPS            = 0xbc\n+\tDLT_IEEE802_16_MAC_CPS_RADIO      = 0xc1\n+\tDLT_IPMB                          = 0xc7\n+\tDLT_IPMB_LINUX                    = 0xd1\n+\tDLT_IPNET                         = 0xe2\n+\tDLT_IPV4                          = 0xe4\n+\tDLT_IPV6                          = 0xe5\n+\tDLT_IP_OVER_FC                    = 0x7a\n+\tDLT_JUNIPER_ATM1                  = 0x89\n+\tDLT_JUNIPER_ATM2                  = 0x87\n+\tDLT_JUNIPER_CHDLC                 = 0xb5\n+\tDLT_JUNIPER_ES                    = 0x84\n+\tDLT_JUNIPER_ETHER                 = 0xb2\n+\tDLT_JUNIPER_FRELAY                = 0xb4\n+\tDLT_JUNIPER_GGSN                  = 0x85\n+\tDLT_JUNIPER_ISM                   = 0xc2\n+\tDLT_JUNIPER_MFR                   = 0x86\n+\tDLT_JUNIPER_MLFR                  = 0x83\n+\tDLT_JUNIPER_MLPPP                 = 0x82\n+\tDLT_JUNIPER_MONITOR               = 0xa4\n+\tDLT_JUNIPER_PIC_PEER              = 0xae\n+\tDLT_JUNIPER_PPP                   = 0xb3\n+\tDLT_JUNIPER_PPPOE                 = 0xa7\n+\tDLT_JUNIPER_PPPOE_ATM             = 0xa8\n+\tDLT_JUNIPER_SERVICES              = 0x88\n+\tDLT_JUNIPER_ST                    = 0xc8\n+\tDLT_JUNIPER_VP                    = 0xb7\n+\tDLT_LAPB_WITH_DIR                 = 0xcf\n+\tDLT_LAPD                          = 0xcb\n+\tDLT_LIN                           = 0xd4\n+\tDLT_LINUX_EVDEV                   = 0xd8\n+\tDLT_LINUX_IRDA                    = 0x90\n+\tDLT_LINUX_LAPD                    = 0xb1\n+\tDLT_LINUX_SLL                     = 0x71\n+\tDLT_LOOP                          = 0x6c\n+\tDLT_LTALK                         = 0x72\n+\tDLT_MFR                           = 0xb6\n+\tDLT_MOST                          = 0xd3\n+\tDLT_MPLS                          = 0xdb\n+\tDLT_MTP2                          = 0x8c\n+\tDLT_MTP2_WITH_PHDR                = 0x8b\n+\tDLT_MTP3                          = 0x8d\n+\tDLT_NULL                          = 0x0\n+\tDLT_PCI_EXP                       = 0x7d\n+\tDLT_PFLOG                         = 0x75\n+\tDLT_PFSYNC                        = 0x12\n+\tDLT_PPI                           = 0xc0\n+\tDLT_PPP                           = 0x9\n+\tDLT_PPP_BSDOS                     = 0xe\n+\tDLT_PPP_ETHER                     = 0x33\n+\tDLT_PPP_PPPD                      = 0xa6\n+\tDLT_PPP_SERIAL                    = 0x32\n+\tDLT_PPP_WITH_DIR                  = 0xcc\n+\tDLT_PRISM_HEADER                  = 0x77\n+\tDLT_PRONET                        = 0x4\n+\tDLT_RAIF1                         = 0xc6\n+\tDLT_RAW                           = 0xc\n+\tDLT_RAWAF_MASK                    = 0x2240000\n+\tDLT_RIO                           = 0x7c\n+\tDLT_SCCP                          = 0x8e\n+\tDLT_SITA                          = 0xc4\n+\tDLT_SLIP                          = 0x8\n+\tDLT_SLIP_BSDOS                    = 0xd\n+\tDLT_SUNATM                        = 0x7b\n+\tDLT_SYMANTEC_FIREWALL             = 0x63\n+\tDLT_TZSP                          = 0x80\n+\tDLT_USB                           = 0xba\n+\tDLT_USB_LINUX                     = 0xbd\n+\tDLT_USB_LINUX_MMAPPED             = 0xdc\n+\tDLT_WIHART                        = 0xdf\n+\tDLT_X2E_SERIAL                    = 0xd5\n+\tDLT_X2E_XORAYA                    = 0xd6\n+\tDT_BLK                            = 0x6\n+\tDT_CHR                            = 0x2\n+\tDT_DIR                            = 0x4\n+\tDT_FIFO                           = 0x1\n+\tDT_LNK                            = 0xa\n+\tDT_REG                            = 0x8\n+\tDT_SOCK                           = 0xc\n+\tDT_UNKNOWN                        = 0x0\n+\tDT_WHT                            = 0xe\n+\tECHO                              = 0x8\n+\tECHOCTL                           = 0x40\n+\tECHOE                             = 0x2\n+\tECHOK                             = 0x4\n+\tECHOKE                            = 0x1\n+\tECHONL                            = 0x10\n+\tECHOPRT                           = 0x20\n+\tEMUL_LINUX                        = 0x1\n+\tEMUL_LINUX32                      = 0x5\n+\tEMUL_MAXID                        = 0x6\n+\tETHERCAP_JUMBO_MTU                = 0x4\n+\tETHERCAP_VLAN_HWTAGGING           = 0x2\n+\tETHERCAP_VLAN_MTU                 = 0x1\n+\tETHERMIN                          = 0x2e\n+\tETHERMTU                          = 0x5dc\n+\tETHERMTU_JUMBO                    = 0x2328\n+\tETHERTYPE_8023                    = 0x4\n+\tETHERTYPE_AARP                    = 0x80f3\n+\tETHERTYPE_ACCTON                  = 0x8390\n+\tETHERTYPE_AEONIC                  = 0x8036\n+\tETHERTYPE_ALPHA                   = 0x814a\n+\tETHERTYPE_AMBER                   = 0x6008\n+\tETHERTYPE_AMOEBA                  = 0x8145\n+\tETHERTYPE_APOLLO                  = 0x80f7\n+\tETHERTYPE_APOLLODOMAIN            = 0x8019\n+\tETHERTYPE_APPLETALK               = 0x809b\n+\tETHERTYPE_APPLITEK                = 0x80c7\n+\tETHERTYPE_ARGONAUT                = 0x803a\n+\tETHERTYPE_ARP                     = 0x806\n+\tETHERTYPE_AT                      = 0x809b\n+\tETHERTYPE_ATALK                   = 0x809b\n+\tETHERTYPE_ATOMIC                  = 0x86df\n+\tETHERTYPE_ATT                     = 0x8069\n+\tETHERTYPE_ATTSTANFORD             = 0x8008\n+\tETHERTYPE_AUTOPHON                = 0x806a\n+\tETHERTYPE_AXIS                    = 0x8856\n+\tETHERTYPE_BCLOOP                  = 0x9003\n+\tETHERTYPE_BOFL                    = 0x8102\n+\tETHERTYPE_CABLETRON               = 0x7034\n+\tETHERTYPE_CHAOS                   = 0x804\n+\tETHERTYPE_COMDESIGN               = 0x806c\n+\tETHERTYPE_COMPUGRAPHIC            = 0x806d\n+\tETHERTYPE_COUNTERPOINT            = 0x8062\n+\tETHERTYPE_CRONUS                  = 0x8004\n+\tETHERTYPE_CRONUSVLN               = 0x8003\n+\tETHERTYPE_DCA                     = 0x1234\n+\tETHERTYPE_DDE                     = 0x807b\n+\tETHERTYPE_DEBNI                   = 0xaaaa\n+\tETHERTYPE_DECAM                   = 0x8048\n+\tETHERTYPE_DECCUST                 = 0x6006\n+\tETHERTYPE_DECDIAG                 = 0x6005\n+\tETHERTYPE_DECDNS                  = 0x803c\n+\tETHERTYPE_DECDTS                  = 0x803e\n+\tETHERTYPE_DECEXPER                = 0x6000\n+\tETHERTYPE_DECLAST                 = 0x8041\n+\tETHERTYPE_DECLTM                  = 0x803f\n+\tETHERTYPE_DECMUMPS                = 0x6009\n+\tETHERTYPE_DECNETBIOS              = 0x8040\n+\tETHERTYPE_DELTACON                = 0x86de\n+\tETHERTYPE_DIDDLE                  = 0x4321\n+\tETHERTYPE_DLOG1                   = 0x660\n+\tETHERTYPE_DLOG2                   = 0x661\n+\tETHERTYPE_DN                      = 0x6003\n+\tETHERTYPE_DOGFIGHT                = 0x1989\n+\tETHERTYPE_DSMD                    = 0x8039\n+\tETHERTYPE_ECMA                    = 0x803\n+\tETHERTYPE_ENCRYPT                 = 0x803d\n+\tETHERTYPE_ES                      = 0x805d\n+\tETHERTYPE_EXCELAN                 = 0x8010\n+\tETHERTYPE_EXPERDATA               = 0x8049\n+\tETHERTYPE_FLIP                    = 0x8146\n+\tETHERTYPE_FLOWCONTROL             = 0x8808\n+\tETHERTYPE_FRARP                   = 0x808\n+\tETHERTYPE_GENDYN                  = 0x8068\n+\tETHERTYPE_HAYES                   = 0x8130\n+\tETHERTYPE_HIPPI_FP                = 0x8180\n+\tETHERTYPE_HITACHI                 = 0x8820\n+\tETHERTYPE_HP                      = 0x8005\n+\tETHERTYPE_IEEEPUP                 = 0xa00\n+\tETHERTYPE_IEEEPUPAT               = 0xa01\n+\tETHERTYPE_IMLBL                   = 0x4c42\n+\tETHERTYPE_IMLBLDIAG               = 0x424c\n+\tETHERTYPE_IP                      = 0x800\n+\tETHERTYPE_IPAS                    = 0x876c\n+\tETHERTYPE_IPV6                    = 0x86dd\n+\tETHERTYPE_IPX                     = 0x8137\n+\tETHERTYPE_IPXNEW                  = 0x8037\n+\tETHERTYPE_KALPANA                 = 0x8582\n+\tETHERTYPE_LANBRIDGE               = 0x8038\n+\tETHERTYPE_LANPROBE                = 0x8888\n+\tETHERTYPE_LAT                     = 0x6004\n+\tETHERTYPE_LBACK                   = 0x9000\n+\tETHERTYPE_LITTLE                  = 0x8060\n+\tETHERTYPE_LOGICRAFT               = 0x8148\n+\tETHERTYPE_LOOPBACK                = 0x9000\n+\tETHERTYPE_MATRA                   = 0x807a\n+\tETHERTYPE_MAX                     = 0xffff\n+\tETHERTYPE_MERIT                   = 0x807c\n+\tETHERTYPE_MICP                    = 0x873a\n+\tETHERTYPE_MOPDL                   = 0x6001\n+\tETHERTYPE_MOPRC                   = 0x6002\n+\tETHERTYPE_MOTOROLA                = 0x818d\n+\tETHERTYPE_MPLS                    = 0x8847\n+\tETHERTYPE_MPLS_MCAST              = 0x8848\n+\tETHERTYPE_MUMPS                   = 0x813f\n+\tETHERTYPE_NBPCC                   = 0x3c04\n+\tETHERTYPE_NBPCLAIM                = 0x3c09\n+\tETHERTYPE_NBPCLREQ                = 0x3c05\n+\tETHERTYPE_NBPCLRSP                = 0x3c06\n+\tETHERTYPE_NBPCREQ                 = 0x3c02\n+\tETHERTYPE_NBPCRSP                 = 0x3c03\n+\tETHERTYPE_NBPDG                   = 0x3c07\n+\tETHERTYPE_NBPDGB                  = 0x3c08\n+\tETHERTYPE_NBPDLTE                 = 0x3c0a\n+\tETHERTYPE_NBPRAR                  = 0x3c0c\n+\tETHERTYPE_NBPRAS                  = 0x3c0b\n+\tETHERTYPE_NBPRST                  = 0x3c0d\n+\tETHERTYPE_NBPSCD                  = 0x3c01\n+\tETHERTYPE_NBPVCD                  = 0x3c00\n+\tETHERTYPE_NBS                     = 0x802\n+\tETHERTYPE_NCD                     = 0x8149\n+\tETHERTYPE_NESTAR                  = 0x8006\n+\tETHERTYPE_NETBEUI                 = 0x8191\n+\tETHERTYPE_NOVELL                  = 0x8138\n+\tETHERTYPE_NS                      = 0x600\n+\tETHERTYPE_NSAT                    = 0x601\n+\tETHERTYPE_NSCOMPAT                = 0x807\n+\tETHERTYPE_NTRAILER                = 0x10\n+\tETHERTYPE_OS9                     = 0x7007\n+\tETHERTYPE_OS9NET                  = 0x7009\n+\tETHERTYPE_PACER                   = 0x80c6\n+\tETHERTYPE_PAE                     = 0x888e\n+\tETHERTYPE_PCS                     = 0x4242\n+\tETHERTYPE_PLANNING                = 0x8044\n+\tETHERTYPE_PPP                     = 0x880b\n+\tETHERTYPE_PPPOE                   = 0x8864\n+\tETHERTYPE_PPPOEDISC               = 0x8863\n+\tETHERTYPE_PRIMENTS                = 0x7031\n+\tETHERTYPE_PUP                     = 0x200\n+\tETHERTYPE_PUPAT                   = 0x200\n+\tETHERTYPE_RACAL                   = 0x7030\n+\tETHERTYPE_RATIONAL                = 0x8150\n+\tETHERTYPE_RAWFR                   = 0x6559\n+\tETHERTYPE_RCL                     = 0x1995\n+\tETHERTYPE_RDP                     = 0x8739\n+\tETHERTYPE_RETIX                   = 0x80f2\n+\tETHERTYPE_REVARP                  = 0x8035\n+\tETHERTYPE_SCA                     = 0x6007\n+\tETHERTYPE_SECTRA                  = 0x86db\n+\tETHERTYPE_SECUREDATA              = 0x876d\n+\tETHERTYPE_SGITW                   = 0x817e\n+\tETHERTYPE_SG_BOUNCE               = 0x8016\n+\tETHERTYPE_SG_DIAG                 = 0x8013\n+\tETHERTYPE_SG_NETGAMES             = 0x8014\n+\tETHERTYPE_SG_RESV                 = 0x8015\n+\tETHERTYPE_SIMNET                  = 0x5208\n+\tETHERTYPE_SLOWPROTOCOLS           = 0x8809\n+\tETHERTYPE_SNA                     = 0x80d5\n+\tETHERTYPE_SNMP                    = 0x814c\n+\tETHERTYPE_SONIX                   = 0xfaf5\n+\tETHERTYPE_SPIDER                  = 0x809f\n+\tETHERTYPE_SPRITE                  = 0x500\n+\tETHERTYPE_STP                     = 0x8181\n+\tETHERTYPE_TALARIS                 = 0x812b\n+\tETHERTYPE_TALARISMC               = 0x852b\n+\tETHERTYPE_TCPCOMP                 = 0x876b\n+\tETHERTYPE_TCPSM                   = 0x9002\n+\tETHERTYPE_TEC                     = 0x814f\n+\tETHERTYPE_TIGAN                   = 0x802f\n+\tETHERTYPE_TRAIL                   = 0x1000\n+\tETHERTYPE_TRANSETHER              = 0x6558\n+\tETHERTYPE_TYMSHARE                = 0x802e\n+\tETHERTYPE_UBBST                   = 0x7005\n+\tETHERTYPE_UBDEBUG                 = 0x900\n+\tETHERTYPE_UBDIAGLOOP              = 0x7002\n+\tETHERTYPE_UBDL                    = 0x7000\n+\tETHERTYPE_UBNIU                   = 0x7001\n+\tETHERTYPE_UBNMC                   = 0x7003\n+\tETHERTYPE_VALID                   = 0x1600\n+\tETHERTYPE_VARIAN                  = 0x80dd\n+\tETHERTYPE_VAXELN                  = 0x803b\n+\tETHERTYPE_VEECO                   = 0x8067\n+\tETHERTYPE_VEXP                    = 0x805b\n+\tETHERTYPE_VGLAB                   = 0x8131\n+\tETHERTYPE_VINES                   = 0xbad\n+\tETHERTYPE_VINESECHO               = 0xbaf\n+\tETHERTYPE_VINESLOOP               = 0xbae\n+\tETHERTYPE_VITAL                   = 0xff00\n+\tETHERTYPE_VLAN                    = 0x8100\n+\tETHERTYPE_VLTLMAN                 = 0x8080\n+\tETHERTYPE_VPROD                   = 0x805c\n+\tETHERTYPE_VURESERVED              = 0x8147\n+\tETHERTYPE_WATERLOO                = 0x8130\n+\tETHERTYPE_WELLFLEET               = 0x8103\n+\tETHERTYPE_X25                     = 0x805\n+\tETHERTYPE_X75                     = 0x801\n+\tETHERTYPE_XNSSM                   = 0x9001\n+\tETHERTYPE_XTP                     = 0x817d\n+\tETHER_ADDR_LEN                    = 0x6\n+\tETHER_CRC_LEN                     = 0x4\n+\tETHER_CRC_POLY_BE                 = 0x4c11db6\n+\tETHER_CRC_POLY_LE                 = 0xedb88320\n+\tETHER_HDR_LEN                     = 0xe\n+\tETHER_MAX_LEN                     = 0x5ee\n+\tETHER_MAX_LEN_JUMBO               = 0x233a\n+\tETHER_MIN_LEN                     = 0x40\n+\tETHER_PPPOE_ENCAP_LEN             = 0x8\n+\tETHER_TYPE_LEN                    = 0x2\n+\tETHER_VLAN_ENCAP_LEN              = 0x4\n+\tEVFILT_AIO                        = 0x2\n+\tEVFILT_PROC                       = 0x4\n+\tEVFILT_READ                       = 0x0\n+\tEVFILT_SIGNAL                     = 0x5\n+\tEVFILT_SYSCOUNT                   = 0x7\n+\tEVFILT_TIMER                      = 0x6\n+\tEVFILT_VNODE                      = 0x3\n+\tEVFILT_WRITE                      = 0x1\n+\tEV_ADD                            = 0x1\n+\tEV_CLEAR                          = 0x20\n+\tEV_DELETE                         = 0x2\n+\tEV_DISABLE                        = 0x8\n+\tEV_ENABLE                         = 0x4\n+\tEV_EOF                            = 0x8000\n+\tEV_ERROR                          = 0x4000\n+\tEV_FLAG1                          = 0x2000\n+\tEV_ONESHOT                        = 0x10\n+\tEV_SYSFLAGS                       = 0xf000\n+\tEXTA                              = 0x4b00\n+\tEXTATTR_CMD_START                 = 0x1\n+\tEXTATTR_CMD_STOP                  = 0x2\n+\tEXTATTR_NAMESPACE_SYSTEM          = 0x2\n+\tEXTATTR_NAMESPACE_USER            = 0x1\n+\tEXTB                              = 0x9600\n+\tEXTPROC                           = 0x800\n+\tFD_CLOEXEC                        = 0x1\n+\tFD_SETSIZE                        = 0x100\n+\tFLUSHO                            = 0x800000\n+\tF_CLOSEM                          = 0xa\n+\tF_DUPFD                           = 0x0\n+\tF_DUPFD_CLOEXEC                   = 0xc\n+\tF_FSCTL                           = -0x80000000\n+\tF_FSDIRMASK                       = 0x70000000\n+\tF_FSIN                            = 0x10000000\n+\tF_FSINOUT                         = 0x30000000\n+\tF_FSOUT                           = 0x20000000\n+\tF_FSPRIV                          = 0x8000\n+\tF_FSVOID                          = 0x40000000\n+\tF_GETFD                           = 0x1\n+\tF_GETFL                           = 0x3\n+\tF_GETLK                           = 0x7\n+\tF_GETNOSIGPIPE                    = 0xd\n+\tF_GETOWN                          = 0x5\n+\tF_MAXFD                           = 0xb\n+\tF_OK                              = 0x0\n+\tF_PARAM_MASK                      = 0xfff\n+\tF_PARAM_MAX                       = 0xfff\n+\tF_RDLCK                           = 0x1\n+\tF_SETFD                           = 0x2\n+\tF_SETFL                           = 0x4\n+\tF_SETLK                           = 0x8\n+\tF_SETLKW                          = 0x9\n+\tF_SETNOSIGPIPE                    = 0xe\n+\tF_SETOWN                          = 0x6\n+\tF_UNLCK                           = 0x2\n+\tF_WRLCK                           = 0x3\n+\tHUPCL                             = 0x4000\n+\tHW_MACHINE                        = 0x1\n+\tICANON                            = 0x100\n+\tICMP6_FILTER                      = 0x12\n+\tICRNL                             = 0x100\n+\tIEXTEN                            = 0x400\n+\tIFAN_ARRIVAL                      = 0x0\n+\tIFAN_DEPARTURE                    = 0x1\n+\tIFA_ROUTE                         = 0x1\n+\tIFF_ALLMULTI                      = 0x200\n+\tIFF_BROADCAST                     = 0x2\n+\tIFF_CANTCHANGE                    = 0x8f52\n+\tIFF_DEBUG                         = 0x4\n+\tIFF_LINK0                         = 0x1000\n+\tIFF_LINK1                         = 0x2000\n+\tIFF_LINK2                         = 0x4000\n+\tIFF_LOOPBACK                      = 0x8\n+\tIFF_MULTICAST                     = 0x8000\n+\tIFF_NOARP                         = 0x80\n+\tIFF_NOTRAILERS                    = 0x20\n+\tIFF_OACTIVE                       = 0x400\n+\tIFF_POINTOPOINT                   = 0x10\n+\tIFF_PROMISC                       = 0x100\n+\tIFF_RUNNING                       = 0x40\n+\tIFF_SIMPLEX                       = 0x800\n+\tIFF_UP                            = 0x1\n+\tIFNAMSIZ                          = 0x10\n+\tIFT_1822                          = 0x2\n+\tIFT_A12MPPSWITCH                  = 0x82\n+\tIFT_AAL2                          = 0xbb\n+\tIFT_AAL5                          = 0x31\n+\tIFT_ADSL                          = 0x5e\n+\tIFT_AFLANE8023                    = 0x3b\n+\tIFT_AFLANE8025                    = 0x3c\n+\tIFT_ARAP                          = 0x58\n+\tIFT_ARCNET                        = 0x23\n+\tIFT_ARCNETPLUS                    = 0x24\n+\tIFT_ASYNC                         = 0x54\n+\tIFT_ATM                           = 0x25\n+\tIFT_ATMDXI                        = 0x69\n+\tIFT_ATMFUNI                       = 0x6a\n+\tIFT_ATMIMA                        = 0x6b\n+\tIFT_ATMLOGICAL                    = 0x50\n+\tIFT_ATMRADIO                      = 0xbd\n+\tIFT_ATMSUBINTERFACE               = 0x86\n+\tIFT_ATMVCIENDPT                   = 0xc2\n+\tIFT_ATMVIRTUAL                    = 0x95\n+\tIFT_BGPPOLICYACCOUNTING           = 0xa2\n+\tIFT_BRIDGE                        = 0xd1\n+\tIFT_BSC                           = 0x53\n+\tIFT_CARP                          = 0xf8\n+\tIFT_CCTEMUL                       = 0x3d\n+\tIFT_CEPT                          = 0x13\n+\tIFT_CES                           = 0x85\n+\tIFT_CHANNEL                       = 0x46\n+\tIFT_CNR                           = 0x55\n+\tIFT_COFFEE                        = 0x84\n+\tIFT_COMPOSITELINK                 = 0x9b\n+\tIFT_DCN                           = 0x8d\n+\tIFT_DIGITALPOWERLINE              = 0x8a\n+\tIFT_DIGITALWRAPPEROVERHEADCHANNEL = 0xba\n+\tIFT_DLSW                          = 0x4a\n+\tIFT_DOCSCABLEDOWNSTREAM           = 0x80\n+\tIFT_DOCSCABLEMACLAYER             = 0x7f\n+\tIFT_DOCSCABLEUPSTREAM             = 0x81\n+\tIFT_DOCSCABLEUPSTREAMCHANNEL      = 0xcd\n+\tIFT_DS0                           = 0x51\n+\tIFT_DS0BUNDLE                     = 0x52\n+\tIFT_DS1FDL                        = 0xaa\n+\tIFT_DS3                           = 0x1e\n+\tIFT_DTM                           = 0x8c\n+\tIFT_DVBASILN                      = 0xac\n+\tIFT_DVBASIOUT                     = 0xad\n+\tIFT_DVBRCCDOWNSTREAM              = 0x93\n+\tIFT_DVBRCCMACLAYER                = 0x92\n+\tIFT_DVBRCCUPSTREAM                = 0x94\n+\tIFT_ECONET                        = 0xce\n+\tIFT_EON                           = 0x19\n+\tIFT_EPLRS                         = 0x57\n+\tIFT_ESCON                         = 0x49\n+\tIFT_ETHER                         = 0x6\n+\tIFT_FAITH                         = 0xf2\n+\tIFT_FAST                          = 0x7d\n+\tIFT_FASTETHER                     = 0x3e\n+\tIFT_FASTETHERFX                   = 0x45\n+\tIFT_FDDI                          = 0xf\n+\tIFT_FIBRECHANNEL                  = 0x38\n+\tIFT_FRAMERELAYINTERCONNECT        = 0x3a\n+\tIFT_FRAMERELAYMPI                 = 0x5c\n+\tIFT_FRDLCIENDPT                   = 0xc1\n+\tIFT_FRELAY                        = 0x20\n+\tIFT_FRELAYDCE                     = 0x2c\n+\tIFT_FRF16MFRBUNDLE                = 0xa3\n+\tIFT_FRFORWARD                     = 0x9e\n+\tIFT_G703AT2MB                     = 0x43\n+\tIFT_G703AT64K                     = 0x42\n+\tIFT_GIF                           = 0xf0\n+\tIFT_GIGABITETHERNET               = 0x75\n+\tIFT_GR303IDT                      = 0xb2\n+\tIFT_GR303RDT                      = 0xb1\n+\tIFT_H323GATEKEEPER                = 0xa4\n+\tIFT_H323PROXY                     = 0xa5\n+\tIFT_HDH1822                       = 0x3\n+\tIFT_HDLC                          = 0x76\n+\tIFT_HDSL2                         = 0xa8\n+\tIFT_HIPERLAN2                     = 0xb7\n+\tIFT_HIPPI                         = 0x2f\n+\tIFT_HIPPIINTERFACE                = 0x39\n+\tIFT_HOSTPAD                       = 0x5a\n+\tIFT_HSSI                          = 0x2e\n+\tIFT_HY                            = 0xe\n+\tIFT_IBM370PARCHAN                 = 0x48\n+\tIFT_IDSL                          = 0x9a\n+\tIFT_IEEE1394                      = 0x90\n+\tIFT_IEEE80211                     = 0x47\n+\tIFT_IEEE80212                     = 0x37\n+\tIFT_IEEE8023ADLAG                 = 0xa1\n+\tIFT_IFGSN                         = 0x91\n+\tIFT_IMT                           = 0xbe\n+\tIFT_INFINIBAND                    = 0xc7\n+\tIFT_INTERLEAVE                    = 0x7c\n+\tIFT_IP                            = 0x7e\n+\tIFT_IPFORWARD                     = 0x8e\n+\tIFT_IPOVERATM                     = 0x72\n+\tIFT_IPOVERCDLC                    = 0x6d\n+\tIFT_IPOVERCLAW                    = 0x6e\n+\tIFT_IPSWITCH                      = 0x4e\n+\tIFT_ISDN                          = 0x3f\n+\tIFT_ISDNBASIC                     = 0x14\n+\tIFT_ISDNPRIMARY                   = 0x15\n+\tIFT_ISDNS                         = 0x4b\n+\tIFT_ISDNU                         = 0x4c\n+\tIFT_ISO88022LLC                   = 0x29\n+\tIFT_ISO88023                      = 0x7\n+\tIFT_ISO88024                      = 0x8\n+\tIFT_ISO88025                      = 0x9\n+\tIFT_ISO88025CRFPINT               = 0x62\n+\tIFT_ISO88025DTR                   = 0x56\n+\tIFT_ISO88025FIBER                 = 0x73\n+\tIFT_ISO88026                      = 0xa\n+\tIFT_ISUP                          = 0xb3\n+\tIFT_L2VLAN                        = 0x87\n+\tIFT_L3IPVLAN                      = 0x88\n+\tIFT_L3IPXVLAN                     = 0x89\n+\tIFT_LAPB                          = 0x10\n+\tIFT_LAPD                          = 0x4d\n+\tIFT_LAPF                          = 0x77\n+\tIFT_LINEGROUP                     = 0xd2\n+\tIFT_LOCALTALK                     = 0x2a\n+\tIFT_LOOP                          = 0x18\n+\tIFT_MEDIAMAILOVERIP               = 0x8b\n+\tIFT_MFSIGLINK                     = 0xa7\n+\tIFT_MIOX25                        = 0x26\n+\tIFT_MODEM                         = 0x30\n+\tIFT_MPC                           = 0x71\n+\tIFT_MPLS                          = 0xa6\n+\tIFT_MPLSTUNNEL                    = 0x96\n+\tIFT_MSDSL                         = 0x8f\n+\tIFT_MVL                           = 0xbf\n+\tIFT_MYRINET                       = 0x63\n+\tIFT_NFAS                          = 0xaf\n+\tIFT_NSIP                          = 0x1b\n+\tIFT_OPTICALCHANNEL                = 0xc3\n+\tIFT_OPTICALTRANSPORT              = 0xc4\n+\tIFT_OTHER                         = 0x1\n+\tIFT_P10                           = 0xc\n+\tIFT_P80                           = 0xd\n+\tIFT_PARA                          = 0x22\n+\tIFT_PFLOG                         = 0xf5\n+\tIFT_PFSYNC                        = 0xf6\n+\tIFT_PLC                           = 0xae\n+\tIFT_PON155                        = 0xcf\n+\tIFT_PON622                        = 0xd0\n+\tIFT_POS                           = 0xab\n+\tIFT_PPP                           = 0x17\n+\tIFT_PPPMULTILINKBUNDLE            = 0x6c\n+\tIFT_PROPATM                       = 0xc5\n+\tIFT_PROPBWAP2MP                   = 0xb8\n+\tIFT_PROPCNLS                      = 0x59\n+\tIFT_PROPDOCSWIRELESSDOWNSTREAM    = 0xb5\n+\tIFT_PROPDOCSWIRELESSMACLAYER      = 0xb4\n+\tIFT_PROPDOCSWIRELESSUPSTREAM      = 0xb6\n+\tIFT_PROPMUX                       = 0x36\n+\tIFT_PROPVIRTUAL                   = 0x35\n+\tIFT_PROPWIRELESSP2P               = 0x9d\n+\tIFT_PTPSERIAL                     = 0x16\n+\tIFT_PVC                           = 0xf1\n+\tIFT_Q2931                         = 0xc9\n+\tIFT_QLLC                          = 0x44\n+\tIFT_RADIOMAC                      = 0xbc\n+\tIFT_RADSL                         = 0x5f\n+\tIFT_REACHDSL                      = 0xc0\n+\tIFT_RFC1483                       = 0x9f\n+\tIFT_RS232                         = 0x21\n+\tIFT_RSRB                          = 0x4f\n+\tIFT_SDLC                          = 0x11\n+\tIFT_SDSL                          = 0x60\n+\tIFT_SHDSL                         = 0xa9\n+\tIFT_SIP                           = 0x1f\n+\tIFT_SIPSIG                        = 0xcc\n+\tIFT_SIPTG                         = 0xcb\n+\tIFT_SLIP                          = 0x1c\n+\tIFT_SMDSDXI                       = 0x2b\n+\tIFT_SMDSICIP                      = 0x34\n+\tIFT_SONET                         = 0x27\n+\tIFT_SONETOVERHEADCHANNEL          = 0xb9\n+\tIFT_SONETPATH                     = 0x32\n+\tIFT_SONETVT                       = 0x33\n+\tIFT_SRP                           = 0x97\n+\tIFT_SS7SIGLINK                    = 0x9c\n+\tIFT_STACKTOSTACK                  = 0x6f\n+\tIFT_STARLAN                       = 0xb\n+\tIFT_STF                           = 0xd7\n+\tIFT_T1                            = 0x12\n+\tIFT_TDLC                          = 0x74\n+\tIFT_TELINK                        = 0xc8\n+\tIFT_TERMPAD                       = 0x5b\n+\tIFT_TR008                         = 0xb0\n+\tIFT_TRANSPHDLC                    = 0x7b\n+\tIFT_TUNNEL                        = 0x83\n+\tIFT_ULTRA                         = 0x1d\n+\tIFT_USB                           = 0xa0\n+\tIFT_V11                           = 0x40\n+\tIFT_V35                           = 0x2d\n+\tIFT_V36                           = 0x41\n+\tIFT_V37                           = 0x78\n+\tIFT_VDSL                          = 0x61\n+\tIFT_VIRTUALIPADDRESS              = 0x70\n+\tIFT_VIRTUALTG                     = 0xca\n+\tIFT_VOICEDID                      = 0xd5\n+\tIFT_VOICEEM                       = 0x64\n+\tIFT_VOICEEMFGD                    = 0xd3\n+\tIFT_VOICEENCAP                    = 0x67\n+\tIFT_VOICEFGDEANA                  = 0xd4\n+\tIFT_VOICEFXO                      = 0x65\n+\tIFT_VOICEFXS                      = 0x66\n+\tIFT_VOICEOVERATM                  = 0x98\n+\tIFT_VOICEOVERCABLE                = 0xc6\n+\tIFT_VOICEOVERFRAMERELAY           = 0x99\n+\tIFT_VOICEOVERIP                   = 0x68\n+\tIFT_X213                          = 0x5d\n+\tIFT_X25                           = 0x5\n+\tIFT_X25DDN                        = 0x4\n+\tIFT_X25HUNTGROUP                  = 0x7a\n+\tIFT_X25MLP                        = 0x79\n+\tIFT_X25PLE                        = 0x28\n+\tIFT_XETHER                        = 0x1a\n+\tIGNBRK                            = 0x1\n+\tIGNCR                             = 0x80\n+\tIGNPAR                            = 0x4\n+\tIMAXBEL                           = 0x2000\n+\tINLCR                             = 0x40\n+\tINPCK                             = 0x10\n+\tIN_CLASSA_HOST                    = 0xffffff\n+\tIN_CLASSA_MAX                     = 0x80\n+\tIN_CLASSA_NET                     = 0xff000000\n+\tIN_CLASSA_NSHIFT                  = 0x18\n+\tIN_CLASSB_HOST                    = 0xffff\n+\tIN_CLASSB_MAX                     = 0x10000\n+\tIN_CLASSB_NET                     = 0xffff0000\n+\tIN_CLASSB_NSHIFT                  = 0x10\n+\tIN_CLASSC_HOST                    = 0xff\n+\tIN_CLASSC_NET                     = 0xffffff00\n+\tIN_CLASSC_NSHIFT                  = 0x8\n+\tIN_CLASSD_HOST                    = 0xfffffff\n+\tIN_CLASSD_NET                     = 0xf0000000\n+\tIN_CLASSD_NSHIFT                  = 0x1c\n+\tIN_LOOPBACKNET                    = 0x7f\n+\tIPPROTO_AH                        = 0x33\n+\tIPPROTO_CARP                      = 0x70\n+\tIPPROTO_DONE                      = 0x101\n+\tIPPROTO_DSTOPTS                   = 0x3c\n+\tIPPROTO_EGP                       = 0x8\n+\tIPPROTO_ENCAP                     = 0x62\n+\tIPPROTO_EON                       = 0x50\n+\tIPPROTO_ESP                       = 0x32\n+\tIPPROTO_ETHERIP                   = 0x61\n+\tIPPROTO_FRAGMENT                  = 0x2c\n+\tIPPROTO_GGP                       = 0x3\n+\tIPPROTO_GRE                       = 0x2f\n+\tIPPROTO_HOPOPTS                   = 0x0\n+\tIPPROTO_ICMP                      = 0x1\n+\tIPPROTO_ICMPV6                    = 0x3a\n+\tIPPROTO_IDP                       = 0x16\n+\tIPPROTO_IGMP                      = 0x2\n+\tIPPROTO_IP                        = 0x0\n+\tIPPROTO_IPCOMP                    = 0x6c\n+\tIPPROTO_IPIP                      = 0x4\n+\tIPPROTO_IPV4                      = 0x4\n+\tIPPROTO_IPV6                      = 0x29\n+\tIPPROTO_IPV6_ICMP                 = 0x3a\n+\tIPPROTO_MAX                       = 0x100\n+\tIPPROTO_MAXID                     = 0x34\n+\tIPPROTO_MOBILE                    = 0x37\n+\tIPPROTO_NONE                      = 0x3b\n+\tIPPROTO_PFSYNC                    = 0xf0\n+\tIPPROTO_PIM                       = 0x67\n+\tIPPROTO_PUP                       = 0xc\n+\tIPPROTO_RAW                       = 0xff\n+\tIPPROTO_ROUTING                   = 0x2b\n+\tIPPROTO_RSVP                      = 0x2e\n+\tIPPROTO_TCP                       = 0x6\n+\tIPPROTO_TP                        = 0x1d\n+\tIPPROTO_UDP                       = 0x11\n+\tIPPROTO_VRRP                      = 0x70\n+\tIPV6_CHECKSUM                     = 0x1a\n+\tIPV6_DEFAULT_MULTICAST_HOPS       = 0x1\n+\tIPV6_DEFAULT_MULTICAST_LOOP       = 0x1\n+\tIPV6_DEFHLIM                      = 0x40\n+\tIPV6_DONTFRAG                     = 0x3e\n+\tIPV6_DSTOPTS                      = 0x32\n+\tIPV6_FAITH                        = 0x1d\n+\tIPV6_FLOWINFO_MASK                = 0xffffff0f\n+\tIPV6_FLOWLABEL_MASK               = 0xffff0f00\n+\tIPV6_FRAGTTL                      = 0x78\n+\tIPV6_HLIMDEC                      = 0x1\n+\tIPV6_HOPLIMIT                     = 0x2f\n+\tIPV6_HOPOPTS                      = 0x31\n+\tIPV6_IPSEC_POLICY                 = 0x1c\n+\tIPV6_JOIN_GROUP                   = 0xc\n+\tIPV6_LEAVE_GROUP                  = 0xd\n+\tIPV6_MAXHLIM                      = 0xff\n+\tIPV6_MAXPACKET                    = 0xffff\n+\tIPV6_MMTU                         = 0x500\n+\tIPV6_MULTICAST_HOPS               = 0xa\n+\tIPV6_MULTICAST_IF                 = 0x9\n+\tIPV6_MULTICAST_LOOP               = 0xb\n+\tIPV6_NEXTHOP                      = 0x30\n+\tIPV6_PATHMTU                      = 0x2c\n+\tIPV6_PKTINFO                      = 0x2e\n+\tIPV6_PORTRANGE                    = 0xe\n+\tIPV6_PORTRANGE_DEFAULT            = 0x0\n+\tIPV6_PORTRANGE_HIGH               = 0x1\n+\tIPV6_PORTRANGE_LOW                = 0x2\n+\tIPV6_RECVDSTOPTS                  = 0x28\n+\tIPV6_RECVHOPLIMIT                 = 0x25\n+\tIPV6_RECVHOPOPTS                  = 0x27\n+\tIPV6_RECVPATHMTU                  = 0x2b\n+\tIPV6_RECVPKTINFO                  = 0x24\n+\tIPV6_RECVRTHDR                    = 0x26\n+\tIPV6_RECVTCLASS                   = 0x39\n+\tIPV6_RTHDR                        = 0x33\n+\tIPV6_RTHDRDSTOPTS                 = 0x23\n+\tIPV6_RTHDR_LOOSE                  = 0x0\n+\tIPV6_RTHDR_STRICT                 = 0x1\n+\tIPV6_RTHDR_TYPE_0                 = 0x0\n+\tIPV6_SOCKOPT_RESERVED1            = 0x3\n+\tIPV6_TCLASS                       = 0x3d\n+\tIPV6_UNICAST_HOPS                 = 0x4\n+\tIPV6_USE_MIN_MTU                  = 0x2a\n+\tIPV6_V6ONLY                       = 0x1b\n+\tIPV6_VERSION                      = 0x60\n+\tIPV6_VERSION_MASK                 = 0xf0\n+\tIP_ADD_MEMBERSHIP                 = 0xc\n+\tIP_DEFAULT_MULTICAST_LOOP         = 0x1\n+\tIP_DEFAULT_MULTICAST_TTL          = 0x1\n+\tIP_DF                             = 0x4000\n+\tIP_DROP_MEMBERSHIP                = 0xd\n+\tIP_EF                             = 0x8000\n+\tIP_ERRORMTU                       = 0x15\n+\tIP_HDRINCL                        = 0x2\n+\tIP_IPSEC_POLICY                   = 0x16\n+\tIP_MAXPACKET                      = 0xffff\n+\tIP_MAX_MEMBERSHIPS                = 0x14\n+\tIP_MF                             = 0x2000\n+\tIP_MINFRAGSIZE                    = 0x45\n+\tIP_MINTTL                         = 0x18\n+\tIP_MSS                            = 0x240\n+\tIP_MULTICAST_IF                   = 0x9\n+\tIP_MULTICAST_LOOP                 = 0xb\n+\tIP_MULTICAST_TTL                  = 0xa\n+\tIP_OFFMASK                        = 0x1fff\n+\tIP_OPTIONS                        = 0x1\n+\tIP_PORTRANGE                      = 0x13\n+\tIP_PORTRANGE_DEFAULT              = 0x0\n+\tIP_PORTRANGE_HIGH                 = 0x1\n+\tIP_PORTRANGE_LOW                  = 0x2\n+\tIP_RECVDSTADDR                    = 0x7\n+\tIP_RECVIF                         = 0x14\n+\tIP_RECVOPTS                       = 0x5\n+\tIP_RECVRETOPTS                    = 0x6\n+\tIP_RECVTTL                        = 0x17\n+\tIP_RETOPTS                        = 0x8\n+\tIP_RF                             = 0x8000\n+\tIP_TOS                            = 0x3\n+\tIP_TTL                            = 0x4\n+\tISIG                              = 0x80\n+\tISTRIP                            = 0x20\n+\tIXANY                             = 0x800\n+\tIXOFF                             = 0x400\n+\tIXON                              = 0x200\n+\tKERN_HOSTNAME                     = 0xa\n+\tKERN_OSRELEASE                    = 0x2\n+\tKERN_OSTYPE                       = 0x1\n+\tKERN_VERSION                      = 0x4\n+\tLOCK_EX                           = 0x2\n+\tLOCK_NB                           = 0x4\n+\tLOCK_SH                           = 0x1\n+\tLOCK_UN                           = 0x8\n+\tMADV_DONTNEED                     = 0x4\n+\tMADV_FREE                         = 0x6\n+\tMADV_NORMAL                       = 0x0\n+\tMADV_RANDOM                       = 0x1\n+\tMADV_SEQUENTIAL                   = 0x2\n+\tMADV_SPACEAVAIL                   = 0x5\n+\tMADV_WILLNEED                     = 0x3\n+\tMAP_ALIGNMENT_16MB                = 0x18000000\n+\tMAP_ALIGNMENT_1TB                 = 0x28000000\n+\tMAP_ALIGNMENT_256TB               = 0x30000000\n+\tMAP_ALIGNMENT_4GB                 = 0x20000000\n+\tMAP_ALIGNMENT_64KB                = 0x10000000\n+\tMAP_ALIGNMENT_64PB                = 0x38000000\n+\tMAP_ALIGNMENT_MASK                = -0x1000000\n+\tMAP_ALIGNMENT_SHIFT               = 0x18\n+\tMAP_ANON                          = 0x1000\n+\tMAP_FILE                          = 0x0\n+\tMAP_FIXED                         = 0x10\n+\tMAP_HASSEMAPHORE                  = 0x200\n+\tMAP_INHERIT                       = 0x80\n+\tMAP_INHERIT_COPY                  = 0x1\n+\tMAP_INHERIT_DEFAULT               = 0x1\n+\tMAP_INHERIT_DONATE_COPY           = 0x3\n+\tMAP_INHERIT_NONE                  = 0x2\n+\tMAP_INHERIT_SHARE                 = 0x0\n+\tMAP_NORESERVE                     = 0x40\n+\tMAP_PRIVATE                       = 0x2\n+\tMAP_RENAME                        = 0x20\n+\tMAP_SHARED                        = 0x1\n+\tMAP_STACK                         = 0x2000\n+\tMAP_TRYFIXED                      = 0x400\n+\tMAP_WIRED                         = 0x800\n+\tMCL_CURRENT                       = 0x1\n+\tMCL_FUTURE                        = 0x2\n+\tMNT_ASYNC                         = 0x40\n+\tMNT_BASIC_FLAGS                   = 0xe782807f\n+\tMNT_DEFEXPORTED                   = 0x200\n+\tMNT_DISCARD                       = 0x800000\n+\tMNT_EXKERB                        = 0x800\n+\tMNT_EXNORESPORT                   = 0x8000000\n+\tMNT_EXPORTANON                    = 0x400\n+\tMNT_EXPORTED                      = 0x100\n+\tMNT_EXPUBLIC                      = 0x10000000\n+\tMNT_EXRDONLY                      = 0x80\n+\tMNT_EXTATTR                       = 0x1000000\n+\tMNT_FORCE                         = 0x80000\n+\tMNT_GETARGS                       = 0x400000\n+\tMNT_IGNORE                        = 0x100000\n+\tMNT_LAZY                          = 0x3\n+\tMNT_LOCAL                         = 0x1000\n+\tMNT_LOG                           = 0x2000000\n+\tMNT_NOATIME                       = 0x4000000\n+\tMNT_NOCOREDUMP                    = 0x8000\n+\tMNT_NODEV                         = 0x10\n+\tMNT_NODEVMTIME                    = 0x40000000\n+\tMNT_NOEXEC                        = 0x4\n+\tMNT_NOSUID                        = 0x8\n+\tMNT_NOWAIT                        = 0x2\n+\tMNT_OP_FLAGS                      = 0x4d0000\n+\tMNT_QUOTA                         = 0x2000\n+\tMNT_RDONLY                        = 0x1\n+\tMNT_RELATIME                      = 0x20000\n+\tMNT_RELOAD                        = 0x40000\n+\tMNT_ROOTFS                        = 0x4000\n+\tMNT_SOFTDEP                       = 0x80000000\n+\tMNT_SYMPERM                       = 0x20000000\n+\tMNT_SYNCHRONOUS                   = 0x2\n+\tMNT_UNION                         = 0x20\n+\tMNT_UPDATE                        = 0x10000\n+\tMNT_VISFLAGMASK                   = 0xff90ffff\n+\tMNT_WAIT                          = 0x1\n+\tMSG_BCAST                         = 0x100\n+\tMSG_CMSG_CLOEXEC                  = 0x800\n+\tMSG_CONTROLMBUF                   = 0x2000000\n+\tMSG_CTRUNC                        = 0x20\n+\tMSG_DONTROUTE                     = 0x4\n+\tMSG_DONTWAIT                      = 0x80\n+\tMSG_EOR                           = 0x8\n+\tMSG_IOVUSRSPACE                   = 0x4000000\n+\tMSG_LENUSRSPACE                   = 0x8000000\n+\tMSG_MCAST                         = 0x200\n+\tMSG_NAMEMBUF                      = 0x1000000\n+\tMSG_NBIO                          = 0x1000\n+\tMSG_NOSIGNAL                      = 0x400\n+\tMSG_OOB                           = 0x1\n+\tMSG_PEEK                          = 0x2\n+\tMSG_TRUNC                         = 0x10\n+\tMSG_USERFLAGS                     = 0xffffff\n+\tMSG_WAITALL                       = 0x40\n+\tMS_ASYNC                          = 0x1\n+\tMS_INVALIDATE                     = 0x2\n+\tMS_SYNC                           = 0x4\n+\tNAME_MAX                          = 0x1ff\n+\tNET_RT_DUMP                       = 0x1\n+\tNET_RT_FLAGS                      = 0x2\n+\tNET_RT_IFLIST                     = 0x5\n+\tNET_RT_MAXID                      = 0x6\n+\tNET_RT_OIFLIST                    = 0x4\n+\tNET_RT_OOIFLIST                   = 0x3\n+\tNOFLSH                            = 0x80000000\n+\tNOTE_ATTRIB                       = 0x8\n+\tNOTE_CHILD                        = 0x4\n+\tNOTE_DELETE                       = 0x1\n+\tNOTE_EXEC                         = 0x20000000\n+\tNOTE_EXIT                         = 0x80000000\n+\tNOTE_EXTEND                       = 0x4\n+\tNOTE_FORK                         = 0x40000000\n+\tNOTE_LINK                         = 0x10\n+\tNOTE_LOWAT                        = 0x1\n+\tNOTE_PCTRLMASK                    = 0xf0000000\n+\tNOTE_PDATAMASK                    = 0xfffff\n+\tNOTE_RENAME                       = 0x20\n+\tNOTE_REVOKE                       = 0x40\n+\tNOTE_TRACK                        = 0x1\n+\tNOTE_TRACKERR                     = 0x2\n+\tNOTE_WRITE                        = 0x2\n+\tOCRNL                             = 0x10\n+\tOFIOGETBMAP                       = 0xc004667a\n+\tONLCR                             = 0x2\n+\tONLRET                            = 0x40\n+\tONOCR                             = 0x20\n+\tONOEOT                            = 0x8\n+\tOPOST                             = 0x1\n+\tO_ACCMODE                         = 0x3\n+\tO_ALT_IO                          = 0x40000\n+\tO_APPEND                          = 0x8\n+\tO_ASYNC                           = 0x40\n+\tO_CLOEXEC                         = 0x400000\n+\tO_CREAT                           = 0x200\n+\tO_DIRECT                          = 0x80000\n+\tO_DIRECTORY                       = 0x200000\n+\tO_DSYNC                           = 0x10000\n+\tO_EXCL                            = 0x800\n+\tO_EXLOCK                          = 0x20\n+\tO_FSYNC                           = 0x80\n+\tO_NDELAY                          = 0x4\n+\tO_NOCTTY                          = 0x8000\n+\tO_NOFOLLOW                        = 0x100\n+\tO_NONBLOCK                        = 0x4\n+\tO_NOSIGPIPE                       = 0x1000000\n+\tO_RDONLY                          = 0x0\n+\tO_RDWR                            = 0x2\n+\tO_RSYNC                           = 0x20000\n+\tO_SHLOCK                          = 0x10\n+\tO_SYNC                            = 0x80\n+\tO_TRUNC                           = 0x400\n+\tO_WRONLY                          = 0x1\n+\tPARENB                            = 0x1000\n+\tPARMRK                            = 0x8\n+\tPARODD                            = 0x2000\n+\tPENDIN                            = 0x20000000\n+\tPRIO_PGRP                         = 0x1\n+\tPRIO_PROCESS                      = 0x0\n+\tPRIO_USER                         = 0x2\n+\tPRI_IOFLUSH                       = 0x7c\n+\tPROT_EXEC                         = 0x4\n+\tPROT_NONE                         = 0x0\n+\tPROT_READ                         = 0x1\n+\tPROT_WRITE                        = 0x2\n+\tRLIMIT_AS                         = 0xa\n+\tRLIMIT_CORE                       = 0x4\n+\tRLIMIT_CPU                        = 0x0\n+\tRLIMIT_DATA                       = 0x2\n+\tRLIMIT_FSIZE                      = 0x1\n+\tRLIMIT_MEMLOCK                    = 0x6\n+\tRLIMIT_NOFILE                     = 0x8\n+\tRLIMIT_NPROC                      = 0x7\n+\tRLIMIT_RSS                        = 0x5\n+\tRLIMIT_STACK                      = 0x3\n+\tRLIM_INFINITY                     = 0x7fffffffffffffff\n+\tRTAX_AUTHOR                       = 0x6\n+\tRTAX_BRD                          = 0x7\n+\tRTAX_DST                          = 0x0\n+\tRTAX_GATEWAY                      = 0x1\n+\tRTAX_GENMASK                      = 0x3\n+\tRTAX_IFA                          = 0x5\n+\tRTAX_IFP                          = 0x4\n+\tRTAX_MAX                          = 0x9\n+\tRTAX_NETMASK                      = 0x2\n+\tRTAX_TAG                          = 0x8\n+\tRTA_AUTHOR                        = 0x40\n+\tRTA_BRD                           = 0x80\n+\tRTA_DST                           = 0x1\n+\tRTA_GATEWAY                       = 0x2\n+\tRTA_GENMASK                       = 0x8\n+\tRTA_IFA                           = 0x20\n+\tRTA_IFP                           = 0x10\n+\tRTA_NETMASK                       = 0x4\n+\tRTA_TAG                           = 0x100\n+\tRTF_ANNOUNCE                      = 0x20000\n+\tRTF_BLACKHOLE                     = 0x1000\n+\tRTF_CLONED                        = 0x2000\n+\tRTF_CLONING                       = 0x100\n+\tRTF_DONE                          = 0x40\n+\tRTF_DYNAMIC                       = 0x10\n+\tRTF_GATEWAY                       = 0x2\n+\tRTF_HOST                          = 0x4\n+\tRTF_LLINFO                        = 0x400\n+\tRTF_MASK                          = 0x80\n+\tRTF_MODIFIED                      = 0x20\n+\tRTF_PROTO1                        = 0x8000\n+\tRTF_PROTO2                        = 0x4000\n+\tRTF_REJECT                        = 0x8\n+\tRTF_SRC                           = 0x10000\n+\tRTF_STATIC                        = 0x800\n+\tRTF_UP                            = 0x1\n+\tRTF_XRESOLVE                      = 0x200\n+\tRTM_ADD                           = 0x1\n+\tRTM_CHANGE                        = 0x3\n+\tRTM_CHGADDR                       = 0x15\n+\tRTM_DELADDR                       = 0xd\n+\tRTM_DELETE                        = 0x2\n+\tRTM_GET                           = 0x4\n+\tRTM_IEEE80211                     = 0x11\n+\tRTM_IFANNOUNCE                    = 0x10\n+\tRTM_IFINFO                        = 0x14\n+\tRTM_LLINFO_UPD                    = 0x13\n+\tRTM_LOCK                          = 0x8\n+\tRTM_LOSING                        = 0x5\n+\tRTM_MISS                          = 0x7\n+\tRTM_NEWADDR                       = 0xc\n+\tRTM_OIFINFO                       = 0xf\n+\tRTM_OLDADD                        = 0x9\n+\tRTM_OLDDEL                        = 0xa\n+\tRTM_OOIFINFO                      = 0xe\n+\tRTM_REDIRECT                      = 0x6\n+\tRTM_RESOLVE                       = 0xb\n+\tRTM_RTTUNIT                       = 0xf4240\n+\tRTM_SETGATE                       = 0x12\n+\tRTM_VERSION                       = 0x4\n+\tRTV_EXPIRE                        = 0x4\n+\tRTV_HOPCOUNT                      = 0x2\n+\tRTV_MTU                           = 0x1\n+\tRTV_RPIPE                         = 0x8\n+\tRTV_RTT                           = 0x40\n+\tRTV_RTTVAR                        = 0x80\n+\tRTV_SPIPE                         = 0x10\n+\tRTV_SSTHRESH                      = 0x20\n+\tRUSAGE_CHILDREN                   = -0x1\n+\tRUSAGE_SELF                       = 0x0\n+\tSCM_CREDS                         = 0x4\n+\tSCM_RIGHTS                        = 0x1\n+\tSCM_TIMESTAMP                     = 0x8\n+\tSHUT_RD                           = 0x0\n+\tSHUT_RDWR                         = 0x2\n+\tSHUT_WR                           = 0x1\n+\tSIOCADDMULTI                      = 0x80906931\n+\tSIOCADDRT                         = 0x8038720a\n+\tSIOCAIFADDR                       = 0x8040691a\n+\tSIOCALIFADDR                      = 0x8118691c\n+\tSIOCATMARK                        = 0x40047307\n+\tSIOCDELMULTI                      = 0x80906932\n+\tSIOCDELRT                         = 0x8038720b\n+\tSIOCDIFADDR                       = 0x80906919\n+\tSIOCDIFPHYADDR                    = 0x80906949\n+\tSIOCDLIFADDR                      = 0x8118691e\n+\tSIOCGDRVSPEC                      = 0xc028697b\n+\tSIOCGETPFSYNC                     = 0xc09069f8\n+\tSIOCGETSGCNT                      = 0xc0207534\n+\tSIOCGETVIFCNT                     = 0xc0287533\n+\tSIOCGHIWAT                        = 0x40047301\n+\tSIOCGIFADDR                       = 0xc0906921\n+\tSIOCGIFADDRPREF                   = 0xc0986920\n+\tSIOCGIFALIAS                      = 0xc040691b\n+\tSIOCGIFBRDADDR                    = 0xc0906923\n+\tSIOCGIFCAP                        = 0xc0206976\n+\tSIOCGIFCONF                       = 0xc0106926\n+\tSIOCGIFDATA                       = 0xc0986985\n+\tSIOCGIFDLT                        = 0xc0906977\n+\tSIOCGIFDSTADDR                    = 0xc0906922\n+\tSIOCGIFFLAGS                      = 0xc0906911\n+\tSIOCGIFGENERIC                    = 0xc090693a\n+\tSIOCGIFMEDIA                      = 0xc0306936\n+\tSIOCGIFMETRIC                     = 0xc0906917\n+\tSIOCGIFMTU                        = 0xc090697e\n+\tSIOCGIFNETMASK                    = 0xc0906925\n+\tSIOCGIFPDSTADDR                   = 0xc0906948\n+\tSIOCGIFPSRCADDR                   = 0xc0906947\n+\tSIOCGLIFADDR                      = 0xc118691d\n+\tSIOCGLIFPHYADDR                   = 0xc118694b\n+\tSIOCGLINKSTR                      = 0xc0286987\n+\tSIOCGLOWAT                        = 0x40047303\n+\tSIOCGPGRP                         = 0x40047309\n+\tSIOCGVH                           = 0xc0906983\n+\tSIOCIFCREATE                      = 0x8090697a\n+\tSIOCIFDESTROY                     = 0x80906979\n+\tSIOCIFGCLONERS                    = 0xc0106978\n+\tSIOCINITIFADDR                    = 0xc0706984\n+\tSIOCSDRVSPEC                      = 0x8028697b\n+\tSIOCSETPFSYNC                     = 0x809069f7\n+\tSIOCSHIWAT                        = 0x80047300\n+\tSIOCSIFADDR                       = 0x8090690c\n+\tSIOCSIFADDRPREF                   = 0x8098691f\n+\tSIOCSIFBRDADDR                    = 0x80906913\n+\tSIOCSIFCAP                        = 0x80206975\n+\tSIOCSIFDSTADDR                    = 0x8090690e\n+\tSIOCSIFFLAGS                      = 0x80906910\n+\tSIOCSIFGENERIC                    = 0x80906939\n+\tSIOCSIFMEDIA                      = 0xc0906935\n+\tSIOCSIFMETRIC                     = 0x80906918\n+\tSIOCSIFMTU                        = 0x8090697f\n+\tSIOCSIFNETMASK                    = 0x80906916\n+\tSIOCSIFPHYADDR                    = 0x80406946\n+\tSIOCSLIFPHYADDR                   = 0x8118694a\n+\tSIOCSLINKSTR                      = 0x80286988\n+\tSIOCSLOWAT                        = 0x80047302\n+\tSIOCSPGRP                         = 0x80047308\n+\tSIOCSVH                           = 0xc0906982\n+\tSIOCZIFDATA                       = 0xc0986986\n+\tSOCK_CLOEXEC                      = 0x10000000\n+\tSOCK_DGRAM                        = 0x2\n+\tSOCK_FLAGS_MASK                   = 0xf0000000\n+\tSOCK_NONBLOCK                     = 0x20000000\n+\tSOCK_NOSIGPIPE                    = 0x40000000\n+\tSOCK_RAW                          = 0x3\n+\tSOCK_RDM                          = 0x4\n+\tSOCK_SEQPACKET                    = 0x5\n+\tSOCK_STREAM                       = 0x1\n+\tSOL_SOCKET                        = 0xffff\n+\tSOMAXCONN                         = 0x80\n+\tSO_ACCEPTCONN                     = 0x2\n+\tSO_ACCEPTFILTER                   = 0x1000\n+\tSO_BROADCAST                      = 0x20\n+\tSO_DEBUG                          = 0x1\n+\tSO_DONTROUTE                      = 0x10\n+\tSO_ERROR                          = 0x1007\n+\tSO_KEEPALIVE                      = 0x8\n+\tSO_LINGER                         = 0x80\n+\tSO_NOHEADER                       = 0x100a\n+\tSO_NOSIGPIPE                      = 0x800\n+\tSO_OOBINLINE                      = 0x100\n+\tSO_OVERFLOWED                     = 0x1009\n+\tSO_RCVBUF                         = 0x1002\n+\tSO_RCVLOWAT                       = 0x1004\n+\tSO_RCVTIMEO                       = 0x100c\n+\tSO_REUSEADDR                      = 0x4\n+\tSO_REUSEPORT                      = 0x200\n+\tSO_SNDBUF                         = 0x1001\n+\tSO_SNDLOWAT                       = 0x1003\n+\tSO_SNDTIMEO                       = 0x100b\n+\tSO_TIMESTAMP                      = 0x2000\n+\tSO_TYPE                           = 0x1008\n+\tSO_USELOOPBACK                    = 0x40\n+\tSYSCTL_VERSION                    = 0x1000000\n+\tSYSCTL_VERS_0                     = 0x0\n+\tSYSCTL_VERS_1                     = 0x1000000\n+\tSYSCTL_VERS_MASK                  = 0xff000000\n+\tS_ARCH1                           = 0x10000\n+\tS_ARCH2                           = 0x20000\n+\tS_BLKSIZE                         = 0x200\n+\tS_IEXEC                           = 0x40\n+\tS_IFBLK                           = 0x6000\n+\tS_IFCHR                           = 0x2000\n+\tS_IFDIR                           = 0x4000\n+\tS_IFIFO                           = 0x1000\n+\tS_IFLNK                           = 0xa000\n+\tS_IFMT                            = 0xf000\n+\tS_IFREG                           = 0x8000\n+\tS_IFSOCK                          = 0xc000\n+\tS_IFWHT                           = 0xe000\n+\tS_IREAD                           = 0x100\n+\tS_IRGRP                           = 0x20\n+\tS_IROTH                           = 0x4\n+\tS_IRUSR                           = 0x100\n+\tS_IRWXG                           = 0x38\n+\tS_IRWXO                           = 0x7\n+\tS_IRWXU                           = 0x1c0\n+\tS_ISGID                           = 0x400\n+\tS_ISTXT                           = 0x200\n+\tS_ISUID                           = 0x800\n+\tS_ISVTX                           = 0x200\n+\tS_IWGRP                           = 0x10\n+\tS_IWOTH                           = 0x2\n+\tS_IWRITE                          = 0x80\n+\tS_IWUSR                           = 0x80\n+\tS_IXGRP                           = 0x8\n+\tS_IXOTH                           = 0x1\n+\tS_IXUSR                           = 0x40\n+\tS_LOGIN_SET                       = 0x1\n+\tTCIFLUSH                          = 0x1\n+\tTCIOFLUSH                         = 0x3\n+\tTCOFLUSH                          = 0x2\n+\tTCP_CONGCTL                       = 0x20\n+\tTCP_KEEPCNT                       = 0x6\n+\tTCP_KEEPIDLE                      = 0x3\n+\tTCP_KEEPINIT                      = 0x7\n+\tTCP_KEEPINTVL                     = 0x5\n+\tTCP_MAXBURST                      = 0x4\n+\tTCP_MAXSEG                        = 0x2\n+\tTCP_MAXWIN                        = 0xffff\n+\tTCP_MAX_WINSHIFT                  = 0xe\n+\tTCP_MD5SIG                        = 0x10\n+\tTCP_MINMSS                        = 0xd8\n+\tTCP_MSS                           = 0x218\n+\tTCP_NODELAY                       = 0x1\n+\tTCSAFLUSH                         = 0x2\n+\tTIOCCBRK                          = 0x2000747a\n+\tTIOCCDTR                          = 0x20007478\n+\tTIOCCONS                          = 0x80047462\n+\tTIOCDCDTIMESTAMP                  = 0x40107458\n+\tTIOCDRAIN                         = 0x2000745e\n+\tTIOCEXCL                          = 0x2000740d\n+\tTIOCEXT                           = 0x80047460\n+\tTIOCFLAG_CDTRCTS                  = 0x10\n+\tTIOCFLAG_CLOCAL                   = 0x2\n+\tTIOCFLAG_CRTSCTS                  = 0x4\n+\tTIOCFLAG_MDMBUF                   = 0x8\n+\tTIOCFLAG_SOFTCAR                  = 0x1\n+\tTIOCFLUSH                         = 0x80047410\n+\tTIOCGETA                          = 0x402c7413\n+\tTIOCGETD                          = 0x4004741a\n+\tTIOCGFLAGS                        = 0x4004745d\n+\tTIOCGLINED                        = 0x40207442\n+\tTIOCGPGRP                         = 0x40047477\n+\tTIOCGQSIZE                        = 0x40047481\n+\tTIOCGRANTPT                       = 0x20007447\n+\tTIOCGSID                          = 0x40047463\n+\tTIOCGSIZE                         = 0x40087468\n+\tTIOCGWINSZ                        = 0x40087468\n+\tTIOCMBIC                          = 0x8004746b\n+\tTIOCMBIS                          = 0x8004746c\n+\tTIOCMGET                          = 0x4004746a\n+\tTIOCMSET                          = 0x8004746d\n+\tTIOCM_CAR                         = 0x40\n+\tTIOCM_CD                          = 0x40\n+\tTIOCM_CTS                         = 0x20\n+\tTIOCM_DSR                         = 0x100\n+\tTIOCM_DTR                         = 0x2\n+\tTIOCM_LE                          = 0x1\n+\tTIOCM_RI                          = 0x80\n+\tTIOCM_RNG                         = 0x80\n+\tTIOCM_RTS                         = 0x4\n+\tTIOCM_SR                          = 0x10\n+\tTIOCM_ST                          = 0x8\n+\tTIOCNOTTY                         = 0x20007471\n+\tTIOCNXCL                          = 0x2000740e\n+\tTIOCOUTQ                          = 0x40047473\n+\tTIOCPKT                           = 0x80047470\n+\tTIOCPKT_DATA                      = 0x0\n+\tTIOCPKT_DOSTOP                    = 0x20\n+\tTIOCPKT_FLUSHREAD                 = 0x1\n+\tTIOCPKT_FLUSHWRITE                = 0x2\n+\tTIOCPKT_IOCTL                     = 0x40\n+\tTIOCPKT_NOSTOP                    = 0x10\n+\tTIOCPKT_START                     = 0x8\n+\tTIOCPKT_STOP                      = 0x4\n+\tTIOCPTMGET                        = 0x40287446\n+\tTIOCPTSNAME                       = 0x40287448\n+\tTIOCRCVFRAME                      = 0x80087445\n+\tTIOCREMOTE                        = 0x80047469\n+\tTIOCSBRK                          = 0x2000747b\n+\tTIOCSCTTY                         = 0x20007461\n+\tTIOCSDTR                          = 0x20007479\n+\tTIOCSETA                          = 0x802c7414\n+\tTIOCSETAF                         = 0x802c7416\n+\tTIOCSETAW                         = 0x802c7415\n+\tTIOCSETD                          = 0x8004741b\n+\tTIOCSFLAGS                        = 0x8004745c\n+\tTIOCSIG                           = 0x2000745f\n+\tTIOCSLINED                        = 0x80207443\n+\tTIOCSPGRP                         = 0x80047476\n+\tTIOCSQSIZE                        = 0x80047480\n+\tTIOCSSIZE                         = 0x80087467\n+\tTIOCSTART                         = 0x2000746e\n+\tTIOCSTAT                          = 0x80047465\n+\tTIOCSTI                           = 0x80017472\n+\tTIOCSTOP                          = 0x2000746f\n+\tTIOCSWINSZ                        = 0x80087467\n+\tTIOCUCNTL                         = 0x80047466\n+\tTIOCXMTFRAME                      = 0x80087444\n+\tTOSTOP                            = 0x400000\n+\tVDISCARD                          = 0xf\n+\tVDSUSP                            = 0xb\n+\tVEOF                              = 0x0\n+\tVEOL                              = 0x1\n+\tVEOL2                             = 0x2\n+\tVERASE                            = 0x3\n+\tVINTR                             = 0x8\n+\tVKILL                             = 0x5\n+\tVLNEXT                            = 0xe\n+\tVMIN                              = 0x10\n+\tVQUIT                             = 0x9\n+\tVREPRINT                          = 0x6\n+\tVSTART                            = 0xc\n+\tVSTATUS                           = 0x12\n+\tVSTOP                             = 0xd\n+\tVSUSP                             = 0xa\n+\tVTIME                             = 0x11\n+\tVWERASE                           = 0x4\n+\tWALL                              = 0x8\n+\tWALLSIG                           = 0x8\n+\tWALTSIG                           = 0x4\n+\tWCLONE                            = 0x4\n+\tWCOREFLAG                         = 0x80\n+\tWNOHANG                           = 0x1\n+\tWNOWAIT                           = 0x10000\n+\tWNOZOMBIE                         = 0x20000\n+\tWOPTSCHECKED                      = 0x40000\n+\tWSTOPPED                          = 0x7f\n+\tWUNTRACED                         = 0x2\n+)\n+\n+// Errors\n+const (\n+\tE2BIG           = syscall.Errno(0x7)\n+\tEACCES          = syscall.Errno(0xd)\n+\tEADDRINUSE      = syscall.Errno(0x30)\n+\tEADDRNOTAVAIL   = syscall.Errno(0x31)\n+\tEAFNOSUPPORT    = syscall.Errno(0x2f)\n+\tEAGAIN          = syscall.Errno(0x23)\n+\tEALREADY        = syscall.Errno(0x25)\n+\tEAUTH           = syscall.Errno(0x50)\n+\tEBADF           = syscall.Errno(0x9)\n+\tEBADMSG         = syscall.Errno(0x58)\n+\tEBADRPC         = syscall.Errno(0x48)\n+\tEBUSY           = syscall.Errno(0x10)\n+\tECANCELED       = syscall.Errno(0x57)\n+\tECHILD          = syscall.Errno(0xa)\n+\tECONNABORTED    = syscall.Errno(0x35)\n+\tECONNREFUSED    = syscall.Errno(0x3d)\n+\tECONNRESET      = syscall.Errno(0x36)\n+\tEDEADLK         = syscall.Errno(0xb)\n+\tEDESTADDRREQ    = syscall.Errno(0x27)\n+\tEDOM            = syscall.Errno(0x21)\n+\tEDQUOT          = syscall.Errno(0x45)\n+\tEEXIST          = syscall.Errno(0x11)\n+\tEFAULT          = syscall.Errno(0xe)\n+\tEFBIG           = syscall.Errno(0x1b)\n+\tEFTYPE          = syscall.Errno(0x4f)\n+\tEHOSTDOWN       = syscall.Errno(0x40)\n+\tEHOSTUNREACH    = syscall.Errno(0x41)\n+\tEIDRM           = syscall.Errno(0x52)\n+\tEILSEQ          = syscall.Errno(0x55)\n+\tEINPROGRESS     = syscall.Errno(0x24)\n+\tEINTR           = syscall.Errno(0x4)\n+\tEINVAL          = syscall.Errno(0x16)\n+\tEIO             = syscall.Errno(0x5)\n+\tEISCONN         = syscall.Errno(0x38)\n+\tEISDIR          = syscall.Errno(0x15)\n+\tELAST           = syscall.Errno(0x60)\n+\tELOOP           = syscall.Errno(0x3e)\n+\tEMFILE          = syscall.Errno(0x18)\n+\tEMLINK          = syscall.Errno(0x1f)\n+\tEMSGSIZE        = syscall.Errno(0x28)\n+\tEMULTIHOP       = syscall.Errno(0x5e)\n+\tENAMETOOLONG    = syscall.Errno(0x3f)\n+\tENEEDAUTH       = syscall.Errno(0x51)\n+\tENETDOWN        = syscall.Errno(0x32)\n+\tENETRESET       = syscall.Errno(0x34)\n+\tENETUNREACH     = syscall.Errno(0x33)\n+\tENFILE          = syscall.Errno(0x17)\n+\tENOATTR         = syscall.Errno(0x5d)\n+\tENOBUFS         = syscall.Errno(0x37)\n+\tENODATA         = syscall.Errno(0x59)\n+\tENODEV          = syscall.Errno(0x13)\n+\tENOENT          = syscall.Errno(0x2)\n+\tENOEXEC         = syscall.Errno(0x8)\n+\tENOLCK          = syscall.Errno(0x4d)\n+\tENOLINK         = syscall.Errno(0x5f)\n+\tENOMEM          = syscall.Errno(0xc)\n+\tENOMSG          = syscall.Errno(0x53)\n+\tENOPROTOOPT     = syscall.Errno(0x2a)\n+\tENOSPC          = syscall.Errno(0x1c)\n+\tENOSR           = syscall.Errno(0x5a)\n+\tENOSTR          = syscall.Errno(0x5b)\n+\tENOSYS          = syscall.Errno(0x4e)\n+\tENOTBLK         = syscall.Errno(0xf)\n+\tENOTCONN        = syscall.Errno(0x39)\n+\tENOTDIR         = syscall.Errno(0x14)\n+\tENOTEMPTY       = syscall.Errno(0x42)\n+\tENOTSOCK        = syscall.Errno(0x26)\n+\tENOTSUP         = syscall.Errno(0x56)\n+\tENOTTY          = syscall.Errno(0x19)\n+\tENXIO           = syscall.Errno(0x6)\n+\tEOPNOTSUPP      = syscall.Errno(0x2d)\n+\tEOVERFLOW       = syscall.Errno(0x54)\n+\tEPERM           = syscall.Errno(0x1)\n+\tEPFNOSUPPORT    = syscall.Errno(0x2e)\n+\tEPIPE           = syscall.Errno(0x20)\n+\tEPROCLIM        = syscall.Errno(0x43)\n+\tEPROCUNAVAIL    = syscall.Errno(0x4c)\n+\tEPROGMISMATCH   = syscall.Errno(0x4b)\n+\tEPROGUNAVAIL    = syscall.Errno(0x4a)\n+\tEPROTO          = syscall.Errno(0x60)\n+\tEPROTONOSUPPORT = syscall.Errno(0x2b)\n+\tEPROTOTYPE      = syscall.Errno(0x29)\n+\tERANGE          = syscall.Errno(0x22)\n+\tEREMOTE         = syscall.Errno(0x47)\n+\tEROFS           = syscall.Errno(0x1e)\n+\tERPCMISMATCH    = syscall.Errno(0x49)\n+\tESHUTDOWN       = syscall.Errno(0x3a)\n+\tESOCKTNOSUPPORT = syscall.Errno(0x2c)\n+\tESPIPE          = syscall.Errno(0x1d)\n+\tESRCH           = syscall.Errno(0x3)\n+\tESTALE          = syscall.Errno(0x46)\n+\tETIME           = syscall.Errno(0x5c)\n+\tETIMEDOUT       = syscall.Errno(0x3c)\n+\tETOOMANYREFS    = syscall.Errno(0x3b)\n+\tETXTBSY         = syscall.Errno(0x1a)\n+\tEUSERS          = syscall.Errno(0x44)\n+\tEWOULDBLOCK     = syscall.Errno(0x23)\n+\tEXDEV           = syscall.Errno(0x12)\n+)\n+\n+// Signals\n+const (\n+\tSIGABRT   = syscall.Signal(0x6)\n+\tSIGALRM   = syscall.Signal(0xe)\n+\tSIGBUS    = syscall.Signal(0xa)\n+\tSIGCHLD   = syscall.Signal(0x14)\n+\tSIGCONT   = syscall.Signal(0x13)\n+\tSIGEMT    = syscall.Signal(0x7)\n+\tSIGFPE    = syscall.Signal(0x8)\n+\tSIGHUP    = syscall.Signal(0x1)\n+\tSIGILL    = syscall.Signal(0x4)\n+\tSIGINFO   = syscall.Signal(0x1d)\n+\tSIGINT    = syscall.Signal(0x2)\n+\tSIGIO     = syscall.Signal(0x17)\n+\tSIGIOT    = syscall.Signal(0x6)\n+\tSIGKILL   = syscall.Signal(0x9)\n+\tSIGPIPE   = syscall.Signal(0xd)\n+\tSIGPROF   = syscall.Signal(0x1b)\n+\tSIGPWR    = syscall.Signal(0x20)\n+\tSIGQUIT   = syscall.Signal(0x3)\n+\tSIGSEGV   = syscall.Signal(0xb)\n+\tSIGSTOP   = syscall.Signal(0x11)\n+\tSIGSYS    = syscall.Signal(0xc)\n+\tSIGTERM   = syscall.Signal(0xf)\n+\tSIGTRAP   = syscall.Signal(0x5)\n+\tSIGTSTP   = syscall.Signal(0x12)\n+\tSIGTTIN   = syscall.Signal(0x15)\n+\tSIGTTOU   = syscall.Signal(0x16)\n+\tSIGURG    = syscall.Signal(0x10)\n+\tSIGUSR1   = syscall.Signal(0x1e)\n+\tSIGUSR2   = syscall.Signal(0x1f)\n+\tSIGVTALRM = syscall.Signal(0x1a)\n+\tSIGWINCH  = syscall.Signal(0x1c)\n+\tSIGXCPU   = syscall.Signal(0x18)\n+\tSIGXFSZ   = syscall.Signal(0x19)\n+)\n+\n+// Error table\n+var errorList = [...]struct {\n+\tnum  syscall.Errno\n+\tname string\n+\tdesc string\n+}{\n+\t{1, \"EPERM\", \"operation not permitted\"},\n+\t{2, \"ENOENT\", \"no such file or directory\"},\n+\t{3, \"ESRCH\", \"no such process\"},\n+\t{4, \"EINTR\", \"interrupted system call\"},\n+\t{5, \"EIO\", \"input/output error\"},\n+\t{6, \"ENXIO\", \"device not configured\"},\n+\t{7, \"E2BIG\", \"argument list too long\"},\n+\t{8, \"ENOEXEC\", \"exec format error\"},\n+\t{9, \"EBADF\", \"bad file descriptor\"},\n+\t{10, \"ECHILD\", \"no child processes\"},\n+\t{11, \"EDEADLK\", \"resource deadlock avoided\"},\n+\t{12, \"ENOMEM\", \"cannot allocate memory\"},\n+\t{13, \"EACCES\", \"permission denied\"},\n+\t{14, \"EFAULT\", \"bad address\"},\n+\t{15, \"ENOTBLK\", \"block device required\"},\n+\t{16, \"EBUSY\", \"device busy\"},\n+\t{17, \"EEXIST\", \"file exists\"},\n+\t{18, \"EXDEV\", \"cross-device link\"},\n+\t{19, \"ENODEV\", \"operation not supported by device\"},\n+\t{20, \"ENOTDIR\", \"not a directory\"},\n+\t{21, \"EISDIR\", \"is a directory\"},\n+\t{22, \"EINVAL\", \"invalid argument\"},\n+\t{23, \"ENFILE\", \"too many open files in system\"},\n+\t{24, \"EMFILE\", \"too many open files\"},\n+\t{25, \"ENOTTY\", \"inappropriate ioctl for device\"},\n+\t{26, \"ETXTBSY\", \"text file busy\"},\n+\t{27, \"EFBIG\", \"file too large\"},\n+\t{28, \"ENOSPC\", \"no space left on device\"},\n+\t{29, \"ESPIPE\", \"illegal seek\"},\n+\t{30, \"EROFS\", \"read-only file system\"},\n+\t{31, \"EMLINK\", \"too many links\"},\n+\t{32, \"EPIPE\", \"broken pipe\"},\n+\t{33, \"EDOM\", \"numerical argument out of domain\"},\n+\t{34, \"ERANGE\", \"result too large or too small\"},\n+\t{35, \"EAGAIN\", \"resource temporarily unavailable\"},\n+\t{36, \"EINPROGRESS\", \"operation now in progress\"},\n+\t{37, \"EALREADY\", \"operation already in progress\"},\n+\t{38, \"ENOTSOCK\", \"socket operation on non-socket\"},\n+\t{39, \"EDESTADDRREQ\", \"destination address required\"},\n+\t{40, \"EMSGSIZE\", \"message too long\"},\n+\t{41, \"EPROTOTYPE\", \"protocol wrong type for socket\"},\n+\t{42, \"ENOPROTOOPT\", \"protocol option not available\"},\n+\t{43, \"EPROTONOSUPPORT\", \"protocol not supported\"},\n+\t{44, \"ESOCKTNOSUPPORT\", \"socket type not supported\"},\n+\t{45, \"EOPNOTSUPP\", \"operation not supported\"},\n+\t{46, \"EPFNOSUPPORT\", \"protocol family not supported\"},\n+\t{47, \"EAFNOSUPPORT\", \"address family not supported by protocol family\"},\n+\t{48, \"EADDRINUSE\", \"address already in use\"},\n+\t{49, \"EADDRNOTAVAIL\", \"can't assign requested address\"},\n+\t{50, \"ENETDOWN\", \"network is down\"},\n+\t{51, \"ENETUNREACH\", \"network is unreachable\"},\n+\t{52, \"ENETRESET\", \"network dropped connection on reset\"},\n+\t{53, \"ECONNABORTED\", \"software caused connection abort\"},\n+\t{54, \"ECONNRESET\", \"connection reset by peer\"},\n+\t{55, \"ENOBUFS\", \"no buffer space available\"},\n+\t{56, \"EISCONN\", \"socket is already connected\"},\n+\t{57, \"ENOTCONN\", \"socket is not connected\"},\n+\t{58, \"ESHUTDOWN\", \"can't send after socket shutdown\"},\n+\t{59, \"ETOOMANYREFS\", \"too many references: can't splice\"},\n+\t{60, \"ETIMEDOUT\", \"connection timed out\"},\n+\t{61, \"ECONNREFUSED\", \"connection refused\"},\n+\t{62, \"ELOOP\", \"too many levels of symbolic links\"},\n+\t{63, \"ENAMETOOLONG\", \"file name too long\"},\n+\t{64, \"EHOSTDOWN\", \"host is down\"},\n+\t{65, \"EHOSTUNREACH\", \"no route to host\"},\n+\t{66, \"ENOTEMPTY\", \"directory not empty\"},\n+\t{67, \"EPROCLIM\", \"too many processes\"},\n+\t{68, \"EUSERS\", \"too many users\"},\n+\t{69, \"EDQUOT\", \"disc quota exceeded\"},\n+\t{70, \"ESTALE\", \"stale NFS file handle\"},\n+\t{71, \"EREMOTE\", \"too many levels of remote in path\"},\n+\t{72, \"EBADRPC\", \"RPC struct is bad\"},\n+\t{73, \"ERPCMISMATCH\", \"RPC version wrong\"},\n+\t{74, \"EPROGUNAVAIL\", \"RPC prog. not avail\"},\n+\t{75, \"EPROGMISMATCH\", \"program version wrong\"},\n+\t{76, \"EPROCUNAVAIL\", \"bad procedure for program\"},\n+\t{77, \"ENOLCK\", \"no locks available\"},\n+\t{78, \"ENOSYS\", \"function not implemented\"},\n+\t{79, \"EFTYPE\", \"inappropriate file type or format\"},\n+\t{80, \"EAUTH\", \"authentication error\"},\n+\t{81, \"ENEEDAUTH\", \"need authenticator\"},\n+\t{82, \"EIDRM\", \"identifier removed\"},\n+\t{83, \"ENOMSG\", \"no message of desired type\"},\n+\t{84, \"EOVERFLOW\", \"value too large to be stored in data type\"},\n+\t{85, \"EILSEQ\", \"illegal byte sequence\"},\n+\t{86, \"ENOTSUP\", \"not supported\"},\n+\t{87, \"ECANCELED\", \"operation Canceled\"},\n+\t{88, \"EBADMSG\", \"bad or Corrupt message\"},\n+\t{89, \"ENODATA\", \"no message available\"},\n+\t{90, \"ENOSR\", \"no STREAM resources\"},\n+\t{91, \"ENOSTR\", \"not a STREAM\"},\n+\t{92, \"ETIME\", \"STREAM ioctl timeout\"},\n+\t{93, \"ENOATTR\", \"attribute not found\"},\n+\t{94, \"EMULTIHOP\", \"multihop attempted\"},\n+\t{95, \"ENOLINK\", \"link has been severed\"},\n+\t{96, \"ELAST\", \"protocol error\"},\n+}\n+\n+// Signal table\n+var signalList = [...]struct {\n+\tnum  syscall.Signal\n+\tname string\n+\tdesc string\n+}{\n+\t{1, \"SIGHUP\", \"hangup\"},\n+\t{2, \"SIGINT\", \"interrupt\"},\n+\t{3, \"SIGQUIT\", \"quit\"},\n+\t{4, \"SIGILL\", \"illegal instruction\"},\n+\t{5, \"SIGTRAP\", \"trace/BPT trap\"},\n+\t{6, \"SIGIOT\", \"abort trap\"},\n+\t{7, \"SIGEMT\", \"EMT trap\"},\n+\t{8, \"SIGFPE\", \"floating point exception\"},\n+\t{9, \"SIGKILL\", \"killed\"},\n+\t{10, \"SIGBUS\", \"bus error\"},\n+\t{11, \"SIGSEGV\", \"segmentation fault\"},\n+\t{12, \"SIGSYS\", \"bad system call\"},\n+\t{13, \"SIGPIPE\", \"broken pipe\"},\n+\t{14, \"SIGALRM\", \"alarm clock\"},\n+\t{15, \"SIGTERM\", \"terminated\"},\n+\t{16, \"SIGURG\", \"urgent I/O condition\"},\n+\t{17, \"SIGSTOP\", \"stopped (signal)\"},\n+\t{18, \"SIGTSTP\", \"stopped\"},\n+\t{19, \"SIGCONT\", \"continued\"},\n+\t{20, \"SIGCHLD\", \"child exited\"},\n+\t{21, \"SIGTTIN\", \"stopped (tty input)\"},\n+\t{22, \"SIGTTOU\", \"stopped (tty output)\"},\n+\t{23, \"SIGIO\", \"I/O possible\"},\n+\t{24, \"SIGXCPU\", \"cputime limit exceeded\"},\n+\t{25, \"SIGXFSZ\", \"filesize limit exceeded\"},\n+\t{26, \"SIGVTALRM\", \"virtual timer expired\"},\n+\t{27, \"SIGPROF\", \"profiling timer expired\"},\n+\t{28, \"SIGWINCH\", \"window size changes\"},\n+\t{29, \"SIGINFO\", \"information request\"},\n+\t{30, \"SIGUSR1\", \"user defined signal 1\"},\n+\t{31, \"SIGUSR2\", \"user defined signal 2\"},\n+\t{32, \"SIGPWR\", \"power fail/restart\"},\n+}"
    },
    {
      "sha": "e645a05cbeb462b796922db5716eb93646dc3880",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,4 +1,4 @@\n-// mksyscall_aix_ppc64.pl -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go\n+// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go\n // Code generated by the command above; see README.md. DO NOT EDIT.\n \n // +build aix,ppc64"
    },
    {
      "sha": "0b8eb721022760acacab5337f09c65f7ef44e3f6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,4 +1,4 @@\n-// mksyscall_aix_ppc64.pl -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go\n+// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go\n // Code generated by the command above; see README.md. DO NOT EDIT.\n \n // +build aix,ppc64"
    },
    {
      "sha": "e88a442787d31e283aaf2bde72cec2ab40cd796b",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,4 +1,4 @@\n-// mksyscall_aix_ppc64.pl -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go\n+// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go\n // Code generated by the command above; see README.md. DO NOT EDIT.\n \n // +build aix,ppc64"
    },
    {
      "sha": "c142e33e92e992a33193c80baf32a2c1af6253e9",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -943,6 +943,21 @@ func libc_chroot_trampoline()\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockGettime(clockid int32, time *Timespec) (err error) {\n+\t_, _, e1 := syscall_syscall(funcPC(libc_clock_gettime_trampoline), uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func libc_clock_gettime_trampoline()\n+\n+//go:linkname libc_clock_gettime libc_clock_gettime\n+//go:cgo_import_dynamic libc_clock_gettime clock_gettime \"/usr/lib/libSystem.B.dylib\"\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := syscall_syscall(funcPC(libc_close_trampoline), uintptr(fd), 0, 0)\n \tif e1 != 0 {"
    },
    {
      "sha": "1a3915197d4ec4c7dbba200646559ed24713addd",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -108,6 +108,8 @@ TEXT libc_chown_trampoline(SB),NOSPLIT,$0-0\n \tJMP\tlibc_chown(SB)\n TEXT libc_chroot_trampoline(SB),NOSPLIT,$0-0\n \tJMP\tlibc_chroot(SB)\n+TEXT libc_clock_gettime_trampoline(SB),NOSPLIT,$0-0\n+\tJMP\tlibc_clock_gettime(SB)\n TEXT libc_close_trampoline(SB),NOSPLIT,$0-0\n \tJMP\tlibc_close(SB)\n TEXT libc_dup_trampoline(SB),NOSPLIT,$0-0"
    },
    {
      "sha": "ae9f1a21e6228017c29fc4d750b919ed920f86bf",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1194,6 +1194,26 @@ func Rename(from string, to string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(fromfd int, from string, tofd int, to string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(from)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(to)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Revoke(path string) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)"
    },
    {
      "sha": "c8b451000b09bdaf300b1a772e80f9aa033f07f5",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1901,6 +1898,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {\n \tr0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)\n \twritten = int(r0)"
    },
    {
      "sha": "2aac3184bc0da9bb4f8e2eeca515b018ec4cf6e4",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1906,6 +1903,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "13c06c2815808bb62093d7a78ed56c7cd5d2b628",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -2016,6 +2013,26 @@ func Pause() (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {\n \tr0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)\n \twritten = int(r0)"
    },
    {
      "sha": "737fa8d1812acd5960fcec3750daf586a62696f5",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1829,6 +1826,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "0a85f3f8db3331af60f9c1d3ad2ebcf12bc0dbe6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1820,6 +1817,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {\n \tr0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)\n \tn = int(r0)"
    },
    {
      "sha": "ec7007e781ded90bf4f8eec945e0fade21c30328",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1850,6 +1847,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "c5bb25d9643aeeece89a0b6cd73dc31da547aa7a",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1850,6 +1847,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "26ada0478f9600be5d7212be96a5c6217aaac545",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1820,6 +1817,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {\n \tr0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)\n \tn = int(r0)"
    },
    {
      "sha": "2da9cb700a7f5289d6dd8026764bd78ac18c5dd1",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1921,6 +1918,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "772733d83ffbc78c5c460b19179bf35906293f37",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1921,6 +1918,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "996eba517ac3d9d904090ea86189d74c6781d29c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go",
      "status": "modified",
      "additions": 17,
      "deletions": 20,
      "changes": 37,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)"
    },
    {
      "sha": "cb9072a33a480390f9304ab4f3dd38dda83ff9f3",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1891,6 +1888,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "5e48a1001b9f0bc0668758c6228dba1c93c2d129",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go",
      "status": "modified",
      "additions": 37,
      "deletions": 20,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -437,6 +437,16 @@ func ClockGettime(clockid int32, time *Timespec) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {\n+\t_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Close(fd int) (err error) {\n \t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n \tif e1 != 0 {\n@@ -1195,26 +1205,6 @@ func Removexattr(path string, attr string) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n-func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n-\tvar _p0 *byte\n-\t_p0, err = BytePtrFromString(oldpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tvar _p1 *byte\n-\t_p1, err = BytePtrFromString(newpath)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n-\tif e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n-// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n-\n func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(oldpath)\n@@ -1370,6 +1360,13 @@ func Setxattr(path string, attr string, data []byte, flags int) (err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Signalfd(fd int, mask *Sigset_t, flags int) {\n+\tSyscallNoError(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(mask)), uintptr(flags))\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {\n \tvar _p0 *byte\n \t_p0, err = BytePtrFromString(path)\n@@ -1890,6 +1887,26 @@ func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n \n // THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n \n+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n func Seek(fd int, offset int64, whence int) (off int64, err error) {\n \tr0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))\n \toff = int64(r0)"
    },
    {
      "sha": "603d144334966fb2ff483061d4cd9e9b6c8a2cc5",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go",
      "status": "added",
      "additions": 1826,
      "deletions": 0,
      "changes": 1826,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,1826 @@\n+// go run mksyscall.go -netbsd -tags netbsd,arm64 syscall_bsd.go syscall_netbsd.go syscall_netbsd_arm64.go\n+// Code generated by the command above; see README.md. DO NOT EDIT.\n+\n+// +build netbsd,arm64\n+\n+package unix\n+\n+import (\n+\t\"syscall\"\n+\t\"unsafe\"\n+)\n+\n+var _ syscall.Errno\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func getgroups(ngid int, gid *_Gid_t) (n int, err error) {\n+\tr0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func setgroups(ngid int, gid *_Gid_t) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) {\n+\tr0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)\n+\twpid = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) {\n+\tr0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))\n+\tfd = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {\n+\t_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {\n+\t_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func socket(domain int, typ int, proto int) (fd int, err error) {\n+\tr0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))\n+\tfd = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {\n+\t_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {\n+\t_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Shutdown(s int, how int) (err error) {\n+\t_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {\n+\t_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(p) > 0 {\n+\t\t_p0 = unsafe.Pointer(&p[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(buf) > 0 {\n+\t\t_p0 = unsafe.Pointer(&buf[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\t_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {\n+\tr0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {\n+\tr0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) {\n+\tr0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(mib) > 0 {\n+\t\t_p0 = unsafe.Pointer(&mib[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\t_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func utimes(path string, timeval *[2]Timeval) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func futimes(fd int, timeval *[2]Timeval) (err error) {\n+\t_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func fcntl(fd int, cmd int, arg int) (val int, err error) {\n+\tr0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))\n+\tval = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func poll(fds *PollFd, nfds int, timeout int) (n int, err error) {\n+\tr0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Madvise(b []byte, behav int) (err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(b) > 0 {\n+\t\t_p0 = unsafe.Pointer(&b[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\t_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mlock(b []byte) (err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(b) > 0 {\n+\t\t_p0 = unsafe.Pointer(&b[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\t_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mlockall(flags int) (err error) {\n+\t_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mprotect(b []byte, prot int) (err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(b) > 0 {\n+\t\t_p0 = unsafe.Pointer(&b[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\t_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Msync(b []byte, flags int) (err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(b) > 0 {\n+\t\t_p0 = unsafe.Pointer(&b[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\t_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Munlock(b []byte) (err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(b) > 0 {\n+\t\t_p0 = unsafe.Pointer(&b[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\t_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Munlockall() (err error) {\n+\t_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func pipe() (fd1 int, fd2 int, err error) {\n+\tr0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)\n+\tfd1 = int(r0)\n+\tfd2 = int(r1)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func getdents(fd int, buf []byte) (n int, err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(buf) > 0 {\n+\t\t_p0 = unsafe.Pointer(&buf[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getcwd(buf []byte) (n int, err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(buf) > 0 {\n+\t\t_p0 = unsafe.Pointer(&buf[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ioctl(fd int, req uint, arg uintptr) (err error) {\n+\t_, _, e1 := Syscall(SYS_IOCTL, uintptr(fd), uintptr(req), uintptr(arg))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Access(path string, mode uint32) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Adjtime(delta *Timeval, olddelta *Timeval) (err error) {\n+\t_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Chdir(path string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Chflags(path string, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Chmod(path string, mode uint32) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Chown(path string, uid int, gid int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Chroot(path string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Close(fd int) (err error) {\n+\t_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Dup(fd int) (nfd int, err error) {\n+\tr0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)\n+\tnfd = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Dup2(from int, to int) (err error) {\n+\t_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Exit(code int) {\n+\tSyscall(SYS_EXIT, uintptr(code), 0, 0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) {\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(file)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(file)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(file)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(file)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(link)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(link)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(link)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(attrname)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(link)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)\n+\tret = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fadvise(fd int, offset int64, length int64, advice int) (err error) {\n+\t_, _, e1 := Syscall6(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), 0, uintptr(length), uintptr(advice))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fchdir(fd int) (err error) {\n+\t_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fchflags(fd int, flags int) (err error) {\n+\t_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fchmod(fd int, mode uint32) (err error) {\n+\t_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fchown(fd int, uid int, gid int) (err error) {\n+\t_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Flock(fd int, how int) (err error) {\n+\t_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fpathconf(fd int, name int) (val int, err error) {\n+\tr0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)\n+\tval = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fstat(fd int, stat *Stat_t) (err error) {\n+\t_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Fsync(fd int) (err error) {\n+\t_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Ftruncate(fd int, length int64) (err error) {\n+\t_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getegid() (egid int) {\n+\tr0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)\n+\tegid = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Geteuid() (uid int) {\n+\tr0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)\n+\tuid = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getgid() (gid int) {\n+\tr0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)\n+\tgid = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getpgid(pid int) (pgid int, err error) {\n+\tr0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)\n+\tpgid = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getpgrp() (pgrp int) {\n+\tr0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)\n+\tpgrp = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getpid() (pid int) {\n+\tr0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)\n+\tpid = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getppid() (ppid int) {\n+\tr0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)\n+\tppid = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getpriority(which int, who int) (prio int, err error) {\n+\tr0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)\n+\tprio = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getrlimit(which int, lim *Rlimit) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getrusage(who int, rusage *Rusage) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getsid(pid int) (sid int, err error) {\n+\tr0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)\n+\tsid = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Gettimeofday(tv *Timeval) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Getuid() (uid int) {\n+\tr0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)\n+\tuid = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Issetugid() (tainted bool) {\n+\tr0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)\n+\ttainted = bool(r0 != 0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Kill(pid int, signum syscall.Signal) (err error) {\n+\t_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Kqueue() (fd int, err error) {\n+\tr0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)\n+\tfd = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Lchown(path string, uid int, gid int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Link(path string, link string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(link)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(link)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Listen(s int, backlog int) (err error) {\n+\t_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Lstat(path string, stat *Stat_t) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mkdir(path string, mode uint32) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mkdirat(dirfd int, path string, mode uint32) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mkfifo(path string, mode uint32) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mkfifoat(dirfd int, path string, mode uint32) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_MKFIFOAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mknod(path string, mode uint32, dev int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Nanosleep(time *Timespec, leftover *Timespec) (err error) {\n+\t_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Open(path string, mode int, perm uint32) (fd int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))\n+\tfd = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)\n+\tfd = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Pathconf(path string, name int) (val int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tr0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)\n+\tval = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Pread(fd int, p []byte, offset int64) (n int, err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(p) > 0 {\n+\t\t_p0 = unsafe.Pointer(&p[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Pwrite(fd int, p []byte, offset int64) (n int, err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(p) > 0 {\n+\t\t_p0 = unsafe.Pointer(&p[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func read(fd int, p []byte) (n int, err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(p) > 0 {\n+\t\t_p0 = unsafe.Pointer(&p[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Readlink(path string, buf []byte) (n int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 unsafe.Pointer\n+\tif len(buf) > 0 {\n+\t\t_p1 = unsafe.Pointer(&buf[0])\n+\t} else {\n+\t\t_p1 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 unsafe.Pointer\n+\tif len(buf) > 0 {\n+\t\t_p1 = unsafe.Pointer(&buf[0])\n+\t} else {\n+\t\t_p1 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Rename(from string, to string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(from)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(to)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Renameat(fromfd int, from string, tofd int, to string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(from)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(to)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Revoke(path string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Rmdir(path string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Seek(fd int, offset int64, whence int) (newoffset int64, err error) {\n+\tr0, _, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(whence), 0, 0)\n+\tnewoffset = int64(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) {\n+\t_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setegid(egid int) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Seteuid(euid int) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setgid(gid int) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setpgid(pid int, pgid int) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setpriority(which int, who int, prio int) (err error) {\n+\t_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setregid(rgid int, egid int) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setreuid(ruid int, euid int) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setrlimit(which int, lim *Rlimit) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setsid() (pid int, err error) {\n+\tr0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)\n+\tpid = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Settimeofday(tp *Timeval) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Setuid(uid int) (err error) {\n+\t_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Stat(path string, stat *Stat_t) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Symlink(path string, link string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(link)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(oldpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar _p1 *byte\n+\t_p1, err = BytePtrFromString(newpath)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Sync() (err error) {\n+\t_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Truncate(path string, length int64) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Umask(newmask int) (oldmask int) {\n+\tr0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)\n+\toldmask = int(r0)\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Unlink(path string) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Unlinkat(dirfd int, path string, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func Unmount(path string, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func write(fd int, p []byte) (n int, err error) {\n+\tvar _p0 unsafe.Pointer\n+\tif len(p) > 0 {\n+\t\t_p0 = unsafe.Pointer(&p[0])\n+\t} else {\n+\t\t_p0 = unsafe.Pointer(&_zero)\n+\t}\n+\tr0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) {\n+\tr0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), 0, 0)\n+\tret = uintptr(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func munmap(addr uintptr, length uintptr) (err error) {\n+\t_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func readlen(fd int, buf *byte, nbuf int) (n int, err error) {\n+\tr0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func writelen(fd int, buf *byte, nbuf int) (n int, err error) {\n+\tr0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))\n+\tn = int(r0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT\n+\n+func utimensat(dirfd int, path string, times *[2]Timespec, flags int) (err error) {\n+\tvar _p0 *byte\n+\t_p0, err = BytePtrFromString(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)\n+\tif e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}"
    },
    {
      "sha": "5f614760c6c8fcab630f8d87510ed2ee6f9217cf",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,4 +1,4 @@\n-// mksyscall_solaris.pl -tags solaris,amd64 syscall_solaris.go syscall_solaris_amd64.go\n+// go run mksyscall_solaris.go -tags solaris,amd64 syscall_solaris.go syscall_solaris_amd64.go\n // Code generated by the command above; see README.md. DO NOT EDIT.\n \n // +build solaris,amd64"
    },
    {
      "sha": "654dd3da3be44213cf1271ccefcc0107467b6995",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,4 +1,4 @@\n-// go run mksysnum.go /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/sys/syscall.h\n+// go run mksysnum.go /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/usr/include/sys/syscall.h\n // Code generated by the command above; see README.md. DO NOT EDIT.\n \n // +build amd64,darwin\n@@ -431,6 +431,8 @@ const (\n \tSYS_NTP_ADJTIME                    = 527\n \tSYS_NTP_GETTIME                    = 528\n \tSYS_OS_FAULT_WITH_PAYLOAD          = 529\n-\tSYS_MAXSYSCALL                     = 530\n+\tSYS_KQUEUE_WORKLOOP_CTL            = 530\n+\tSYS___MACH_BRIDGE_REMOTE_TIME      = 531\n+\tSYS_MAXSYSCALL                     = 532\n \tSYS_INVALID                        = 63\n )"
    },
    {
      "sha": "9f21e9550edd6b3fce22a5155239dbbecd05ef1b",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -1,4 +1,4 @@\n-// mksysnum_freebsd.pl\n+// go run mksysnum.go https://svn.freebsd.org/base/stable/10/sys/kern/syscalls.master\n // Code generated by the command above; see README.md. DO NOT EDIT.\n \n // +build arm64,freebsd"
    },
    {
      "sha": "0291c0931b4f47765ab663e59eaa35d4290633d4",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm64.go",
      "status": "added",
      "additions": 274,
      "deletions": 0,
      "changes": 274,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,274 @@\n+// go run mksysnum.go http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/sys/kern/syscalls.master\n+// Code generated by the command above; DO NOT EDIT.\n+\n+// +build arm64,netbsd\n+\n+package unix\n+\n+const (\n+\tSYS_EXIT                 = 1   // { void|sys||exit(int rval); }\n+\tSYS_FORK                 = 2   // { int|sys||fork(void); }\n+\tSYS_READ                 = 3   // { ssize_t|sys||read(int fd, void *buf, size_t nbyte); }\n+\tSYS_WRITE                = 4   // { ssize_t|sys||write(int fd, const void *buf, size_t nbyte); }\n+\tSYS_OPEN                 = 5   // { int|sys||open(const char *path, int flags, ... mode_t mode); }\n+\tSYS_CLOSE                = 6   // { int|sys||close(int fd); }\n+\tSYS_LINK                 = 9   // { int|sys||link(const char *path, const char *link); }\n+\tSYS_UNLINK               = 10  // { int|sys||unlink(const char *path); }\n+\tSYS_CHDIR                = 12  // { int|sys||chdir(const char *path); }\n+\tSYS_FCHDIR               = 13  // { int|sys||fchdir(int fd); }\n+\tSYS_CHMOD                = 15  // { int|sys||chmod(const char *path, mode_t mode); }\n+\tSYS_CHOWN                = 16  // { int|sys||chown(const char *path, uid_t uid, gid_t gid); }\n+\tSYS_BREAK                = 17  // { int|sys||obreak(char *nsize); }\n+\tSYS_GETPID               = 20  // { pid_t|sys||getpid_with_ppid(void); }\n+\tSYS_UNMOUNT              = 22  // { int|sys||unmount(const char *path, int flags); }\n+\tSYS_SETUID               = 23  // { int|sys||setuid(uid_t uid); }\n+\tSYS_GETUID               = 24  // { uid_t|sys||getuid_with_euid(void); }\n+\tSYS_GETEUID              = 25  // { uid_t|sys||geteuid(void); }\n+\tSYS_PTRACE               = 26  // { int|sys||ptrace(int req, pid_t pid, void *addr, int data); }\n+\tSYS_RECVMSG              = 27  // { ssize_t|sys||recvmsg(int s, struct msghdr *msg, int flags); }\n+\tSYS_SENDMSG              = 28  // { ssize_t|sys||sendmsg(int s, const struct msghdr *msg, int flags); }\n+\tSYS_RECVFROM             = 29  // { ssize_t|sys||recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlenaddr); }\n+\tSYS_ACCEPT               = 30  // { int|sys||accept(int s, struct sockaddr *name, socklen_t *anamelen); }\n+\tSYS_GETPEERNAME          = 31  // { int|sys||getpeername(int fdes, struct sockaddr *asa, socklen_t *alen); }\n+\tSYS_GETSOCKNAME          = 32  // { int|sys||getsockname(int fdes, struct sockaddr *asa, socklen_t *alen); }\n+\tSYS_ACCESS               = 33  // { int|sys||access(const char *path, int flags); }\n+\tSYS_CHFLAGS              = 34  // { int|sys||chflags(const char *path, u_long flags); }\n+\tSYS_FCHFLAGS             = 35  // { int|sys||fchflags(int fd, u_long flags); }\n+\tSYS_SYNC                 = 36  // { void|sys||sync(void); }\n+\tSYS_KILL                 = 37  // { int|sys||kill(pid_t pid, int signum); }\n+\tSYS_GETPPID              = 39  // { pid_t|sys||getppid(void); }\n+\tSYS_DUP                  = 41  // { int|sys||dup(int fd); }\n+\tSYS_PIPE                 = 42  // { int|sys||pipe(void); }\n+\tSYS_GETEGID              = 43  // { gid_t|sys||getegid(void); }\n+\tSYS_PROFIL               = 44  // { int|sys||profil(char *samples, size_t size, u_long offset, u_int scale); }\n+\tSYS_KTRACE               = 45  // { int|sys||ktrace(const char *fname, int ops, int facs, pid_t pid); }\n+\tSYS_GETGID               = 47  // { gid_t|sys||getgid_with_egid(void); }\n+\tSYS___GETLOGIN           = 49  // { int|sys||__getlogin(char *namebuf, size_t namelen); }\n+\tSYS___SETLOGIN           = 50  // { int|sys||__setlogin(const char *namebuf); }\n+\tSYS_ACCT                 = 51  // { int|sys||acct(const char *path); }\n+\tSYS_IOCTL                = 54  // { int|sys||ioctl(int fd, u_long com, ... void *data); }\n+\tSYS_REVOKE               = 56  // { int|sys||revoke(const char *path); }\n+\tSYS_SYMLINK              = 57  // { int|sys||symlink(const char *path, const char *link); }\n+\tSYS_READLINK             = 58  // { ssize_t|sys||readlink(const char *path, char *buf, size_t count); }\n+\tSYS_EXECVE               = 59  // { int|sys||execve(const char *path, char * const *argp, char * const *envp); }\n+\tSYS_UMASK                = 60  // { mode_t|sys||umask(mode_t newmask); }\n+\tSYS_CHROOT               = 61  // { int|sys||chroot(const char *path); }\n+\tSYS_VFORK                = 66  // { int|sys||vfork(void); }\n+\tSYS_SBRK                 = 69  // { int|sys||sbrk(intptr_t incr); }\n+\tSYS_SSTK                 = 70  // { int|sys||sstk(int incr); }\n+\tSYS_VADVISE              = 72  // { int|sys||ovadvise(int anom); }\n+\tSYS_MUNMAP               = 73  // { int|sys||munmap(void *addr, size_t len); }\n+\tSYS_MPROTECT             = 74  // { int|sys||mprotect(void *addr, size_t len, int prot); }\n+\tSYS_MADVISE              = 75  // { int|sys||madvise(void *addr, size_t len, int behav); }\n+\tSYS_MINCORE              = 78  // { int|sys||mincore(void *addr, size_t len, char *vec); }\n+\tSYS_GETGROUPS            = 79  // { int|sys||getgroups(int gidsetsize, gid_t *gidset); }\n+\tSYS_SETGROUPS            = 80  // { int|sys||setgroups(int gidsetsize, const gid_t *gidset); }\n+\tSYS_GETPGRP              = 81  // { int|sys||getpgrp(void); }\n+\tSYS_SETPGID              = 82  // { int|sys||setpgid(pid_t pid, pid_t pgid); }\n+\tSYS_DUP2                 = 90  // { int|sys||dup2(int from, int to); }\n+\tSYS_FCNTL                = 92  // { int|sys||fcntl(int fd, int cmd, ... void *arg); }\n+\tSYS_FSYNC                = 95  // { int|sys||fsync(int fd); }\n+\tSYS_SETPRIORITY          = 96  // { int|sys||setpriority(int which, id_t who, int prio); }\n+\tSYS_CONNECT              = 98  // { int|sys||connect(int s, const struct sockaddr *name, socklen_t namelen); }\n+\tSYS_GETPRIORITY          = 100 // { int|sys||getpriority(int which, id_t who); }\n+\tSYS_BIND                 = 104 // { int|sys||bind(int s, const struct sockaddr *name, socklen_t namelen); }\n+\tSYS_SETSOCKOPT           = 105 // { int|sys||setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }\n+\tSYS_LISTEN               = 106 // { int|sys||listen(int s, int backlog); }\n+\tSYS_GETSOCKOPT           = 118 // { int|sys||getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }\n+\tSYS_READV                = 120 // { ssize_t|sys||readv(int fd, const struct iovec *iovp, int iovcnt); }\n+\tSYS_WRITEV               = 121 // { ssize_t|sys||writev(int fd, const struct iovec *iovp, int iovcnt); }\n+\tSYS_FCHOWN               = 123 // { int|sys||fchown(int fd, uid_t uid, gid_t gid); }\n+\tSYS_FCHMOD               = 124 // { int|sys||fchmod(int fd, mode_t mode); }\n+\tSYS_SETREUID             = 126 // { int|sys||setreuid(uid_t ruid, uid_t euid); }\n+\tSYS_SETREGID             = 127 // { int|sys||setregid(gid_t rgid, gid_t egid); }\n+\tSYS_RENAME               = 128 // { int|sys||rename(const char *from, const char *to); }\n+\tSYS_FLOCK                = 131 // { int|sys||flock(int fd, int how); }\n+\tSYS_MKFIFO               = 132 // { int|sys||mkfifo(const char *path, mode_t mode); }\n+\tSYS_SENDTO               = 133 // { ssize_t|sys||sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen); }\n+\tSYS_SHUTDOWN             = 134 // { int|sys||shutdown(int s, int how); }\n+\tSYS_SOCKETPAIR           = 135 // { int|sys||socketpair(int domain, int type, int protocol, int *rsv); }\n+\tSYS_MKDIR                = 136 // { int|sys||mkdir(const char *path, mode_t mode); }\n+\tSYS_RMDIR                = 137 // { int|sys||rmdir(const char *path); }\n+\tSYS_SETSID               = 147 // { int|sys||setsid(void); }\n+\tSYS_SYSARCH              = 165 // { int|sys||sysarch(int op, void *parms); }\n+\tSYS_PREAD                = 173 // { ssize_t|sys||pread(int fd, void *buf, size_t nbyte, int PAD, off_t offset); }\n+\tSYS_PWRITE               = 174 // { ssize_t|sys||pwrite(int fd, const void *buf, size_t nbyte, int PAD, off_t offset); }\n+\tSYS_NTP_ADJTIME          = 176 // { int|sys||ntp_adjtime(struct timex *tp); }\n+\tSYS_SETGID               = 181 // { int|sys||setgid(gid_t gid); }\n+\tSYS_SETEGID              = 182 // { int|sys||setegid(gid_t egid); }\n+\tSYS_SETEUID              = 183 // { int|sys||seteuid(uid_t euid); }\n+\tSYS_PATHCONF             = 191 // { long|sys||pathconf(const char *path, int name); }\n+\tSYS_FPATHCONF            = 192 // { long|sys||fpathconf(int fd, int name); }\n+\tSYS_GETRLIMIT            = 194 // { int|sys||getrlimit(int which, struct rlimit *rlp); }\n+\tSYS_SETRLIMIT            = 195 // { int|sys||setrlimit(int which, const struct rlimit *rlp); }\n+\tSYS_MMAP                 = 197 // { void *|sys||mmap(void *addr, size_t len, int prot, int flags, int fd, long PAD, off_t pos); }\n+\tSYS_LSEEK                = 199 // { off_t|sys||lseek(int fd, int PAD, off_t offset, int whence); }\n+\tSYS_TRUNCATE             = 200 // { int|sys||truncate(const char *path, int PAD, off_t length); }\n+\tSYS_FTRUNCATE            = 201 // { int|sys||ftruncate(int fd, int PAD, off_t length); }\n+\tSYS___SYSCTL             = 202 // { int|sys||__sysctl(const int *name, u_int namelen, void *old, size_t *oldlenp, const void *new, size_t newlen); }\n+\tSYS_MLOCK                = 203 // { int|sys||mlock(const void *addr, size_t len); }\n+\tSYS_MUNLOCK              = 204 // { int|sys||munlock(const void *addr, size_t len); }\n+\tSYS_UNDELETE             = 205 // { int|sys||undelete(const char *path); }\n+\tSYS_GETPGID              = 207 // { pid_t|sys||getpgid(pid_t pid); }\n+\tSYS_REBOOT               = 208 // { int|sys||reboot(int opt, char *bootstr); }\n+\tSYS_POLL                 = 209 // { int|sys||poll(struct pollfd *fds, u_int nfds, int timeout); }\n+\tSYS_SEMGET               = 221 // { int|sys||semget(key_t key, int nsems, int semflg); }\n+\tSYS_SEMOP                = 222 // { int|sys||semop(int semid, struct sembuf *sops, size_t nsops); }\n+\tSYS_SEMCONFIG            = 223 // { int|sys||semconfig(int flag); }\n+\tSYS_MSGGET               = 225 // { int|sys||msgget(key_t key, int msgflg); }\n+\tSYS_MSGSND               = 226 // { int|sys||msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }\n+\tSYS_MSGRCV               = 227 // { ssize_t|sys||msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }\n+\tSYS_SHMAT                = 228 // { void *|sys||shmat(int shmid, const void *shmaddr, int shmflg); }\n+\tSYS_SHMDT                = 230 // { int|sys||shmdt(const void *shmaddr); }\n+\tSYS_SHMGET               = 231 // { int|sys||shmget(key_t key, size_t size, int shmflg); }\n+\tSYS_TIMER_CREATE         = 235 // { int|sys||timer_create(clockid_t clock_id, struct sigevent *evp, timer_t *timerid); }\n+\tSYS_TIMER_DELETE         = 236 // { int|sys||timer_delete(timer_t timerid); }\n+\tSYS_TIMER_GETOVERRUN     = 239 // { int|sys||timer_getoverrun(timer_t timerid); }\n+\tSYS_FDATASYNC            = 241 // { int|sys||fdatasync(int fd); }\n+\tSYS_MLOCKALL             = 242 // { int|sys||mlockall(int flags); }\n+\tSYS_MUNLOCKALL           = 243 // { int|sys||munlockall(void); }\n+\tSYS_SIGQUEUEINFO         = 245 // { int|sys||sigqueueinfo(pid_t pid, const siginfo_t *info); }\n+\tSYS_MODCTL               = 246 // { int|sys||modctl(int cmd, void *arg); }\n+\tSYS___POSIX_RENAME       = 270 // { int|sys||__posix_rename(const char *from, const char *to); }\n+\tSYS_SWAPCTL              = 271 // { int|sys||swapctl(int cmd, void *arg, int misc); }\n+\tSYS_MINHERIT             = 273 // { int|sys||minherit(void *addr, size_t len, int inherit); }\n+\tSYS_LCHMOD               = 274 // { int|sys||lchmod(const char *path, mode_t mode); }\n+\tSYS_LCHOWN               = 275 // { int|sys||lchown(const char *path, uid_t uid, gid_t gid); }\n+\tSYS_MSYNC                = 277 // { int|sys|13|msync(void *addr, size_t len, int flags); }\n+\tSYS___POSIX_CHOWN        = 283 // { int|sys||__posix_chown(const char *path, uid_t uid, gid_t gid); }\n+\tSYS___POSIX_FCHOWN       = 284 // { int|sys||__posix_fchown(int fd, uid_t uid, gid_t gid); }\n+\tSYS___POSIX_LCHOWN       = 285 // { int|sys||__posix_lchown(const char *path, uid_t uid, gid_t gid); }\n+\tSYS_GETSID               = 286 // { pid_t|sys||getsid(pid_t pid); }\n+\tSYS___CLONE              = 287 // { pid_t|sys||__clone(int flags, void *stack); }\n+\tSYS_FKTRACE              = 288 // { int|sys||fktrace(int fd, int ops, int facs, pid_t pid); }\n+\tSYS_PREADV               = 289 // { ssize_t|sys||preadv(int fd, const struct iovec *iovp, int iovcnt, int PAD, off_t offset); }\n+\tSYS_PWRITEV              = 290 // { ssize_t|sys||pwritev(int fd, const struct iovec *iovp, int iovcnt, int PAD, off_t offset); }\n+\tSYS___GETCWD             = 296 // { int|sys||__getcwd(char *bufp, size_t length); }\n+\tSYS_FCHROOT              = 297 // { int|sys||fchroot(int fd); }\n+\tSYS_LCHFLAGS             = 304 // { int|sys||lchflags(const char *path, u_long flags); }\n+\tSYS_ISSETUGID            = 305 // { int|sys||issetugid(void); }\n+\tSYS_UTRACE               = 306 // { int|sys||utrace(const char *label, void *addr, size_t len); }\n+\tSYS_GETCONTEXT           = 307 // { int|sys||getcontext(struct __ucontext *ucp); }\n+\tSYS_SETCONTEXT           = 308 // { int|sys||setcontext(const struct __ucontext *ucp); }\n+\tSYS__LWP_CREATE          = 309 // { int|sys||_lwp_create(const struct __ucontext *ucp, u_long flags, lwpid_t *new_lwp); }\n+\tSYS__LWP_EXIT            = 310 // { int|sys||_lwp_exit(void); }\n+\tSYS__LWP_SELF            = 311 // { lwpid_t|sys||_lwp_self(void); }\n+\tSYS__LWP_WAIT            = 312 // { int|sys||_lwp_wait(lwpid_t wait_for, lwpid_t *departed); }\n+\tSYS__LWP_SUSPEND         = 313 // { int|sys||_lwp_suspend(lwpid_t target); }\n+\tSYS__LWP_CONTINUE        = 314 // { int|sys||_lwp_continue(lwpid_t target); }\n+\tSYS__LWP_WAKEUP          = 315 // { int|sys||_lwp_wakeup(lwpid_t target); }\n+\tSYS__LWP_GETPRIVATE      = 316 // { void *|sys||_lwp_getprivate(void); }\n+\tSYS__LWP_SETPRIVATE      = 317 // { void|sys||_lwp_setprivate(void *ptr); }\n+\tSYS__LWP_KILL            = 318 // { int|sys||_lwp_kill(lwpid_t target, int signo); }\n+\tSYS__LWP_DETACH          = 319 // { int|sys||_lwp_detach(lwpid_t target); }\n+\tSYS__LWP_UNPARK          = 321 // { int|sys||_lwp_unpark(lwpid_t target, const void *hint); }\n+\tSYS__LWP_UNPARK_ALL      = 322 // { ssize_t|sys||_lwp_unpark_all(const lwpid_t *targets, size_t ntargets, const void *hint); }\n+\tSYS__LWP_SETNAME         = 323 // { int|sys||_lwp_setname(lwpid_t target, const char *name); }\n+\tSYS__LWP_GETNAME         = 324 // { int|sys||_lwp_getname(lwpid_t target, char *name, size_t len); }\n+\tSYS__LWP_CTL             = 325 // { int|sys||_lwp_ctl(int features, struct lwpctl **address); }\n+\tSYS___SIGACTION_SIGTRAMP = 340 // { int|sys||__sigaction_sigtramp(int signum, const struct sigaction *nsa, struct sigaction *osa, const void *tramp, int vers); }\n+\tSYS_PMC_GET_INFO         = 341 // { int|sys||pmc_get_info(int ctr, int op, void *args); }\n+\tSYS_PMC_CONTROL          = 342 // { int|sys||pmc_control(int ctr, int op, void *args); }\n+\tSYS_RASCTL               = 343 // { int|sys||rasctl(void *addr, size_t len, int op); }\n+\tSYS_KQUEUE               = 344 // { int|sys||kqueue(void); }\n+\tSYS__SCHED_SETPARAM      = 346 // { int|sys||_sched_setparam(pid_t pid, lwpid_t lid, int policy, const struct sched_param *params); }\n+\tSYS__SCHED_GETPARAM      = 347 // { int|sys||_sched_getparam(pid_t pid, lwpid_t lid, int *policy, struct sched_param *params); }\n+\tSYS__SCHED_SETAFFINITY   = 348 // { int|sys||_sched_setaffinity(pid_t pid, lwpid_t lid, size_t size, const cpuset_t *cpuset); }\n+\tSYS__SCHED_GETAFFINITY   = 349 // { int|sys||_sched_getaffinity(pid_t pid, lwpid_t lid, size_t size, cpuset_t *cpuset); }\n+\tSYS_SCHED_YIELD          = 350 // { int|sys||sched_yield(void); }\n+\tSYS_FSYNC_RANGE          = 354 // { int|sys||fsync_range(int fd, int flags, off_t start, off_t length); }\n+\tSYS_UUIDGEN              = 355 // { int|sys||uuidgen(struct uuid *store, int count); }\n+\tSYS_GETVFSSTAT           = 356 // { int|sys||getvfsstat(struct statvfs *buf, size_t bufsize, int flags); }\n+\tSYS_STATVFS1             = 357 // { int|sys||statvfs1(const char *path, struct statvfs *buf, int flags); }\n+\tSYS_FSTATVFS1            = 358 // { int|sys||fstatvfs1(int fd, struct statvfs *buf, int flags); }\n+\tSYS_EXTATTRCTL           = 360 // { int|sys||extattrctl(const char *path, int cmd, const char *filename, int attrnamespace, const char *attrname); }\n+\tSYS_EXTATTR_SET_FILE     = 361 // { int|sys||extattr_set_file(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes); }\n+\tSYS_EXTATTR_GET_FILE     = 362 // { ssize_t|sys||extattr_get_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }\n+\tSYS_EXTATTR_DELETE_FILE  = 363 // { int|sys||extattr_delete_file(const char *path, int attrnamespace, const char *attrname); }\n+\tSYS_EXTATTR_SET_FD       = 364 // { int|sys||extattr_set_fd(int fd, int attrnamespace, const char *attrname, const void *data, size_t nbytes); }\n+\tSYS_EXTATTR_GET_FD       = 365 // { ssize_t|sys||extattr_get_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes); }\n+\tSYS_EXTATTR_DELETE_FD    = 366 // { int|sys||extattr_delete_fd(int fd, int attrnamespace, const char *attrname); }\n+\tSYS_EXTATTR_SET_LINK     = 367 // { int|sys||extattr_set_link(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes); }\n+\tSYS_EXTATTR_GET_LINK     = 368 // { ssize_t|sys||extattr_get_link(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }\n+\tSYS_EXTATTR_DELETE_LINK  = 369 // { int|sys||extattr_delete_link(const char *path, int attrnamespace, const char *attrname); }\n+\tSYS_EXTATTR_LIST_FD      = 370 // { ssize_t|sys||extattr_list_fd(int fd, int attrnamespace, void *data, size_t nbytes); }\n+\tSYS_EXTATTR_LIST_FILE    = 371 // { ssize_t|sys||extattr_list_file(const char *path, int attrnamespace, void *data, size_t nbytes); }\n+\tSYS_EXTATTR_LIST_LINK    = 372 // { ssize_t|sys||extattr_list_link(const char *path, int attrnamespace, void *data, size_t nbytes); }\n+\tSYS_SETXATTR             = 375 // { int|sys||setxattr(const char *path, const char *name, const void *value, size_t size, int flags); }\n+\tSYS_LSETXATTR            = 376 // { int|sys||lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags); }\n+\tSYS_FSETXATTR            = 377 // { int|sys||fsetxattr(int fd, const char *name, const void *value, size_t size, int flags); }\n+\tSYS_GETXATTR             = 378 // { int|sys||getxattr(const char *path, const char *name, void *value, size_t size); }\n+\tSYS_LGETXATTR            = 379 // { int|sys||lgetxattr(const char *path, const char *name, void *value, size_t size); }\n+\tSYS_FGETXATTR            = 380 // { int|sys||fgetxattr(int fd, const char *name, void *value, size_t size); }\n+\tSYS_LISTXATTR            = 381 // { int|sys||listxattr(const char *path, char *list, size_t size); }\n+\tSYS_LLISTXATTR           = 382 // { int|sys||llistxattr(const char *path, char *list, size_t size); }\n+\tSYS_FLISTXATTR           = 383 // { int|sys||flistxattr(int fd, char *list, size_t size); }\n+\tSYS_REMOVEXATTR          = 384 // { int|sys||removexattr(const char *path, const char *name); }\n+\tSYS_LREMOVEXATTR         = 385 // { int|sys||lremovexattr(const char *path, const char *name); }\n+\tSYS_FREMOVEXATTR         = 386 // { int|sys||fremovexattr(int fd, const char *name); }\n+\tSYS_GETDENTS             = 390 // { int|sys|30|getdents(int fd, char *buf, size_t count); }\n+\tSYS_SOCKET               = 394 // { int|sys|30|socket(int domain, int type, int protocol); }\n+\tSYS_GETFH                = 395 // { int|sys|30|getfh(const char *fname, void *fhp, size_t *fh_size); }\n+\tSYS_MOUNT                = 410 // { int|sys|50|mount(const char *type, const char *path, int flags, void *data, size_t data_len); }\n+\tSYS_MREMAP               = 411 // { void *|sys||mremap(void *old_address, size_t old_size, void *new_address, size_t new_size, int flags); }\n+\tSYS_PSET_CREATE          = 412 // { int|sys||pset_create(psetid_t *psid); }\n+\tSYS_PSET_DESTROY         = 413 // { int|sys||pset_destroy(psetid_t psid); }\n+\tSYS_PSET_ASSIGN          = 414 // { int|sys||pset_assign(psetid_t psid, cpuid_t cpuid, psetid_t *opsid); }\n+\tSYS__PSET_BIND           = 415 // { int|sys||_pset_bind(idtype_t idtype, id_t first_id, id_t second_id, psetid_t psid, psetid_t *opsid); }\n+\tSYS_POSIX_FADVISE        = 416 // { int|sys|50|posix_fadvise(int fd, int PAD, off_t offset, off_t len, int advice); }\n+\tSYS_SELECT               = 417 // { int|sys|50|select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }\n+\tSYS_GETTIMEOFDAY         = 418 // { int|sys|50|gettimeofday(struct timeval *tp, void *tzp); }\n+\tSYS_SETTIMEOFDAY         = 419 // { int|sys|50|settimeofday(const struct timeval *tv, const void *tzp); }\n+\tSYS_UTIMES               = 420 // { int|sys|50|utimes(const char *path, const struct timeval *tptr); }\n+\tSYS_ADJTIME              = 421 // { int|sys|50|adjtime(const struct timeval *delta, struct timeval *olddelta); }\n+\tSYS_FUTIMES              = 423 // { int|sys|50|futimes(int fd, const struct timeval *tptr); }\n+\tSYS_LUTIMES              = 424 // { int|sys|50|lutimes(const char *path, const struct timeval *tptr); }\n+\tSYS_SETITIMER            = 425 // { int|sys|50|setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }\n+\tSYS_GETITIMER            = 426 // { int|sys|50|getitimer(int which, struct itimerval *itv); }\n+\tSYS_CLOCK_GETTIME        = 427 // { int|sys|50|clock_gettime(clockid_t clock_id, struct timespec *tp); }\n+\tSYS_CLOCK_SETTIME        = 428 // { int|sys|50|clock_settime(clockid_t clock_id, const struct timespec *tp); }\n+\tSYS_CLOCK_GETRES         = 429 // { int|sys|50|clock_getres(clockid_t clock_id, struct timespec *tp); }\n+\tSYS_NANOSLEEP            = 430 // { int|sys|50|nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }\n+\tSYS___SIGTIMEDWAIT       = 431 // { int|sys|50|__sigtimedwait(const sigset_t *set, siginfo_t *info, struct timespec *timeout); }\n+\tSYS__LWP_PARK            = 434 // { int|sys|50|_lwp_park(const struct timespec *ts, lwpid_t unpark, const void *hint, const void *unparkhint); }\n+\tSYS_KEVENT               = 435 // { int|sys|50|kevent(int fd, const struct kevent *changelist, size_t nchanges, struct kevent *eventlist, size_t nevents, const struct timespec *timeout); }\n+\tSYS_PSELECT              = 436 // { int|sys|50|pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *mask); }\n+\tSYS_POLLTS               = 437 // { int|sys|50|pollts(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask); }\n+\tSYS_STAT                 = 439 // { int|sys|50|stat(const char *path, struct stat *ub); }\n+\tSYS_FSTAT                = 440 // { int|sys|50|fstat(int fd, struct stat *sb); }\n+\tSYS_LSTAT                = 441 // { int|sys|50|lstat(const char *path, struct stat *ub); }\n+\tSYS___SEMCTL             = 442 // { int|sys|50|__semctl(int semid, int semnum, int cmd, ... union __semun *arg); }\n+\tSYS_SHMCTL               = 443 // { int|sys|50|shmctl(int shmid, int cmd, struct shmid_ds *buf); }\n+\tSYS_MSGCTL               = 444 // { int|sys|50|msgctl(int msqid, int cmd, struct msqid_ds *buf); }\n+\tSYS_GETRUSAGE            = 445 // { int|sys|50|getrusage(int who, struct rusage *rusage); }\n+\tSYS_TIMER_SETTIME        = 446 // { int|sys|50|timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue); }\n+\tSYS_TIMER_GETTIME        = 447 // { int|sys|50|timer_gettime(timer_t timerid, struct itimerspec *value); }\n+\tSYS_NTP_GETTIME          = 448 // { int|sys|50|ntp_gettime(struct ntptimeval *ntvp); }\n+\tSYS_WAIT4                = 449 // { int|sys|50|wait4(pid_t pid, int *status, int options, struct rusage *rusage); }\n+\tSYS_MKNOD                = 450 // { int|sys|50|mknod(const char *path, mode_t mode, dev_t dev); }\n+\tSYS_FHSTAT               = 451 // { int|sys|50|fhstat(const void *fhp, size_t fh_size, struct stat *sb); }\n+\tSYS_PIPE2                = 453 // { int|sys||pipe2(int *fildes, int flags); }\n+\tSYS_DUP3                 = 454 // { int|sys||dup3(int from, int to, int flags); }\n+\tSYS_KQUEUE1              = 455 // { int|sys||kqueue1(int flags); }\n+\tSYS_PACCEPT              = 456 // { int|sys||paccept(int s, struct sockaddr *name, socklen_t *anamelen, const sigset_t *mask, int flags); }\n+\tSYS_LINKAT               = 457 // { int|sys||linkat(int fd1, const char *name1, int fd2, const char *name2, int flags); }\n+\tSYS_RENAMEAT             = 458 // { int|sys||renameat(int fromfd, const char *from, int tofd, const char *to); }\n+\tSYS_MKFIFOAT             = 459 // { int|sys||mkfifoat(int fd, const char *path, mode_t mode); }\n+\tSYS_MKNODAT              = 460 // { int|sys||mknodat(int fd, const char *path, mode_t mode, uint32_t dev); }\n+\tSYS_MKDIRAT              = 461 // { int|sys||mkdirat(int fd, const char *path, mode_t mode); }\n+\tSYS_FACCESSAT            = 462 // { int|sys||faccessat(int fd, const char *path, int amode, int flag); }\n+\tSYS_FCHMODAT             = 463 // { int|sys||fchmodat(int fd, const char *path, mode_t mode, int flag); }\n+\tSYS_FCHOWNAT             = 464 // { int|sys||fchownat(int fd, const char *path, uid_t owner, gid_t group, int flag); }\n+\tSYS_FEXECVE              = 465 // { int|sys||fexecve(int fd, char * const *argp, char * const *envp); }\n+\tSYS_FSTATAT              = 466 // { int|sys||fstatat(int fd, const char *path, struct stat *buf, int flag); }\n+\tSYS_UTIMENSAT            = 467 // { int|sys||utimensat(int fd, const char *path, const struct timespec *tptr, int flag); }\n+\tSYS_OPENAT               = 468 // { int|sys||openat(int fd, const char *path, int oflags, ... mode_t mode); }\n+\tSYS_READLINKAT           = 469 // { int|sys||readlinkat(int fd, const char *path, char *buf, size_t bufsize); }\n+\tSYS_SYMLINKAT            = 470 // { int|sys||symlinkat(const char *path1, int fd, const char *path2); }\n+\tSYS_UNLINKAT             = 471 // { int|sys||unlinkat(int fd, const char *path, int flag); }\n+\tSYS_FUTIMENS             = 472 // { int|sys||futimens(int fd, const struct timespec *tptr); }\n+\tSYS___QUOTACTL           = 473 // { int|sys||__quotactl(const char *path, struct quotactl_args *args); }\n+\tSYS_POSIX_SPAWN          = 474 // { int|sys||posix_spawn(pid_t *pid, const char *path, const struct posix_spawn_file_actions *file_actions, const struct posix_spawnattr *attrp, char *const *argv, char *const *envp); }\n+\tSYS_RECVMMSG             = 475 // { int|sys||recvmmsg(int s, struct mmsghdr *mmsg, unsigned int vlen, unsigned int flags, struct timespec *timeout); }\n+\tSYS_SENDMMSG             = 476 // { int|sys||sendmmsg(int s, struct mmsghdr *mmsg, unsigned int vlen, unsigned int flags); }\n+)"
    },
    {
      "sha": "d262150cc084292cb4fce1606494b82c12d32b03",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -759,7 +759,30 @@ type Sigset_t struct {\n \tVal [32]uint32\n }\n \n-const RNDGETENTCNT = 0x80045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1964,6 +1987,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1983,4 +2010,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "e492caacda58c1f14221acb5d33eb4d0efa529ca",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -772,7 +772,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x80045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1977,6 +2000,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1996,4 +2023,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "ad4342156e67dba136a6bab8c58cf6206108efeb",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -748,7 +748,30 @@ type Sigset_t struct {\n \tVal [32]uint32\n }\n \n-const RNDGETENTCNT = 0x80045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1955,6 +1978,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1974,4 +2001,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "ef76a362d9c76006a20a93d390b670c6eb49559f",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -751,7 +751,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x80045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1956,6 +1979,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1975,4 +2002,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "dbf05903d4248f12e2108aba69d8ba16764f61b5",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -753,7 +753,30 @@ type Sigset_t struct {\n \tVal [32]uint32\n }\n \n-const RNDGETENTCNT = 0x40045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1961,6 +1984,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1980,4 +2007,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "1b7e6707934d0926b1e328578240a9571ce59a32",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -753,7 +753,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x40045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1958,6 +1981,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1977,4 +2004,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "57379005b58a4b8af7703c1227a1470e9a2c20d1",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -753,7 +753,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x40045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1958,6 +1981,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1977,4 +2004,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "0e88bf47bcd518738642b7d3b87f199eff60bb3c",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -753,7 +753,30 @@ type Sigset_t struct {\n \tVal [32]uint32\n }\n \n-const RNDGETENTCNT = 0x40045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1961,6 +1984,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1980,4 +2007,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "5ac91b3f7aa59156b1b2be3b2849ec4d9b309906",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -761,7 +761,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x40045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1966,6 +1989,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1985,4 +2012,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "1e59b45068c547bd751029da5cc997ef06adcc4b",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -761,7 +761,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x40045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1966,6 +1989,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1985,4 +2012,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "508885f11f0dc093ac42d47abfadacb5418080ae",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go",
      "status": "modified",
      "additions": 43,
      "deletions": 2,
      "changes": 45,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -212,7 +212,7 @@ type RawSockaddrInet6 struct {\n \n type RawSockaddrUnix struct {\n \tFamily uint16\n-\tPath   [108]uint8\n+\tPath   [108]int8\n }\n \n type RawSockaddrLinklayer struct {\n@@ -778,7 +778,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x80045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1983,6 +2006,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -2002,4 +2029,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "d315f2c3a7a6815a06deb9aa3edb29e1ea9c984e",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -774,7 +774,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x80045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1980,6 +2003,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1999,4 +2026,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "a1a9279c225062b91b34da0c0a5be5d0a27894ce",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -756,7 +756,30 @@ type Sigset_t struct {\n \tVal [16]uint64\n }\n \n-const RNDGETENTCNT = 0x40045200\n+type SignalfdSiginfo struct {\n+\tSigno     uint32\n+\tErrno     int32\n+\tCode      int32\n+\tPid       uint32\n+\tUid       uint32\n+\tFd        int32\n+\tTid       uint32\n+\tBand      uint32\n+\tOverrun   uint32\n+\tTrapno    uint32\n+\tStatus    int32\n+\tInt       int32\n+\tPtr       uint64\n+\tUtime     uint64\n+\tStime     uint64\n+\tAddr      uint64\n+\tAddr_lsb  uint16\n+\t_         uint16\n+\tSyscall   int32\n+\tCall_addr uint64\n+\tArch      uint32\n+\t_         [28]uint8\n+}\n \n const PERF_IOC_FLAG_GROUP = 0x1\n \n@@ -1961,6 +1984,10 @@ const (\n \tNCSI_CHANNEL_ATTR_VLAN_ID       = 0xa\n )\n \n+type ScmTimestamping struct {\n+\tTs [3]Timespec\n+}\n+\n const (\n \tSOF_TIMESTAMPING_TX_HARDWARE  = 0x1\n \tSOF_TIMESTAMPING_TX_SOFTWARE  = 0x2\n@@ -1980,4 +2007,18 @@ const (\n \n \tSOF_TIMESTAMPING_LAST = 0x4000\n \tSOF_TIMESTAMPING_MASK = 0x7fff\n+\n+\tSCM_TSTAMP_SND   = 0x0\n+\tSCM_TSTAMP_SCHED = 0x1\n+\tSCM_TSTAMP_ACK   = 0x2\n )\n+\n+type SockExtendedErr struct {\n+\tErrno  uint32\n+\tOrigin uint8\n+\tType   uint8\n+\tCode   uint8\n+\tPad    uint8\n+\tInfo   uint32\n+\tData   uint32\n+}"
    },
    {
      "sha": "43da2c41c50364c7adf3fba145bd1b90a90b20d9",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm64.go",
      "status": "added",
      "additions": 472,
      "deletions": 0,
      "changes": 472,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_netbsd_arm64.go?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -0,0 +1,472 @@\n+// cgo -godefs types_netbsd.go | go run mkpost.go\n+// Code generated by the command above; see README.md. DO NOT EDIT.\n+\n+// +build arm64,netbsd\n+\n+package unix\n+\n+const (\n+\tSizeofPtr      = 0x8\n+\tSizeofShort    = 0x2\n+\tSizeofInt      = 0x4\n+\tSizeofLong     = 0x8\n+\tSizeofLongLong = 0x8\n+)\n+\n+type (\n+\t_C_short     int16\n+\t_C_int       int32\n+\t_C_long      int64\n+\t_C_long_long int64\n+)\n+\n+type Timespec struct {\n+\tSec  int64\n+\tNsec int64\n+}\n+\n+type Timeval struct {\n+\tSec       int64\n+\tUsec      int32\n+\tPad_cgo_0 [4]byte\n+}\n+\n+type Rusage struct {\n+\tUtime    Timeval\n+\tStime    Timeval\n+\tMaxrss   int64\n+\tIxrss    int64\n+\tIdrss    int64\n+\tIsrss    int64\n+\tMinflt   int64\n+\tMajflt   int64\n+\tNswap    int64\n+\tInblock  int64\n+\tOublock  int64\n+\tMsgsnd   int64\n+\tMsgrcv   int64\n+\tNsignals int64\n+\tNvcsw    int64\n+\tNivcsw   int64\n+}\n+\n+type Rlimit struct {\n+\tCur uint64\n+\tMax uint64\n+}\n+\n+type _Gid_t uint32\n+\n+type Stat_t struct {\n+\tDev           uint64\n+\tMode          uint32\n+\tPad_cgo_0     [4]byte\n+\tIno           uint64\n+\tNlink         uint32\n+\tUid           uint32\n+\tGid           uint32\n+\tPad_cgo_1     [4]byte\n+\tRdev          uint64\n+\tAtimespec     Timespec\n+\tMtimespec     Timespec\n+\tCtimespec     Timespec\n+\tBirthtimespec Timespec\n+\tSize          int64\n+\tBlocks        int64\n+\tBlksize       uint32\n+\tFlags         uint32\n+\tGen           uint32\n+\tSpare         [2]uint32\n+\tPad_cgo_2     [4]byte\n+}\n+\n+type Statfs_t [0]byte\n+\n+type Flock_t struct {\n+\tStart  int64\n+\tLen    int64\n+\tPid    int32\n+\tType   int16\n+\tWhence int16\n+}\n+\n+type Dirent struct {\n+\tFileno    uint64\n+\tReclen    uint16\n+\tNamlen    uint16\n+\tType      uint8\n+\tName      [512]int8\n+\tPad_cgo_0 [3]byte\n+}\n+\n+type Fsid struct {\n+\tX__fsid_val [2]int32\n+}\n+\n+const (\n+\tPathMax = 0x400\n+)\n+\n+const (\n+\tFADV_NORMAL     = 0x0\n+\tFADV_RANDOM     = 0x1\n+\tFADV_SEQUENTIAL = 0x2\n+\tFADV_WILLNEED   = 0x3\n+\tFADV_DONTNEED   = 0x4\n+\tFADV_NOREUSE    = 0x5\n+)\n+\n+type RawSockaddrInet4 struct {\n+\tLen    uint8\n+\tFamily uint8\n+\tPort   uint16\n+\tAddr   [4]byte /* in_addr */\n+\tZero   [8]int8\n+}\n+\n+type RawSockaddrInet6 struct {\n+\tLen      uint8\n+\tFamily   uint8\n+\tPort     uint16\n+\tFlowinfo uint32\n+\tAddr     [16]byte /* in6_addr */\n+\tScope_id uint32\n+}\n+\n+type RawSockaddrUnix struct {\n+\tLen    uint8\n+\tFamily uint8\n+\tPath   [104]int8\n+}\n+\n+type RawSockaddrDatalink struct {\n+\tLen    uint8\n+\tFamily uint8\n+\tIndex  uint16\n+\tType   uint8\n+\tNlen   uint8\n+\tAlen   uint8\n+\tSlen   uint8\n+\tData   [12]int8\n+}\n+\n+type RawSockaddr struct {\n+\tLen    uint8\n+\tFamily uint8\n+\tData   [14]int8\n+}\n+\n+type RawSockaddrAny struct {\n+\tAddr RawSockaddr\n+\tPad  [92]int8\n+}\n+\n+type _Socklen uint32\n+\n+type Linger struct {\n+\tOnoff  int32\n+\tLinger int32\n+}\n+\n+type Iovec struct {\n+\tBase *byte\n+\tLen  uint64\n+}\n+\n+type IPMreq struct {\n+\tMultiaddr [4]byte /* in_addr */\n+\tInterface [4]byte /* in_addr */\n+}\n+\n+type IPv6Mreq struct {\n+\tMultiaddr [16]byte /* in6_addr */\n+\tInterface uint32\n+}\n+\n+type Msghdr struct {\n+\tName       *byte\n+\tNamelen    uint32\n+\tPad_cgo_0  [4]byte\n+\tIov        *Iovec\n+\tIovlen     int32\n+\tPad_cgo_1  [4]byte\n+\tControl    *byte\n+\tControllen uint32\n+\tFlags      int32\n+}\n+\n+type Cmsghdr struct {\n+\tLen   uint32\n+\tLevel int32\n+\tType  int32\n+}\n+\n+type Inet6Pktinfo struct {\n+\tAddr    [16]byte /* in6_addr */\n+\tIfindex uint32\n+}\n+\n+type IPv6MTUInfo struct {\n+\tAddr RawSockaddrInet6\n+\tMtu  uint32\n+}\n+\n+type ICMPv6Filter struct {\n+\tFilt [8]uint32\n+}\n+\n+const (\n+\tSizeofSockaddrInet4    = 0x10\n+\tSizeofSockaddrInet6    = 0x1c\n+\tSizeofSockaddrAny      = 0x6c\n+\tSizeofSockaddrUnix     = 0x6a\n+\tSizeofSockaddrDatalink = 0x14\n+\tSizeofLinger           = 0x8\n+\tSizeofIPMreq           = 0x8\n+\tSizeofIPv6Mreq         = 0x14\n+\tSizeofMsghdr           = 0x30\n+\tSizeofCmsghdr          = 0xc\n+\tSizeofInet6Pktinfo     = 0x14\n+\tSizeofIPv6MTUInfo      = 0x20\n+\tSizeofICMPv6Filter     = 0x20\n+)\n+\n+const (\n+\tPTRACE_TRACEME = 0x0\n+\tPTRACE_CONT    = 0x7\n+\tPTRACE_KILL    = 0x8\n+)\n+\n+type Kevent_t struct {\n+\tIdent     uint64\n+\tFilter    uint32\n+\tFlags     uint32\n+\tFflags    uint32\n+\tPad_cgo_0 [4]byte\n+\tData      int64\n+\tUdata     int64\n+}\n+\n+type FdSet struct {\n+\tBits [8]uint32\n+}\n+\n+const (\n+\tSizeofIfMsghdr         = 0x98\n+\tSizeofIfData           = 0x88\n+\tSizeofIfaMsghdr        = 0x18\n+\tSizeofIfAnnounceMsghdr = 0x18\n+\tSizeofRtMsghdr         = 0x78\n+\tSizeofRtMetrics        = 0x50\n+)\n+\n+type IfMsghdr struct {\n+\tMsglen    uint16\n+\tVersion   uint8\n+\tType      uint8\n+\tAddrs     int32\n+\tFlags     int32\n+\tIndex     uint16\n+\tPad_cgo_0 [2]byte\n+\tData      IfData\n+}\n+\n+type IfData struct {\n+\tType       uint8\n+\tAddrlen    uint8\n+\tHdrlen     uint8\n+\tPad_cgo_0  [1]byte\n+\tLink_state int32\n+\tMtu        uint64\n+\tMetric     uint64\n+\tBaudrate   uint64\n+\tIpackets   uint64\n+\tIerrors    uint64\n+\tOpackets   uint64\n+\tOerrors    uint64\n+\tCollisions uint64\n+\tIbytes     uint64\n+\tObytes     uint64\n+\tImcasts    uint64\n+\tOmcasts    uint64\n+\tIqdrops    uint64\n+\tNoproto    uint64\n+\tLastchange Timespec\n+}\n+\n+type IfaMsghdr struct {\n+\tMsglen    uint16\n+\tVersion   uint8\n+\tType      uint8\n+\tAddrs     int32\n+\tFlags     int32\n+\tMetric    int32\n+\tIndex     uint16\n+\tPad_cgo_0 [6]byte\n+}\n+\n+type IfAnnounceMsghdr struct {\n+\tMsglen  uint16\n+\tVersion uint8\n+\tType    uint8\n+\tIndex   uint16\n+\tName    [16]int8\n+\tWhat    uint16\n+}\n+\n+type RtMsghdr struct {\n+\tMsglen    uint16\n+\tVersion   uint8\n+\tType      uint8\n+\tIndex     uint16\n+\tPad_cgo_0 [2]byte\n+\tFlags     int32\n+\tAddrs     int32\n+\tPid       int32\n+\tSeq       int32\n+\tErrno     int32\n+\tUse       int32\n+\tInits     int32\n+\tPad_cgo_1 [4]byte\n+\tRmx       RtMetrics\n+}\n+\n+type RtMetrics struct {\n+\tLocks    uint64\n+\tMtu      uint64\n+\tHopcount uint64\n+\tRecvpipe uint64\n+\tSendpipe uint64\n+\tSsthresh uint64\n+\tRtt      uint64\n+\tRttvar   uint64\n+\tExpire   int64\n+\tPksent   int64\n+}\n+\n+type Mclpool [0]byte\n+\n+const (\n+\tSizeofBpfVersion = 0x4\n+\tSizeofBpfStat    = 0x80\n+\tSizeofBpfProgram = 0x10\n+\tSizeofBpfInsn    = 0x8\n+\tSizeofBpfHdr     = 0x20\n+)\n+\n+type BpfVersion struct {\n+\tMajor uint16\n+\tMinor uint16\n+}\n+\n+type BpfStat struct {\n+\tRecv    uint64\n+\tDrop    uint64\n+\tCapt    uint64\n+\tPadding [13]uint64\n+}\n+\n+type BpfProgram struct {\n+\tLen       uint32\n+\tPad_cgo_0 [4]byte\n+\tInsns     *BpfInsn\n+}\n+\n+type BpfInsn struct {\n+\tCode uint16\n+\tJt   uint8\n+\tJf   uint8\n+\tK    uint32\n+}\n+\n+type BpfHdr struct {\n+\tTstamp    BpfTimeval\n+\tCaplen    uint32\n+\tDatalen   uint32\n+\tHdrlen    uint16\n+\tPad_cgo_0 [6]byte\n+}\n+\n+type BpfTimeval struct {\n+\tSec  int64\n+\tUsec int64\n+}\n+\n+type Termios struct {\n+\tIflag  uint32\n+\tOflag  uint32\n+\tCflag  uint32\n+\tLflag  uint32\n+\tCc     [20]uint8\n+\tIspeed int32\n+\tOspeed int32\n+}\n+\n+type Winsize struct {\n+\tRow    uint16\n+\tCol    uint16\n+\tXpixel uint16\n+\tYpixel uint16\n+}\n+\n+type Ptmget struct {\n+\tCfd int32\n+\tSfd int32\n+\tCn  [1024]byte\n+\tSn  [1024]byte\n+}\n+\n+const (\n+\tAT_FDCWD            = -0x64\n+\tAT_SYMLINK_NOFOLLOW = 0x200\n+)\n+\n+type PollFd struct {\n+\tFd      int32\n+\tEvents  int16\n+\tRevents int16\n+}\n+\n+const (\n+\tPOLLERR    = 0x8\n+\tPOLLHUP    = 0x10\n+\tPOLLIN     = 0x1\n+\tPOLLNVAL   = 0x20\n+\tPOLLOUT    = 0x4\n+\tPOLLPRI    = 0x2\n+\tPOLLRDBAND = 0x80\n+\tPOLLRDNORM = 0x40\n+\tPOLLWRBAND = 0x100\n+\tPOLLWRNORM = 0x4\n+)\n+\n+type Sysctlnode struct {\n+\tFlags           uint32\n+\tNum             int32\n+\tName            [32]int8\n+\tVer             uint32\n+\tX__rsvd         uint32\n+\tUn              [16]byte\n+\tX_sysctl_size   [8]byte\n+\tX_sysctl_func   [8]byte\n+\tX_sysctl_parent [8]byte\n+\tX_sysctl_desc   [8]byte\n+}\n+\n+type Utsname struct {\n+\tSysname  [256]byte\n+\tNodename [256]byte\n+\tRelease  [256]byte\n+\tVersion  [256]byte\n+\tMachine  [256]byte\n+}\n+\n+const SizeofClockinfo = 0x14\n+\n+type Clockinfo struct {\n+\tHz      int32\n+\tTick    int32\n+\tTickadj int32\n+\tStathz  int32\n+\tProfhz  int32\n+}"
    },
    {
      "sha": "c48935e5b0a1efc51916560ad39349206cc39adb",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/modules.txt",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/backend/vendor/modules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/modules.txt?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -85,16 +85,19 @@ github.com/rakyll/statik/fs\n github.com/rs/xid\n # github.com/shurcooL/sanitized_anchor_name v1.0.0\n github.com/shurcooL/sanitized_anchor_name\n+# github.com/stretchr/objx v0.1.1\n+github.com/stretchr/objx\n # github.com/stretchr/testify v1.3.0\n+github.com/stretchr/testify/mock\n github.com/stretchr/testify/assert\n github.com/stretchr/testify/require\n-# golang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16\n+# golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2\n golang.org/x/crypto/acme/autocert\n golang.org/x/crypto/acme\n # golang.org/x/image v0.0.0-20181116024801-cd38e8056d9b\n golang.org/x/image/draw\n golang.org/x/image/math/f64\n-# golang.org/x/net v0.0.0-20190107210223-45ffb0cd1ba0\n+# golang.org/x/net v0.0.0-20190415214537-1da14a5a36f2\n golang.org/x/net/html\n golang.org/x/net/html/atom\n golang.org/x/net/context/ctxhttp\n@@ -108,7 +111,7 @@ golang.org/x/oauth2/yandex\n golang.org/x/oauth2/internal\n golang.org/x/oauth2/jws\n golang.org/x/oauth2/jwt\n-# golang.org/x/sys v0.0.0-20190109145017-48ac38b7c8cb\n+# golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a\n golang.org/x/sys/unix\n # golang.org/x/time v0.0.0-20190308202827-9d24e82272b4\n golang.org/x/time/rate"
    },
    {
      "sha": "fed061f2030d03909313ae3bbe6266515f357894",
      "filename": "compose-dev-backend.yml",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/68b892f5e913e60ed9a2d38fe96af0b63e05a642/compose-dev-backend.yml",
      "raw_url": "https://github.com/umputun/remark/raw/68b892f5e913e60ed9a2d38fe96af0b63e05a642/compose-dev-backend.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/compose-dev-backend.yml?ref=68b892f5e913e60ed9a2d38fe96af0b63e05a642",
      "patch": "@@ -17,6 +17,7 @@ services:\n             context: .\n             dockerfile: Dockerfile\n             args:\n+                - SKIP_BACKEND_TEST\n                 - SKIP_FRONTEND_TEST=true\n                 - MONGO_TEST=skip # disable mongo tests on build by default. To allow remove =skip part and see above\n "
    }
  ]
}
