{
  "sha": "07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
  "node_id": "C_kwDOAKEu-toAKDA3YWM4MWEwNTc4YmJmMTVkMGM0Yjk1ZTdkNDY0ZWVjN2JlMzExZmQ",
  "commit": {
    "author": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2024-09-09T03:04:55Z"
    },
    "committer": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2024-09-09T03:04:55Z"
    },
    "message": "Merge v0.2024.006 into 'release'.",
    "tree": {
      "sha": "a675e78fae5681ce9c5d5b68f983928a8d7de1b5",
      "url": "https://api.github.com/repos/debiki/talkyard/git/trees/a675e78fae5681ce9c5d5b68f983928a8d7de1b5"
    },
    "url": "https://api.github.com/repos/debiki/talkyard/git/commits/07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/debiki/talkyard/commits/07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
  "html_url": "https://github.com/debiki/talkyard/commit/07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
  "comments_url": "https://api.github.com/repos/debiki/talkyard/commits/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/comments",
  "author": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a941015db661e13ac3e5523d2ab5a3e600275acc",
      "url": "https://api.github.com/repos/debiki/talkyard/commits/a941015db661e13ac3e5523d2ab5a3e600275acc",
      "html_url": "https://github.com/debiki/talkyard/commit/a941015db661e13ac3e5523d2ab5a3e600275acc"
    },
    {
      "sha": "0c47139374d2fbd66dacc0de53f1b4cf562ac556",
      "url": "https://api.github.com/repos/debiki/talkyard/commits/0c47139374d2fbd66dacc0de53f1b4cf562ac556",
      "html_url": "https://github.com/debiki/talkyard/commit/0c47139374d2fbd66dacc0de53f1b4cf562ac556"
    }
  ],
  "stats": {
    "total": 6326,
    "additions": 4642,
    "deletions": 1684
  },
  "files": [
    {
      "sha": "fca0a1a02844f5353afcc38bef9a7715b52cd87b",
      "filename": "appsv/model/src/main/scala/com/debiki/core/Post.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPost.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPost.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPost.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -354,7 +354,7 @@ case class Draft(\n   deletedAt: Option[When] = None,\n   topicType: Option[PageType] = None,\n   postType: Option[PostType] = None,\n-  doAsAnon: Opt[WhichAnon],\n+  doAsAnon: Opt[WhichAliasId],\n   title: String,\n   text: String) {\n "
    },
    {
      "sha": "3be4ec1a2b751268ea0c0a877f1c8069bdc81724",
      "filename": "appsv/model/src/main/scala/com/debiki/core/SiteTransaction.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FSiteTransaction.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FSiteTransaction.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FSiteTransaction.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -494,6 +494,8 @@ trait SiteTransaction {   RENAME // to SiteTx — already started with a type Si\n \n   def insertAnonym(anonym: Anonym): U\n \n+  def loadAnyAnon(userId: UserId, pageId: PageId, anonStatus: AnonStatus): Opt[Anonym]\n+\n   def nextMemberId: UserId\n   def insertMember(user: UserInclDetails): Unit\n "
    },
    {
      "sha": "29657be6bf0be4b4b15f301faafa5571209afb95",
      "filename": "appsv/model/src/main/scala/com/debiki/core/dao-db.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fdao-db.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fdao-db.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fdao-db.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -69,6 +69,7 @@ object DbDao {\n   object BadPasswordException extends QuickMessageException(\"Bad password\")\n   object UserDeletedException extends QuickMessageException(\"User deleted\")\n \n+  RENAME // to DuplicateActionEx?\n   case object DuplicateVoteException extends RuntimeException(\"Duplicate vote\")\n \n   class PageNotFoundException(message: String) extends RuntimeException(message)"
    },
    {
      "sha": "e8ff6a3874d25c4c0893fb593f3ee906c259a0ac",
      "filename": "appsv/model/src/main/scala/com/debiki/core/package.scala",
      "status": "modified",
      "additions": 84,
      "deletions": 28,
      "changes": 112,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpackage.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpackage.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpackage.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -939,20 +939,6 @@ package object core {\n   }\n \n \n-  /*\n-  sealed abstract class AnonLevel(val IntVal: i32) { def toInt: i32 = IntVal }\n-  object AnonLevel {\n-    case object NotAnon extends AnonLevel(10)\n-    case object AnonymPerPage extends AnonLevel(50)\n-\n-    def fromInt(value: i32): Opt[AnonLevel] = Some(value match {\n-      case NotAnon.IntVal => NotAnon\n-      case AnonymPerPage.IntVal => AnonymPerPage\n-      case _ => return None\n-    })\n-  }*/\n-\n-\n \n   /** A bitfield. Currently only None, 65535 = IsAnonOnlySelfCanDeanon\n     * and 2097151 = IsAnonCanAutoDeanon are supported.\n@@ -1080,27 +1066,92 @@ package object core {\n   }\n \n \n-  sealed abstract class WhichAnon() {\n-    require(anySameAnonId.isDefined != anyNewAnonStatus.isDefined, \"TyE6G0FM2TF3\")\n+  /** For before an alias has been looked up — we know only its id. Or,\n+    * if it's a lazy-created anon, we don't know its id (doesn't yet exist),\n+    * instead, we only know what type of anon it's going to be, that is, its\n+    * future anon status (currently, either temporarily anonymous,\n+    * for ideation, or permanently, for sensitive discussions).\n+    */\n+  sealed abstract class WhichAliasId() {\n+    // Remove later. [chk_alias_status]\n+    require(anySameAliasId.isEmpty || anyAnonStatus.isEmpty, \"TyE6G0FM2TF3\")\n+\n+    def anyAnonStatus: Opt[AnonStatus]\n+    def anySameAliasId: Opt[AnonId]\n+  }\n+\n+\n+  object WhichAliasId {\n+\n+    /** For doing sth as oneself (even if anonymity is the default) — \"Yourself Mode\". */\n+    case object Oneself extends WhichAliasId {\n+      def anySameAliasId: Opt[AnonId] = None\n+      def anyAnonStatus: Opt[AnonStatus] = None\n+    }\n+\n+    // Later:  [pseudonyms_later]\n+    //case class SamePseudonym(sameAliasId: PatId) extends WhichAliasId with SameAlias {\n+    //  def anySameAliasId: Opt[PatId] = Some(sameAliasId)\n+    //  def anyAnonStatus: Opt[AnonStatus] = None\n+    //}\n+\n+    COULD // add   anonStatus, error if mismatch? [chk_alias_status]\n+    case class SameAnon(sameAnonId: PatId) extends WhichAliasId {\n+      require(sameAnonId <= Pat.MaxAnonId, s\"Not an anon id: $sameAnonId\")\n+      def anySameAliasId: Opt[AnonId] = Some(sameAnonId)\n+      def anyAnonStatus: Opt[AnonStatus] = None\n+    }\n+\n+    case class LazyCreatedAnon(anonStatus: AnonStatus) extends WhichAliasId {\n+      require(anonStatus != AnonStatus.NotAnon, \"WhichAliasId.anonStatus is NotAnon [TyE2M068G]\")\n+      def anySameAliasId: Opt[AnonId] = None\n+      def anyAnonStatus: Opt[AnonStatus] = Some(anonStatus)\n+    }\n+  }\n+\n \n-    // Either ...\n-    def anyNewAnonStatus: Opt[AnonStatus] = None\n-    // ... or.\n-    def anySameAnonId: Opt[AnonId] = None\n+  /** For after the alias has been looked up by any id, when we have an Anonym or Pseudonym,\n+    * not just an id. (Or still just a to-be-lazy-created anonym, with a future anon status.)\n+    */\n+  sealed trait WhichAliasPat {\n+    def anyPat: Opt[Pat]\n   }\n \n-  object WhichAnon {\n-    case class NewAnon(anonStatus: AnonStatus) extends WhichAnon {\n-      require(anonStatus != AnonStatus.NotAnon, \"WhichAnon is NotAnon [TyE2MC06Y8G]\")\n-      override def anyNewAnonStatus: Opt[AnonStatus] = Some(anonStatus)\n+\n+  object WhichAliasPat {\n+    // Later:  [pseudonyms_later]\n+    // Create a Pseudonym class? Pat / PatBr has unnecessary stuff, e.g. sso id.\n+    //case class SamePseudonym(pseudonym: Pseudonym) extends WhichAliasPat {\n+    //  def anyPat: Opt[Pat] = Some(pseudonym)\n+    //}\n+\n+    case class SameAnon(anon: Anonym) extends WhichAliasPat {\n+      def anyPat: Opt[Pat] = Some(anon)\n     }\n \n-    case class SameAsBefore(sameAnonId: PatId) extends WhichAnon {\n-      override def anySameAnonId: Opt[AnonId] = Some(sameAnonId)\n+    /** Reuses any already existing anonym with the same anon status,\n+      * on the same page.\n+      *\n+      * If there're many, on the relevant page, then what? Throw an error?\n+      * Can't happen, yet, because [one_anon_per_page].\n+      */\n+    case class LazyCreatedAnon(anonStatus: AnonStatus) extends WhichAliasPat {\n+      def anyPat: Opt[Pat] = None // might not yet exist\n     }\n+\n+    // Let's not support creating more than one anonym per user & page, for now.\n+    //case class NewAnon(anonStatus: AnonStatus) extends WhichAliasPat {\n+    //  def anyPat: Opt[Pat] = None\n+    //}\n   }\n \n \n+  sealed abstract class AnyUserAndLevels {\n+    def anyUser: Opt[Pat]\n+    def trustLevel: TrustLevel\n+    def threatLevel: ThreatLevel\n+  }\n+\n   /**\n     * @param user, (RENAME to patOrPseudonym?) — the id of the requester, can be a pseudonym. But not an anonym.\n     * @param trustLevel — if patOrPseudonym is a pseudonym, then this is the pseudonym's\n@@ -1111,13 +1162,17 @@ package object core {\n     user: Pat,\n     trustLevel: TrustLevel,\n     threatLevel: ThreatLevel,\n-  ) {\n+  ) extends AnyUserAndLevels {\n+    def anyUser = Some(user)\n     def id: UserId = user.id\n     def isStaff: Boolean = user.isStaff\n     def nameHashId: String = user.nameHashId\n   }\n \n-  case class AnyUserAndThreatLevel(user: Option[Participant], threatLevel: ThreatLevel)\n+  case class StrangerAndThreatLevel(threatLevel: ThreatLevel) extends AnyUserAndLevels {\n+    def anyUser: Opt[Pat] = None\n+    def trustLevel: TrustLevel = TrustLevel.Stranger\n+  }\n \n \n   sealed trait OrderBy { def isDescending: Boolean = false }\n@@ -2057,6 +2112,7 @@ package object core {\n \n \n   implicit class RichBoolean(underlying: Boolean) {\n+    // (For find-by-similar-name: \"oneIfTrue\".)\n     def toZeroOne: i32 = if (underlying) 1 else 0\n   }\n "
    },
    {
      "sha": "1029242a5fadacf34676e9dd809dcccf053d2ddd",
      "filename": "appsv/model/src/main/scala/com/debiki/core/permissions.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpermissions.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpermissions.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpermissions.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -123,6 +123,7 @@ case class PermsOnPages(  // [exp] ok use. Missing, fine: may_see_private_flagge\n   mayCreatePage: Opt[Bo] = None,\n   mayPostComment: Opt[Bo] = None,\n   maySee: Opt[Bo] = None,\n+  // Wants index: pages_i_authorid_catid_createdat_pageid\n   maySeeOwn: Opt[Bo] = None) {\n \n   // maySeeIfEmbeddedAlthoughLoginRequired  [emb_login_req]"
    },
    {
      "sha": "c9881001a1e826e79135031506c6964482e639a7",
      "filename": "appsv/model/src/main/scala/com/debiki/core/user.scala",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fuser.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fuser.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fuser.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1024,6 +1024,10 @@ trait MemberMaybeDetails {\n }\n \n \n+trait Alias {\n+  def aliasForPatId: PatId\n+}\n+\n \n case class Anonym(\n   id: AnonId,\n@@ -1032,12 +1036,18 @@ case class Anonym(\n   anonForPatId: MembId,\n   anonOnPageId: PageId,\n   // deanonymizedById: Opt[MembId],  // later\n-  ) extends Pat with GuestOrAnon with Someone {\n+  ) extends Pat with GuestOrAnon with Someone with Alias {\n \n   override def trueId2: TrueId = TrueId(id, anyTrueId = Some(anonForPatId))\n+  def aliasForPatId = anonForPatId\n \n   def anyUsername: Opt[St] = None\n+\n+  // Not that much in use — client side code shows the anon status instead   [anon_2_str]\n+  // (e.g. \"Temp Anonym\" or \"Aonymous\"), in different languages.  But is used in\n+  // \"Written by ...\" in email notifications?\n   def nameOrUsername: St = \"Anonym\"\n+\n   override def anyName: Opt[St] = Some(nameOrUsername)\n   override def usernameOrGuestName: St = nameOrUsername\n "
    },
    {
      "sha": "09a25cd53224e89f4a7d92265d263d3034ca4d41",
      "filename": "appsv/rdb/src/main/resources/db/migration/db-wip.sql",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fdb-wip.sql",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fdb-wip.sql",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fdb-wip.sql?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -64,6 +64,21 @@ alter domain  alnum_plusdashdot_arr_d add\n -- Odd, last_approved_edit_at can be not null, also if  approved_at is null.\n -- Harmless but maybe surprising in the future.\n \n+-- For listing pages by someone in a specific category. Helpful, for categories where\n+-- one may post topics, but not see others' posts.  That is:\n+--    PermsOnPages(\n+--      mayCreatePage = true,\n+--      mayPostComment = true,\n+--      maySee = false  <——\n+--      maySeeOwn = true  <——\n+--      ...)\n+\n+create index  pages_i_authorid_catid_createdat_pageid  on  pages3 (\n+      site_id, author_id, category_id, created_at desc, page_id desc);\n+\n+-- No longer needed.  Same as pages_i_createdby_catid but only on: (site_id, author_id).\n+drop index dw2_pages_createdby__i;\n+\n \n --=============================================================================\n --  Upload refs"
    },
    {
      "sha": "e100926e9bf6e18a4c325e69f76064feb4043977",
      "filename": "appsv/rdb/src/main/resources/db/migration/y2024/wip_v427__alias.sql",
      "status": "added",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fy2024%2Fwip_v427__alias.sql",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fy2024%2Fwip_v427__alias.sql",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fy2024%2Fwip_v427__alias.sql?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,7 @@\n+\n+\n+alter table  page_users3  add column  prefer_alias_id_c  pat_id_d;\n+-- +\n+-- fk deferred\n+-- ix\n+"
    },
    {
      "sha": "79be362082a1aa7276a5ea3a631928d0add7805a",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/DraftsSiteDaoMixin.scala",
      "status": "modified",
      "additions": 12,
      "deletions": 7,
      "changes": 19,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FDraftsSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FDraftsSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FDraftsSiteDaoMixin.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -111,8 +111,8 @@ trait DraftsSiteDaoMixin extends SiteTransaction {\n       locator.postId.orNullInt,\n       draft.postType.map(_.toInt).orNullInt,\n       locator.toUserId.orNullInt,\n-      draft.doAsAnon.flatMap(_.anySameAnonId.map(_.toInt)).orNullInt,\n-      draft.doAsAnon.flatMap(_.anyNewAnonStatus.map(_.toInt)).orNullInt,\n+      draft.doAsAnon.flatMap(_.anySameAliasId.map(_.toInt)).orNullInt,\n+      draft.doAsAnon.flatMap(_.anyAnonStatus.map(_.toInt)).orNullInt,\n       draft.title,\n       draft.text))\n   }\n@@ -215,7 +215,7 @@ trait DraftsSiteDaoMixin extends SiteTransaction {\n \n     Draft(\n       byUserId = getInt(rs, \"by_user_id\"),\n-      doAsAnon = parseWhichAnon(rs),\n+      doAsAnon = parseWhichAliasId(rs),\n       draftNr = getInt(rs, \"draft_nr\"),\n       forWhat = draftLocator,\n       createdAt = getWhen(rs, \"created_at\"),\n@@ -228,21 +228,26 @@ trait DraftsSiteDaoMixin extends SiteTransaction {\n   }\n \n \n-  /** Sync w talkyard.server.parser.parseWhichAnonJson().\n+  /** Sync w talkyard.server.parser.parseWhichAliasIdJson().\n     */\n-  def parseWhichAnon(rs: js.ResultSet): Opt[WhichAnon] = {\n+  private def parseWhichAliasId(rs: js.ResultSet): Opt[WhichAliasId] = {\n     val sameAnonId = getOptInt(rs, \"post_as_id_c\")\n+\n+    // Would need to remember  anonStatus  in new_anon_status_c, to  [chk_alias_status]\n+    // be able to check if the alias still has the same status as when the user\n+    // started composing the draft. (If different, could notify han.)\n+    //\n     // PostgreSQL custom domain  anonym_status_d  has verified that the value is valid.\n     val newAnonStatus = AnonStatus.fromOptInt(getOptInt(rs, \"new_anon_status_c\"))\n     dieIf(sameAnonId.isDefined && newAnonStatus.isDefined, \"TyE6023RAKJ5\",\n             \"Both  post_as_id_c  and  new_anon_status_c  non-null\")\n     if (sameAnonId.isDefined) {\n-      Some(WhichAnon.SameAsBefore(sameAnonId.get))\n+      Some(WhichAliasId.SameAnon(sameAnonId.get))\n     }\n     else if (newAnonStatus.isDefined) {\n       val anonStatus = newAnonStatus.get\n       if (anonStatus == AnonStatus.NotAnon) return None\n-      Some(WhichAnon.NewAnon(anonStatus))\n+      Some(WhichAliasId.LazyCreatedAnon(anonStatus))\n     }\n     else {\n       None"
    },
    {
      "sha": "62e8d27f85e96889ffb55479e24f8051b34b3342",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/PostsSiteDaoMixin.scala",
      "status": "modified",
      "additions": 37,
      "deletions": 7,
      "changes": 44,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPostsSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPostsSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPostsSiteDaoMixin.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1291,30 +1291,60 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n       case vote: PostVote =>\n         insertPostActionImpl(\n               postId = vote.uniqueId, pageId = vote.pageId, postNr = vote.postNr,\n-          actionType = vote.voteType, doerId = vote.doerId, doneAt = vote.doneAt)\n+              actionType = vote.voteType, doerId = vote.doerId, doneAt = vote.doneAt,\n+              manyOk = false)\n       case flag: PostFlag =>\n         insertPostActionImpl(\n               postId = flag.uniqueId, pageId = flag.pageId, postNr = flag.postNr,\n-          actionType = flag.flagType, doerId = flag.doerId, doneAt = flag.doneAt)\n+              actionType = flag.flagType, doerId = flag.doerId, doneAt = flag.doneAt,\n+              manyOk = true)\n       case rel: PatNodeRel[_] =>\n         // This covers owner-of  (or will owner-of be in pat_node_multi_rels_t?),\n         // author-of and assigned-to.\n         // (The other approach: PostVote and PostFlag, above, is deprecated.)\n         insertPostActionImpl(\n               postId = rel.uniqueId, pageId = rel.pageId, postNr = rel.postNr,\n-              actionType = rel.relType, doerId = rel.fromPatId, doneAt = rel.addedAt)\n+              actionType = rel.relType, doerId = rel.fromPatId, doneAt = rel.addedAt,\n+              manyOk = false)\n     }\n   }\n \n \n   private def insertPostActionImpl(postId: PostId, pageId: PageId, postNr: PostNr,\n-        actionType: PostActionType, doerId: PatIds, doneAt: When) {\n-    val statement = \"\"\"\n+        actionType: PostActionType, doerId: PatIds, doneAt: When, manyOk: Bo) {\n+\n+    val subTypeOne: i32 = 1\n+\n+    // Has the same person done this already (e.g. voted), using another persona?\n+    if (!manyOk) {\n+      // Let's run a `select`, so we'll know for sure what's wrong. If we instead\n+      // use `insert into ... where not exists (...)`, we can't know if 0 updated rows\n+      // is because of duplicated actions, or a SQL query or values bug.\n+      TESTS_MISSING // TyTALIVOTES\n+      val query = s\"\"\"\n+          select * from post_actions3\n+          where  site_id = ?\n+              and  to_post_id_c = ?\n+              and  rel_type_c = ?\n+              and  (from_pat_id_c = ?  or  from_true_id_c = ?)\n+              and  sub_type_c = $subTypeOne\n+              -- Let's skip, for now — otherwise might run into conflicts, if\n+              -- undoing the deletion of a vote?\n+              -- and  deleted_at is null\n+          limit 1 \"\"\"\n+      val values = List(siteId.asAnyRef, postId.asAnyRef, toActionTypeInt(actionType),\n+            doerId.trueId.asAnyRef, doerId.trueId.asAnyRef)\n+      runQueryFindMany(query, values, rs => {\n+        throw DbDao.DuplicateVoteException\n+      })\n+    }\n+\n+    val statement = s\"\"\"\n       insert into post_actions3(site_id, to_post_id_c, page_id, post_nr, rel_type_c,\n           from_pat_id_c, from_true_id_c,\n           created_at, sub_type_c)\n-      values (?, ?, ?, ?, ?, ?, ?, ?, 1)\n-      \"\"\"\n+      values (?, ?, ?, ?, ?, ?, ?, ?, $subTypeOne) \"\"\"\n+\n     val values = List[AnyRef](siteId.asAnyRef, postId.asAnyRef, pageId, postNr.asAnyRef,\n           toActionTypeInt(actionType), doerId.pubId.asAnyRef,\n           doerId.anyTrueId.orNullInt32, doneAt.asTimestamp)"
    },
    {
      "sha": "cf11a4a6373957533155b2a43469043db270809c",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/RdbUtil.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FRdbUtil.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FRdbUtil.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FRdbUtil.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -290,7 +290,7 @@ object RdbUtil {\n \n     def createdAt = getWhen(rs, \"u_created_at\")\n     val emailNotfPrefs = {\n-      if (isGuestId(userId))\n+      if (isGuestId(userId) && anonStatus.isEmpty)\n         _toEmailNotfs(rs.getString(\"g_email_notfs\"))\n       else\n         _toEmailNotfs(rs.getString(\"u_email_notfs\"))\n@@ -313,8 +313,7 @@ object RdbUtil {\n           createdAt = createdAt,\n           anonForPatId = getInt32(rs, \"u_true_id_c\"),\n           anonStatus = anonStatus.get,\n-          anonOnPageId = getString(rs, \"u_anon_on_page_id_st_c\"),\n-      )\n+          anonOnPageId = getString(rs, \"u_anon_on_page_id_st_c\"))\n     }\n     else if (isGuestId(userId)) {\n       Guest("
    },
    {
      "sha": "46d9670a89f85c7cb53ebde6e75a6b2a3f71f18e",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/UserSiteDaoMixin.scala",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FUserSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FUserSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FUserSiteDaoMixin.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -617,6 +617,21 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n   }\n \n \n+  def loadAnyAnon(userId: UserId, pageId: PageId, anonStatus: AnonStatus): Opt[Anonym] = {\n+    val query = s\"\"\"\n+          select $UserSelectListItemsNoGuests\n+          from users3 u\n+          where site_id = ?\n+            and true_id_c = ?\n+            and anon_on_page_id_st_c = ?\n+            and anonym_status_c = ? \"\"\"\n+    val values = List(siteId.asAnyRef, userId.asAnyRef, pageId, anonStatus.toInt.asAnyRef)\n+    // One or none: Should be at most [one_anon_per_page] of the same type (anon status).\n+    runQueryFindOneOrNone(query, values, rs =>\n+          getParticipant(rs).asAnonOrThrow)\n+  }\n+\n+\n   def insertMember(user: UserInclDetails) {\n     try {\n       runUpdate(\"\"\""
    },
    {
      "sha": "f7439a2818d2abe67e58dcbaf6509870dc6a7c1f",
      "filename": "appsv/server/controllers/CloseCollapseController.scala",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FCloseCollapseController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FCloseCollapseController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FCloseCollapseController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -67,7 +67,10 @@ class CloseCollapseController @Inject()(cc: ControllerComponents, edContext: TyC\n     val pageId = (apiReq.body \\ \"pageId\").as[PageId]\n     val postNr = (apiReq.body \\ \"postNr\").as[PostNr]\n \n-    dao.changePostStatus(postNr, pageId = pageId, action, apiReq.reqrIds)\n+    ANON_UNIMPL // hide, close, collapse comment trees\n+    // Later:  SiteDao.checkAliasOrThrowForbidden\n+\n+    dao.changePostStatus(postNr, pageId = pageId, action, apiReq.reqrIds, asAlias = None)\n \n     OkSafeJson(dao.jsonMaker.postToJson2(postNr, pageId = pageId, // COULD stop including post in reply? It'd be annoying if other unrelated changes were loaded just because the post was toggled open?\n       includeUnapproved = true))"
    },
    {
      "sha": "2fdd8b627da64645d6f3e1b9c95bc3ad5dd1bf52",
      "filename": "appsv/server/controllers/CustomFormController.scala",
      "status": "modified",
      "additions": 21,
      "deletions": 9,
      "changes": 30,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FCustomFormController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FCustomFormController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FCustomFormController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -21,6 +21,7 @@ import com.debiki.core._\n import com.debiki.core.Prelude._\n import debiki._\n import debiki.EdHttp._\n+import debiki.dao.CreatePageResult\n import talkyard.server._\n import talkyard.server.authz.Authz\n import javax.inject.Inject\n@@ -52,15 +53,13 @@ class CustomFormController @Inject()(cc: ControllerComponents, edContext: TyCont\n \n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n-    // (A bit weird, here we authz with Authz.maySubmitCustomForm(), but later in\n-    // PostsDao.insertReply via Authz.mayPostReply() — but works okay.)\n     throwNoUnless(Authz.maySubmitCustomForm(\n       request.userAndLevels, dao.getGroupIdsOwnFirst(request.user),\n       pageMeta, inCategoriesRootLast = categoriesRootLast,\n       tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)),\n       \"EdE2TE4A0\")\n \n-    request.dao.insertReply(textAndHtml, pageId, Set.empty, PostType.CompletedForm,\n+    request.dao.insertReplySkipAuZ(textAndHtml, pageId, Set.empty, PostType.CompletedForm,\n         deleteDraftNr = None, request.whoOrUnknown, request.spamRelatedStuff)\n     Ok\n   }\n@@ -83,12 +82,25 @@ class CustomFormController @Inject()(cc: ControllerComponents, edContext: TyCont\n     val category = request.dao.getCategoryBySlug(categorySlug).getOrThrowBadArgument(\n         \"EsE0FYK42\", s\"No category with slug: $categorySlug\")\n \n-    val pagePath = request.dao.createPage(pageType, PageStatus.Published, Some(category.id),\n-      anyFolder = None, anySlug = None, titleSourceAndHtml, bodyTextAndHtml,\n-      showId = true, deleteDraftNr = None,\n-      request.who, request.spamRelatedStuff)\n-\n-    OkSafeJson(Json.obj(\"newPageId\" -> pagePath.pageId))\n+    val res: CreatePageResult = dao.createPageIfAuZ(\n+          pageType,\n+          PageStatus.Published,\n+          inCatId = Some(category.id),\n+          withTags = Nil,\n+          anyFolder = None,\n+          anySlug = None,\n+          title = titleSourceAndHtml,\n+          bodyTextAndHtml = bodyTextAndHtml,\n+          showId = true,\n+          deleteDraftNr = None,\n+          reqrAndCreator = request.reqrTargetSelf,\n+          spamRelReqStuff = request.spamRelatedStuff,\n+          asAlias = None,\n+          discussionIds = Set.empty,\n+          embeddingUrl = None,\n+          refId = None)\n+\n+    OkSafeJson(Json.obj(\"newPageId\" -> res.path.pageId))\n   }\n \n "
    },
    {
      "sha": "26990098d4bee61e8389de16d79954528258444b",
      "filename": "appsv/server/controllers/DebugTestController.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FDebugTestController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FDebugTestController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FDebugTestController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -95,7 +95,8 @@ class DebugTestController @Inject()(cc: ControllerComponents, edContext: TyConte\n     * endpoint, which logs it, so we'll get to know about client side errors.\n     */\n   def logBrowserErrors: Action[JsValue] = PostJsonAction(\n-        RateLimits.BrowserError, MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 10000) {\n+        RateLimits.BrowserError, MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 10000,\n+        ignoreAlias = true) {\n         request =>\n     val allErrorMessages = request.body.as[Seq[String]]\n     // If there are super many errors, perhaps all of them is the same error. Don't log too many."
    },
    {
      "sha": "3bcec4bb84caa1325ecb7f95098ae4b8e08061dc",
      "filename": "appsv/server/controllers/DraftsController.scala",
      "status": "modified",
      "additions": 28,
      "deletions": 16,
      "changes": 44,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FDraftsController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FDraftsController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FDraftsController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -41,7 +41,11 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def upsertDraft: Action[JsValue] = PostJsonAction(RateLimits.DraftSomething,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) {\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize,\n+        // We remember which persona this draft should be posted as, independently\n+        // of any current persona mode (since there's a post-as dropdown in the\n+        // editor that can be set to sth else than any current persona mode). [_See_ignoreAlias]\n+        ignoreAlias = true) {\n         request: JsonPostRequest =>\n     upsertDraftImpl(request.body, request)\n   }\n@@ -51,7 +55,9 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     */\n   def upsertDraftBeacon: Action[String] = PostTextAction(\n         RateLimits.DraftSomething,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) { request =>\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize,\n+        // _See_ignoreAlias in upsertDraft() above.\n+        ignoreAlias = true) { request =>\n     val bodyXsrfTokenRemoved = request.body.dropWhile(_ != '\\n') // [7GKW20TD]\n     val json = Json.parse(bodyXsrfTokenRemoved)\n     upsertDraftImpl(json, request)\n@@ -108,21 +114,27 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n       if (draft.isReply) {\n         val postType = draft.postType getOrDie \"TyER35SKS02GU\"\n         throwNoUnless(Authz.mayPostReply(\n-          request.theUserAndLevels, dao.getOnesGroupIds(requester),\n-          postType, pageMeta, Vector(post), dao.getAnyPrivateGroupTalkMembers(pageMeta),\n-          inCategoriesRootLast = categoriesRootLast,\n-          tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)), \"EdEZBXK3M2\")\n+              request.theUserAndLevels, asAlias = None, dao.getOnesGroupIds(requester),\n+              postType, pageMeta, Vector(post), dao.getAnyPrivateGroupTalkMembers(pageMeta),\n+              inCategoriesRootLast = categoriesRootLast,\n+              tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)), \"EdEZBXK3M2\")\n       }\n       else {\n-        val anyOtherAuthor =\n-              if (post.createdById == requester.id) None\n-              else dao.getParticipant(post.createdById)\n+        // Won't need later, when true id stored in posts3/nodes_t? [posts3_true_id]\n+        val postAuthor: Pat =\n+              if (post.createdById == requester.id) requester\n+              else dao.getParticipant(post.createdById) getOrDie \"TyE2FLU58\"\n+        val pageAuthor =\n+              if (pageMeta.authorId == requester.id) requester\n+              else dao.getTheParticipant(pageMeta.authorId)\n         throwNoUnless(Authz.mayEditPost(\n-          request.theUserAndLevels, dao.getOnesGroupIds(requester),\n-          post, otherAuthor = anyOtherAuthor, pageMeta,\n-          dao.getAnyPrivateGroupTalkMembers(pageMeta),\n-          inCategoriesRootLast = categoriesRootLast,\n-          tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)), \"TyEZBXK3M3\")\n+              request.theUserAndLevels, asAlias = None, dao.getOnesGroupIds(requester),\n+              post, postAuthor = postAuthor, pageMeta, pageAuthor = pageAuthor,\n+              dao.getAnyPrivateGroupTalkMembers(pageMeta),\n+              inCategoriesRootLast = categoriesRootLast,\n+              tooManyPermissions = dao.getPermsOnPages(categoriesRootLast),\n+              // We're just saving a draft, can choose an ok alias later if needed.\n+              ignoreAlias = true), \"TyEZBXK3M3\")\n       }\n     }\n     else {\n@@ -194,14 +206,14 @@ class DraftsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def deleteDrafts: Action[JsValue] = PostJsonAction(RateLimits.DraftSomething,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) {\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000, ignoreAlias = true) {\n         request: JsonPostRequest =>\n     deleteDraftsImpl(request.body, request)\n   }\n \n \n   def deleteDraftsBeacon: Action[String] = PostTextAction(RateLimits.DraftSomething,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) {\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000, ignoreAlias = true) {\n         request: ApiRequest[String] =>\n     val bodyXsrfTokenRemoved = request.body.dropWhile(_ != '\\n') // [7GKW20TD]\n     val json = Json.parse(bodyXsrfTokenRemoved)"
    },
    {
      "sha": "61af4e5bcc51631418ffc18bc9c495e9b1545447",
      "filename": "appsv/server/controllers/EditController.scala",
      "status": "modified",
      "additions": 47,
      "deletions": 24,
      "changes": 71,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FEditController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FEditController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FEditController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -20,6 +20,7 @@ package controllers\n import com.debiki.core._\n import com.debiki.core.Prelude._\n import debiki._\n+import debiki.dao.SiteDao\n import debiki.EdHttp._\n import debiki.JsonUtils.asJsObject\n import talkyard.server.linkpreviews.{LinkPreviewRenderer, PreviewResult, LinkPreviewProblem}\n@@ -28,6 +29,7 @@ import talkyard.server.{TyContext, TyController}\n import talkyard.server.parser\n import javax.inject.Inject\n import play.api.mvc.{Action, ControllerComponents}\n+import com.debiki.core.Prelude.JsEmptyObj2\n import play.api.libs.json._\n import EditController._\n import scala.concurrent.ExecutionContext\n@@ -142,17 +144,26 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val pageMeta = dao.getPageMeta(pageId) getOrElse throwIndistinguishableNotFound(\"EdE4JBR01\")\n     val post = dao.loadPost(pageId, postNr) getOrElse throwIndistinguishableNotFound(\"EdE0DK9WY3\")\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n-    val anyOtherAuthor =\n-          if (post.createdById == requester.id) None\n-          else dao.getParticipant(post.createdById)\n+\n+    // Won't need later, when true id stored in posts3/nodes_t? [posts3_true_id]\n+    val postAuthor: Pat =\n+          if (post.createdById == requester.id) requester\n+          else dao.getParticipant(post.createdById) getOrElse throwNotFound(\n+                  \"TyEATR0FND03\", s\"Author of post ${post.id} missing\")\n+    val pageAuthor =\n+          if (pageMeta.authorId == requester.id) requester\n+          else dao.getTheParticipant(pageMeta.authorId)\n \n     CHECK_AUTHN_STRENGTH\n \n     throwNoUnless(Authz.mayEditPost(\n-      request.theUserAndLevels, dao.getOnesGroupIds(request.theUser),\n-      post, otherAuthor = anyOtherAuthor, pageMeta, dao.getAnyPrivateGroupTalkMembers(pageMeta),\n-      inCategoriesRootLast = categoriesRootLast,\n-      tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)), \"EdEZBXKSM2\")\n+          request.theUserAndLevels, asAlias = None, dao.getOnesGroupIds(request.theUser),\n+          post, postAuthor = postAuthor, pageMeta, pageAuthor = pageAuthor,\n+          dao.getAnyPrivateGroupTalkMembers(pageMeta),\n+          inCategoriesRootLast = categoriesRootLast,\n+          tooManyPermissions = dao.getPermsOnPages(categoriesRootLast),\n+          // We're just loading the draft text\n+          ignoreAlias = true), \"EdEZBXKSM2\")\n \n     val draftLocator = DraftLocator(\n       DraftType.Edit,\n@@ -181,7 +192,7 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   /** Edits posts.\n     */\n   def edit: Action[JsValue] = PostJsonAction(RateLimits.EditPost,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) {\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize, canUseAlias = true) {\n         request: JsonPostRequest =>\n     import request.{dao, theRequester => requester}\n     val body = asJsObject(request.body, \"request body\")\n@@ -190,10 +201,10 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val anyPostId: Option[PostId] = (body \\ \"postId\").asOpt[PostId]\n     val newText = (body \\ \"text\").as[String]\n     val deleteDraftNr = (body \\ \"deleteDraftNr\").asOpt[DraftNr]\n+\n     TESTS_MISSING // Do as anon  TyTANONEDIT\n-    val doAsAnon: Opt[WhichAnon] = parser.parseWhichAnonJson(body) getOrIfBad { prob =>\n-      throwBadReq(\"TyEANONPARED\", s\"Bad anon params: $prob\")\n-    }\n+    val asAlias: Opt[WhichAliasPat] =\n+          debiki.dao.SiteDao.checkAliasOrThrowForbidden(body, requester, request.anyAliasPat)(dao)\n \n     if (postNr == PageParts.TitleNr)\n       throwForbidden(\"DwE5KEWF4\", \"Edit the title via /-/edit-title-save-settings instead\")\n@@ -219,13 +230,20 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n     CHECK_AUTHN_STRENGTH\n \n-    val anyOtherAuthor =\n-          if (post.createdById == requester.id) None\n-          else dao.getParticipant(post.createdById)\n+    // Won't need later, when true id stored in posts3/nodes_t? [posts3_true_id]\n+    val postAuthor: Pat =\n+          if (post.createdById == requester.id) requester\n+          else dao.getParticipant(post.createdById) getOrElse throwNotFound(\n+                \"TyEATR0FND05\", s\"Author of post ${post.id} missing\")\n+    val pageAuthor =\n+          if (pageMeta.authorId == requester.id) requester\n+          else dao.getTheParticipant(pageMeta.authorId)\n \n+    // [dupl_ed_perm_chk]?\n     throwNoUnless(Authz.mayEditPost(\n-      request.theUserAndLevels, dao.getOnesGroupIds(request.theUser),\n-      post, otherAuthor = anyOtherAuthor, pageMeta, dao.getAnyPrivateGroupTalkMembers(pageMeta),\n+      request.theUserAndLevels, asAlias, groupIds = dao.getOnesGroupIds(request.reqr),\n+      post, postAuthor = postAuthor, pageMeta, pageAuthor = pageAuthor,\n+      dao.getAnyPrivateGroupTalkMembers(pageMeta),\n       inCategoriesRootLast = categoriesRootLast,\n       tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)), \"EdE4JBTYE8\")\n \n@@ -241,7 +259,8 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n       followLinks = postNr == PageParts.BodyNr && pageMeta.pageType.shallFollowLinks)\n \n     request.dao.editPostIfAuth(pageId = pageId, postNr = postNr, deleteDraftNr = deleteDraftNr,\n-          request.who, request.spamRelatedStuff, newTextAndHtml, doAsAnon)\n+          request.who, // [alias_4_principal]\n+          request.spamRelatedStuff, newTextAndHtml, asAlias)\n \n     OkSafeJson(dao.jsonMaker.postToJson2(postNr = postNr, pageId = pageId,\n       includeUnapproved = true))\n@@ -358,27 +377,31 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def deletePost: Action[JsValue] = PostJsonAction(RateLimits.DeletePost,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 5000) { request =>\n-    import request.dao\n-    val pageId = (request.body \\ \"pageId\").as[PageId]\n-    val postNr = (request.body \\ \"postNr\").as[PostNr]\n-    val repliesToo = (request.body \\ \"repliesToo\").asOpt[Boolean] getOrElse false\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 5000, canUseAlias = true) { req =>\n+    import req.dao\n+    val body = asJsObject(req.body, \"Delete post request body\")\n+    val pageId = (body \\ \"pageId\").as[PageId]\n+    val postNr = (body \\ \"postNr\").as[PostNr]\n+    val repliesToo = (body \\ \"repliesToo\").asOpt[Boolean] getOrElse false\n \n     val action =\n       if (repliesToo) PostStatusAction.DeleteTree\n       else PostStatusAction.DeletePost(clearFlags = false)\n \n     CHECK_AUTHN_STRENGTH\n \n-    val result = dao.changePostStatus(postNr, pageId = pageId, action, request.reqrIds)\n+    val asAlias = SiteDao.checkAliasOrThrowForbidden(\n+          body, req.reqr, req.anyAliasPat, mayCreateAnon = false)(dao)\n+\n+    val result = dao.changePostStatus(postNr, pageId = pageId, action, req.reqrIds, asAlias)\n \n     OkSafeJson(Json.obj(\n       \"answerGotDeleted\" -> result.answerGotDeleted,\n       \"deletedPost\" ->\n         // COULD: don't include post in reply? It'd be annoying if other unrelated changes\n         // were loaded just because the post was toggled open? [5GKU0234]\n         dao.jsonMaker.postToJson2(\n-          postNr = postNr, pageId = pageId, includeUnapproved = request.theUser.isStaff)))\n+          postNr = postNr, pageId = pageId, includeUnapproved = req.theUser.isStaff)))\n   }\n \n "
    },
    {
      "sha": "4a30cd8bc24497b95cd3826c16751f2ad824a486",
      "filename": "appsv/server/controllers/ForumController.scala",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FForumController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FForumController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FForumController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -118,7 +118,10 @@ class ForumController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  def saveCategory: Action[JsValue] = AdminPostJsonAction(maxBytes = 5000) { request =>\n+  def saveCategory: Action[JsValue] = AdminPostJsonAction(maxBytes = 5000,\n+        // It's annoying if, when edit anonymity settings, one needs to enter Self mode.\n+        // And feels pretty obvious that one isn't editing the category settings anonymously.\n+        ignoreAlias = true) { request =>\n     BUG // fairly harmless in this case: The lost update bug.\n \n     import request.{dao, body, requester}"
    },
    {
      "sha": "e381690c685ea8f227089ef21842a1a34d02f49e",
      "filename": "appsv/server/controllers/PageController.scala",
      "status": "modified",
      "additions": 76,
      "deletions": 60,
      "changes": 136,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FPageController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FPageController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FPageController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -20,6 +20,7 @@ package controllers\n import com.debiki.core._\n import com.debiki.core.Prelude._\n import debiki._\n+import debiki.dao.CreatePageResult\n import debiki.EdHttp._\n import debiki.JsonUtils._\n import debiki.dao.SiteDao\n@@ -41,7 +42,9 @@ class PageController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n   import context.security.throwNoUnless\n \n-  def createPage: Action[JsValue] = PostJsonAction(RateLimits.CreateTopic, maxBytes = 20 * 1000) {\n+\n+  def createPage: Action[JsValue] = PostJsonAction(\n+        RateLimits.CreateTopic, maxBytes = 20 * 1000, canUseAlias = true) {\n         request =>\n     import request.{dao, theRequester => requester}\n     // Similar to Do API with CreatePageParams. [create_page]\n@@ -60,15 +63,9 @@ class PageController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val bodyText = (body \\ \"pageBody\").as[String]\n     val showId = (body \\ \"showId\").asOpt[Boolean].getOrElse(true)\n     val deleteDraftNr = (body \\ \"deleteDraftNr\").asOpt[DraftNr]\n-    val doAsAnon: Opt[WhichAnon] = parser.parseWhichAnonJson(body) getOrIfBad { prob =>\n-      throwBadReq(\"TyEANONPARCRPG\", s\"Bad anon params: $prob\")\n-    }\n-    val doAsNewAnon: Opt[WhichAnon.NewAnon] = doAsAnon map {\n-      case _new: WhichAnon.NewAnon => _new\n-      case _: WhichAnon.SameAsBefore => throwBadReq(\"TyE5MWE2J8\", o\"\"\"Cannot keep\n-            reusing an old anonym, when creating a new page. Anonyms are per page.\"\"\")\n-    }\n-    // val anonStatus = parseOptInt32(body, \"anonStatus\").flatMap(AnonStatus.fromInt)\n+    val asAlias: Opt[WhichAliasPat] =\n+            SiteDao.checkAliasOrThrowForbidden(body, requester, request.anyAliasPat,\n+                mayReuseAnon = false)(dao)\n \n     val postRenderSettings = dao.makePostRenderSettings(pageRole)\n     val bodyTextAndHtml = dao.textAndHtmlMaker.forBodyOrComment(bodyText,\n@@ -91,20 +88,25 @@ class PageController @Inject()(cc: ControllerComponents, edContext: TyContext)\n       throwForbidden(\"DwE8GKE4\", \"No category specified\")\n     }\n \n-    val categoriesRootLast = dao.getAncestorCategoriesRootLast(anyCategoryId)\n-\n-    throwNoUnless(Authz.mayCreatePage(  // [dupl_api_perm_check]  use createPageIfAuZ() instead CLEAN_UP\n-      request.theUserAndLevels, dao.getOnesGroupIds(request.theUser),\n-      pageRole, PostType.Normal, pinWhere = None, anySlug = anySlug, anyFolder = anyFolder,\n-      inCategoriesRootLast = categoriesRootLast,\n-      tooManyPermissions = dao.getPermsOnPages(categories = categoriesRootLast)),\n-      \"EdE5KW20A\")\n-\n-    val pagePath = dao.createPage(pageRole, pageStatus, anyCategoryId, anyFolder,\n-          anySlug, titleSourceAndHtml, bodyTextAndHtml, showId, deleteDraftNr = deleteDraftNr,\n-          request.who, request.spamRelatedStuff, doAsAnon = doAsNewAnon)\n-\n-    OkSafeJson(Json.obj(\"newPageId\" -> pagePath.pageId))\n+    val res: CreatePageResult = dao.createPageIfAuZ(\n+          pageRole,\n+          pageStatus,\n+          inCatId = anyCategoryId,\n+          withTags = Nil, // later\n+          anyFolder = anyFolder,\n+          anySlug = anySlug,\n+          title = titleSourceAndHtml,\n+          bodyTextAndHtml = bodyTextAndHtml,\n+          showId = showId,\n+          deleteDraftNr = deleteDraftNr,\n+          reqrAndCreator = request.reqrTargetSelf, // [alias_4_principal]\n+          spamRelReqStuff = request.spamRelatedStuff,\n+          asAlias = asAlias,\n+          discussionIds = Set.empty,\n+          embeddingUrl = None,\n+          refId = None)\n+\n+    OkSafeJson(Json.obj(\"newPageId\" -> res.path.pageId))\n   }\n \n \n@@ -265,61 +267,75 @@ class PageController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   */\n \n \n-  def acceptAnswer: Action[JsValue] = PostJsonAction(RateLimits.TogglePage, maxBytes = 100) {\n-        request =>\n-    val pageId = (request.body \\ \"pageId\").as[PageId]\n-    val postUniqueId = (request.body \\ \"postId\").as[PostId]   // id not nr\n-\n-    // DO_AS_ALIAS !\n-    ANON_UNIMPL /* If created a page as anon, would accept it as anon too?  [anon_pages] So need:\n-    val doAsAnon: Opt[WhichAnon.SameAsBefore] = parser.parseWhichAnonJson(body) ...\n-            case _new: WhichAnon.NewAnon => throwBadReq(..., o\"\"\"Cannot create\n-            a new anonym, when accepting an answer. Should instead use the anonym\n-            that posted the page in the first place.\"\"\")  */\n+  def acceptAnswer: Action[JsValue] = PostJsonAction(RateLimits.TogglePage, maxBytes = 100,\n+        canUseAlias = true) { request =>\n+    import request.{dao, reqr}\n+    val body = asJsObject(request.body, \"acceptAnswer request body\")\n+    val pageId = parseSt(body, \"pageId\")\n+    val postId = parseInt32(body, \"postId\")   // id not nr\n+    val asAlias: Opt[WhichAliasPat] =\n+          SiteDao.checkAliasOrThrowForbidden(body, reqr, request.anyAliasPat,\n+                mayCreateAnon = false)(dao)\n \n     val acceptedAt: Option[ju.Date] = request.dao.ifAuthAcceptAnswer(\n-          pageId, postUniqueId, request.theReqerTrueId, request.theBrowserIdData)\n+          pageId, postId, request.theReqrTargetSelf, // [alias_4_principal]\n+          request.theBrowserIdData, asAlias)\n     OkSafeJsValue(JsLongOrNull(acceptedAt.map(_.getTime)))\n   }\n \n \n-  def unacceptAnswer: Action[JsValue] = PostJsonAction(RateLimits.TogglePage, maxBytes = 100) {\n-        request =>\n-    // DO_AS_ALIAS !\n-    ANON_UNIMPL // Need:  doAsAnon: Opt[WhichAnon.SameAsBefore] ?   [anon_pages]\n-    val body = asJsObject(request.body, \"Page-closed request body\")\n+  def unacceptAnswer: Action[JsValue] = PostJsonAction(RateLimits.TogglePage, maxBytes = 100,\n+        canUseAlias = true) { request =>\n+    import request.{dao, reqr}\n+    val body = asJsObject(request.body, \"unacceptAnswer request body\")\n     val pageId = parseSt(body, \"pageId\")\n-    val asAlias = parser.parseDoAsAliasJsonOrThrow(body)\n-    request.dao.ifAuthUnacceptAnswer(pageId, request.theReqerTrueId, request.theBrowserIdData)\n+    val asAlias: Opt[WhichAliasPat] =\n+          SiteDao.checkAliasOrThrowForbidden(body, reqr, request.anyAliasPat,\n+              mayCreateAnon = false)(dao)\n+\n+    dao.ifAuthUnacceptAnswer(\n+            pageId, request.theReqrTargetSelf, // [alias_4_principal]\n+            request.theBrowserIdData, asAlias)\n     Ok\n   }\n \n \n-  def togglePageClosed: Action[JsValue] = PostJsonAction(RateLimits.TogglePage, maxBytes = 100) {\n-        request =>\n+  def togglePageClosed: Action[JsValue] = PostJsonAction(RateLimits.TogglePage, maxBytes = 100,\n+          canUseAlias = true) { request =>\n+    import request.{dao, reqr}\n     val body = asJsObject(request.body, \"Page-closed request body\")\n     val pageId = parseSt(body, \"pageId\")\n-    val asAlias = parser.parseDoAsAliasJsonOrThrow(body)\n-    val closedAt: Option[ju.Date] = request.dao.ifAuthTogglePageClosed(\n-          pageId, request.reqrIds, asAlias)\n-    TESTS_MISSING // DO_AS_ALIAS\n-    //ANON_UNIPL // Need:  doAsAnon: Opt[WhichAnon.SameAsBefore] ?   [anon_pages]\n+    val asAlias: Opt[WhichAliasPat] =\n+          SiteDao.checkAliasOrThrowForbidden(body, reqr, request.anyAliasPat,\n+              mayCreateAnon = false)(dao)\n+\n+    val closedAt: Opt[ju.Date] =\n+          dao.ifAuthTogglePageClosed(pageId, request.reqrIds, asAlias) // [alias_4_principal]\n+\n     OkSafeJsValue(JsLongOrNull(closedAt.map(_.getTime)))\n   }\n \n+\n   def deletePages: Action[JsValue] = PostJsonAction(\n-          RateLimits.TogglePage, maxBytes = 1000) { request =>\n-    val pageIds = (request.body \\ \"pageIds\").as[Seq[PageId]]\n-    ANON_UNIMPL // ! Need:  doAsAnon: Opt[WhichAnon.SameAsBefore] ?   [anon_pages]\n-    request.dao.deletePagesIfAuth(pageIds, request.reqrIds, undelete = false)\n+          RateLimits.TogglePage, maxBytes = 1000, canUseAlias = true) { req =>\n+    import req.dao\n+    val body = asJsObject(req.body, \"Delete pages request body\")\n+    val pageIds = (body \\ \"pageIds\").as[Seq[PageId]]\n+    val asAlias = SiteDao.checkAliasOrThrowForbidden(\n+          body, req.reqr, req.anyAliasPat, mayCreateAnon = false)(dao)\n+    dao.deletePagesIfAuth(pageIds, req.reqrIds, asAlias, undelete = false)\n     Ok\n   }\n \n+\n   def undeletePages: Action[JsValue] = PostJsonAction(\n-          RateLimits.TogglePage, maxBytes = 1000) { request =>\n-    val pageIds = (request.body \\ \"pageIds\").as[Seq[PageId]]\n-    ANON_UNIMPL // ! Need:  doAsAnon: Opt[WhichAnon.SameAsBefore] ?   [anon_pages]\n-    request.dao.deletePagesIfAuth(pageIds, request.reqrIds, undelete = true)\n+          RateLimits.TogglePage, maxBytes = 1000, canUseAlias = true) { req =>\n+    import req.dao\n+    val body = asJsObject(req.body, \"Undelete pages request body\")\n+    val pageIds = (body \\ \"pageIds\").as[Seq[PageId]]\n+    val asAlias = SiteDao.checkAliasOrThrowForbidden(\n+          body, req.reqr, req.anyAliasPat, mayCreateAnon = false)(dao)\n+    dao.deletePagesIfAuth(pageIds, req.reqrIds, asAlias, undelete = true)\n     Ok\n   }\n \n@@ -328,7 +344,7 @@ class PageController @Inject()(cc: ControllerComponents, edContext: TyContext)\n         request =>\n     val pageId = (request.body \\ \"pageId\").as[PageId]\n     val userIds = (request.body \\ \"userIds\").as[Set[UserId]]\n-    // Later, need:  doAsAnon: Opt[WhichAnon.SameAsBefore] ?  [anon_priv_msgs]\n+    // Later, also:  SiteDao.checkAliasOrThrowForbidden ?  [anon_priv_msgs]\n     request.dao.addUsersToPage(userIds, pageId, request.who)\n     Ok\n   }\n@@ -338,7 +354,7 @@ class PageController @Inject()(cc: ControllerComponents, edContext: TyContext)\n         maxBytes = 100) { request =>\n     val pageId = (request.body \\ \"pageId\").as[PageId]\n     val userIds = (request.body \\ \"userIds\").as[Set[UserId]]\n-    // Later, need:  doAsAnon: Opt[WhichAnon.SameAsBefore] ?  [anon_priv_msgs]\n+    // Later, also: SiteDao.checkAliasOrThrowForbidden ?  [anon_priv_msgs]\n     request.dao.removeUsersFromPage(userIds, pageId, request.who)\n     Ok\n   }"
    },
    {
      "sha": "c3052a43b9e3f4ed5fc240faa08e320b656d43a0",
      "filename": "appsv/server/controllers/PageTitleSettingsController.scala",
      "status": "modified",
      "additions": 42,
      "deletions": 73,
      "changes": 115,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FPageTitleSettingsController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FPageTitleSettingsController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FPageTitleSettingsController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -38,16 +38,17 @@ import talkyard.server.JsX.{JsPageMeta, JsStringOrNull}\n   * which layout to use, <html><head><title> and description.\n   *\n   * MOVE to PageController, right?  It's confusing to have 2 controllers that do\n-  * almost the same things.\n+  * almost the same things.  [pg_ctrl_dao]\n   */\n class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   extends TyController(cc, edContext) {\n \n   import context.security.{throwNoUnless, throwIndistinguishableNotFound}\n \n-  def editTitleSaveSettings: Action[JsValue] = PostJsonAction(RateLimits.EditPost, maxBytes = 2000) {\n+  def editTitleSaveSettings: Action[JsValue] = PostJsonAction(RateLimits.EditPost,\n+          maxBytes = 2000, canUseAlias = true) {\n         request: JsonPostRequest =>\n-    import request.{body, dao, theRequester => trueEditor}\n+    import request.{body, dao, theRequester => trueEditor} // [alias_4_principal]\n \n     val pageJo = asJsObject(request.body, \"the request body\")\n     CLEAN_UP // use JsonUtils below, not '\\'.\n@@ -91,8 +92,10 @@ class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext:\n       PageDoingStatus.fromInt(value) getOrElse throwBadArgument(\"TyE2ABKR04\", \"doingStatus\")\n     }\n \n-    TESTS_MISSING // & ren to  doAsAlias\n-    val doAsAnon = parser.parseDoAsAliasJsonOrThrow(pageJo)\n+    TESTS_MISSING // TyTALIALTERPG\n+    val asAlias: Opt[WhichAliasPat] =\n+          SiteDao.checkAliasOrThrowForbidden(pageJo, trueEditor, request.anyAliasPat,\n+              mayCreateAnon = false)(dao)\n \n     val hasManuallyEditedSlug = anySlug.exists(slug => {\n       // The user interface currently makes impossible to post a new slug, without a page title.\n@@ -116,25 +119,31 @@ class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext:\n     val changesOnlyTypeOrStatus =\n           // If we got the page id (required, always present) and exactly one more field, ...\n           (pageJo.value.size == 2\n-                // Except for the doAsAnon field which is off-topic\n+                // Except for the asAlias field which is off-topic\n                 || pageJo.value.size == 3 && pageJo.\\(parser.DoAsAnonFieldName).isDefined\n                 )  &&\n           // ... and it is the page type or doing status, then, pat is trying to change,\n           // well, only the type or doing status.  Nothing else.\n           (anyNewDoingStatus.isDefined || anyNewRole.isDefined)\n \n-    val anyOtherAuthor =\n-          if (oldMeta.authorId == trueEditor.id) None\n-          else Some(dao.getTheParticipant(oldMeta.authorId))\n+    // Above, mayCreateAnon = false, so any anonym would already exist.\n+    dieIf(asAlias.exists(_.anyPat.isEmpty), \"TyE5FML28PW\")\n+\n+    val pageAuthor =\n+          if (oldMeta.authorId == trueEditor.id) trueEditor\n+          else dao.getTheParticipant(oldMeta.authorId)\n \n     // AuthZ check 1/3:\n+    // (Similar to throwIfMayNotAlterPage(): Authz.mayEditPage() is inlined here\n+    // so we can reuse some arguments, e.g. requestersGroupIds.)\n     // Could skip authz check 2/3 below: [.dbl_auz] ?\n     val oldCatsRootLast = dao.getAncestorCategoriesRootLast(oldMeta.categoryId)\n     val requestersGroupIds = dao.getOnesGroupIds(trueEditor)\n     throwNoUnless(Authz.mayEditPage(\n           pageMeta = oldMeta,\n           pat = trueEditor,\n-          otherAuthor = anyOtherAuthor,\n+          asAlias = asAlias,\n+          pageAuthor = pageAuthor,\n           groupIds = requestersGroupIds,\n           pageMembers = dao.getAnyPrivateGroupTalkMembers(oldMeta),\n           catsRootLast = oldCatsRootLast,\n@@ -162,9 +171,11 @@ class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext:\n     throwForbiddenIf(forumViewChanged && pageTypeAfter != PageType.Forum,\n           \"TyE0FORMPGE\", \"Can only edit these properties for forum pages\")\n \n-    // [choose_alias] [deanon_risk]\n-    if (!trueEditor.isStaff || doAsAnon.isDefined) {\n-      val who = (trueEditor.isStaff && doAsAnon.isDefined) ? \"Anonyms\" | \"You\"\n+    // Would be confusing if anyone could change the comment order.\n+    // If anonyms could do things only mods may do, others could guess\n+    // that the anon is a mod. [deanon_risk]\n+    if (!trueEditor.isStaff || asAlias.isDefined) {\n+      val who = trueEditor.isStaff ? \"Anonyms\" | \"You\"\n       throwForbiddenIf(\n           anyComtOrder.isSomethingButNot(oldMeta.comtOrder),\n           \"TyEXCMTORD\", s\"$who may not change the comment sort order\")\n@@ -174,59 +185,10 @@ class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext:\n           \"TyEXCMTNST\", s\"$who may not change the comment nesting max depth\")\n     }\n \n-    val isEditorsAnonsPage = doAsAnon.exists(_.anySameAnonId.is(oldMeta.authorId))\n-    val isEditorsOwnPage = trueEditor.id == oldMeta.authorId\n-\n-    if (doAsAnon.isDefined) {\n-      if (isEditorsAnonsPage) {\n-        // Fine. If you create a page anonymously, you can close/reopen it,\n-        // mark it as solved, etc, using the same anonym.\n-      }\n-      else if (isEditorsOwnPage) {\n-        // It's the trueEditor's page, but han created it using hans real account.\n-        // Disallow, so others won't know that `doAsAnon` is the same person.\n-        throwForbidden(\"TyECHPGUSINGALIAS\",\n-              s\"You cannot alter this page as anonym ${doAsAnon\n-              } — you created it using your real account, ${trueEditor.nameParaId}\")\n-      }\n-      else if (anyOtherAuthor.exists(_.trueId2.trueId == trueEditor.id)) {\n-        // It's the trueEditor's page, but han created it using _another_ anonym\n-        // or pseudonym.  `doAsAnon` is the wrong anonym. Disallow, so others can't\n-        // know that the two aliases (anyOtherAuthor and doAsAnon) are in fact\n-        // the same person. [deanon_risk]\n-        throwForbidden(\"TyECHPGWRONGALIAS\",\n-              s\"You cannot alter this page as anonym ${doAsAnon\n-              } — you created it as ${anyOtherAuthor.get.nameParaId}\")\n-      }\n-      else {\n-        // This must be beore the `isStaff` test — anonymous moderation [anon_mods] is\n-        // not yet suppored. (If the same anon was reused, others might see that\n-        // that anon is a moderator.)\n-        throwForbidden(\"TyECHOTRPGSANO\",\n-              \"You cannot alter other people's pages anonymously\" + (\n-                  trueEditor.isStaffOrCoreMember ?  // [deanon_risk]\n-                        \" even if you're a moderator or core member\" | \"\"))\n-      }\n-    }\n-    else if (trueEditor.isStaff || isEditorsOwnPage) {\n-      // Fine. Moderators can edit pages they have access too, and others can\n-      // edit pages they created themselves.\n-      // (Maybe later there will be more [granular_perms].)\n-    }\n-    else if (changesOnlyTypeOrStatus && trueEditor.isStaffOrCoreMember) {\n-      // Fine: Core members can alter page type, or mark pages as solved or closed.\n-    }\n-    else {\n-      throwForbidden(\"TyECHOTRPGS\", \"You may not alter other people's pages\")\n-    }\n-\n-    // If anonyms or pseudonyms could do the things in this block (e.g. change page slug\n-    // or folder, change layout),  if the true user is an admin,  then,\n-    // others could guess who the anonym is.  [deanon_risk] [choose_alias]\n-    // (Since probably there are just a few admins, and if there might be some meta message\n-    // about what was done by the anonym, who must thus be one of the admins.)\n-    if (!trueEditor.isAdmin || doAsAnon.isDefined) {\n-      val prefix = doAsAnon.isDefined ? \"Anonyms cannot\" | \"Only admins can\"\n+    // If anonyms or pseudonyms could do things only admins can do (e.g. change page slug\n+    // or folder, change layout), others could guess that the anon is an admin.  [deanon_risk]\n+    if (!trueEditor.isAdmin || asAlias.isDefined) {\n+      val prefix = trueEditor.isAdmin ? \"Anonyms cannot\" | \"Only admins can\"\n \n       // Forum page URL.\n       throwForbiddenIf(hasManuallyEditedSlug,\n@@ -299,7 +261,8 @@ class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext:\n       // move it, in a separate step.)\n       val newTextAndHtml = dao.textAndHtmlMaker.forTitle(newTitle)\n       request.dao.editPostIfAuth(pageId = pageId, postNr = PageParts.TitleNr, deleteDraftNr = None,\n-            request.who, request.spamRelatedStuff, newTextAndHtml, doAsAnon)\n+            request.who, // [alias_4_principal]\n+            request.spamRelatedStuff, newTextAndHtml, asAlias)\n     }}\n \n     // Load old section page id before changing it.\n@@ -336,17 +299,23 @@ class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext:\n     // allow that, but only if no *additional* people then gets to see the page.\n     // (But if fewer, that's ok.) — There'll also be [alterPage] maybe move page permissions.\n     //\n-    // [deanon_risk] If the page author, or hans anonym, appear in a page changelog, then,\n-    // others can guess they're the same? (If only few people have access to the destination\n-    // category).\n+    // COULD check if may use alias in the new cat, so cannot move a page  [move_anon_page]\n+    // with anon comments to a category where anon comments are disabled?  Let's wait.\n+    //\n+    // [deanon_risk] If few people have access to both the old and new category, then, it's\n+    // simpler for others to guess who a [pseudonym who moves the page] is.  [pseudonyms_later]\n+    // And if one could move one's anonymous page using one's true id (but one cannot,\n+    // see [true_0_ed_alias]), then, others could also guess that the anon and oneself is\n+    // the same (otherwise, why would one have been able to move it (unless is e.g. a mod)).\n     //\n     if (newMeta.categoryId != oldMeta.categoryId) {\n+      // (Similar to throwIfMayNotAlterPage().)\n       val newCatsRootLast = dao.getAncestorCategoriesRootLast(newMeta.categoryId)\n       throwNoUnless(Authz.mayEditPage(\n             pageMeta = newMeta,\n             pat = trueEditor,\n-            // asAlias =  — Check if [may_use_alias] in the new category   DO_AS_ALIAS\n-            otherAuthor = anyOtherAuthor,\n+            asAlias = asAlias,\n+            pageAuthor = pageAuthor,\n             groupIds = requestersGroupIds,\n             pageMembers = dao.getAnyPrivateGroupTalkMembers(newMeta),\n             catsRootLast = newCatsRootLast,\n@@ -360,7 +329,7 @@ class PageTitleSettingsController @Inject()(cc: ControllerComponents, edContext:\n       tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n \n       val aliasOrTrue: Pat = SiteDao.getAliasOrTruePat(truePat = trueEditor, pageId = pageId,\n-            doAsAnon, mayCreateAnon = false)(tx, IfBadAbortReq)\n+            asAlias, mayCreateAnon = false)(tx, IfBadAbortReq)\n \n       if (addsNewDoingStatusMetaPost) {\n         dao.addMetaMessage(aliasOrTrue, s\" marked this topic as ${newMeta.doingStatus}\", pageId, tx)"
    },
    {
      "sha": "8f99004f0b4082027c02e42c1b74a3cc08536f96",
      "filename": "appsv/server/controllers/ReplyController.scala",
      "status": "modified",
      "additions": 24,
      "deletions": 13,
      "changes": 37,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FReplyController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FReplyController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FReplyController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -22,6 +22,7 @@ import com.debiki.core.Prelude._\n import debiki._\n import debiki.EdHttp._\n import debiki.JsonUtils.asJsObject\n+import debiki.dao.CreatePageResult\n import talkyard.server.{TyContext, TyController}\n import talkyard.server.authz.Authz\n import talkyard.server.http._\n@@ -43,7 +44,7 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def handleReply: Action[JsValue] = PostJsonAction(RateLimits.PostReply,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize) {\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize, canUseAlias = true) {\n         request: JsonPostRequest =>\n     import request.{dao, theRequester => requester}\n     val body = asJsObject(request.body, \"request body\")\n@@ -57,9 +58,9 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val postType = PostType.fromInt((body \\ \"postType\").as[Int]) getOrElse throwBadReq(\n       \"DwE6KG4\", \"Bad post type\")\n     val deleteDraftNr = (body \\ \"deleteDraftNr\").asOpt[DraftNr]\n-    val doAsAnon: Opt[WhichAnon] = parser.parseWhichAnonJson(body) getOrIfBad { prob =>\n-      throwBadReq(\"TyEANONPARRE\", s\"Bad anon params: $prob\")\n-    }\n+\n+    val asAlias: Opt[WhichAliasPat] =\n+          debiki.dao.SiteDao.checkAliasOrThrowForbidden(body, requester, request.anyAliasPat)(dao)\n \n     throwBadRequestIf(text.isEmpty, \"EdE85FK03\", \"Empty post\")\n     throwForbiddenIf(requester.isGroup, \"EdE4GKRSR1\", \"Groups may not reply\")\n@@ -84,7 +85,7 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n     CLEAN_UP // [dupl_re_authz_chk]  and see the REM OVE just above too, and COU LD below.\n     throwNoUnless(Authz.mayPostReply(\n-      request.theUserAndLevels, dao.getOnesGroupIds(request.theUser),\n+      request.theUserAndLevels, asAlias, dao.getOnesGroupIds(request.theUser),\n       postType, pageMeta, replyToPosts, dao.getAnyPrivateGroupTalkMembers(pageMeta),\n       inCategoriesRootLast = categoriesRootLast,\n       tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)),\n@@ -103,8 +104,9 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n       embeddedOriginOrEmpty = postRenderSettings.embeddedOriginOrEmpty,\n       followLinks = false)\n \n-    val result = dao.insertReply(textAndHtml, pageId = pageId, replyToPostNrs,\n-      postType, deleteDraftNr, request.who, request.spamRelatedStuff, doAsAnon)\n+    val result = dao.insertReplySkipAuZ(textAndHtml, pageId = pageId, replyToPostNrs,\n+          postType, deleteDraftNr, request.who, // [alias_4_principal]\n+          request.spamRelatedStuff, asAlias)\n \n     var responseJson: JsObject = result.storePatchJson\n     if (newEmbPage.isDefined) {\n@@ -122,6 +124,8 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val text = (body \\ \"text\").as[String].trim\n     val deleteDraftNr = (body \\ \"deleteDraftNr\").asOpt[DraftNr]\n \n+    // Not yet supported, for chat messages.\n+    // val asAlias: Opt[WhichAliasPat] = ...\n \n     throwBadRequestIf(text.isEmpty, \"EsE0WQCB\", \"Empty chat message\")\n \n@@ -132,7 +136,7 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n     throwNoUnless(Authz.mayPostReply(\n-      request.theUserAndLevels, dao.getOnesGroupIds(request.theMember),\n+      request.theUserAndLevels, asAlias = None, dao.getOnesGroupIds(request.theMember),\n       PostType.ChatMessage, pageMeta, replyToPosts, dao.getAnyPrivateGroupTalkMembers(pageMeta),\n       inCategoriesRootLast = categoriesRootLast,\n       tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)),\n@@ -336,21 +340,28 @@ object EmbeddedCommentsPageCreator {   REFACTOR; CLEAN_UP; // moe to talkyard.se\n     val pageRole = PageType.EmbeddedComments\n \n     context.security.throwNoUnless(Authz.mayCreatePage(\n-          request.theUserAndLevels, dao.getGroupIdsOwnFirst(requester),\n+          request.theUserAndLevels, asAlias = None, dao.getGroupIdsOwnFirst(requester),\n           pageRole, PostType.Normal, pinWhere = None, anySlug = slug, anyFolder = folder,\n           inCategoriesRootLast = categoriesRootLast,\n           tooManyPermissions = dao.getPermsOnPages(categories = categoriesRootLast)),\n           \"EdE7USC2R8\")\n \n     // This won't generate any new page notf — but the first *reply*, does. [new_emb_pg_notf]\n-    dao.createPage(pageRole, PageStatus.Published,\n-          anyCategoryId = Some(placeInCatId), anyFolder = slug, anySlug = folder,\n+    //\n+    // Don't use dao.createPageIfAuZ() — we don't want request.reqr to be the page author;\n+    // instead, the page is auto generated by System.\n+    //\n+    val res: CreatePageResult = dao.createPageSkipAuZ(pageRole, PageStatus.Published,\n+          anyCategoryId = Some(placeInCatId), withTags = Nil, anyFolder = folder, anySlug = slug,\n           title = TitleSourceAndHtml(s\"Comments for $embeddingUrl\"),\n           bodyTextAndHtml = dao.textAndHtmlMaker.forBodyOrComment(\n             s\"Comments for: $embeddingUrl\"),\n           showId = true, deleteDraftNr = None,  // later, will be a draft to delete? [BLGCMNT1]\n-          Who.System, request.spamRelatedStuff, discussionIds = anyDiscussionId.toSet,\n-          embeddingUrl = Some(embeddingUrl))\n+          Who.System, request.spamRelatedStuff, asAlias = None,\n+          discussionIds = anyDiscussionId.toSet,\n+          embeddingUrl = Some(embeddingUrl), extId = None)\n+\n+    res.path\n   }\n \n }"
    },
    {
      "sha": "b252126cca8089aeaca2651c144335d22bd52e72",
      "filename": "appsv/server/controllers/SearchController.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FSearchController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FSearchController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FSearchController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -55,8 +55,8 @@ class SearchController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  def doSearch(): Action[JsValue] = AsyncPostJsonAction(RateLimits.FullTextSearch, maxBytes = 1000) {\n-        request: JsonPostRequest =>\n+  def doSearch(): Action[JsValue] = AsyncPostJsonAction(RateLimits.FullTextSearch,\n+        maxBytes = 1000, ignoreAlias = true) { request: JsonPostRequest =>\n     import request.dao\n \n     val rawQuery = (request.body \\ \"rawQuery\").as[String]"
    },
    {
      "sha": "6db2ee96d3daabdd81b62182cd0fbded7037291a",
      "filename": "appsv/server/controllers/UserController.scala",
      "status": "modified",
      "additions": 36,
      "deletions": 28,
      "changes": 64,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FUserController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FUserController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FUserController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -524,7 +524,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def setPrimaryEmailAddresses: Action[JsValue] =\n-        PostJsonAction(RateLimits.AddEmailLogin, maxBytes = 300) { request =>\n+        PostJsonAction(RateLimits.AddEmailLogin, maxBytes = 300, ignoreAlias = true) { request =>\n     import request.{dao, body, theRequester => requester}\n     // SECURITY maybe send an email and verify with the old address that changing to the new is ok?\n \n@@ -552,8 +552,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  def addUserEmail: Action[JsValue] = PostJsonAction(RateLimits.AddEmailLogin, maxBytes = 300) {\n-        request =>\n+  def addUserEmail: Action[JsValue] = PostJsonAction(RateLimits.AddEmailLogin, maxBytes = 300,\n+        ignoreAlias = true) { request =>\n     import request.{dao, body, theRequester => requester}\n \n     val userId = (body \\ \"userId\").as[UserId]\n@@ -588,7 +588,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def resendEmailAddrVerifEmail: Action[JsValue] = PostJsonAction(\n-        RateLimits.ConfirmEmailAddress, maxBytes = 300) { request =>\n+        RateLimits.ConfirmEmailAddress, maxBytes = 300, ignoreAlias = true) { request =>\n \n     import request.{dao, body, theRequester => requester}\n \n@@ -730,8 +730,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  def removeUserEmail: Action[JsValue] = PostJsonAction(RateLimits.AddEmailLogin, maxBytes = 300) {\n-        request =>\n+  def removeUserEmail: Action[JsValue] = PostJsonAction(RateLimits.AddEmailLogin, maxBytes = 300,\n+        ignoreAlias = true) { request =>\n     import request.{dao, body, theRequester => requester}\n \n     val userId = (body \\ \"userId\").as[UserId]\n@@ -1013,8 +1013,17 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  def trackReadingProgress: Action[JsValue] = PostJsonAction(RateLimits.TrackReadingActivity,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) { request =>\n+  /** Ignores any [persona_mode] — the purpose is to help the true user remember what\n+    * han has read, regardless of they're anonymous or not for the moment. And others\n+    * can't access hans reading progress. [anon_read_progr]\n+    */\n+  def trackReadingProgress: Action[JsValue] = PostJsonAction(\n+        RateLimits.TrackReadingActivity,\n+        MinAuthnStrength.EmbeddingStorageSid12,\n+        maxBytes = 1000,\n+        ignoreAlias = true,\n+        ) { request =>\n+\n     import request.{dao, theRequester}\n     val readMoreResult = trackReadingProgressImpl(request, request.body)\n     val result =\n@@ -1045,7 +1054,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   /** In the browser, navigator.sendBeacon insists on sending plain text. So need this text handler.\n     */\n   def trackReadingProgressText: Action[String] = PostTextAction(RateLimits.TrackReadingActivity,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000) { request =>\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 1000, ignoreAlias = true) { request =>\n     val bodyXsrfTokenRemoved = request.body.dropWhile(_ != '\\n') // [7GKW20TD]\n     val json = Json.parse(bodyXsrfTokenRemoved)\n     trackReadingProgressImpl(request, json)\n@@ -1157,7 +1166,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def toggleTips: Action[JsValue] = UserPostJsonAction(RateLimits.TrackReadingActivity,\n-        maxBytes = 200) { request =>\n+        maxBytes = 200, ignoreAlias = true) { request =>\n     import request.{dao, body, theRequester => requester}\n     val tipsId: Opt[St] = parseOptSt(body, \"tipsId\")\n     val hide: Bo = parseBo(body, \"hide\")\n@@ -1176,22 +1185,22 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  def loadNotificationsImpl(userId: UserId, upToWhen: Option[When], request: DebikiRequest[_])\n+  private def loadNotificationsImpl(userId: UserId, upToWhen: Opt[When], req: DebikiRequest[_])\n         : mvc.Result = {\n-    val notfsAndCounts = request.dao.loadNotificationsSkipReviewTasks(userId, upToWhen, request.who)\n-    OkSafeJson(notfsAndCounts.notfsJson)\n+    val notfsAndCounts = req.dao.loadNotificationsSkipReviewTasks(userId, upToWhen, req.who)\n+    OkSafeJson(Json.obj(\"notfs\" -> notfsAndCounts.notfsJson)) // ts: NotfSListResponse\n   }\n \n \n   def markAllNotfsAsSeen(): Action[JsValue] = PostJsonAction(RateLimits.MarkNotfAsSeen,\n-        maxBytes = 200) { request =>\n+        maxBytes = 200, ignoreAlias = true) { request =>\n     request.dao.markAllNotfsAsSeen(request.theUserId)\n     loadNotificationsImpl(request.theUserId, upToWhen = None, request)\n   }\n \n \n   def markNotificationAsSeen(): Action[JsValue] = PostJsonAction(RateLimits.MarkNotfAsSeen,\n-        maxBytes = 200) { request =>\n+        maxBytes = 200, ignoreAlias = true) { request =>\n     import request.{dao, theRequesterId}\n     val notfId = (request.body \\ \"notfId\").as[NotificationId]\n     dao.markNotificationAsSeen(theRequesterId, notfId)\n@@ -1200,7 +1209,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def snoozeNotifications(): Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n-        maxBytes = 200) { request =>\n+        maxBytes = 200, ignoreAlias = true) { request =>\n     import request.{dao, theRequesterId}\n     val untilWhen: Option[When] =\n           (request.body \\ \"untilMins\").as[JsValue] match {\n@@ -1215,7 +1224,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def saveContentNotfPref: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n-          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 500) { request =>\n+          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 500, ignoreAlias = true,\n+          ) { request =>\n     import request.{dao, theRequester => requester}\n     val body = request.body\n     val memberId = (body \\ \"memberId\").as[MemberId]\n@@ -1407,20 +1417,15 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n           RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     import request.{dao, requester}\n \n-    val pageMeta = dao.getPageMeta(pageId) getOrElse throwIndistinguishableNotFound(\"EdE4Z0B8P5\")\n-    val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n-\n     SECURITY // Later: skip authors of hidden / deleted / private comments.  [priv_comts]\n+    // & bookmarks, once implemented. [dont_list_bookmarkers]\n     // Or if some time in the future there will be \"hidden\" accounts  [private_pats]\n     // — someone who don't want strangers and new members to see hens profile —\n     // then, would need to exclude those accounts here.\n \n     CHECK_AUTHN_STRENGTH  // disallow if just sid part 1+2 but not embedded page\n \n-    throwNoUnless(Authz.maySeePage(\n-      pageMeta, request.user, dao.getGroupIdsOwnFirst(request.user),\n-      dao.getAnyPrivateGroupTalkMembers(pageMeta), categoriesRootLast,\n-      tooManyPermissions = dao.getPermsOnPages(categoriesRootLast)), \"EdEZBXKSM2\")\n+    dao.throwIfMayNotSeePage2(pageId, request.reqrTargetSelf)(anyTx = None)\n \n     // Also load deleted anon12345 members. Simpler, and they'll typically be very few or none. [5KKQXA4]\n     COULD // load groups too, so it'll be simpler to e.g. mention @support.\n@@ -1465,7 +1470,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   /** maxBytes = 3000 because the about text might be fairly long.\n     */\n   def saveAboutMemberPrefs: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n-        maxBytes = 3000) { request =>\n+        maxBytes = 3000, ignoreAlias = true) { request =>\n     val prefs = aboutMemberPrefsFromJson(request.body)\n     _quickThrowUnlessMayEditPrefs(prefs.userId, request.theRequester)\n     request.dao.saveAboutMemberPrefsIfAuZ(prefs, request.who)\n@@ -1478,7 +1483,10 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def saveAboutGroupPreferences: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n-        maxBytes = 3000) { request =>\n+        maxBytes = 3000,\n+        // ignoreAlias = true, — or do care? Groups != oneself, maybe some admin\n+        // might believe they'd be editing the group settings anonymously?\n+        ) { request =>\n     import request.{dao, theRequester => requester}\n     val prefs = aboutGroupPrefsFromJson(request.body)\n     if (!requester.isAdmin)\n@@ -1506,7 +1514,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def saveUiPreferences: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n-        maxBytes = 3000) { request =>\n+        maxBytes = 3000, ignoreAlias = true) { request =>\n     import request.{body, dao, theRequester => requester}\n     val memberId = (body \\ \"memberId\").as[UserId]\n     val prefs = (body \\ \"prefs\").as[JsObject]\n@@ -1578,7 +1586,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   def saveMemberPrivacyPrefs: Action[JsValue] = PostJsonAction(RateLimits.ConfigUser,\n-        maxBytes = 100) { request =>\n+        maxBytes = 100, ignoreAlias = true) { request =>\n     val userId = parseInt32(request.body, \"userId\")\n     val prefs: MemberPrivacyPrefs = JsX.memberPrivacyPrefsFromJson(request.body)\n     _quickThrowUnlessMayEditPrefs(userId, request.theRequester)"
    },
    {
      "sha": "513aa2983651dfa5406a8e34501e2aa52e1947f1",
      "filename": "appsv/server/controllers/ViewPageController.scala",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FViewPageController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FViewPageController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FViewPageController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -247,8 +247,10 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: TyContex\n   }\n \n \n+  /** Ignores any [persona_mode].  See [anon_read_progr].\n+    */\n   def markPageAsSeen(pageId: PageId): Action[JsValue] = PostJsonAction(NoRateLimits,\n-        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 2) { request =>\n+        MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 2, ignoreAlias = true) { request =>\n     CHECK_AUTHN_STRENGTH\n     request.dao.getAnyWatchbar(request.theReqerId) foreach { watchbar =>\n       val newWatchbar = watchbar.markPageAsSeen(pageId)"
    },
    {
      "sha": "fc7608ecd4820c0fd97309f0512e4f6873d085d5",
      "filename": "appsv/server/controllers/VoteController.scala",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FVoteController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fcontrollers%2FVoteController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FVoteController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -22,6 +22,7 @@ import com.debiki.core.Prelude._\n import collection.immutable\n import debiki._\n import debiki.EdHttp._\n+import debiki.dao.SiteDao\n import debiki.JsonUtils.{asJsObject, parseInt32}\n import talkyard.server.{TyContext, TyController}\n import talkyard.server.authz.Authz\n@@ -51,7 +52,7 @@ class VoteController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     *   postIdsRead: [1, 9, 53, 82]\n     */\n   def handleVotes: Action[JsValue] = PostJsonAction(RateLimits.RatePost,\n-          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 500) {\n+          MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 500, canUseAlias = true) {\n           request: JsonPostRequest =>\n     import request.{dao, theRequester => requester}\n     val body = asJsObject(request.body, \"votes request body\")\n@@ -69,9 +70,8 @@ class VoteController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val actionStr = (body \\ \"action\").as[String]\n     val postNrsReadSeq = (body \\ \"postNrsRead\").asOpt[immutable.Seq[PostNr]]\n \n-    val doAsAnon: Opt[WhichAnon] = parser.parseWhichAnonJson(body) getOrIfBad { prob =>\n-      throwBadReq(\"TyEANONPARVO\", s\"Bad anon params: $prob\")\n-    }\n+    val asAlias: Opt[WhichAliasPat] =\n+          SiteDao.checkAliasOrThrowForbidden(body, requester, request.anyAliasPat)(dao)\n \n     val postNrsRead = postNrsReadSeq.getOrElse(Nil).toSet\n \n@@ -106,7 +106,7 @@ class VoteController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n     CHECK_AUTHN_STRENGTH\n \n-    val reqrTgt = request.reqrTargetSelf.denyUnlessLoggedIn()\n+    val reqrTgt = request.reqrTargetSelf.denyUnlessLoggedIn() // [alias_4_principal]\n \n     var anyNewAnon: Opt[Anonym] = None\n \n@@ -115,7 +115,7 @@ class VoteController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     }\n     else {\n       anyNewAnon = dao.addVoteIfAuZ(pageId, postNr, voteType, reqrAndVoter = reqrTgt,\n-            voterIp = Some(request.ip), postNrsRead, doAsAnon)\n+            voterIp = Some(request.ip), postNrsRead, asAlias)\n     }\n \n     RACE // Fine, harmless."
    },
    {
      "sha": "84d617cf85fad0065c890e064f6389687c0eb424",
      "filename": "appsv/server/debiki/MailerActor.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2FMailerActor.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2FMailerActor.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2FMailerActor.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -355,7 +355,7 @@ class MailerActor(\n         emailMaybeWrongAddr.sentTo\n       }\n       else {\n-        val anyPp = emailMaybeWrongAddr.toUserId.flatMap(siteDao.getParticipant)\n+        val anyPp = emailMaybeWrongAddr.toUserId.flatMap(id => siteDao.getParticipant(id))\n         anyPp.map(_.email) getOrElse emailMaybeWrongAddr.sentTo\n       }\n "
    },
    {
      "sha": "42b05beaaacb87417129e662a0b29353a327d0c4",
      "filename": "appsv/server/debiki/ReactJson.scala",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2FReactJson.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2FReactJson.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2FReactJson.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -498,7 +498,7 @@ class JsonMaker(dao: SiteDao) {\n     val site = dao.theSite()\n     val idps = dao.getSiteCustomIdentityProviders(onlyEnabled = true)\n \n-    val jsonObj = Json.obj(\n+    var jsonObj = Json.obj(\n       \"dbgSrc\" -> \"PgToJ\",\n       // These render params need to be known client side, so the page can be rendered in exactly\n       // the same way, client side. Otherwise React can mess up the html structure, & things = broken.\n@@ -534,6 +534,16 @@ class JsonMaker(dao: SiteDao) {\n       \"tagTypesById\" -> JsObject(tagTypes.map(tt => tt.id.toString -> JsTagType(tt))),\n       \"pagesById\" -> Json.obj(page.id -> pageJsonObj))\n \n+    // If listing topics, we've set `store.topics` to the topic list (just above),\n+    // but the client also wants to know for which category we're listing topics.\n+    // (Pat might be listing topics in a sub category in the forum. Currently, the\n+    // server side renderer always lists recently active topics in *all* forum\n+    // categories though.)\n+    if (page.pageType == PageType.Forum) {\n+      devDieIf(anyCurCatId.isEmpty, \"TyE2GPS7N3\")\n+      anyCurCatId.foreach(id => jsonObj += \"listingCatId\" -> JsNumber(id))\n+    }\n+\n     val reactStoreJsonString = jsonObj.toString()\n \n     val version = CachedPageVersion("
    },
    {
      "sha": "f1df848d831de4820bf8ade8e8034b330e4a5213",
      "filename": "appsv/server/debiki/dao/CategoriesDao.scala",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FCategoriesDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FCategoriesDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FCategoriesDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -544,9 +544,14 @@ trait CategoriesDao {\n     // just because all most-recent-pages are e.g. hidden.\n     val filteredPages = pagesInclForbidden filter { page =>\n       val categories = getAncestorCategoriesRootLast(page.categoryId)\n+      val pageAuthor = getParticipant(page.meta.authorId)\n       COULD_OPTIMIZE // Do for all pages in the same cat at once?  [authz_chk_mny_pgs]\n+      COULD_OPTIMIZE // Lazy-load e.g. page author and members — usually not needed.\n+      COULD_OPTIMIZE // Don't load author — instead, compare directly with  [list_by_alias]\n+                      // posts3 & pages3.true_author_id_c / true_owner_id_c\n       val may = talkyard.server.authz.Authz.maySeePage(\n             page.meta,\n+            pageAuthor = pageAuthor.getOrDie(\"TyE402SKJF4\"),\n             user = authzCtx.requester,\n             groupIds = authzCtx.groupIdsUserIdFirst,\n             pageMembers = getAnyPrivateGroupTalkMembers(page.meta),"
    },
    {
      "sha": "2d90ec94d1e03389642c03925ae1e14e57b9f1f9",
      "filename": "appsv/server/debiki/dao/PageDao.scala",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FPageDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FPageDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FPageDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -34,6 +34,8 @@ case class PageDao(override val id: PageId, settings: AllSettings,\n       transaction: SiteTransaction, anyDao: Opt[SiteDao])\n   extends Page {\n \n+  assert(id ne null)\n+\n   def sitePageId = SitePageId(transaction.siteId, id)\n \n   var _path: Option[PagePathWithId] = null\n@@ -99,6 +101,7 @@ case class PagePartsDao(\n   anyDao: Opt[SiteDao] = None,\n   ) extends PageParts {\n \n+  assert(pageId ne null)\n \n   private var _meta: Option[PageMeta] = null\n "
    },
    {
      "sha": "f78b0167f2ecf374ba57caf8c59879ae2a97873c",
      "filename": "appsv/server/debiki/dao/PagesDao.scala",
      "status": "modified",
      "additions": 146,
      "deletions": 118,
      "changes": 264,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FPagesDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FPagesDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FPagesDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -24,7 +24,7 @@ import com.debiki.core.PageParts.FirstReplyNr\n import com.debiki.core.Participant.SystemUserId\n import debiki._\n import debiki.EdHttp._\n-import talkyard.server.authz.{Authz, ReqrAndTgt}\n+import talkyard.server.authz.{Authz, ReqrAndTgt, ReqrStranger, AnyReqrAndTgt}\n import talkyard.server.spam.SpamChecker\n import java.{util => ju}\n import scala.collection.immutable\n@@ -51,6 +51,10 @@ case class CreatePageResult(\n   * SECURITY SHOULD either continue creating review tasks for new users, until they've been\n   * reviewed and we know the user is safe. Or block the user from posting more comments,\n   * until his/her first ones have been reviewed.\n+  *\n+  * REFACTOR: Split into  CreatePageDao  and  AlterPageDao.  [pg_ctrl_dao]\n+  * Merge  PageTitleSettingsController into AlterPageDao,  except for HTTP req\n+  * handling which could be merged into PageController?\n   */\n trait PagesDao {\n   self: SiteDao =>\n@@ -71,17 +75,17 @@ trait PagesDao {\n         anyFolder: Option[String], anySlug: Option[String], title: TitleSourceAndHtml,\n         bodyTextAndHtml: TextAndHtml, showId: Boolean, deleteDraftNr: Option[DraftNr], byWho: Who,\n         spamRelReqStuff: SpamRelReqStuff,\n-        doAsAnon: Opt[WhichAnon.NewAnon] = None, // make non-optional?\n         discussionIds: Set[AltPageId] = Set.empty, embeddingUrl: Option[String] = None,\n         extId: Option[ExtId] = None,\n         ): PagePathWithId = {\n+    dieIf(!globals.isOrWasTest, \"TyE306MGJCW2\") // see deprecation note above\n     val withTags = Nil\n-    createPage2(pageRole, pageStatus = pageStatus, anyCategoryId = anyCategoryId, withTags,\n+    createPageSkipAuZ(pageRole, pageStatus = pageStatus, anyCategoryId = anyCategoryId, withTags,\n           anyFolder = anyFolder, anySlug = anySlug, title = title,\n           bodyTextAndHtml = bodyTextAndHtml, showId = showId,\n           deleteDraftNr = deleteDraftNr, byWho = byWho,\n           spamRelReqStuff = spamRelReqStuff,\n-          doAsAnon = doAsAnon,\n+          asAlias = None,\n           discussionIds = discussionIds, embeddingUrl = embeddingUrl,\n           extId = extId,\n           ).path\n@@ -102,15 +106,24 @@ trait PagesDao {\n         withTags: ImmSeq[TagTypeValue],\n         anyFolder: Opt[St], anySlug: Opt[St], title: TitleSourceAndHtml,\n         bodyTextAndHtml: TextAndHtml, showId: Bo, deleteDraftNr: Opt[DraftNr],\n-        reqrAndCreator: ReqrAndTgt,\n+        reqrAndCreator: AnyReqrAndTgt,\n         spamRelReqStuff: SpamRelReqStuff,\n-        doAsAnon: Opt[WhichAnon.NewAnon] = None, // make non-optional?\n+        asAlias: Opt[WhichAliasPat],\n         discussionIds: Set[AltPageId] = Set.empty,\n         embeddingUrl: Opt[St] = None,\n         refId: Opt[RefId] = None,\n         ): CreatePageResult = {\n \n-    val reqrAndLevels = readTx(loadUserAndLevels(reqrAndCreator.reqrToWho, _))\n+    // [dupl_load_lvls]\n+    val reqrAndLevels: AnyUserAndLevels = reqrAndCreator match {\n+      case rt: ReqrAndTgt =>\n+        readTx(loadUserAndLevels(rt.reqrToWho, _))\n+      case _: ReqrStranger =>\n+        val threatLevel = this.readTx(this.loadThreatLevelNoUser(\n+              reqrAndCreator.browserIdData, _))\n+        StrangerAndThreatLevel(threatLevel)\n+    }\n+\n     val catsRootLast = getAncestorCategoriesSelfFirst(inCatId)\n     val tooManyPermissions = getPermsOnPages(categories = catsRootLast)\n \n@@ -119,45 +132,67 @@ trait PagesDao {\n     // Both the requester and the creator need the mayCreatePage() permission. [2_perm_chks]\n     // See docs in docs/ty-security.adoc [api_do_as].\n \n-    // [dupl_api_perm_check]\n+    TESTS_MISSING\n+    // Dupl permission check, below? [dupl_prem_chk]\n     throwNoUnless(Authz.mayCreatePage(\n-          reqrAndLevels, getOnesGroupIds(reqrAndLevels.user),\n+          reqrAndLevels,\n+          asAlias =\n+              if (reqrAndCreator.areNotTheSame) {\n+                // Then the alias is for the user who will be the page author, [4_doer_not_reqr]\n+                // not for the HTTP request requester.\n+                None\n+              }\n+              else {\n+                // The requester is the creator, so any alias is also the requester's.\n+                asAlias\n+              },\n+          getOnesGroupIds(reqrAndLevels.anyUser getOrElse UnknownParticipant),\n           pageType, PostType.Normal, pinWhere = None,\n           anySlug = anySlug, anyFolder = anyFolder,\n           inCategoriesRootLast = catsRootLast,\n           tooManyPermissions),\n           \"TyE_CRPG_REQR_PERMS\")\n \n-    if (reqrAndCreator.areNotTheSame) {\n-      val creatorAndLevels = readTx(loadUserAndLevels(reqrAndCreator.targetToWho, _))\n-      throwNoUnless(Authz.mayCreatePage(\n-            creatorAndLevels, getOnesGroupIds(creatorAndLevels.user),\n-            pageType, PostType.Normal, pinWhere = None,\n-            anySlug = anySlug, anyFolder = anyFolder,\n-            inCategoriesRootLast = catsRootLast,\n-            tooManyPermissions),\n-            \"TyE_CRPG_TGT_PERMS\")\n+    val createdByWho: Who = reqrAndCreator match {\n+      case theReqrAndCreator: ReqrAndTgt =>\n+        val creatorWho = theReqrAndCreator.targetToWho\n+        if (theReqrAndCreator.areNotTheSame) {\n+          TESTS_MISSING; COULD_OPTIMIZE // don't load user again [2WKG06SU]\n+          val creatorAndLevels: UserAndLevels = readTx(loadUserAndLevels(creatorWho, _))\n+          throwNoUnless(Authz.mayCreatePage(\n+                creatorAndLevels, asAlias, getOnesGroupIds(creatorAndLevels.user),\n+                pageType, PostType.Normal, pinWhere = None,\n+                anySlug = anySlug, anyFolder = anyFolder,\n+                inCategoriesRootLast = catsRootLast,\n+                // (This includes permissions for both the requester and target users, and\n+                // everyone else, but mayCreatePage() uses only those of the creator.)\n+                tooManyPermissions),\n+                \"TyE_CRPG_TGT_PERMS\")\n+        }\n+        creatorWho\n+      case _ =>\n+        Who(TrueId(UnknownUserId), reqrAndCreator.browserIdData, isAnon = false)\n     }\n \n-    createPage2(\n+    createPageSkipAuZ(\n           pageType, pageStatus, anyCategoryId = inCatId, withTags,\n           anyFolder = anyFolder, anySlug = anySlug, title,\n           bodyTextAndHtml = bodyTextAndHtml, showId = showId, deleteDraftNr = deleteDraftNr,\n-          byWho = reqrAndCreator.targetToWho,\n+          byWho = createdByWho,\n           spamRelReqStuff,\n-          doAsAnon,\n+          asAlias,\n           discussionIds = discussionIds,\n           embeddingUrl = embeddingUrl,\n           extId = refId)\n   }\n \n-  @deprecated(\"Merge with  createPageIfAuZ?\")\n-  def createPage2(pageRole: PageType, pageStatus: PageStatus, anyCategoryId: Option[CategoryId],\n+\n+  def createPageSkipAuZ(pageRole: PageType, pageStatus: PageStatus, anyCategoryId: Option[CategoryId],\n         withTags: ImmSeq[TagTypeValue],\n         anyFolder: Option[String], anySlug: Option[String], title: TitleSourceAndHtml,\n         bodyTextAndHtml: TextAndHtml, showId: Boolean, deleteDraftNr: Option[DraftNr], byWho: Who,\n         spamRelReqStuff: SpamRelReqStuff,\n-        doAsAnon: Opt[WhichAnon.NewAnon] = None, // make non-optional?\n+        asAlias: Opt[WhichAliasPat],\n         discussionIds: Set[AltPageId] = Set.empty, embeddingUrl: Option[String] = None,\n         extId: Option[ExtId] = None,\n         ): CreatePageResult = {\n@@ -203,7 +238,7 @@ trait PagesDao {\n                 pinWhere = None,\n                 byWho,\n                 Some(spamRelReqStuff),\n-                doAsAnon,\n+                asAlias,\n                 discussionIds = discussionIds,\n                 embeddingUrl = embeddingUrl,\n                 extId = extId)(tx, staleStuff)\n@@ -222,7 +257,7 @@ trait PagesDao {\n \n   /** Returns (PagePath, body-post, any-review-task)\n     *\n-    * @param doAsAnon — must be a new anonym, since anons are per page, and this page is new.\n+    * @param asAlias — must be a new anonym, since anons are per page, and this page is new.\n     */\n   def createPageImpl(pageRole: PageType,\n       pageStatus: PageStatus,\n@@ -237,7 +272,7 @@ trait PagesDao {\n       pinWhere: Option[PinPageWhere] = None,\n       byWho: Who,\n       spamRelReqStuff: Option[SpamRelReqStuff],\n-      doAsAnon: Opt[WhichAnon.NewAnon] = None,\n+      asAlias: Opt[WhichAliasPat] = None,\n       hidePageBody: Boolean = false,\n       layout: Option[PageLayout] = None,\n       bodyPostType: PostType = PostType.Normal,\n@@ -265,8 +300,9 @@ trait PagesDao {\n     //val authzCtx = ForumAuthzContext(Some(author), groupIds, permissions)  ?  [5FLK02]\n     val settings = loadWholeSiteSettings(tx)\n \n+    // Dupl permission check [dupl_prem_chk] when called via createPageIfAuZ()?\n     dieOrThrowNoUnless(Authz.mayCreatePage(  // REFACTOR COULD pass a pageAuthzCtx instead [5FLK02]\n-      realAuthorAndLevels, groupIds,\n+      realAuthorAndLevels, asAlias, groupIds,\n       pageRole, bodyPostType, pinWhere, anySlug = anySlug, anyFolder = anyFolder,\n       inCategoriesRootLast = categoryPath,\n       permissions), \"EdE5JGK2W4\")\n@@ -286,10 +322,10 @@ trait PagesDao {\n     val (\n       reviewReasons: Seq[ReviewReason],\n       shallApprove: Boolean) =\n-        throwOrFindReviewNewPageReasons(realAuthorAndLevels, pageRole, tx)\n+        throwOrFindReviewNewPageReasons(realAuthorAndLevels, pageRole, tx)  // [mod_deanon_risk]\n \n     val approvedById =\n-      if (realAuthor.isStaff) {\n+      if (realAuthor.isStaff) {  // [mod_deanon_risk]\n         dieIf(!shallApprove, \"EsE2UPU70\")\n         Some(realAuthor.id)\n       }\n@@ -334,28 +370,9 @@ trait PagesDao {\n     val titleUniqueId = tx.nextPostId()\n     val bodyUniqueId = titleUniqueId + 1\n \n-    TESTS_MISSING // Dupl code. [get_anon] check all other too.\n-    val authorMaybeAnon =\n-          if (doAsAnon.forall(!_.anonStatus.isAnon)) {\n-            realAuthor\n-          }\n-          else {\n-            throwForbiddenIf(doAsAnon.exists(_.isInstanceOf[WhichAnon.SameAsBefore]),\n-                  \"TyE5FWMJL30P\", \"There're no anons to reuse on a new page\")\n-            // Dupl code. [mk_new_anon]\n-            val anonymId = tx.nextGuestId\n-            val anonym = Anonym(\n-                  id = anonymId,\n-                  createdAt = tx.now,\n-                  anonStatus = doAsAnon.getOrDie(\"TyE7MF26F\").anonStatus,\n-                  anonForPatId = realAuthorId,\n-                  anonOnPageId = pageId)\n-            // We'll insert the anonym before the page exists, but there's a\n-            // foreign key: pats_t.anon_on_page_id_st_c, so defer constraints:\n-            tx.deferConstraints()\n-            tx.insertAnonym(anonym)\n-            anonym\n-          }\n+    val authorMaybeAnon: Pat = SiteDao.getAliasOrTruePat(\n+          truePat = realAuthor, pageId = pageId, asAlias, mayReuseAnon = false,\n+          isCreatingPage = true)(tx, IfBadAbortReq)\n \n     val titlePost = Post.createTitle(\n       uniqueId = titleUniqueId,\n@@ -377,7 +394,7 @@ trait PagesDao {\n       approvedById = approvedById)\n       .copy(\n         bodyHiddenAt = ifThenSome(hidePageBody, now.toJavaDate),\n-        bodyHiddenById = ifThenSome(hidePageBody, authorMaybeAnon.id), \n+        bodyHiddenById = ifThenSome(hidePageBody, authorMaybeAnon.id),\n         bodyHiddenReason = None) // add `hiddenReason` function parameter?\n \n     var nextTagId: TagId =\n@@ -436,7 +453,7 @@ trait PagesDao {\n       if (spamRelReqStuff.isEmpty || !globals.spamChecker.spamChecksEnabled) None\n       else if (settings.userMustBeAuthenticated) None\n       else if (!canStrangersSeePagesInCat_useTxMostly(anyCategoryId, tx)) None\n-      else if (!SpamChecker.shallCheckSpamFor(realAuthorAndLevels)) None\n+      else if (!SpamChecker.shallCheckSpamFor(realAuthorAndLevels)) None  // [mod_deanon_risk]\n       else {\n         // The uri is now sth like /-/create-page. Change to the path to the page\n         // we're creating.\n@@ -600,23 +617,24 @@ trait PagesDao {\n   }\n \n \n-  def ifAuthAcceptAnswer(pageId: PageId, postUniqueId: PostId, reqerTrueId: TrueId,\n-        browserIdData: BrowserIdData): Option[ju.Date] = {\n+  def ifAuthAcceptAnswer(pageId: PageId, postUniqueId: PostId, reqrAndDoer: ReqrAndTgt,\n+        browserIdData: BrowserIdData, asAlias: Opt[WhichAliasPat]): Opt[ju.Date] = {\n+    unimplIf(reqrAndDoer.areNotTheSame, \"Accepting answer on behalf of sbd else\")\n+\n     val answeredAt = writeTx { (tx, staleStuff) =>\n-      val user = tx.loadTheParticipant(reqerTrueId.curId)\n+\n+      val user = tx.loadTheParticipant(reqrAndDoer.reqrId) // reqr & doer are the same, see above\n       val oldMeta = tx.loadThePageMeta(pageId)\n+\n+      COULD_OPTIMIZE // Check see-post & alter-page at the same time, 1 fn call.\n+      throwIfMayNotSeePost2(ThePost.WithId(postUniqueId), reqrAndDoer)(tx)\n+      throwIfMayNotAlterPage(user, asAlias, oldMeta, changesOnlyTypeOrStatus = true, tx)\n+\n       if (!oldMeta.pageType.canBeSolved)\n         throwBadReq(\"DwE4KGP2\", \"This page is not a question so no answer can be selected\")\n \n-      ANON_UNIMPL; BUG // This prevents anons from accepting answers to their own\n-      // questions? [anon_pages]\n-      throwForbiddenIf(!user.isStaffOrCoreMember && user.id != oldMeta.authorId,\n-            \"TyE8JGY3\", \"Only core members and the topic author can accept an answer\")\n-\n-      // Pat might no longer be allowed to see the page — maybe it's been deleted,\n-      // or moved to a private category. [may0_see_own]\n-      SECURITY // minor: Should be may-not-see-post.\n-      throwIfMayNotSeePage(oldMeta, Some(user))(tx)\n+      val doingAs: Pat = SiteDao.getAliasOrTruePat(\n+            user, pageId = pageId, asAlias, mayCreateAnon = false)(tx, IfBadAbortReq)\n \n       val post = tx.loadThePost(postUniqueId)\n       throwBadRequestIf(post.isDeleted, \"TyE4BQR20\", \"That post has been deleted, cannot mark as answer\")\n@@ -637,13 +655,14 @@ trait PagesDao {\n             version = oldMeta.version + 1)\n \n       tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n+      addMetaMessage(doingAs, s\" accepted an answer\", pageId, tx)  // I18N\n       staleStuff.addPageId(pageId, memCacheOnly = true)\n \n       val auditLogEntry = AuditLogEntry(\n             siteId = siteId,\n             id = AuditLogEntry.UnassignedId,\n             didWhat = AuditLogEntryType.PageAnswered,\n-            doerTrueId = reqerTrueId,\n+            doerTrueId = doingAs.trueId2,\n             doneAt = tx.now.toJavaDate,\n             browserIdData = browserIdData,\n             pageId = Some(pageId),\n@@ -660,12 +679,12 @@ trait PagesDao {\n       // If a trusted member thinks the answer is ok, then, maybe resolving\n       // any review mod tasks for the answer — and the question too.\n       // Test:  modn-from-disc-page-review-after.2browsers  TyTE2E603RKG4.TyTE2E50ARMS\n-      if (user.isStaffOrTrustedNotThreat) {\n-        maybeReviewAcceptPostByInteracting(post, moderator = user,\n+      if (doingAs.isStaffOrTrustedNotThreat) {\n+        maybeReviewAcceptPostByInteracting(post, moderator = doingAs,\n               ReviewDecision.InteractAcceptAnswer)(tx, staleStuff)\n \n         tx.loadOrigPost(pageId).getOrBugWarn(\"TyE205WKT734\") { origPost =>\n-          maybeReviewAcceptPostByInteracting(origPost, moderator = user,\n+          maybeReviewAcceptPostByInteracting(origPost, moderator = doingAs,\n                 ReviewDecision.InteractAcceptAnswer)(tx, staleStuff)\n         }\n       }\n@@ -677,17 +696,20 @@ trait PagesDao {\n   }\n \n \n-  def ifAuthUnacceptAnswer(pageId: PageId, reqerTrueId: TrueId,\n-          browserIdData: BrowserIdData): U = {\n+  def ifAuthUnacceptAnswer(pageId: PageId, reqrAndDoer: ReqrAndTgt,\n+          browserIdData: BrowserIdData, asAlias: Opt[WhichAliasPat]): U = {\n+\n+    unimplIf(reqrAndDoer.areNotTheSame, \"Unaccepting answer on behalf of sbd else\")\n+\n     readWriteTransaction { tx =>\n-      val user = tx.loadTheParticipant(reqerTrueId.curId)\n+      val user = tx.loadTheParticipant(reqrAndDoer.reqrId)\n       val oldMeta = tx.loadThePageMeta(pageId)\n-      ANON_UNIMPL; BUG // This prevents anons from un-accepting answers? [anon_pages]\n-      throwForbiddenIf(!user.isStaffOrCoreMember && user.id != oldMeta.authorId,\n-            \"TyE2GKUB4\", \"Only core members and the topic author can unaccept an answer\")\n \n-      // Pat might no longer be allowed to see the page. [may0_see_own]\n-      throwIfMayNotSeePage(oldMeta, Some(user))(tx)\n+      throwIfMayNotAlterPage(user, asAlias, oldMeta, changesOnlyTypeOrStatus = true, tx)\n+      // (Don't require user to be able to see the current answer —  maybe it's been deleted.)\n+\n+      val doingAs: Pat = SiteDao.getAliasOrTruePat(user, pageId = pageId, asAlias,\n+            mayCreateAnon = false)(tx, IfBadAbortReq)\n \n       // Dupl line. [4UKP58B]\n       val newMeta = oldMeta.copy(answeredAt = None, answerPostId = None, closedAt = None,\n@@ -697,7 +719,7 @@ trait PagesDao {\n             siteId = siteId,\n             id = AuditLogEntry.UnassignedId,\n             didWhat = AuditLogEntryType.PageUnanswered,\n-            doerTrueId = reqerTrueId,\n+            doerTrueId = doingAs.trueId2,\n             doneAt = tx.now.toJavaDate,\n             browserIdData = browserIdData,\n             pageId = Some(pageId),\n@@ -707,13 +729,14 @@ trait PagesDao {\n             postNr = None)\n \n       tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n+      addMetaMessage(doingAs, s\" unaccepted an answer\", pageId, tx)  // I18N\n       tx.insertAuditLogEntry(auditLogEntry)\n     }\n     refreshPageInMemCache(pageId)\n   }\n \n \n-  def ifAuthTogglePageClosed(pageId: PageId, reqr: ReqrId, asAlias: Opt[WhichAnon])\n+  def ifAuthTogglePageClosed(pageId: PageId, reqr: ReqrId, asAlias: Opt[WhichAliasPat])\n           : Opt[ju.Date] = {\n     val now = globals.now()\n     val newClosedAt = readWriteTransaction { tx =>\n@@ -722,32 +745,22 @@ trait PagesDao {\n \n       TESTS_MISSING\n \n-      throwIfMayNotSeePage(oldMeta, Some(user))(tx)\n+      throwIfMayNotAlterPage(user, asAlias, oldMeta, changesOnlyTypeOrStatus = true, tx)\n+\n+      val doingAs: Pat = SiteDao.getAliasOrTruePat(user, pageId = pageId, asAlias,\n+            mayCreateAnon = false)(tx, IfBadAbortReq)\n \n       throwBadRequestIf(oldMeta.isDeleted,\n           \"TyE0CLSPGDLD\", s\"Cannot close or reopen deleted pages\")\n \n       throwBadRequestIf(!oldMeta.pageType.canClose,\n           \"DwE4PKF7\", s\"Cannot close pages of type ${oldMeta.pageType}\")\n \n-      val aliasOrTrue: Pat = SiteDao.getAliasOrTruePat(truePat = user, pageId = pageId,\n-            asAlias, mayCreateAnon = false)(tx, IfBadAbortReq)\n-\n-      val isAuthor = aliasOrTrue.id == oldMeta.authorId\n-\n-      if (!isAuthor) {\n-        throwForbiddenIf(!user.isStaffOrCoreMember,\n-              \"TyE5JPK7\", \"Only core members and the topic author can close / reopen\")\n-\n-        // Later: Allow, but use a separate anon for moderator actions. [anon_mods] [deanon_risk]\n-        throwForbiddenIf(aliasOrTrue.isAlias,\n-              \"TyE4PGR02P\", \"Can't open/close sbd else's page anonymously\")\n-      }\n-\n       val (newClosedAt: Option[ju.Date], didWhat: String) = oldMeta.closedAt match {\n         case None => (Some(now.toJavaDate), \"closed\")\n         case Some(_) => (None, \"reopened\")\n       }\n+\n       val newMeta = oldMeta.copy(\n         closedAt = newClosedAt,\n         version = oldMeta.version + 1,\n@@ -759,13 +772,13 @@ trait PagesDao {\n             didWhat =\n                   if (newMeta.isClosed) AuditLogEntryType.PageClosed\n                   else AuditLogEntryType.PageReopened,\n-            doerTrueId = reqr.trueId,\n+            doerTrueId = doingAs.trueId2,\n             doneAt = tx.now.toJavaDate,\n             browserIdData = reqr.browserIdData,\n             pageId = Some(pageId))\n \n       tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = true)\n-      addMetaMessage(aliasOrTrue, s\" $didWhat this topic\", pageId, tx)\n+      addMetaMessage(doingAs, s\" $didWhat this topic\", pageId, tx)\n       tx.insertAuditLogEntry(auditLogEntry)\n \n       newClosedAt\n@@ -775,51 +788,66 @@ trait PagesDao {\n   }\n \n \n-  def deletePagesIfAuth(pageIds: Seq[PageId], reqr: ReqrId, undelete: Bo): U = {\n+  def deletePagesIfAuth(pageIds: Seq[PageId], reqr: ReqrId, asAlias: Opt[WhichAliasPat],\n+          undelete: Bo): U = {\n+    // Anonyms are per page, so we can't delete many pages at a time, if asAlias is an anonym.\n+    throwForbiddenIf(asAlias.isDefined && pageIds.size != 1,\n+          \"TyEALIMANYPAGES\", s\"Can delete only one page at a time, when using an alias. I got ${\n+              pageIds.size} pages\")\n+\n     writeTx { (tx, staleStuff) =>\n-      // SHOULD LATER: [4GWRQA28] If is sub community (= forum page), delete the root category too,\n-      // so all topics in the sub community will get deleted.\n+      // Later: [4GWRQA28] If is a sub community (= forum page), delete the root category too,\n+      // so all topics in the sub community will get deleted. [subcomms]\n       // And remove the sub community from the watchbar's Communities section.\n       // (And if undeleting the sub community, undelete the root category too.)\n-      deletePagesImpl(pageIds, reqr, undelete = undelete)(tx, staleStuff)\n+      deletePagesImpl(pageIds, reqr, asAlias, undelete = undelete)(tx, staleStuff)\n     }\n     refreshPagesInMemCache(pageIds.toSet)\n   }\n \n \n-  def deletePagesImpl(pageIds: Seq[PageId], reqr: ReqrId, undelete: Bo = false)(\n-          tx: SiteTx, staleStuff: StaleStuff): U = {\n+  def deletePagesImpl(pageIds: Seq[PageId], reqr: ReqrId, asAlias: Opt[WhichAliasPat],\n+          undelete: Bo = false)(tx: SiteTx, staleStuff: StaleStuff): U = {\n \n     BUG; SHOULD // delete notfs or mark deleted?  [notfs_bug]  [nice_notfs]\n     // But don't delete any review tasks — good if staff reviews, if a new\n     // member posts something trollish, people react, then hen deletes hens page.\n     // Later, if undeleting, then restore the notfs? [undel_posts]\n \n-    val deleter = tx.loadTheParticipant(reqr.id)\n+    val trueDeleter = tx.loadTheParticipant(reqr.id) // [alias_4_principal]\n+\n+    dieIf(asAlias.isDefined && pageIds.size != 1,\n+          \"TyEALIMANYPGS2\", s\"Alias deleting ${pageIds.size} != 1 pages\")\n+\n+    val deleterPersona: Pat = SiteDao.getAliasOrTruePat(\n+          truePat = trueDeleter, pageId = pageIds(0), asAlias,\n+          mayCreateAnon = false)(tx, IfBadAbortReq)\n \n     for {\n       pageId <- pageIds\n       pageMeta <- tx.loadPageMeta(pageId)\n       // Hmm but trying to delete a deleted *post*, throws an error. [5WKQRH2]\n       if pageMeta.isDeleted == undelete\n     } {\n+      SHOULD // use Authz and  mayDeletePage  instead? [authz_may_del] [granular_perms]\n+\n       // Mods may not delete pages they cannot see — maybe admins have\n       // their own internal discussions.\n-      throwIfMayNotSeePage(pageMeta, Some(deleter))(tx)\n+      throwIfMayNotSeePage(pageMeta, Some(trueDeleter))(tx)\n \n       // Ordinary members may only delete their own pages, before others have replied.\n       // Sync with client side. [who_del_pge]\n-      ANON_UNIMPL // This prevents anons from deleting their pages? [anon_pages]  (authorId\n-      // is the anon, reqr.id is the true id != the anon.)\n-      if (!deleter.isStaff) {\n-        throwForbiddenIf(pageMeta.authorId != reqr.id,\n+      if (!deleterPersona.isStaff) {\n+        // (This message is misleading if trying to delete one's own post, using the wrong\n+        // alias. But let's fix by using  Authz & mayDeletePage  instead? [authz_may_del])\n+        throwForbiddenIf(pageMeta.authorId != deleterPersona.id,\n                 \"TyEDELOTRSPG_\", \"May not delete other people's pages\")\n \n         // Shouldn't have been allowed to see sbd else's deleted page.\n-        val deletedOwn = pageMeta.deletedById.is(reqr.id) &&\n-                pageMeta.authorId == reqr.id\n-        dieIf(undelete && !deletedOwn, \"TyEUNDELOTRS\",\n-              s\"s$siteId: User ${reqr.id} may not undelete sbd else's page $pageId\")\n+        val deletedOwn = pageMeta.deletedById.is(deleterPersona.id) &&\n+                pageMeta.authorId == deleterPersona.id\n+        dieIf(undelete && !deletedOwn, \"TyEUNDELOTRS\", s\"s$siteId: User ${\n+              deleterPersona.nameParaId} may not undelete sbd else's page $pageId\")\n \n         // When there are replies, the UX should send a request to delete the\n         // orig post only — but not the whole page. (Unless is staff, then can delete\n@@ -831,14 +859,14 @@ trait PagesDao {\n       }\n \n       if ((pageMeta.pageType.isSection || pageMeta.pageType == PageType.CustomHtmlPage) &&\n-          !deleter.isAdmin)\n+          !deleterPersona.isAdmin)\n         throwForbidden(\"EsE5GKF23_\", \"Only admin may (un)delete sections and HTML pages\")\n \n       val baseAuditEntry = AuditLogEntry(\n         siteId = siteId,\n         id = AuditLogEntry.UnassignedId,\n         didWhat = AuditLogEntryType.DeletePage,\n-        doerTrueId = reqr.trueId,\n+        doerTrueId = deleterPersona.trueId2,\n         doneAt = tx.now.toJavaDate,\n         browserIdData = reqr.browserIdData,\n         pageId = Some(pageId),\n@@ -855,7 +883,7 @@ trait PagesDao {\n         else {\n           (pageMeta.copy(\n                 deletedAt = Some(tx.now.toJavaDate),\n-                deletedById = Some(deleter.id),\n+                deletedById = Some(deleterPersona.id),\n                 version = pageMeta.version + 1),\n             baseAuditEntry)\n         }\n@@ -884,7 +912,7 @@ trait PagesDao {\n       tx.loadOrigPost(pageMeta.pageId) foreach { origPost =>\n         TESTS_MISSING\n         val postAuthor = tx.loadTheParticipant(origPost.createdById)\n-        updateSpamCheckTaskBecausePostDeleted(origPost, postAuthor, deleter = deleter, tx)\n+        updateSpamCheckTaskBecausePostDeleted(origPost, postAuthor, deleter = deleterPersona, tx)\n       }\n \n       tx.updatePageMeta(newMeta, oldMeta = pageMeta, markSectionPageStale = true)\n@@ -903,7 +931,7 @@ trait PagesDao {\n       staleStuff.addPageId(pageId, memCacheOnly = true)\n \n       val un = undelete ? \"un\" | \"\"\n-      addMetaMessage(deleter, s\" ${un}deleted this topic\", pageId, tx)\n+      addMetaMessage(deleterPersona, s\" ${un}deleted this topic\", pageId, tx)\n     }\n   }\n "
    },
    {
      "sha": "df5f2c7a70903395bf9db828e715adae57ce0a4a",
      "filename": "appsv/server/debiki/dao/PostsDao.scala",
      "status": "modified",
      "additions": 90,
      "deletions": 141,
      "changes": 231,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FPostsDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FPostsDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FPostsDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -71,7 +71,7 @@ trait PostsDao {\n         postType: PostType, deleteDraftNr: Option[DraftNr],\n         reqrAndReplyer: ReqrAndTgt,\n         spamRelReqStuff: SpamRelReqStuff,\n-        anonHow: Opt[WhichAnon] = None, refId: Opt[RefId] = None,\n+        asAlias: Opt[WhichAliasPat] = None, refId: Opt[RefId] = None,\n         withTags: ImmSeq[TagTypeValue] = Nil)  // oops forgot_to_use\n         : InsertPostResult = {\n \n@@ -91,31 +91,34 @@ trait PostsDao {\n \n     // [2_perm_chks] [dupl_re_authz_chk]\n     throwNoUnless(Authz.mayPostReply(\n-          reqrAndLevels, this.getOnesGroupIds(reqrAndLevels.user),\n+          reqrAndLevels,\n+          // See [4_doer_not_reqr].\n+          asAlias = if (reqrAndReplyer.areNotTheSame) None else asAlias,\n+          this.getOnesGroupIds(reqrAndLevels.user),\n           postType, pageMeta, replyToPosts, privTalkMembers,\n           inCategoriesRootLast = catsRootLast, tooManyPermissions),\n           \"TyEM0REPLY1\")\n \n     if (reqrAndReplyer.areNotTheSame) {\n       val replyerAndLevels = readTx(this.loadUserAndLevels(reqrAndReplyer.targetToWho, _))\n       throwNoUnless(Authz.mayPostReply(\n-            replyerAndLevels, this.getOnesGroupIds(replyerAndLevels.user),\n+            replyerAndLevels, asAlias, this.getOnesGroupIds(replyerAndLevels.user),\n             postType, pageMeta, replyToPosts, privTalkMembers,\n             inCategoriesRootLast = catsRootLast, tooManyPermissions),\n             \"TyEM0REPLY2\")\n     }\n \n-    this.insertReply(textAndHtml, pageId = pageId, replyToPostNrs = replyToPostNrs,\n+    this.insertReplySkipAuZ(textAndHtml, pageId = pageId, replyToPostNrs = replyToPostNrs,\n           postType, deleteDraftNr = deleteDraftNr,\n           byWho = reqrAndReplyer.targetToWho, spamRelReqStuff,\n-          anonHow, refId = refId, withTags)\n+          asAlias, refId = refId, withTags)\n   }\n \n \n-  def insertReply(textAndHtml: TextAndHtml, pageId: PageId, replyToPostNrs: Set[PostNr],\n+  def insertReplySkipAuZ(textAndHtml: TextAndHtml, pageId: PageId, replyToPostNrs: Set[PostNr],\n         postType: PostType, deleteDraftNr: Option[DraftNr],\n         byWho: Who, spamRelReqStuff: SpamRelReqStuff,\n-        anonHow: Opt[WhichAnon] = None, refId: Opt[RefId] = None,\n+        asAlias: Opt[WhichAliasPat] = None, refId: Opt[RefId] = None,\n         withTags: ImmSeq[TagTypeValue] = Nil)  // oops forgot_to_use\n         : InsertPostResult = {\n \n@@ -140,7 +143,7 @@ trait PostsDao {\n     val (newPost, author, notifications, anyReviewTask) = writeTx { (tx, staleStuff) =>\n       deleteDraftNr.foreach(nr => tx.deleteDraft(byWho.id, nr))\n       insertReplyImpl(textAndHtml, pageId, replyToPostNrs, postType,\n-            byWho, spamRelReqStuff, now, authorId, tx, staleStuff, anonHow, refId = refId)\n+            byWho, spamRelReqStuff, now, authorId, tx, staleStuff, asAlias, refId = refId)\n     }\n \n     refreshPageInMemCache(pageId)\n@@ -163,7 +166,7 @@ trait PostsDao {\n         // Rename authorId to what? realAuthorId?  or rename  author  to  authorMaybeAnon?\n         authorId: UserId,\n         tx: SiteTx, staleStuff: StaleStuff,\n-        doAsAnon: Opt[WhichAnon] = None,\n+        asAlias: Opt[WhichAliasPat] = None,\n         skipNotfsAndAuditLog: Boolean = false,\n         refId: Opt[RefId] = None)\n         : (Post, Participant, Notifications, Option[ReviewTask]) = {\n@@ -180,36 +183,11 @@ trait PostsDao {\n     val realAuthor = realAuthorAndLevels.user\n     val realAuthorAndGroupIds = tx.loadGroupIdsMemberIdFirst(realAuthor)\n \n-    // Dupl code. [get_anon]\n-    // ------- Maybe ------------\n-    // Hmm, rename to  otherAuthor,  and None by default.  And set  createdById\n-    // to the real account, always,  and  author_id_c  to any anonym's id.   [mk_new_anon]\n-    // --------------------------\n-    val authorMaybeAnon: Pat =\n-          if (doAsAnon.isEmpty) {\n-            realAuthor\n-          }\n-          else doAsAnon.get match {\n-            case WhichAnon.SameAsBefore(anonId) =>\n-              // Hmm, verify it's realAuthor's anon ???  — use getAliasOrTruePat() instead\n-              tx.loadTheParticipant(anonId).asAnonOrThrow\n-            case WhichAnon.NewAnon(anonStatus) =>\n-              // Dupl code. [mk_new_anon]\n-              val anonymId = tx.nextGuestId\n-              val anonym = Anonym(\n-                    id = anonymId,\n-                    createdAt = tx.now,\n-                    anonStatus = anonStatus,\n-                    anonForPatId = realAuthor.id,\n-                    anonOnPageId = pageId)\n-              // We'll insert the anonym before the page exists, but there's a\n-              // foreign key: pats_t.anon_on_page_id_st_c, so defer constraints:\n-              tx.deferConstraints()\n-              tx.insertAnonym(anonym)\n-              anonym\n-          }\n+    val authorMaybeAnon: Pat = SiteDao.getAliasOrTruePat(\n+          truePat = realAuthor, pageId = pageId, asAlias)(tx, IfBadAbortReq)\n \n-    dieOrThrowNoUnless(Authz.mayPostReply(realAuthorAndLevels, realAuthorAndGroupIds,\n+    dieOrThrowNoUnless(Authz.mayPostReply(\n+      realAuthorAndLevels, asAlias /* _not_same_tx, ok */, realAuthorAndGroupIds,\n       postType, page.meta, replyToPosts, tx.loadAnyPrivateGroupTalkMembers(page.meta),\n       tx.loadCategoryPathRootLast(page.meta.categoryId, inclSelfFirst = true),\n       tx.loadPermsOnPages()), \"EdEMAY0RE\")\n@@ -258,7 +236,7 @@ trait PostsDao {\n     val approverId =\n       if (realAuthor.isStaff) {\n         dieIf(!shallApprove, \"EsE5903\")\n-        Some(realAuthor.id)\n+        Some(realAuthor.id)  // [mod_deanon_risk]\n       }\n       else if (shallApprove) Some(SystemUserId)\n       else None\n@@ -681,8 +659,10 @@ trait PostsDao {\n       SHOULD_OPTIMIZE // don't load all posts [2GKF0S6], because this is a chat, could be too many.\n       val page = newPageDao(pageId, tx)\n       val replyToPosts = Nil // currently cannot reply to specific posts, in the chat. [7YKDW3]\n+      val asAlias = None // [anon_chats]\n \n-      dieOrThrowNoUnless(Authz.mayPostReply(authorAndLevels, tx.loadGroupIdsMemberIdFirst(author),\n+      dieOrThrowNoUnless(Authz.mayPostReply(\n+        authorAndLevels, asAlias = asAlias, tx.loadGroupIdsMemberIdFirst(author),\n         PostType.ChatMessage, page.meta, Nil, tx.loadAnyPrivateGroupTalkMembers(page.meta),\n         tx.loadCategoryPathRootLast(page.meta.categoryId, inclSelfFirst = true),\n         tx.loadPermsOnPages()), \"EdEMAY0CHAT\")\n@@ -754,7 +734,7 @@ trait PostsDao {\n     require(textAndHtml.safeHtml.trim.nonEmpty, \"TyE592MWP2\")\n \n     // Chat messages currently cannot be anonymous. [anon_chats]\n-    // Note: Farily similar to insertReply() a bit above. [4UYKF21]\n+    // Note: Farily similar to insertReplySkipAuZ() a bit above. [4UYKF21]\n     val authorAndLevels = loadUserAndLevels(who, tx)\n     val author: Pat = authorAndLevels.user\n \n@@ -1021,7 +1001,7 @@ trait PostsDao {\n     */\n   def editPostIfAuth(pageId: PageId, postNr: PostNr, deleteDraftNr: Option[DraftNr],\n         who: Who, spamRelReqStuff: SpamRelReqStuff, newTextAndHtml: SourceAndHtml,\n-        doAsAnon: Opt[WhichAnon] = None): U = {\n+        asAlias: Opt[WhichAliasPat] = None): U = {\n     val realEditorId = who.id\n \n     // Note: Farily similar to appendChatMessageToLastMessage() just above. [2GLK572]\n@@ -1049,38 +1029,23 @@ trait PostsDao {\n       if (postToEdit.currentSource == newTextAndHtml.text)\n         return\n \n-      val anyOtherAuthor =\n-            if (postToEdit.createdById == realEditor.id) None\n-            else Some(tx.loadTheParticipant(postToEdit.createdById))\n+      // Won't need later, when true id stored in posts3/nodes_t? [posts3_true_id]\n+      val postAuthor =\n+            if (postToEdit.createdById == realEditor.id) realEditor\n+            else tx.loadTheParticipant(postToEdit.createdById)\n+      val pageAuthor =\n+            if (page.meta.authorId == realEditor.id) realEditor\n+            else tx.loadTheParticipant(page.meta.authorId)\n \n-      // Dupl code. [get_anon]\n-      val editorMaybeAnon =\n-            if (doAsAnon.isEmpty) {\n-              realEditor\n-            }\n-            else doAsAnon.get match {\n-              case WhichAnon.SameAsBefore(anonId) =>\n-                tx.loadTheParticipant(anonId).asAnonOrThrow\n-              case WhichAnon.NewAnon(anonStatus) =>\n-                // Dupl code. [mk_new_anon]\n-                val anonymId = tx.nextGuestId\n-                val anonym = Anonym(\n-                      id = anonymId,\n-                      createdAt = tx.now,\n-                      anonStatus = anonStatus,\n-                      anonForPatId = realEditor.id,\n-                      anonOnPageId = pageId)\n-                // We'll insert the anonym before the page exists, but there's a\n-                // foreign key: pats_t.anon_on_page_id_st_c, so defer constraints:\n-                tx.deferConstraints()\n-                tx.insertAnonym(anonym)\n-                anonym\n-            }\n+      val editorMaybeAnon = SiteDao.getAliasOrTruePat(\n+            truePat = realEditor, pageId = pageId, asAlias)(tx, IfBadAbortReq)\n \n+      // [dupl_ed_perm_chk]?\n       dieOrThrowNoUnless(Authz.mayEditPost(\n-            realEditorAndLevels, tx.loadGroupIdsMemberIdFirst(realEditor),\n-            postToEdit, otherAuthor = anyOtherAuthor,\n-            page.meta, tx.loadAnyPrivateGroupTalkMembers(page.meta),\n+            realEditorAndLevels, asAlias /* _not_same_tx, ok */,\n+            groupIds = tx.loadGroupIdsMemberIdFirst(realEditor),\n+            postToEdit, postAuthor = postAuthor, page.meta, pageAuthor = pageAuthor,\n+            tx.loadAnyPrivateGroupTalkMembers(page.meta),\n             inCategoriesRootLast = tx.loadCategoryPathRootLast(\n                   page.meta.categoryId, inclSelfFirst = true),\n             tooManyPermissions = tx.loadPermsOnPages()), \"EdE6JLKW2R\")\n@@ -1129,7 +1094,7 @@ trait PostsDao {\n           else {\n             // Older revision already approved and post already published.\n             // Then, continue approving it.\n-            Some(realEditor.id)\n+            Some(realEditor.id)  // [mod_deanon_risk]\n           }\n         }\n         else {\n@@ -1275,6 +1240,7 @@ trait PostsDao {\n                   tx.loadTheOrigPost(postToEdit.pageId)\n                 }\n \n+          // [mod_deanon_risk]\n           maybeReviewAcceptPostByInteracting(postWithModTasks, moderator = realEditor,\n                 ReviewDecision.InteractEdit)(tx, staleStuff)\n \n@@ -1323,7 +1289,7 @@ trait PostsDao {\n         if (!globals.spamChecker.spamChecksEnabled) None\n         else if (settings.userMustBeAuthenticated) None\n         else if (!canStrangersSeePagesInCat_useTxMostly(page.meta.categoryId, tx)) None\n-        else if (!SpamChecker.shallCheckSpamFor(realEditor)) None\n+        else if (!SpamChecker.shallCheckSpamFor(realEditor)) None  // [mod_deanon_risk]\n         else Some(\n           // This can get same prim key as earlier spam check task, if is ninja edit. [SPMCHKED]\n           // Solution: Give each spam check task its own id field.\n@@ -1352,7 +1318,9 @@ trait PostsDao {\n         pageId = Some(pageId),\n         uniquePostId = Some(postToEdit.id),\n         postNr = Some(postNr),\n-        targetPatTrueId = anyOtherAuthor.map(_.trueId2))\n+        targetPatTrueId =\n+              if (postAuthor.trueId2 == realEditor.trueId2) None\n+              else Some(postAuthor.trueId2))\n \n       tx.updatePost(editedPost)\n       // Pointless, if edits not approved? We only index the approved plain text? [ix_unappr]\n@@ -1879,10 +1847,10 @@ trait PostsDao {\n   }\n \n \n-  def changePostStatus(postNr: PostNr, pageId: PageId, action: PostStatusAction, reqr: ReqrId)\n-        : ChangePostStatusResult = {\n+  def changePostStatus(postNr: PostNr, pageId: PageId, action: PostStatusAction, reqr: ReqrId,\n+          asAlias: Opt[WhichAliasPat]): ChangePostStatusResult = {\n     val result = writeTx { (tx, staleStuff) =>\n-      changePostStatusImpl(postNr, pageId = pageId, action, reqr, tx, staleStuff)\n+      changePostStatusImpl(postNr, pageId = pageId, action, reqr, asAlias, tx, staleStuff)\n     }\n     refreshPageInMemCache(pageId)\n     result\n@@ -1897,7 +1865,7 @@ trait PostsDao {\n     * and UI buttons? [deld_post_mod_tasks]\n     */\n   def changePostStatusImpl(postNr: PostNr, pageId: PageId, action: PostStatusAction,\n-         reqr: ReqrId, tx: SiteTx, staleStuff: StaleStuff)\n+         reqr: ReqrId, asAlias: Opt[WhichAliasPat], tx: SiteTx, staleStuff: StaleStuff)\n         : ChangePostStatusResult =  {\n     import com.debiki.core.{PostStatusAction => PSA}\n     import context.security.throwIndistinguishableNotFound\n@@ -1906,28 +1874,36 @@ trait PostsDao {\n     if (!pageBef.exists)\n       throwIndistinguishableNotFound(\"TyE05KSRDM3\")\n \n-    val userId: UserId = reqr.id\n-    val user = tx.loadParticipant(userId) getOrElse throwForbidden(\"DwE3KFW2\", \"Bad user id\")\n+    val trueUser = tx.loadParticipant(reqr.id  // [alias_4_principal]\n+                                      ) getOrElse throwForbidden(\"DwE3KFW2\", \"Bad user id\")\n \n+    val doerPersona: Pat = SiteDao.getAliasOrTruePat(\n+              truePat = trueUser, pageId = pageId, asAlias, mayCreateAnon = false\n+              )(tx, IfBadAbortReq)\n+\n+    SHOULD // use Authz + mayDeleteComment instead, if deleting? [authz_may_del] [granular_perms]\n     SECURITY; COULD // check if may see post, not just the page?  [priv_comts] [staff_can_see]\n     // If doing that, then: TESTS_MISSING — namely deleting an anon post on may not see.\n-    throwIfMayNotSeePage(pageBef, Some(user))(tx)\n+    throwIfMayNotSeePage(pageBef, Some(trueUser))(tx)\n \n     val postBefore = pageBef.parts.thePostByNr(postNr)\n     lazy val postAuthor = tx.loadTheParticipant(postBefore.createdById)\n-    ANON_UNIMPL // Cannot do this as an anonym, although looks as if one can change\n-    // one's own anon posts (using one's real account).\n-    // Need:  doAsAnon: Opt[WhichAnon.SameAsBefore]  [anon_pages]\n \n     // Authorization.\n-    if (!user.isStaff) {\n-      val isOwn =  postBefore.createdById == userId || (postAuthor match {\n-        case anon: Anonym => anon.anonForPatId == userId\n-        case _ => false\n-      })\n+    if (!doerPersona.isStaff) {\n+      val isPersonasOwn =  postBefore.createdById == doerPersona.id\n \n-      if (!isOwn)\n+      if (!isPersonasOwn) {\n+        val isTrueUsers = postAuthor match {\n+          case anon: Anonym => anon.anonForPatId == trueUser.id\n+          case _ => false\n+        }\n+        val author = tx.loadTheParticipant(postBefore.createdById)\n+        throwForbiddenIf(isTrueUsers, \"TyETRUERMALIPO\",\n+              o\"\"\"You created that post as ${author.nameParaId}, and should modify it\n+              as the same persona\"\"\")\n         throwForbidden(\"DwE0PK24\", \"You may not modify that post, it's not yours\")\n+      }\n \n       if (!action.isInstanceOf[PSA.DeletePost] && action != PSA.CollapsePost)\n         throwForbidden(\"DwE5JKF7\", \"You may not modify the whole tree\")\n@@ -1991,13 +1967,13 @@ trait PostsDao {\n     // ----- Update the directly affected post\n \n     val postAfter = action match {\n-      case PSA.HidePost => postBefore.copyWithNewStatus(now, userId, bodyHidden = true)\n-      case PSA.UnhidePost => postBefore.copyWithNewStatus(now, userId, bodyUnhidden = true)\n-      case PSA.CloseTree => postBefore.copyWithNewStatus(now, userId, treeClosed = true)\n-      case PSA.CollapsePost => postBefore.copyWithNewStatus(now, userId, postCollapsed = true)\n-      case PSA.CollapseTree => postBefore.copyWithNewStatus(now, userId, treeCollapsed = true)\n-      case PSA.DeletePost(clearFlags) => postBefore.copyWithNewStatus(now, userId, postDeleted = true)\n-      case PSA.DeleteTree => postBefore.copyWithNewStatus(now, userId, treeDeleted = true)\n+      case PSA.HidePost => postBefore.copyWithNewStatus(now, doerPersona.id, bodyHidden = true)\n+      case PSA.UnhidePost => postBefore.copyWithNewStatus(now, doerPersona.id, bodyUnhidden = true)\n+      case PSA.CloseTree => postBefore.copyWithNewStatus(now, doerPersona.id, treeClosed = true)\n+      case PSA.CollapsePost => postBefore.copyWithNewStatus(now, doerPersona.id, postCollapsed = true)\n+      case PSA.CollapseTree => postBefore.copyWithNewStatus(now, doerPersona.id, treeCollapsed = true)\n+      case PSA.DeletePost(clearFlags) => postBefore.copyWithNewStatus(now, doerPersona.id, postDeleted = true)\n+      case PSA.DeleteTree => postBefore.copyWithNewStatus(now, doerPersona.id, treeDeleted = true)\n     }\n \n     rememberBacklinksUpdCounts(postBefore, postAfter = postAfter)\n@@ -2027,14 +2003,15 @@ trait PostsDao {\n       val anyUpdatedSuccessor: Option[Post] = action match {\n         case PSA.CloseTree =>\n           if (successor.closedStatus.areAncestorsClosed) None\n-          else Some(successor.copyWithNewStatus(now, userId, ancestorsClosed = true))\n+          else Some(successor.copyWithNewStatus(now, doerPersona.id, ancestorsClosed = true))\n         case PSA.CollapseTree =>\n           if (successor.collapsedStatus.areAncestorsCollapsed) None\n-          else Some(successor.copyWithNewStatus(now, userId, ancestorsCollapsed = true))\n+          else Some(successor.copyWithNewStatus(now, doerPersona.id, ancestorsCollapsed = true))\n         case PSA.DeleteTree =>\n           if (successor.deletedStatus.areAncestorsDeleted) None\n           else {\n-            val successorDeleted = successor.copyWithNewStatus(now, userId, ancestorsDeleted = true)\n+            val successorDeleted = successor.copyWithNewStatus(\n+                  now, doerPersona.id, ancestorsDeleted = true)\n             postsDeleted.append(successorDeleted)\n             Some(successorDeleted)\n           }\n@@ -2086,7 +2063,7 @@ trait PostsDao {\n               siteId = siteId,\n               id = AuditLogEntry.UnassignedId,\n               didWhat = AuditLogEntryType.PageUnanswered,\n-              doerTrueId = user.trueId2,\n+              doerTrueId = doerPersona.trueId2,\n               doneAt = tx.now.toJavaDate,\n               browserIdData = reqr.browserIdData,\n               pageId = Some(pageId),\n@@ -2131,7 +2108,7 @@ trait PostsDao {\n       dieIf(!action.isInstanceOf[PostStatusAction.DeletePost] &&\n           action != PostStatusAction.DeleteTree, \"TyE205MKSD\")\n       // + true_pat_id_c?\n-      updateSpamCheckTaskBecausePostDeleted(postBefore, postAuthor, deleter = user, tx)\n+      updateSpamCheckTaskBecausePostDeleted(postBefore, postAuthor, deleter = doerPersona, tx)\n     }\n \n     // ----- Update the page\n@@ -2468,18 +2445,11 @@ trait PostsDao {\n   }\n \n \n-  def deletePost(pageId: PageId, postNr: PostNr, deletedBy: ReqrId): U = {\n-    writeTx { (tx, staleStuff) =>\n-      deletePostImpl(pageId, postNr = postNr, deletedBy, tx, staleStuff)\n-    }\n-    refreshPageInMemCache(pageId)  ; REMOVE // auto do via [staleStuff]\n-  }\n-\n-\n   def deletePostImpl(pageId: PageId, postNr: PostNr, deletedBy: ReqrId,\n         tx: SiteTx, staleStuff: StaleStuff): ChangePostStatusResult = {\n     val result = changePostStatusImpl(pageId = pageId, postNr = postNr,\n           action = PostStatusAction.DeletePost(clearFlags = false), reqr = deletedBy,\n+          asAlias = None, // [anon_mods]\n           tx = tx, staleStuff = staleStuff)\n \n     BUG; SHOULD // delete notfs or mark deleted?  [notfs_bug]  [nice_notfs]\n@@ -2562,7 +2532,7 @@ trait PostsDao {\n \n   def addVoteIfAuZ(pageId: PageId, postNr: PostNr, voteType: PostVoteType,\n         reqrAndVoter: ReqrAndTgt, voterIp: Opt[IpAdr], postNrsRead: Set[PostNr],\n-        doAsAnon: Opt[WhichAnon] = None): Opt[Anonym] = {\n+        asAlias: Opt[WhichAliasPat] = None): Opt[Anonym] = {\n     require(postNr >= PageParts.BodyNr, \"TyE5WKAB20\")\n \n     SECURITY; SLEEPING // May the requester vote on behalf of voter?  [vote_as_otr]\n@@ -2576,32 +2546,11 @@ trait PostsDao {\n \n       // Could do an [authz_pre_check] in VoteController? But why?\n       this.throwIfMayNotSeePost2(ThePost.Here(post), reqrAndVoter)(tx)\n+      // Later: A may-vote permission? [granular_perms] Can be important for Do-It votes f.ex.\n \n       val trueVoter = reqrAndVoter.target\n-      // Dupl code. [get_anon]\n-      val voterMaybeAnon =\n-            if (doAsAnon.isEmpty) {\n-              trueVoter\n-            }\n-            else doAsAnon.get match {\n-              case WhichAnon.SameAsBefore(anonId) =>\n-                // Hmm, verify it's target's anon ???  — use getAliasOrTruePat() instead\n-                tx.loadTheParticipant(anonId).asAnonOrThrow\n-              case WhichAnon.NewAnon(anonStatus) =>\n-                // Dupl code. [mk_new_anon]\n-                val anonymId = tx.nextGuestId\n-                val anonym = Anonym(\n-                      id = anonymId,\n-                      createdAt = tx.now,\n-                      anonStatus = anonStatus,\n-                      anonForPatId = trueVoter.id,\n-                      anonOnPageId = pageId)\n-                // We'll insert the anonym before the page exists, but there's a\n-                // foreign key: pats_t.anon_on_page_id_st_c, so defer constraints:\n-                tx.deferConstraints()\n-                tx.insertAnonym(anonym)\n-                anonym\n-            }\n+      val voterMaybeAnon = SiteDao.getAliasOrTruePat(\n+            truePat = trueVoter, pageId = pageId, asAlias)(tx, IfBadAbortReq)\n \n       if (voteType == PostVoteType.Bury && !voterMaybeAnon.isStaffOrFullMember &&  // [7UKDR10]\n           page.meta.authorId != voterMaybeAnon.id)\n@@ -2686,7 +2635,7 @@ trait PostsDao {\n \n         // Test:  modn-from-disc-page-review-after  TyTE2E603RKG4.TyTE2E5ART25\n         // Don't let anonyms or pseudonyms approve-by-voting — that could leak info\n-        // (namely that han is a mod or admin). [deanon_risk]\n+        // (namely that han is a mod or admin). [mod_deanon_risk]\n         if (!voterMaybeAnon.isAlias) {\n           maybeReviewAcceptPostByInteracting(post, moderator = trueVoter,\n               ReviewDecision.InteractLike)(tx, staleStuff)\n@@ -2882,7 +2831,7 @@ trait PostsDao {\n       if (postToMove.nr == PageParts.TitleNr || postToMove.nr == PageParts.BodyNr)\n         throwForbidden(\"EsE7YKG25_\", \"Cannot move page title or body\")\n \n-      val postAuthor = tx.loadTheUser(postToMove.createdById)\n+      val postAuthor = tx.loadTheParticipant(postToMove.createdById)\n \n       val newParentPost = tx.loadPost(newParent) getOrElse throwForbidden(\n         \"EsE7YKG42_\", \"New parent post not found\")\n@@ -2935,7 +2884,7 @@ trait PostsDao {\n         // others will be able to see / might-deduce-that hen also wrote [the post that got\n         // moved to another page].\n         // So, for now, disallow this. (Could allow, if the author deanonymizes the post.)\n-        ANON_UNIMPL; TESTS_MISSING // Verify this not allowed.  TyTMOVANONCOMT\n+        TESTS_MISSING // Verify this not allowed.  TyTMOVANONCOMT\n         throwForbiddenIf(postAuthor.isAnon, \"TyE4MW2LR5\",\n               \"Cannot move an anonymous post to another page\")\n       }\n@@ -3103,9 +3052,9 @@ trait PostsDao {\n   private def doFlagPost(pageId: PageId, postNr: PostNr, flagType: PostFlagType,\n         flaggerId: UserId): (Post, Boolean) = {\n \n-    // DO_AS_ALIAS: Anonymous flags might be needed? So an anon can flag a toxic comment\n-    // by another anon, without the mods realizing who the flagger is just because they\n-    // had to use their true account.\n+    ANON_UNIMPL // [anon_flags] Anonymous flags might be needed? So an anon can flag\n+    // a toxic comment by another anon, without the mods realizing who the flagger is\n+    // just because they had to use their true account.\n \n     writeTx { (tx, staleStuff) =>\n       val flagger = tx.loadTheUser(flaggerId)"
    },
    {
      "sha": "7209be1b2c356710a3a5923e2414fbf75e5ce560",
      "filename": "appsv/server/debiki/dao/ReviewsDao.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FReviewsDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FReviewsDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FReviewsDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -414,6 +414,7 @@ trait ReviewsDao {   // RENAME to ModerationDao,  MOVE to  talkyard.server.modn\n                         // So it's missing [save_mod_br_inf]. But not missing when called\n                         // from this.moderatePostInstantly(). Oh well.\n                         browserIdData = BrowserIdData.Missing),\n+                  asAlias = None, // [anon_mods]\n                   tx, staleStuff).updatedPost\n           }\n           else {\n@@ -525,7 +526,7 @@ trait ReviewsDao {   // RENAME to ModerationDao,  MOVE to  talkyard.server.modn\n             // If staff deletes many posts by this user, mark it as a moderate threat?\n             // That'll be done from inside update-because-deleted fn below. [DETCTHR]\n             else if (taskIsForBothTitleAndBody) {\n-              deletePagesImpl(Seq(pageId), reqr)(tx, staleStuff)\n+              deletePagesImpl(Seq(pageId), reqr, asAlias = None /*[anon_mods]*/)(tx, staleStuff)\n               // Posts not individually deleted, instead, whole page gone // [62AKDN46]\n               (Seq.empty, Some(pageId))\n             }"
    },
    {
      "sha": "a29a910e2bae98878a03c89b26bd3f466404c831",
      "filename": "appsv/server/debiki/dao/SearchDao.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FSearchDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FSearchDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FSearchDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -20,6 +20,7 @@ package debiki.dao\n import com.debiki.core._\n import com.debiki.core.Prelude._\n import talkyard.server.search._\n+import talkyard.server.authz.Authz\n import talkyard.server.authz.AuthzCtxOnForum\n import scala.collection.{mutable => mut}\n import scala.collection.immutable.Seq\n@@ -127,7 +128,7 @@ trait SearchDao {\n       val hitsAndPostsMaySee: Seq[(SearchHit, Post)] = hits flatMap { hit =>\n         postsById.get(hit.postId) flatMap { post =>\n           val (seePost, debugCode) =\n-                maySeePostIfMaySeePage(reqr, post)\n+                Authz.maySeePostIfMaySeePage(reqr, post)\n           if (!seePost.may) None\n           else Some(hit -> post)\n         }"
    },
    {
      "sha": "031e88a4c6bb67b545ea4457b12c6403a24495c2",
      "filename": "appsv/server/debiki/dao/SiteDao.scala",
      "status": "modified",
      "additions": 102,
      "deletions": 22,
      "changes": 124,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FSiteDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FSiteDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FSiteDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -31,9 +31,11 @@ import scala.collection.immutable\n import talkyard.server.TyContext\n import talkyard.server.authz.MayMaybe\n import talkyard.server.notf.NotificationGenerator\n+import talkyard.server.parser\n import talkyard.server.pop.PagePopularityDao\n import talkyard.server.pubsub.{PubSubApi, StrangerCounterApi}\n import talkyard.server.summaryemails.SummaryEmailsDao\n+import play.api.libs.json.JsObject\n import org.scalactic.{ErrorMessage, Or}\n import java.util.concurrent.TimeUnit\n import java.util.concurrent.locks.ReentrantLock\n@@ -895,51 +897,129 @@ object SiteDao extends TyLogging {\n   }\n \n \n-  /** If the requester is doing sth anonymously (e.g. anon comments or votes),\n+  /** For rejecting a request early, if an invalid alias is specified,\n+    * while `getAliasOrTruePat()` (below) is used later, in a db tx, to get or lazy-create\n+    * the alias.\n+    *\n+    * @param reqBody If a persona is specified in the request body, it overrides\n+    *   any persona mode. [choose_persona]\n+    * @param reqr The person doing the thing. Rename to 'prin(cipal)'? [rename_2_principal]\n+    * @param modeAlias Any persona mode alias (e.g. if entering Anonymous Mode).\n+    * @param mayCreateAnon If editing one's old comment, should reuse the same anon\n+    *   as when posting the comment; may not create a new.\n+    * @param mayReuseAnon If creating a new page, there's no anonym on that page\n+    *   to reuse, yet.\n+    */\n+  def checkAliasOrThrowForbidden(reqBody: JsObject, reqr: Pat, modeAlias: Opt[WhichAliasPat],\n+          mayCreateAnon: Bo = true, mayReuseAnon: Bo = true,\n+          )(dao: SiteDao): Opt[WhichAliasPat] = {\n+\n+    TESTS_MISSING // [misc_alias_tests], check callers\n+\n+    // Any 'doAsAnon' in the request json body telling us which persona to use?\n+    val anyAliasIdInReqBody: Opt[WhichAliasId] =\n+          parser.parseDoAsAnonField(reqBody) getOrIfBad { prob =>\n+            throwBadReq(\"TyEPERSBDYJSN\", s\"Bad persona req body json: $prob\")\n+          }\n+\n+    // The actual anonym or pseudonym, after having looked up by id.\n+    val anyAliasPatInReqBody: Opt[Opt[WhichAliasPat]] = anyAliasIdInReqBody map {\n+      case WhichAliasId.Oneself =>\n+        // Any alias should be the *principal*'s alias, not the requester's — but\n+        // currently the requester and principal are the same, for all endpoints that\n+        // support persona mode, see  [alias_4_principal].\n+        None\n+\n+      case sa: WhichAliasId.SameAnon =>\n+        throwForbiddenIf(!mayReuseAnon, \"TyEREUSEANON\", \"Cannot reuse anonym here\")\n+        val anon = dao.getTheParticipant(sa.sameAnonId).asAnonOrThrow\n+        throwForbiddenIf(anon.anonForPatId != reqr.id,\n+              \"TyE0YOURANON01\", \"No your anonym\")\n+        Some(WhichAliasPat.SameAnon(anon))\n+\n+      case n: WhichAliasId.LazyCreatedAnon =>\n+        throwForbiddenIf(!mayCreateAnon, \"TyENEWANON1\", \"Cannot create anonym now\")\n+        Some(WhichAliasPat.LazyCreatedAnon(n.anonStatus))\n+    }\n+\n+    // if  anyAliasPatInReqBody.get != modeAlias  {\n+    //   Noop. It's ok if any Persona Mode alias is different from any alias in the\n+    //   request body. Then, one can switch to Persona Mode, but still do one-off\n+    //   things as sbd else if in an old discussion one was sbd else.\n+    // }\n+\n+    anyAliasPatInReqBody getOrElse modeAlias\n+  }\n+\n+\n+\n+  /** Gets or lazy-creates the specified alias, or just returns the user hanself (`truePat`).\n+    *\n+    * If the requester is doing sth anonymously (e.g. anon comments or votes),\n     * looks up & returns the anonymous user. Or creates a new anonymous user if\n-    * needed.  Otherwise just returns `truePat`.\n+    * needed.\n     *\n     * @param truePat The true person behind any anonym or pseudonym.\n     * @param pageId Anonyms are per page, each one is restricted to a single page.\n-    * @param doAsAlias The anonym or pseudonym to use.\n+    * @param asAlias The anonym or pseudonym to use.\n     * @param mayCreateAnon If the author of a page closes it or reopens it etc,\n-    *   han cannot create a new anonym to do that.\n+    *   han cannot create a new anonym to do that. Han needs to reuse the same\n+    *   persona, as when creating the page. (Otherwise others can guess that\n+    *   the real person and any anonym of hans are the same —  if they both can\n+    *   alter the same page. [deanon_risk])\n     */\n-  def getAliasOrTruePat(truePat: Pat, pageId: PageId, doAsAlias: Opt[WhichAnon],\n-          mayCreateAnon: Bo, isCreatingPage: Bo = false)(tx: SiteTx, mab: MessAborter): Pat = {\n-    // Dupl code. [get_anon]\n-    if (doAsAlias.isEmpty)\n+  def getAliasOrTruePat(truePat: Pat, pageId: PageId, asAlias: Opt[WhichAliasPat],\n+          mayCreateAnon: Bo = true, mayReuseAnon: Bo = true, isCreatingPage: Bo = false,\n+          )(tx: SiteTx, mab: MessAborter): Pat = {\n+    TESTS_MISSING // [misc_alias_tests], of callers.\n+\n+    if (asAlias.isEmpty)\n       return truePat\n \n-    doAsAlias.get match {\n-      case WhichAnon.SameAsBefore(anonId) =>\n-        val anon = tx.loadTheParticipant(anonId).asAnonOrThrow\n-        if (anon.anonForPatId != truePat.trueId2.trueId)\n-          mab.abortDeny(\"TyE0YOURANON\", \"No your alias\")\n+    asAlias.get match {\n+      case WhichAliasPat.SameAnon(anonOtherTx) =>\n+        if (!mayReuseAnon)\n+          mab.abort(\"TyEOLDANON2\", \"Cannot reuse anonym now\")\n+\n+        // (Maybe we don't actually need to reload the anon. Oh well.)\n+        val anon: Anonym = tx.loadTheParticipant(anonOtherTx.id).asAnonOrThrow\n+        if (anon.anonForPatId != truePat.id)\n+          mab.abortDeny(\"TyE0YOURANON2\", \"No your anon\")\n \n         anon\n \n-      case WhichAnon.NewAnon(anonStatus) =>\n+      case WhichAliasPat.LazyCreatedAnon(anonStatus: AnonStatus) =>\n+        if (!anonStatus.isAnon)\n+          return truePat\n+\n         if (!mayCreateAnon)\n-          mab.abort(\"TyENEWANON02\", \"Cannot create new anonym now\")\n+          mab.abort(\"TyENEWANON2\", \"Cannot create new anonym now\")\n+\n+        // Reuse any already existing anonym [one_anon_per_page] — at most one per page\n+        // and person, for now.\n+        val anyAnon = tx.loadAnyAnon(truePat.id, pageId = pageId, anonStatus)\n+        anyAnon foreach { anon =>\n+          dieIf(anon.anonForPatId != truePat.id, \"TyE7L02SLP3\")\n+          return anon\n+        }\n \n-        // Dupl code. [mk_new_anon]\n-        val anonymId = tx.nextGuestId\n-        val anonym = Anonym(\n-              id = anonymId,\n+        val anonId = tx.nextGuestId\n+        val newAnon = Anonym(\n+              id = anonId,\n               createdAt = tx.now,\n               anonStatus = anonStatus,\n               anonForPatId = truePat.id,\n               anonOnPageId = pageId)\n \n-        // We might insert a new anonym before the page exists, but there's a foreign key\n+        // We might insert the anonym before the page exists, but there's a foreign key\n         // from anons to pages:  pats_t.anon_on_page_id_st_c,  so defer constraints.\n         if (isCreatingPage) {\n           tx.deferConstraints()\n         }\n \n-        tx.insertAnonym(anonym)\n-        anonym\n+        tx.insertAnonym(newAnon)\n+        newAnon\n     }\n   }\n+\n }"
    },
    {
      "sha": "9034bbf5d264b7656e47943fb024e150f60ca162",
      "filename": "appsv/server/debiki/dao/UserDao.scala",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FUserDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Fdebiki%2Fdao%2FUserDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FUserDao.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -944,7 +944,7 @@ trait UserDao {\n       case ParsedRef.ExternalId(extId) =>\n         getParticipantByExtId(extId)\n       case ParsedRef.TalkyardId(tyId) =>\n-        tyId.toIntOption flatMap getParticipant\n+        tyId.toIntOption.flatMap(id => getParticipant(id))\n       case ParsedRef.UserId(id) =>\n         val pat = getParticipant(id)\n         returnBadUnlessIsUser(pat)\n@@ -1006,7 +1006,10 @@ trait UserDao {\n   }\n \n \n-  def getParticipant(userId: UserId): Option[Participant] = {\n+  def getParticipant(userId: UserId, anyTx: Opt[SiteTx] = None): Opt[Pat] = {\n+    anyTx foreach { tx =>\n+      return tx.loadParticipant(userId)\n+    }\n     memCache.lookup[Participant](\n       patKey(userId),\n       orCacheAndReturn = {"
    },
    {
      "sha": "3a8e60fbc8e65b3773bd75ebb690da32bef013cf",
      "filename": "appsv/server/talkyard/server/JsX.scala",
      "status": "modified",
      "additions": 45,
      "deletions": 36,
      "changes": 81,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2FJsX.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2FJsX.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2FJsX.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -29,6 +29,7 @@ import org.scalactic.{Bad, Good, Or}\n \n import com.debiki.core.Notification.NewPost\n import play.api.libs.json._\n+import talkyard.server.parser.DoAsAnonFieldName\n \n import scala.collection.immutable\n import scala.util.matching.Regex\n@@ -178,25 +179,6 @@ object JsX {   RENAME // to JsonPaSe\n   }\n \n \n-  /*  rm\n-  def JsAnon(anon: Anonym, inclRealId: Bo = false): JsObject = {  // ts: Anonym\n-    var json = Json.obj(\n-          \"id\" -> JsNumber(anon.id),\n-          \"isAnon\" -> JsTrue,\n-          \"isEmailUnknown\" -> JsTrue,  // or skip?\n-          )\n-    if (inclRealId) {\n-      json += \"anonForId\" -> JsNumber(anon.anonForPatId)\n-      //json += \"anonOnPageId\" -> JsString(anon.anonOnPageId),\n-      json += \"anonStatus\" -> JsNumber(anon.anonStatus.toInt)\n-    }\n-    if (anon.isGone) {\n-      json += \"isGone\" -> JsTrue\n-    }\n-    json\n-  } */\n-\n-\n   def JsUserOrNull(user: Option[Participant]): JsValue =  // RENAME to JsParticipantOrNull\n     user.map(JsUser(_)).getOrElse(JsNull)\n \n@@ -223,32 +205,32 @@ object JsX {   RENAME // to JsonPaSe\n \n   /** If 'user' is an anonym or pseudonym, then, hens true id is *not* included, unless\n     * toShowForPatId is hens true id  (or, later, if toShowForPatId has permission to\n-    * see anonyms ANON_UNIMPL).  That is, if the person requesting to see a page,\n+    * see anonyms  [see_alias]).  That is, if the person requesting to see a page,\n     * is the the same the ano/pseudony, then, the ano/pseudonym's true id is included\n     * so that that person can see hens own anonym(s).\n+    *\n+    * ts: Pat and subclasses, e.g. Guest, Anonym.\n     */\n   def JsUser(user: Pat, tags: Seq[Tag] = Nil, toShowForPatId: Opt[PatId] = None): JsObject = {  //RENAME to JsPat, ts: Pat\n     var json = JsPatNameAvatar(user)\n     user.smallAvatar foreach { uploadRef =>\n       json += \"avatarSmallHashPath\" -> JsString(uploadRef.hashPath)\n     }\n \n-    if (user.isAnon) {\n-      json += \"isAnon\" -> JsTrue\n-      // If this anonym is user `toShowForPatId`s own anonym, include details — so\n-      // that user can see it's hens own anonym.\n-      toShowForPatId foreach { showForPatId: PatId =>\n-        user match {\n-          case anon: Anonym =>\n-            if (anon.anonForPatId == showForPatId) {\n-              // [see_own_alias]\n-              json += \"anonForId\" -> JsNumber(anon.anonForPatId)\n-              //on += \"anonOnPageId\" -> JsString(anon.anonOnPageId),\n-              json += \"anonStatus\" -> JsNumber(anon.anonStatus.toInt)\n-            }\n-          case x => die(s\"An isAnon pat isn't an Anonym, it's an: ${classNameOf(x)}\")\n+    if (user.isAnon) user match {\n+      case anon: Anonym =>\n+        json += \"isAnon\" -> JsTrue  ; REMOVE // ?, maybe anonStatus is enough\n+        json += \"anonStatus\" -> JsNumber(anon.anonStatus.toInt)\n+        // If this anonym is user `toShowForPatId`s own anonym, include details — so\n+        // that user can see it's hens own anonym.\n+        toShowForPatId foreach { showForPatId: PatId =>\n+          if (anon.anonForPatId == showForPatId) {\n+            // [see_own_alias]\n+            json += \"anonForId\" -> JsNumber(anon.anonForPatId)\n+            //on += \"anonOnPageId\" -> JsString(anon.anonOnPageId),\n+          }\n         }\n-      }\n+      case x => die(s\"An isAnon pat isn't an Anonym, it's an: ${classNameOf(x)}\")\n     }\n     else if (user.isGuest) {\n       json += \"isGuest\" -> JsTrue\n@@ -1165,7 +1147,7 @@ object JsX {   RENAME // to JsonPaSe\n     draft.map(JsDraft).getOrElse(JsNull)\n \n   def JsDraft(draft: Draft): JsObject = {\n-    Json.obj(\n+    var res = Json.obj(\n       \"byUserId\" -> draft.byUserId,\n       \"draftNr\" -> draft.draftNr,\n       \"forWhat\" -> JsDraftLocator(draft.forWhat),\n@@ -1176,6 +1158,33 @@ object JsX {   RENAME // to JsonPaSe\n       \"postType\" -> JsNumberOrNull(draft.postType.map(_.toInt)),\n       \"title\" -> JsString(draft.title),\n       \"text\" -> JsString(draft.text))\n+    draft.doAsAnon foreach { whichAlias =>\n+      res += DoAsAnonFieldName -> JsWhichAliasId(whichAlias)\n+    }\n+    res\n+  }\n+\n+\n+  def JsWhichAliasId(which: WhichAliasId): JsObject = {\n+    import WhichAliasId._\n+    which match {\n+      case Oneself =>\n+        Json.obj(\n+            \"self\" -> true)\n+      case SameAnon(anonId: PatId) =>\n+        Json.obj(\n+            \"sameAnonId\" -> JsNumber(anonId),\n+            // Later, also incl: (but not yet saved in db, for drafts)  [chk_alias_status]\n+            //\"anonStatus\" -> anon.anonStatus\n+            )\n+      case LazyCreatedAnon(anonStatus: AnonStatus) =>\n+        Json.obj(\n+            \"anonStatus\" -> JsNumber(anonStatus.toInt),\n+            \"lazyCreate\" -> JsTrue)\n+      // Maybe later, also:\n+      // case NewAnon(anonStatus: AnonStatus) =>\n+      //    \"createNew_tst\" -> ...\n+    }\n   }\n \n "
    },
    {
      "sha": "d98a72c13f10859cc1cff4e524e29c86c6358868",
      "filename": "appsv/server/talkyard/server/TyController.scala",
      "status": "modified",
      "additions": 29,
      "deletions": 16,
      "changes": 45,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2FTyController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2FTyController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2FTyController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -75,8 +75,10 @@ class TyController(cc: ControllerComponents, val context: TyContext)\n   def GetActionRateLimited(\n         rateLimits: RateLimits = RateLimits.ExpensiveGetRequest,\n         minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n-        allowAnyone: Boolean = false)(f: GetRequest => Result): Action[Unit] =\n-    PlainApiAction(cc.parsers.empty, rateLimits, minAuthnStrength, allowAnyone = allowAnyone)(f)\n+        allowAnyone: Bo = false, canUseAlias: Bo = false, ignoreAlias: Bo = false,\n+        )(f: GetRequest => Result): Action[Unit] =\n+    PlainApiAction(cc.parsers.empty, rateLimits, minAuthnStrength, allowAnyone = allowAnyone,\n+          canUseAlias = canUseAlias, ignoreAlias = ignoreAlias)(f)\n \n   def StaffGetAction(f: GetRequest => Result): Action[Unit] =\n     PlainApiActionStaffOnly(NoRateLimits, cc.parsers.empty)(f)\n@@ -106,60 +108,71 @@ class TyController(cc: ControllerComponents, val context: TyContext)\n           skipXsrfCheck = skipXsrfCheck)(f)\n \n   def AsyncPostJsonAction(rateLimits: RateLimits, maxBytes: i32,\n+        canUseAlias: Bo = false, ignoreAlias: Bo = false,\n         allowAnyone: Bo = false, isGuestLogin: Bo = false, avoidCookies: Bo = false)(\n         f: JsonPostRequest => Future[Result]): Action[JsValue] =\n     PlainApiAction(cc.parsers.json(maxLength = maxBytes),\n-          rateLimits, allowAnyone = allowAnyone, isGuestLogin = isGuestLogin,\n+          rateLimits, allowAnyone = allowAnyone,\n+          canUseAlias = canUseAlias, ignoreAlias = ignoreAlias,\n+          isGuestLogin = isGuestLogin,\n           avoidCookies = avoidCookies).async(f)\n \n   def PostJsonAction(rateLimits: RateLimits,\n         minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n         maxBytes: Int,\n+        canUseAlias: Bo = false, ignoreAlias: Bo = false,\n         allowAnyone: Boolean = false, isLogin: Boolean = false)(\n         f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiAction(cc.parsers.json(maxLength = maxBytes),\n-        rateLimits, minAuthnStrength, allowAnyone = allowAnyone, isLogin = isLogin)(f)\n+        rateLimits, minAuthnStrength, allowAnyone = allowAnyone,\n+        canUseAlias = canUseAlias, ignoreAlias = ignoreAlias,\n+        isLogin = isLogin)(f)\n \n   def AsyncUserPostJsonAction(rateLimits: RateLimits, maxBytes: i32,\n         avoidCookies: Bo = false)(\n         f: JsonPostRequest => Future[Result]): Action[JsValue] =\n     PlainApiAction(cc.parsers.json(maxLength = maxBytes),\n       rateLimits, authnUsersOnly = true, avoidCookies = avoidCookies).async(f)\n \n-  def UserPostJsonAction(rateLimits: RateLimits, maxBytes: i32)(\n+  def UserPostJsonAction(rateLimits: RateLimits, maxBytes: i32, ignoreAlias: Bo = false)(\n         f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiAction(cc.parsers.json(maxLength = maxBytes),\n-      rateLimits, authnUsersOnly = true)(f)\n+      rateLimits, authnUsersOnly = true, ignoreAlias = ignoreAlias)(f)\n \n   def PostTextAction(rateLimits: RateLimits,\n         minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n-        maxBytes: Int, allowAnyone: Boolean = false)(\n+        maxBytes: Int, allowAnyone: Bo = false, ignoreAlias: Bo = false)(\n         f: ApiRequest[String] => Result): Action[String] =\n     PlainApiAction(cc.parsers.text(maxLength = maxBytes),\n-      rateLimits, minAuthnStrength, allowAnyone = allowAnyone)(f)\n+      rateLimits, minAuthnStrength, allowAnyone = allowAnyone, ignoreAlias = ignoreAlias)(f)\n \n   SECURITY // add rate limits for staff too. Started, use  StaffPostJsonAction2  below.\n   def StaffPostJsonAction(\n         minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n-        maxBytes: Int)(f: JsonPostRequest => Result): Action[JsValue] =\n+        maxBytes: i32, canUseAlias: Bo = false, ignoreAlias: Bo = false,\n+        )(f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiActionStaffOnly(\n-      NoRateLimits, cc.parsers.json(maxLength = maxBytes), minAuthnStrength)(f)\n+        NoRateLimits, cc.parsers.json(maxLength = maxBytes), minAuthnStrength,\n+        canUseAlias = canUseAlias, ignoreAlias = ignoreAlias)(f)\n \n   def StaffPostJsonAction2(\n         rateLimits: RateLimits, minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n-        maxBytes: Int)(f: JsonPostRequest => Result): Action[JsValue] =\n+        maxBytes: i32, canUseAlias: Bo = false, ignoreAlias: Bo = false)\n+        (f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiActionStaffOnly(\n-      rateLimits, cc.parsers.json(maxLength = maxBytes), minAuthnStrength)(f)\n+        rateLimits, cc.parsers.json(maxLength = maxBytes), minAuthnStrength,\n+        canUseAlias = canUseAlias, ignoreAlias = ignoreAlias)(f)\n \n   SECURITY // add rate limits for admins — use AdminPostJsonAction2, then remove this & rm '2' from name.\n-  def AdminPostJsonAction(maxBytes: Int)(f: JsonPostRequest => Result): Action[JsValue] =\n+  def AdminPostJsonAction(maxBytes: i32, ignoreAlias: Bo = false,\n+        )(f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiActionAdminOnly(\n-      NoRateLimits, cc.parsers.json(maxLength = maxBytes))(f)\n+      NoRateLimits, cc.parsers.json(maxLength = maxBytes), ignoreAlias = ignoreAlias)(f)\n \n-  def AdminPostJsonAction2(rateLimits: RateLimits, maxBytes: Int)(\n+  def AdminPostJsonAction2(rateLimits: RateLimits, maxBytes: Int, ignoreAlias: Bo = false)(\n         f: JsonPostRequest => Result): Action[JsValue] =\n     PlainApiActionAdminOnly(\n-      rateLimits, cc.parsers.json(maxLength = maxBytes))(f)\n+      rateLimits, cc.parsers.json(maxLength = maxBytes), ignoreAlias = ignoreAlias)(f)\n \n   def ApiSecretPostJsonAction(whatSecret: WhatApiSecret, rateLimits: RateLimits, maxBytes: i32)(\n         f: JsonPostRequest => Result): Action[JsValue] ="
    },
    {
      "sha": "1a3360aa67553ff5dd69fa519fbd08db141c2ea0",
      "filename": "appsv/server/talkyard/server/api/ActionDoer.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FActionDoer.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FActionDoer.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FActionDoer.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -67,7 +67,7 @@ case class ActionDoer(dao: SiteDao, reqrInf: ReqrInf, mab: MessAborter) {\n                   params.pageType, PageStatus.Published, inCatId = Some(cat.id), tags,\n                   anyFolder = None, anySlug = params.urlSlug, titleSourceAndHtml,\n                   bodyTextAndHtml, showId = true, deleteDraftNr = None, reqrTgt,\n-                  spamRelReqStuff = SystemSpamStuff, doAsAnon = None, refId = params.refId)\n+                  spamRelReqStuff = SystemSpamStuff, asAlias = None, refId = params.refId)\n         Json.obj(\n             \"pageId\" -> result.path.pageId,\n             \"pagePath\" -> result.path.value)\n@@ -82,7 +82,7 @@ case class ActionDoer(dao: SiteDao, reqrInf: ReqrInf, mab: MessAborter) {\n               dao.insertReplyIfAuZ(\n                   textAndHtml, pageId = pageMeta.pageId, replyToPostNrs = params.parentNr.toSet,\n                   params.postType, deleteDraftNr = None, reqrTgt,\n-                  spamRelReqStuff = SystemSpamStuff, anonHow = None, refId = params.refId,\n+                  spamRelReqStuff = SystemSpamStuff, asAlias = None, refId = params.refId,\n                   tags)  // ooops forgot_to_use\n         Json.obj(\n             \"postNr\" -> result.post.nr,"
    },
    {
      "sha": "56bdcf74ec75173ffc7f0f5df771368f613e55c1",
      "filename": "appsv/server/talkyard/server/api/GetController.scala",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FGetController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FGetController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FGetController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -129,10 +129,13 @@ class GetController @Inject()(cc: ControllerComponents, edContext: TyContext)\n           case Some(page: PagePathAndMeta) =>\n             COULD_OPTIMIZE // will typically always be same cat, for emb cmts.\n             val categories = dao.getAncestorCategoriesRootLast(page.categoryId)\n+            // COULD_OPTIMIZE [list_by_alias]\n+            val author = dao.getParticipant(page.meta.authorId).getOrDie(\"TyE502WTJT4\")\n             val may = talkyard.server.authz.Authz.maySeePage(  // _access_control\n                   page.meta,\n                   user = authzCtx.requester,\n                   groupIds = authzCtx.groupIdsUserIdFirst,\n+                  pageAuthor = author,\n                   pageMembers = Set.empty, // getAnyPrivateGroupTalkMembers(page.meta),\n                   catsRootLast = categories,\n                   tooManyPermissions = authzCtx.tooManyPermissions,"
    },
    {
      "sha": "f2f0e2985d4616e2892ae30e78efdc99e9befdfb",
      "filename": "appsv/server/talkyard/server/authz/Authz.scala",
      "status": "modified",
      "additions": 297,
      "deletions": 70,
      "changes": 367,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthz.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthz.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthz.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -19,6 +19,7 @@ package talkyard.server.authz\n \n import com.debiki.core._\n import com.debiki.core.Prelude._\n+import debiki.EdHttp.throwForbidden\n import scala.collection.immutable\n import MayMaybe._\n import MayWhat._\n@@ -201,7 +202,8 @@ object Authz {\n \n \n   def mayCreatePage(\n-    userAndLevels: UserAndLevels,\n+    userAndLevels: AnyUserAndLevels,\n+    asAlias: Opt[WhichAliasPat],\n     groupIds: immutable.Seq[GroupId],\n     pageRole: PageType,\n     bodyPostType: PostType,\n@@ -211,10 +213,12 @@ object Authz {\n     inCategoriesRootLast: immutable.Seq[Category],\n     tooManyPermissions: immutable.Seq[PermsOnPages]): MayMaybe = {\n \n-    val user = userAndLevels.user\n+    val anyUser: Opt[Pat] = userAndLevels.anyUser\n \n     val mayWhat = checkPermsOnPages(\n-          Some(user), groupIds, pageMeta = None, pageMembers = None,\n+          anyUser, asAlias = asAlias, groupIds,\n+          // Doesnt' yet exist.\n+          pageMeta = None, pageAuthor = None, pageMembers = None,\n           catsRootLast = inCategoriesRootLast, tooManyPermissions)\n \n     def isPrivate = pageRole.isPrivateGroupTalk && groupIds.nonEmpty &&\n@@ -230,7 +234,7 @@ object Authz {\n     if (!mayWhat.mayCreatePage && !isPrivate)\n       return NoMayNot(s\"EdEMN0CR-${mayWhat.debugCode}\", \"May not create a page in this category\")\n \n-    if (!user.isStaff) {\n+    if (!anyUser.exists(_.isStaff)) {\n       if (inCategoriesRootLast.isEmpty && !isPrivate)\n         return NoMayNot(\"EsEM0CRNOCAT\", \"Only staff may create pages outside any category\")\n \n@@ -271,13 +275,21 @@ object Authz {\n     pageMeta: PageMeta,\n     user: Opt[Pat],\n     groupIds: immutable.Seq[GroupId],\n+    pageAuthor: Pat,\n     pageMembers: Set[UserId],\n     catsRootLast: immutable.Seq[Cat],\n     tooManyPermissions: immutable.Seq[PermsOnPages],\n     maySeeUnlisted: Bo = true): MayMaybe = {\n \n     val mayWhat = checkPermsOnPages(\n-          user, groupIds, Some(pageMeta), Some(pageMembers),\n+          user,\n+          // [pseudonyms_later] Maybe should matter, for pseudonyms? If a pseudonym\n+          // gets added to a group, maybe it's good if one's true user cannot\n+          // accidentally post in a new category, just because one's pseudonym got\n+          // added there? [deanon_risk]  But for a start, simpler to just not\n+          // support granting permissions to pseuonyms.\n+          asAlias = None, // doesn't matter when deriving `maySee`\n+          groupIds, Some(pageMeta), pageAuthor = Some(pageAuthor), Some(pageMembers),\n           catsRootLast = catsRootLast, tooManyPermissions,\n           maySeeUnlisted = maySeeUnlisted)\n \n@@ -298,49 +310,63 @@ object Authz {\n   /** If pat may edit the page title & body, and settings e.g. page type,\n     * and open/close it, delete/undeleted, move to another category.\n     *\n-    * @param otherAuthor the page author, if it's someone else than `pat` — needed,\n-    *   so we can check if `pat` is actually the true author (if `otherAuthor` is hans alias).\n-    *   Confusing param name? Maybe simpler to rename to `pageAuthor` and always include,\n-    *   also if same as `pat`?\n-    *   Or better:   [_pass_alias]  ?\n+    * @param pat The user or guest who wants to edit the page.\n+    * @param asAlias If pat is editing the page anonymously or pseudonymously.\n+    * @param pageAuthor Needed, to know if `pat` is actually the true page author,\n+    *     but maybe created the page anonymously or pseudonymously, using alias `asAlias`.\n+    * @param groupIds `pat`s group ids.\n     */\n   def mayEditPage(\n         pageMeta: PageMeta,\n         pat: Pat,\n-        otherAuthor: Opt[Pat],\n+        asAlias: Opt[WhichAliasPat],\n+        pageAuthor: Pat,\n         groupIds: immutable.Seq[GroupId],\n         pageMembers: Set[UserId],\n         catsRootLast: immutable.Seq[Cat],\n         tooManyPermissions: immutable.Seq[PermsOnPages],\n         changesOnlyTypeOrStatus: Bo,\n         maySeeUnlisted: Bo): MayMaybe = {\n \n+    // Any `asAlias` \"inherits\" may-see-page permissions from the real user (`pat`).\n     val mayWhat = checkPermsOnPages(\n-          Some(pat), groupIds, Some(pageMeta), Some(pageMembers),\n+          Some(pat), asAlias = asAlias, groupIds = groupIds, Some(pageMeta),\n+          pageAuthor = Some(pageAuthor), pageMembers = Some(pageMembers),\n           catsRootLast = catsRootLast, tooManyPermissions,\n-          maySeeUnlisted = maySeeUnlisted, otherAuthor = otherAuthor)\n+          maySeeUnlisted = maySeeUnlisted)\n \n     if (mayWhat.maySee isNot true)\n       return NoNotFound(s\"TyEM0SEE2-${mayWhat.debugCode}\")\n \n-    val isOwnPage = _isOwn(pat, authorId = pageMeta.authorId, otherAuthor)\n+    val (isOwnPage, ownButWrongAlias) =  _isOwn(pat, asAlias, postAuthor = pageAuthor)\n \n     // For now, Core Members can change page type and doing status, if they\n     // can see the page (which we checked just above).  Later, this will be\n-    // the [alterPage] permission.\n+    // the [alterPage] permission. [granular_perms]\n     if (changesOnlyTypeOrStatus && pat.isStaffOrCoreMember) {\n       // Fine (skip the checks below).\n     }\n     else if (isOwnPage) {\n-      // Do this check in mayEditPost() too?  [.mayEditOwn]\n+      // Do this check in mayEditPost() too?  [.mayEditOwn] [granular_perms]\n+      BUG // Too restrictive: Might still be ok to edit, if `mayEditPage`.\n       if (!mayWhat.mayEditOwn)\n         return NoMayNot(s\"TyEM0EDOWN-${mayWhat.debugCode}\", \"\")\n+\n+      // Fine, may edit — if using the correct alias, see _checkDeanonRiskOfEdit().\n     }\n+    // else if (is mind map) — doesn't matter here\n+    // else if (is wiki) — doesn't matter (mayEditWiki is only for the page text,\n+    //                      but not the title, page type, category etc)\n     else {\n       if (!mayWhat.mayEditPage)\n         return NoMayNot(s\"TyEM0EDPG-${mayWhat.debugCode}\", \"\")\n     }\n \n+    _checkDeanonRiskOfEdit(isOwn = isOwnPage, ownButWrongAlias = ownButWrongAlias,\n+          asAlias = asAlias) foreach { mayNot =>\n+            return mayNot\n+          }\n+\n     // [wiki_perms] Maybe the whole page, and not just each post individually,\n     // could be wiki-editable? Then those with wiki-edit-permissions,\n     // could change the page type, doing-status, answer-post, title, etc.\n@@ -356,8 +382,8 @@ object Authz {\n \n   def maySeeCategory(authzCtx: ForumAuthzContext, catsRootLast: immutable.Seq[Category])\n         : MayWhat = {\n-    checkPermsOnPages(authzCtx.requester, authzCtx.groupIdsUserIdFirst,\n-          pageMeta = None, pageMembers = None, catsRootLast = catsRootLast,\n+    checkPermsOnPages(authzCtx.requester, asAlias = None, authzCtx.groupIdsUserIdFirst,\n+          pageMeta = None, pageAuthor = None, pageMembers = None, catsRootLast = catsRootLast,\n           authzCtx.tooManyPermissions, maySeeUnlisted = false)\n   }\n \n@@ -369,10 +395,39 @@ object Authz {\n   }\n \n \n+  def maySeePostIfMaySeePage(pat: Opt[Pat], post: Post): (MaySeeOrWhyNot, St) = {\n+    CLEAN_UP // Dupl code, this stuff repeated in Authz.mayPostReply. [8KUWC1]\n+\n+    // Below: Since the requester may see the page, it's ok if hen learns\n+    // if a post has been deleted or it never existed? (Probably hen can\n+    // figure that out anyway, just by looking for holes in the post nr\n+    // sequence.)\n+\n+    // Staff may see all posts, if they may see the page. [5I8QS2A]\n+    ANON_UNIMPL // if post.createdById  is pat's own alias, han is the author and can see it.\n+    // Don't fix now — wait until true author id is incl in posts3/nodes_t? [posts3_true_id]\n+    def isStaffOrAuthor =\n+          pat.exists(_.isStaff) || pat.exists(_.id == post.createdById)\n+\n+    // Later, [priv_comts]: Exclude private sub threads, also if is staff.\n+\n+    if (post.isDeleted && !isStaffOrAuthor)\n+      return (MaySeeOrWhyNot.NopePostDeleted, \"6PKJ2RU-Post-Deleted\")\n+\n+    if (!post.isSomeVersionApproved && !isStaffOrAuthor)\n+      return (MaySeeOrWhyNot.NopePostNotApproved, \"6PKJ2RW-Post-0Apr\")\n+\n+    // Later: else if is meta discussion ... [METADISC]\n+\n+    (MaySeeOrWhyNot.YesMaySee, \"\")\n+  }\n+\n+\n   /** Sync w ts:  store_mayIReply()\n     */\n   def mayPostReply(\n     userAndLevels: UserAndLevels,\n+    asAlias: Opt[WhichAliasPat],\n     groupIds: immutable.Seq[GroupId],\n     postType: PostType,\n     pageMeta: PageMeta,\n@@ -383,11 +438,16 @@ object Authz {\n \n     val user = userAndLevels.user\n \n-    SHOULD // be check-perms-on pageid + postnr, not just page\n+    SHOULD // check perms on post too, not just page.  Need post author. [posts3_true_id]\n     val mayWhat = checkPermsOnPages(\n-          Some(user), groupIds, Some(pageMeta),\n-          Some(privateGroupTalkMemberIds), catsRootLast = inCategoriesRootLast,\n-          tooManyPermissions)\n+          Some(user), asAlias = asAlias, groupIds,\n+          Some(pageMeta),\n+          // ANON_UNIMPL: Needed, for maySeeOwn [granular_perms], and later, if there'll be\n+          // a mayReplyOnOwn permission?\n+          // But let's wait until true author id is incl in posts3/nodes_t. [posts3_true_id]\n+          pageAuthor = None,\n+          pageMembers = Some(privateGroupTalkMemberIds),\n+          catsRootLast = inCategoriesRootLast, tooManyPermissions)\n \n     if (mayWhat.maySee isNot true)\n       return NoNotFound(s\"TyEM0RE0SEE_-${mayWhat.debugCode}\")\n@@ -431,43 +491,63 @@ object Authz {\n   */\n \n \n+  /** Used also for pages, if editing the *text*.\n+    * Otherwise, for pages, mayEditPage() is used, e.g. to alter page type or\n+    * move the page to another category.\n+    *\n+    * @param ignoreAlias Helpful when just loading the source text to show in\n+    *   the editor — later, pat can choose [a persona to use for editing the post]\n+    *   that is allowed to edit it.\n+    * @param pageAuthor Needed, because of the `maySeeOwn` and `mayEditOwn` permissions.\n+    * @param postAuthor Needed, because of the `mayEditOwn`.\n+    */\n   def mayEditPost(\n-    userAndLevels: UserAndLevels,\n+    userAndLevels: UserAndLevels,  // CLEAN_UP: just use Pat instead?\n+    asAlias: Opt[WhichAliasPat],\n     groupIds: immutable.Seq[GroupId],\n     post: Post,\n-    otherAuthor: Opt[Pat],\n+    postAuthor: Pat,\n     pageMeta: PageMeta,\n+    pageAuthor: Pat,\n     privateGroupTalkMemberIds: Set[UserId],\n     inCategoriesRootLast: immutable.Seq[Category],\n-    tooManyPermissions: immutable.Seq[PermsOnPages]): MayMaybe = {\n+    tooManyPermissions: immutable.Seq[PermsOnPages],\n+    ignoreAlias: Bo = false,\n+    ): MayMaybe = {\n \n-    if (post.isDeleted)\n+    val user = userAndLevels.user\n+\n+    if (post.isDeleted && !user.isStaff)\n       return NoNotFound(\"TyEM0EDPOSTDELD\")\n \n-    val user = userAndLevels.user\n     val mayWhat = checkPermsOnPages(\n-          Some(user), groupIds, Some(pageMeta),\n-          Some(privateGroupTalkMemberIds), catsRootLast = inCategoriesRootLast,\n+          Some(user), asAlias = asAlias, groupIds, Some(pageMeta),\n+          pageAuthor = Some(pageAuthor),\n+          pageMembers = Some(privateGroupTalkMemberIds), catsRootLast = inCategoriesRootLast,\n           tooManyPermissions)\n \n     if (mayWhat.maySee isNot true)\n       return NoNotFound(s\"TyEM0ED0SEE-${mayWhat.debugCode}\")\n \n-    val isOwnPost = _isOwn(user, authorId = post.createdById, otherAuthor)\n+    val (isOwnPost, ownButWrongAlias) = _isOwn(user, asAlias, postAuthor = postAuthor)\n+    var mayBecauseWiki = false\n \n     if (isOwnPost) {\n-      // Fine, may edit.\n+      // Fine, may edit — if using the correct alias, see _checkDeanonRiskOfEdit().\n+\n       // But shouldn't:  isOwnPost && mayWhat[.mayEditOwn] ?  (2020-07-17)\n     }\n     else if (pageMeta.pageType == PageType.MindMap) {  // [0JUK2WA5]\n+      BUG // Too restrictive: Might still be ok to edit, if `mayEditWiki.\n       if (!mayWhat.mayEditPage)\n         return NoMayNot(\"TyEM0ED0YOURMINDM\", \"You may not edit other people's mind maps\")\n     }\n     else if (post.isWiki && mayWhat.mayEditWiki && !post.isTitle) {\n       // Fine, may edit.  But exclude titles, for now. Otherwise, could be\n       // surprising if an attacker renames a page to sth else, and edits it,\n       // and the staff don't realize which page got edited, since renamed?\n-      // I think titles aren't wikifiable at all, currently, anyway.\n+      // I think titles aren't wikifiable at all, currently, anyway. [alias_ed_wiki]\n+      mayBecauseWiki = true\n     }\n     else if (post.isOrigPost || post.isTitle) {\n       if (!mayWhat.mayEditPage)\n@@ -476,7 +556,24 @@ object Authz {\n     // Later: else if is meta discussion ... [METADISC]\n     else {\n       if (!mayWhat.mayEditComment)\n-        return NoMayNot(\"EdEM0ED0YOURPOST\", \"You may not edit other people's posts\")\n+        return NoMayNot(\"EdEM0ED0YOURPOST\", \"You may not edit other people's comments\")\n+    }\n+\n+    if (ignoreAlias) {\n+      // Skip the deanon risk check. (Pat is e.g. just *loading* the source text\n+      // of something to edit — then, not important to specify the correct alias, since\n+      // not modifying anything.\n+    }\n+    else if (mayBecauseWiki) {\n+      // The problem that others might guess that your anonym is you, if you\n+      // edit [a post originally posted as yourself] anonymously, doesn't apply to\n+      // wiki posts, since \"everyone\" can edit wiki posts.  [deanon_risk]\n+    }\n+    else {\n+      _checkDeanonRiskOfEdit(isOwn = isOwnPost, ownButWrongAlias = ownButWrongAlias,\n+            asAlias = asAlias) foreach { mayNot =>\n+              return mayNot\n+            }\n     }\n \n     Yes\n@@ -485,6 +582,7 @@ object Authz {\n \n   def mayFlagPost(\n     member: User,\n+    // asAlias — anonymous flags not yet supported\n     groupIds: immutable.Seq[GroupId],\n     post: Post,\n     pageMeta: PageMeta,\n@@ -508,7 +606,10 @@ object Authz {\n \n     SHOULD // be maySeePost pageid, postnr, not just page\n     val mayWhat = checkPermsOnPages(\n-          Some(member), groupIds, Some(pageMeta),\n+          Some(member), asAlias = None, groupIds, Some(pageMeta),\n+          // Needed for maySeeOwn? [granular_perms]\n+          // Wait until true author id in posts3/nodes_t. [posts3_true_id]\n+          pageAuthor = None,\n           Some(privateGroupTalkMemberIds), catsRootLast = inCategoriesRootLast,\n           tooManyPermissions)\n \n@@ -520,16 +621,17 @@ object Authz {\n \n \n   def maySubmitCustomForm(\n-    userAndLevels: AnyUserAndThreatLevel,\n+    userAndLevels: AnyUserAndLevels,\n+    // asAlias — not supported\n     groupIds: immutable.Seq[GroupId],\n     pageMeta: PageMeta,\n     inCategoriesRootLast: immutable.Seq[Category],\n     tooManyPermissions: immutable.Seq[PermsOnPages]): MayMaybe = {\n \n-    val user = userAndLevels.user\n-\n     val mayWhat = checkPermsOnPages(\n-          user, groupIds, Some(pageMeta), None, catsRootLast = inCategoriesRootLast,\n+          userAndLevels.anyUser, asAlias = None, groupIds,\n+          Some(pageMeta), pageAuthor = None, pageMembers = None,\n+          catsRootLast = inCategoriesRootLast,\n           tooManyPermissions)\n \n     if (mayWhat.maySee isNot true)\n@@ -562,15 +664,22 @@ object Authz {\n     */\n   private def checkPermsOnPages(\n     user: Opt[Pat],\n+    asAlias: Opt[WhichAliasPat],\n     groupIds: immutable.Seq[GroupId],\n     pageMeta: Opt[PageMeta],\n+    pageAuthor: Opt[Pat],\n     pageMembers: Opt[Set[UserId]],\n     catsRootLast: immutable.Seq[Category],\n     tooManyPermissions: immutable.Seq[PermsOnPages],\n     maySeeUnlisted: Bo = true,\n-    otherAuthor: Opt[Pat] = None,\n     ): MayWhat = {\n \n+    require(pageMeta.isDefined || pageAuthor.isEmpty, \"TyEAUTHORMETA\")\n+\n+    val anyAnonAlias: Opt[Anonym] = asAlias.flatMap(_.anyPat.flatMap(_.asAnonOrNone))\n+    require(anyAnonAlias.forall(_.anonForPatId == user.getOrDie(\"TyEALI0USR\").id),\n+          \"Anon true id != user id  [TyEANONFORID]\")  // [throw_or_may_not]\n+\n     // Admins, but not moderators, have access to everything.\n     // Why not mods? Can be good with a place for members to bring up problems\n     // with misbehaving mods, where those mods cannot read and edit & delete\n@@ -580,15 +689,13 @@ object Authz {\n \n     val isStaff = user.exists(_.isStaff)\n \n-    val isOwnPage = user.exists(u => pageMeta exists { page =>\n-      _isOwn(u, authorId = page.authorId, otherAuthor)\n-\n-      // Won't work, if creating as anon and then editing as oneself?:\n-      // user.exists(_.id == m.authorId) || doAsAlias.exists(_.id == m.authorId)\n-      //\n-      // But it's good if that won't work?  [deanon_risk]  Let's use  `useAlias: Opt[Anonym]`\n-      // instead of `otherAuthor` ?   [_pass_alias]\n-    })\n+    // (We ignore `_ownPageWrongAlias`, because it's about the *page* but we might be\n+    // interested in a comment on the page. Instead, the caller looks at the comment or\n+    // page. [alias_0_ed_others])\n+    //\n+    val (isOwnPage, _ownPageWrongAlias) = user.flatMap(u => pageAuthor map { thePageAuthor =>\n+        _isOwn(u, asAlias, postAuthor = thePageAuthor)\n+    }) getOrElse (false, false)\n \n     // For now, don't let people see pages outside any category. Hmm...?\n     // (<= 1 not 0: don't count the root category, no pages should be placed directly in them.)\n@@ -623,6 +730,8 @@ object Authz {\n               debugCode = \"EdMEDOWNMINDM\")\n \n       // Only page participants may see things like private chats. [PRIVCHATNOTFS]\n+      // Later: If some page members are aliases,  [anon_priv_msgs][anon_chats]\n+      // need to consider true ids.\n       if (meta.pageType.isPrivateGroupTalk) {\n         val thePageMembers: Set[MembId] = pageMembers getOrDie \"EdE2SUH5G\"\n         val theUser = user getOrElse {\n@@ -668,9 +777,15 @@ object Authz {\n       // — and thereafter, an admin sets the page author to someone else. Then,\n       // the user should not able to see or undelete the page any longer.\n       // Tests:  delete-pages.2br  TyTE2EDELPG602\n-      val deletedOwnPage = user exists { theUser =>\n-        pageMeta.exists(p => p.authorId == theUser.id && p.deletedById.is(theUser.id))\n-      }\n+      val deletedOwnPage = isOwnPage && user.exists({ theUser =>\n+        pageMeta.exists(page =>\n+              // Pat deleted the page as hanself?\n+              page.deletedById.is(theUser.id) ||\n+              // Pat deleted the page using an alias? — Since its pat's page (`isOwnPage`),\n+              // the page author must be pat's alias. Don't think needed: [posts3_true_id]\n+              pageAuthor.exists(a => page.deletedById.is(a.id)))\n+      })\n+\n       if (!deletedOwnPage)\n         return MayWhat.mayNotSee(\"TyEPAGEDELD_\")\n     }\n@@ -761,30 +876,131 @@ object Authz {\n       mayWhat = mayWhat.copyAsDeleted\n     }\n \n+    // If it's the wrong alias, it's still ok for the requester to look at the thing,\n+    // but han can't edit anything.\n+    for (thePageMeta <- pageMeta; anon <- anyAnonAlias) {\n+      // Is the anonym for this page? (We've checked `anon.anonForPatId` above already.)\n+      if (anon.anonOnPageId != thePageMeta.pageId)\n+        // Is it best to throw, or set mayWhat to false?  [throw_or_may_not]\n+        mayWhat = mayWhat.copyAsMayNothingOrOnlySee(\"-TyEANONPAGEID\")\n+    }\n+\n+    // Check if page or category settings allows anonyms. [derive_node_props_on_server]\n+    // [pseudonyms_later]\n+    val anyComtsStartAnon: Opt[NeverAlways] =\n+            pageMeta.flatMap(_.comtsStartAnon).orElse(\n+                // (Root last — so, the *first* category with `.comtsStartAnon` defined,\n+                // is the most specific one.)\n+                catsRootLast.find(_.comtsStartAnon.isDefined).flatMap(_.comtsStartAnon))\n+    val comtsStartAnon = anyComtsStartAnon getOrElse NeverAlways.NeverButCanContinue\n+\n+    // Later:\n+    // if (comtsStartAnon.toInt <= NeverAlways.Never.toInt) {\n+    //   // Can't even continue being anonymous.\n+    //   throwForbiddenIf(asAlias.isDefined, ...)\n+    // }\n+    // else\n+    if (comtsStartAnon.toInt <= NeverAlways.NeverButCanContinue.toInt) {\n+      asAlias foreach {\n+        case _: WhichAliasPat.LazyCreatedAnon =>\n+          // Can't create new anonyms here — anon comments aren't enabled, ...\n+          // (This might be a browser tab left open for long, and category settings\n+          // got changed, and thereafter the user submitted an anon comment which\n+          // was previously allowed but now isn't.)\n+          // (Throw or set mayWhat to false?  [throw_or_may_not])\n+          throwForbidden(\"TyEM0MKANON_\", \"You cannot be anonymous in this category (any longer)\")\n+        case _: WhichAliasPat.SameAnon =>\n+          // ... But it's ok to continue replying as an already existing anonym —\n+          // that's the \"can continue\" in `NeverAlways.NeverButCanContinue`.\n+          // (So, noop.)\n+      }\n+    }\n+    else {\n+      // COULD require an alias, if `cat.comtsStartAnon >= NeverAlways.AlwaysButCanContinue`,\n+      // but not really important now.\n+    }\n+\n+\n     mayWhat\n   }\n \n \n-  /** Says if whatever-it-is was created by `pat`, by comparing pat's id with that of\n-    * the author — but that won't work, if the author is one of pat's aliases (because\n-    * aliases have their own ids). Therefore, also compares with the true id of\n-    * any alias author (anonym or pseudonym).\n+  /** Says if a user or hans alias is the same as a post author. Or if the user\n+    * is using the wrong alias:\n     *\n-    * Maybe remove?  [_pass_alias]\n+    * Returns two bools, the first says if the post is trueUser' posts. If it is,\n+    * then, the 2nd says if trueUser is using the wrong alias. Look:\n+    * - (false, false) = sbd else's post\n+    * - (true, false) = is trueUser's page, created under alias `asAlias` if defined.\n+    * - (true, true) = problem: It's trueUser's page, but the wrong alias\n+    *       (wrong alias includes specifying an alias, when originally posting as oneself).\n+    * - (false, true) = can't happen: can't be both someone else's page and also\n+    *     tueUser's alias' page.\n+    *\n+    * @param trueUser the one who wants to view/edit/alter the post, possibly using\n+    *   an anonym or pseudonym `asAlias`.\n+    * @param asAlias must be `trueUser`s anonym or pseudonym.\n+    * @param postAuthor – so we can compare the author's true id with trueUser,\n+    *   for better error messages.\n     */\n-  def _isOwn(pat: Pat, authorId: PatId, author: Opt[Pat]): Bo = {\n-    if (pat.id == authorId) {\n-      true\n-    }\n-    else author.exists({\n-      // BUT isn't it safer to pass  pat & patsAlias  and require that the alias is\n-      // the same?  [deanon_risk]  So can't accidentally edit an anon page as oneself\n-      // (one's true id) just because it's one's own anonym — which others might then guess.\n-      case anon: Anonym =>\n-        dieIf(anon.id != authorId, \"TyE0PGAUTHOR\", s\"Anon ${anon.id} != author ${authorId}\")\n-        anon.anonForPatId == pat.id\n-      case _ => false\n-    })\n+  private def _isOwn(trueUser: Pat, asAlias: Opt[WhichAliasPat], postAuthor: Pat): (Bo, Bo) = {\n+    val isTrueUsers = trueUser.id == postAuthor.trueId2.trueId\n+    asAlias.flatMap(_.anyPat) match {\n+      case None =>\n+        val isByTrueUsersAlias = isTrueUsers && trueUser.id != postAuthor.id\n+        // If by an alias, then, we've specified the wrong alias, namely no alias or\n+        // a not-yet-created `LazyCreatedAnon`.\n+        val wrongAlias = isByTrueUsersAlias\n+        (isTrueUsers, wrongAlias)\n+\n+      case Some(alias) =>\n+        require(alias.trueId2.trueId == trueUser.id, s\"Not trueUser's alias. True user: ${\n+              trueUser.trueId2}, alias: ${alias.trueId2} [TyE0OWNALIAS1]\")\n+        val correctAlias = alias.id == postAuthor.id\n+        val ownButWrongAlias = isTrueUsers && !correctAlias\n+        (isTrueUsers, ownButWrongAlias)\n+    }\n+  }\n+\n+\n+  /** Returns `Some(NoMayNot)` if editing the post using the persona specified\n+    * (either an alias, if asAlias defined, or as oneself) would mean that others\n+    * might guess that the anonym you were/are using, is actually you. [deanon_risk] \n+    */\n+  private def _checkDeanonRiskOfEdit(isOwn: Bo, ownButWrongAlias: Bo,\n+        asAlias: Opt[WhichAliasPat]): Opt[NoMayNot] = {\n+\n+    // If true user U wrote something as hanself, han should edit it as hanself (as U).\n+    // Otherwise others might guess that [U's anonym or pseudonym doing the edits], is U.\n+    //\n+    ANON_UNIMPL // [mods_ed_own_anon] If user U can edit the page as hanself for\n+    // *other reasons than* `mayWhat.mayEditOwn`, then, that _is_ok. For example,\n+    // if U is a mod, then, others can see that han can edit the page because han is\n+    // a mod — and they can't conclude that han and [the anonym who posted the page]\n+    // are the same.  Not yet impl though. Currently, need to continue editing\n+    // anonymously (also if U is admin / mod).\n+    //\n+    if (ownButWrongAlias)\n+      return Some(asAlias.isEmpty\n+          ? NoMayNot(\"TyEM0ALIASEDTRUE\", // [true_0_ed_alias]\n+            // (This _is_ok, actually — if pat is a mod or admin. See comment above.)\n+            o\"\"\"You're trying to edit your post as yourself, but you posted it\n+                      anonymously. Then you should edit it anonymously too.\"\"\")\n+          | NoMayNot(\"TyEM0TRUEEDALIAS\",\n+            // [pseudonyms_later] Need to edit this message, if might be the wrong\n+            // pseudonym, not an anonym, that tries to edit.\n+            o\"\"\"You're trying to edit your own post anonymously, but you posted it\n+                      as yourself. Then you should edit it as yourself too.\"\"\"))\n+\n+    // Typically, only few users, say, moderators, can edit *other* people's posts.\n+    // So, if a mod edits others' posts anonymously, the others could guess that the\n+    // anonym is one of the moderators, that's no good. [alias_0_ed_others]\n+    if (!isOwn && asAlias.isDefined)\n+      return Some(NoMayNot(\"TyEM0ALIASEDOTHR\",\n+                    \"You cannot edit other people's pages anonymously, as of now\"))\n+\n+    // Fine. Posted as oneself, is editing as oneself. Or posted as anon, edits as anon.\n+    None\n   }\n \n }\n@@ -890,7 +1106,18 @@ case class MayWhat(\n     mayDeletePage = false,\n     mayDeleteComment = false,\n     mayCreatePage = false,\n-    mayPostComment = false)\n+    mayPostComment = false,\n+    debugCode = debugCode + \"-CPDELD\")\n+\n+  /** Sets everything to false (no-you-may-not), except for `maySee` and `maySeeOwn` which\n+    * are left as-is.\n+    */\n+  def copyAsMayNothingOrOnlySee(debugCode: St): MayWhat =\n+    MayWhat().copy( // everything false by default\n+          maySee = maySee,\n+          maySeeOwn = maySeeOwn,\n+          debugCode = this.debugCode + debugCode)\n+\n }\n \n "
    },
    {
      "sha": "945f33dced7fb9e9a89afb40d474991f8928e3de",
      "filename": "appsv/server/talkyard/server/authz/AuthzSiteDaoMixin.scala",
      "status": "modified",
      "additions": 46,
      "deletions": 38,
      "changes": 84,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthzSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthzSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthzSiteDaoMixin.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -20,7 +20,7 @@ package talkyard.server.authz\n import com.debiki.core._\n import com.debiki.core.Prelude._\n import debiki.dao.{MemCacheKey, SiteDao, CacheOrTx}\n-import debiki.EdHttp.throwNotFound\n+import debiki.EdHttp.{throwNotFound, throwForbidden, throwForbiddenIf}\n import MayMaybe.{NoMayNot, NoNotFound, Yes}\n import talkyard.server.http._\n import scala.collection.immutable\n@@ -36,7 +36,7 @@ trait AuthzSiteDaoMixin {\n     */\n   self: SiteDao =>\n \n-  import context.security.throwIndistinguishableNotFound\n+  import context.security.{throwNoUnless, throwIndistinguishableNotFound}\n \n \n   def deriveEffPatPerms(groupIdsAnyOrder: Iterable[GroupId]): EffPatPerms = {\n@@ -219,25 +219,33 @@ trait AuthzSiteDaoMixin {\n   }\n \n \n-  def throwIfMayNotSeePage2(pageId: PageId, reqrTgt: ReqrAndTgt, checkOnlyReqr: Bo = false\n-          )(anyTx: Opt[SiteTx]): U = {\n+  /** @return the page meta — the caller sort of always needs it.\n+    */\n+  def throwIfMayNotSeePage2(pageId: PageId, reqrTgt: AnyReqrAndTgt, checkOnlyReqr: Bo = false\n+          )(anyTx: Opt[SiteTx]): PageMeta = {\n     val pageMeta: PageMeta =\n           anyTx.map(_.loadPageMeta(pageId)).getOrElse(getPageMeta(pageId)) getOrElse {\n             throwIndistinguishableNotFound(s\"TyEM0SEEPG1\")\n           }\n     {\n-      val seePageResult = maySeePageImpl(pageMeta, Some(reqrTgt.reqr), anyTx)\n+      val seePageResult = maySeePageImpl(pageMeta, reqrTgt.anyReqr, anyTx)\n       if (!seePageResult.maySee)\n         throwIndistinguishableNotFound(s\"TyEM0SEEPG2-${seePageResult.debugCode}\")\n     }\n \n     if (reqrTgt.areNotTheSame && !checkOnlyReqr) {\n       COULD_OPTIMIZE // Getting categories and permissions a 2nd time here.\n       val res2 = maySeePageImpl(pageMeta, reqrTgt.otherTarget, anyTx)\n-      if (!res2.maySee)\n-        throwNotFound(s\"TyEM0SEEPG3-${res2.debugCode}\",\n-              o\"${reqrTgt.target.nameParaId} may not see page $pageId\")\n+      if (!res2.maySee) {\n+        // (It's ok with a more detailed Not Fond message —  we already know that the\n+        // requester can see the page, so han can figure out that `otherTarget`\n+        // can't see it, in any case.)\n+        throwNotFound(s\"TyEM0SEEPG3-${res2.debugCode}\", s\"${reqrTgt.otherTarget.getOrDie(\n+              \"TyE70SKJF4\").nameParaId} may not see page $pageId\")\n+      }\n     }\n+\n+    pageMeta\n   }\n \n \n@@ -320,8 +328,13 @@ trait AuthzSiteDaoMixin {\n         getAnyPrivateGroupTalkMembers(pageMeta)\n       }\n \n-    Authz.maySeePage(pageMeta, authzContext.requester, authzContext.groupIdsUserIdFirst, memberIds,\n-        categories, authzContext.tooManyPermissions, maySeeUnlisted) match {\n+    val pageAuthor = this.getParticipant(pageMeta.authorId, anyTx) getOrElse {\n+      return NotSeePage(\"TyE0PGAUTHOR2\")\n+    }\n+\n+    Authz.maySeePage(pageMeta, authzContext.requester,\n+          authzContext.groupIdsUserIdFirst, pageAuthor = pageAuthor, memberIds,\n+          categories, authzContext.tooManyPermissions, maySeeUnlisted) match {\n       case Yes => PageCtx(categories)\n       case mayNot: NoMayNot => NotSeePage(mayNot.code)\n       case mayNot: NoNotFound => NotSeePage(mayNot.debugCode)\n@@ -431,34 +444,7 @@ trait AuthzSiteDaoMixin {\n     if (!seePageResult.maySee)\n       return (MaySeeOrWhyNot.NopeUnspecified, s\"${seePageResult.debugCode}-ABX94WN_\")\n \n-    maySeePostIfMaySeePage(ppt, post)\n-  }\n-\n-\n-  def maySeePostIfMaySeePage(pat: Opt[Pat], post: Post): (MaySeeOrWhyNot, St) = {\n-    val ppt = pat\n-\n-    MOVE // to Authz, should be a pure fn.\n-    CLEAN_UP // Dupl code, this stuff repeated in Authz.mayPostReply. [8KUWC1]\n-\n-    // Below: Since the requester may see the page, it's ok if hen learns\n-    // if a post has been deleted or it never existed? (Probably hen can\n-    // figure that out anyway, just by looking for holes in the post nr\n-    // sequence.)\n-\n-    // Staff may see all posts, if they may see the page. [5I8QS2A]\n-    def isStaffOrAuthor =\n-      ppt.exists(_.isStaff) || ppt.exists(_.id == post.createdById)\n-\n-    if (post.isDeleted && !isStaffOrAuthor)\n-      return (MaySeeOrWhyNot.NopePostDeleted, \"6PKJ2RU-Post-Deleted\")\n-\n-    if (!post.isSomeVersionApproved && !isStaffOrAuthor)\n-      return (MaySeeOrWhyNot.NopePostNotApproved, \"6PKJ2RW-Post-0Apr\")\n-\n-    // Later: else if is meta discussion ... [METADISC]\n-\n-    (MaySeeOrWhyNot.YesMaySee, \"\")\n+    Authz.maySeePostIfMaySeePage(ppt, post)\n   }\n \n \n@@ -477,6 +463,28 @@ trait AuthzSiteDaoMixin {\n   }\n \n \n+  def throwIfMayNotAlterPage(user: Pat, asAlias: Opt[WhichAliasPat], pageMeta: PageMeta,\n+         changesOnlyTypeOrStatus: Bo, tx: SiteTx): U = {\n+    val pageAuthor =\n+          if (pageMeta.authorId == user.id) user\n+          else this.getTheParticipant(pageMeta.authorId)\n+\n+    val catsRootLast = this.getAncestorCategoriesSelfFirst(pageMeta.categoryId)\n+    val requestersGroupIds = this.getOnesGroupIds(user)\n+    throwNoUnless(Authz.mayEditPage(\n+          pageMeta = pageMeta,\n+          pat = user,\n+          asAlias = asAlias,\n+          pageAuthor = pageAuthor,\n+          groupIds = requestersGroupIds,\n+          pageMembers = this.getAnyPrivateGroupTalkMembers(pageMeta),\n+          catsRootLast = catsRootLast,\n+          tooManyPermissions = this.getPermsOnPages(catsRootLast),\n+          changesOnlyTypeOrStatus = changesOnlyTypeOrStatus,\n+          maySeeUnlisted = true), \"TyE0ALTERPGP01\")\n+  }\n+\n+\n   @deprecated(\"now\", \"use getPermsForPeople instead?\")\n   def getPermsOnPages(categories: immutable.Seq[Category]): immutable.Seq[PermsOnPages] = {\n     getAllPermsOnPages().permsOnPages"
    },
    {
      "sha": "bef7792807361661a257e19f0486787543a6d83d",
      "filename": "appsv/server/talkyard/server/authz/ReqrAndTgt.scala",
      "status": "modified",
      "additions": 15,
      "deletions": 6,
      "changes": 21,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FReqrAndTgt.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FReqrAndTgt.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FReqrAndTgt.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -24,6 +24,9 @@ sealed trait AnyReqrAndTgt {\n     */\n   def otherTarget: Opt[Pat] = None\n \n+  /** If the requester and target are not the same user. */\n+  def areNotTheSame: Bo = false\n+\n   /** For casting the requester to admin, to invoke admin-only functions.\n     * But if the requester is *not* an admin, then, this fn aborts the request,\n     * the server replies Forbidden.\n@@ -51,18 +54,24 @@ sealed trait AnyReqrAndTgt {\n }\n \n \n-/** Requester and target.\n+/** Requester and target. Or, RENAME \"target\" to \"principal\"?  [rename_2_principal]\n+  * \"Prin\" is an abbreviation for 1) \"principal\" and 2) \"principle\" — let's use \"prin\"?\n+  * See: https://www.merriam-webster.com/dictionary/prin\n+  *\n+  * And RENAME this class to  ReqrAndPrin  for \"requester and principal\",\n+  * and instead of \"tgt\", use \"prin\" everywhere. (It's ok to abbreviate\n+  * more commonly used words, and \"principal\" will be \"everywhere\")\n   *\n-  * The requester (the participant doing the request), and the target of the request,\n-  * are usually the same. For example, a user configures their own settings,\n+  * The requester (the participant doing the request) and the principal\n+  * are usually the same. For example, a user configures *hans own* settings,\n   * or looks at a page, or replies to a post.\n   *\n   * But admins and mods can do things on behalf of others. For example, the requester\n   * can be an admin, who configures notification settings for another user,\n-  * or for a group — that other user or group, is then the target user.\n+  * or for a group — that other user or group, is then the principal (or \"target\").\n   *\n   * (The browser info, e.g. ip addr, is about the requester's browser.  — The\n-  * target user might not be at their computer at all, or might be a bot or group.)\n+  * principal might not be at their computer at all, or might be a bot or group.)\n   *\n   * (Short name: \"Reqr\", \"Tgt\", because these requester-and-target classes will be\n   * frequently used — namely in *all* request handling code, eventually?)\n@@ -89,7 +98,7 @@ sealed trait ReqrAndTgt extends AnyReqrAndTgt {\n     if (target.id == reqr.id) None // not an *other* target, but the *same* as reqr\n     else Some(target)\n \n-  def areNotTheSame: Bo = target.id != reqr.id\n+  override def areNotTheSame: Bo = target.id != reqr.id\n }\n \n "
    },
    {
      "sha": "f030fff72f3def1f25d9ecf09686fb599c161bba",
      "filename": "appsv/server/talkyard/server/http/DebikiRequest.scala",
      "status": "modified",
      "additions": 17,
      "deletions": 8,
      "changes": 25,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FDebikiRequest.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FDebikiRequest.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FDebikiRequest.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -106,6 +106,10 @@ abstract class AuthnReqHeader extends SomethingToRateLimit {\n   def theReqer: Pat = theUser  // shorter, better\n   def reqr: Pat = theUser  // better\n \n+  def anyAliasPat: Opt[WhichAliasPat] =\n+    die(\"TyEUSINGALIAS\", \"Cannot use an anonym or pseudonym when doing this\")\n+\n+\n   def tenantId: SiteId = dao.siteId\n   def siteId: SiteId = dao.siteId\n   def isDefaultSite: Boolean = siteId == globals.defaultSiteId\n@@ -133,6 +137,11 @@ abstract class AuthnReqHeader extends SomethingToRateLimit {\n     case Some(theReqr) => ReqrAndTgt(theReqr, theBrowserIdData, target = theReqr)\n   }\n \n+  def theReqrTargetSelf: ReqrAndTgt = reqer match {\n+    case None => throwForbidden(\"TyE0LGDIN2\", \"Not logged in\")\n+    case Some(theReqr) => ReqrAndTgt(theReqr, theBrowserIdData, target = theReqr)\n+  }\n+\n   def reqrAndTarget(target: Pat): ReqrAndTgt =\n     ReqrAndTgt(theReqer, theBrowserIdData, target = target)\n \n@@ -165,20 +174,20 @@ abstract class AuthnReqHeader extends SomethingToRateLimit {\n   def theReqerId: PatId = theRequesterId // shorter, nice\n   def theReqerTrueId: TrueId = theUser.trueId2\n \n-  def userAndLevels: AnyUserAndThreatLevel = {\n-    val threatLevel = user match {\n+  // [dupl_load_lvls]\n+  def userAndLevels: AnyUserAndLevels = {\n+    user match {\n       case Some(user) =>\n-        COULD_OPTIMIZE // this loads the user again (2WKG06SU)\n-        val userAndLevels = theUserAndLevels\n-        userAndLevels.threatLevel\n+        COULD_OPTIMIZE // this loads the user again [2WKG06SU]\n+        theUserAndLevels\n       case None =>\n-        dao.readOnlyTransaction(dao.loadThreatLevelNoUser(theBrowserIdData, _))\n+        val threatLevel = dao.readTx(dao.loadThreatLevelNoUser(theBrowserIdData, _))\n+        StrangerAndThreatLevel(threatLevel)\n     }\n-    AnyUserAndThreatLevel(user, threatLevel)\n   }\n \n   def theUserAndLevels: UserAndLevels = {\n-    COULD_OPTIMIZE // cache levels + user in dao (2WKG06SU), + don't load user again\n+    COULD_OPTIMIZE // cache levels + user in dao [2WKG06SU], + don't load user again\n     dao.readOnlyTransaction(dao.loadUserAndLevels(who, _))\n   }\n "
    },
    {
      "sha": "58b1ec845f2b80df52e4671ba578eb5dd60c6798",
      "filename": "appsv/server/talkyard/server/http/PlainApiActions.scala",
      "status": "modified",
      "additions": 152,
      "deletions": 7,
      "changes": 159,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FPlainApiActions.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FPlainApiActions.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FPlainApiActions.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -29,12 +29,14 @@ import java.{util => ju}\n import play.api.mvc._\n import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n+import EdSecurity.PersonaHeaderName\n import EdSecurity.AvoidCookiesHeaderName\n import scala.collection.mutable\n import play.api.http.{HeaderNames => p_HNs}\n import play.api.mvc.{Results => p_Results}\n import talkyard.server.TyLogging\n import talkyard.server.authn.MinAuthnStrength\n+import JsonUtils.{parseOptSt, asJsObject, parseOptJsObject, parseOptBo}\n \n \n /** Play Framework Actions for requests to Talkyard's HTTP API.\n@@ -58,24 +60,29 @@ class PlainApiActions(\n         isGuestLogin: Bo = false,\n         isLogin: Bo = false,\n         authnUsersOnly: Bo = false,\n+        canUseAlias: Bo = false,\n+        ignoreAlias: Bo = false,\n         avoidCookies: Bo = false,\n         skipXsrfCheck: Bo = false,\n         ): ActionBuilder[ApiRequest, B] =\n     PlainApiActionImpl(parser, rateLimits, minAuthnStrength = minAuthnStrength,\n         authnUsersOnly = authnUsersOnly,\n+        canUseAlias = canUseAlias, ignoreAlias = ignoreAlias,\n         allowAnyone = allowAnyone, isLogin = isLogin, isGuestLogin = isGuestLogin,\n         avoidCookies = avoidCookies, skipXsrfCheck = skipXsrfCheck)\n \n   def PlainApiActionStaffOnly[B](\n           rateLimits: RateLimits,\n           parser: BodyParser[B],\n           minAuthnStrength: MinAuthnStrength = MinAuthnStrength.Normal,\n+          canUseAlias: Bo = false, ignoreAlias: Bo = false,\n           ): ActionBuilder[ApiRequest, B] =\n-    PlainApiActionImpl(parser, rateLimits, minAuthnStrength, staffOnly = true)\n+    PlainApiActionImpl(parser, rateLimits, minAuthnStrength, staffOnly = true,\n+          canUseAlias = canUseAlias, ignoreAlias = ignoreAlias)\n \n-  def PlainApiActionAdminOnly[B](rateLimits: RateLimits, parser: BodyParser[B])\n-        : ActionBuilder[ApiRequest, B] =\n-    PlainApiActionImpl(parser, rateLimits, adminOnly = true)\n+  def PlainApiActionAdminOnly[B](rateLimits: RateLimits, parser: BodyParser[B],\n+        ignoreAlias: Bo = false): ActionBuilder[ApiRequest, B] =\n+    PlainApiActionImpl(parser, rateLimits, adminOnly = true, ignoreAlias = ignoreAlias)\n \n   def PlainApiActionApiSecretOnly[B](whatSecret: WhatApiSecret, rateLimits: RateLimits,\n         parser: BodyParser[B])\n@@ -104,6 +111,8 @@ class PlainApiActions(\n         adminOnly: Boolean = false,\n         staffOnly: Boolean = false,\n         authnUsersOnly: Bo = false,\n+        canUseAlias: Bo = false,\n+        ignoreAlias: Bo = false,\n         allowAnyone: Boolean = false,  // try to delete 'allowAnyone'? REFACTOR\n         avoidCookies: Boolean = false,\n         isGuestLogin: Bo = false,\n@@ -113,6 +122,9 @@ class PlainApiActions(\n         skipXsrfCheck: Bo = false): ActionBuilder[ApiRequest, B] =\n       new ActionBuilder[ApiRequest, B] {\n \n+    // Can't both use and ignore.\n+    assert(!(canUseAlias && ignoreAlias), \"TyE5LFG8M2\")\n+\n     val isUserLogin = isLogin // rename later\n     dieIf(isGuestLogin && isUserLogin, \"TyE306RJU243\")\n \n@@ -546,10 +558,14 @@ class PlainApiActions(\n     private def runBlockIfAuthOk[A](request: Request[A], site: SiteBrief, dao: SiteDao,\n           anyUserMaybeSuspended: Option[Participant],\n           anyTySession: Opt[TySession], sidStatus: SidStatus,\n-          xsrfOk: XsrfOk, browserId: Option[BrowserId], block: ApiRequest[A] => Future[Result])\n+          xsrfOk: XsrfOk, browserId: Option[BrowserId],\n+          block: ApiRequest[A] => Future[Result])\n           : Future[Result] = {\n+\n       val siteId = site.id\n \n+      // ----- User suspended?\n+\n       if (anyUserMaybeSuspended.exists(_.isAnon)) {\n         // Client side bug?\n         return Future.successful(\n@@ -588,6 +604,8 @@ class PlainApiActions(\n               None\n             }\n \n+      // ----- Valid request?\n+\n       // Re the !superAdminOnly test: Do allow access for superadmin endpoints,\n       // so they can reactivate this site, in case this site is the superadmin site itself.\n       // Sync w WebSocket endpoint. [SITESTATUS].\n@@ -647,6 +665,8 @@ class PlainApiActions(\n         dieUnless(anyTySession.exists(_.part4Absent), \"TyE70MWEG25SM\")\n       }\n \n+      // ----- For super admins?\n+\n       if (superAdminOnly) {\n         globals.config.superAdmin.siteIdString match {\n           case Some(siteId) if site.id.toString == siteId =>\n@@ -699,6 +719,8 @@ class PlainApiActions(\n         }\n       }\n \n+      // ----- Authenticated and approved?\n+\n       if (authnUsersOnly) {\n         if (!anyUser.exists(_.isUserNotGuest))\n           throwForbidden(\n@@ -753,8 +775,121 @@ class PlainApiActions(\n         }\n       }\n \n+      // ----- Anonymity?\n+\n+      val anyPersonaHeaderVal: Opt[St] =\n+            if (ignoreAlias) {\n+              // This reqest is on behalf of the true user, even if han has switched\n+              // to Anonymous mode or to a pseudonym.\n+              // E.g. to track one's reading progress [anon_read_progr].\n+              None\n+            }\n+            else {\n+              // The user might have swithecd to Anonymous mode  [alias_mode],\n+              // or han is anonymous automatically.\n+              request.headers.get(PersonaHeaderName)\n+            }\n+\n+      // [parse_pers_mode_hdr]  (Could break out function.)\n+      val anyAliasPat: Opt[WhichAliasPat] = anyPersonaHeaderVal flatMap { headerVal: St =>\n+        import play.api.libs.json.{JsObject, JsValue, Json}\n+        val personaJs: JsValue = scala.util.Try(Json.parse(headerVal)) getOrElse {\n+          throwBadRequest(\"TyEPERSOJSON\", s\"Invalid $PersonaHeaderName json\")\n+        }\n+        val personaJo: JsObject = asJsObject(personaJs, s\"Header $PersonaHeaderName\")\n+        val reqr = anyUser.getOrElse(throwForbidden(\"TyEPERSSTRA\",\n+              \"Can't specify persona when not logged in\"))\n+\n+        val mightModify = request.method != \"GET\" && request.method != \"OPTIONS\"\n+\n+        // If this endpoint modifies something (e.g. posts or edits a comment), but\n+        // doesn't support using anonyms or pseudonyms, we'll reject the request —\n+        // otherwise the modification(s) would be done as the true user (which would be\n+        // no good, since the user thinks han is using an alias).\n+        val rejectIfAlias = mightModify && !canUseAlias\n+\n+        // For safety: [persona_indicator_chk]  If no persona selected, but the browser\n+        // shows \"ones_username —> Anonymous\" (because one has been anonymous before\n+        // on the current page, or it's recommended), then, the browser sends\n+        //     { indicated: { self: true } | { anonStatus: ...} }\n+        // as persona mode json.\n+        val anyIndicatedJo: Opt[JsObject] = parseOptJsObject(personaJo, \"indicated\")\n+        val anyChoosenJo: Opt[JsObject] = parseOptJsObject(personaJo, \"choosen\")\n+        val isAmbiguous: Opt[Bo] = parseOptBo(personaJo, \"ambiguous\")\n+\n+        val numFields = personaJo.value.size\n+        val numKnownFields = anyIndicatedJo.oneIfDefined + anyChoosenJo.oneIfDefined +\n+                                isAmbiguous.oneIfDefined\n+\n+        throwBadReqIf(numFields > numKnownFields, \"TyEPERSUNKFLD\",\n+              s\"${numFields - numKnownFields} unknown persona json fields in: ${\n+              personaJo.value.keySet}\")\n+\n+        throwBadReqIf(anyChoosenJo.isDefined && anyIndicatedJo.isDefined,\n+              \"TyEPERSCHOIND\", \"Both choosen and indicated\")\n+\n+        throwBadReqIf(anyChoosenJo.isDefined && isAmbiguous.is(true),\n+              \"TyEPERSCHOAMB\", \"The choosen one is not ambiguous\")\n+\n+        if (rejectIfAlias) {\n+          // If the browser has indicated  [persona_indicator] to the user that they're\n+          // currently anonymous or using a pseudonym, but if this endpoint doesn't\n+          // support that, then, we should not continue.\n+          anyIndicatedJo foreach { indicatedJo =>\n+            // Doing things as oneself is fine, also for endpoints that don't support aliases.\n+            val anyIsSelf = parseOptBo(indicatedJo, \"self\")\n+            val ok = anyIsSelf is true\n+            throwForbiddenIf(!ok, \"TyEPERSONAUNSUP1\", o\"\"\"You cannot yet do this anonymously\n+                  — you need to enter Yourself mode, to do this, right now.\"\"\")\n+          }\n+          // Apart from the above test, we actually ignore any indicated persona —\n+          // the persona to use, is instead in the request body. (This makes it\n+          // possible to do one-off things as some other persona, if f.ex. you visit\n+          // an old discussion where you were using an old pseudonym, and want to\n+          // reply once as that old pseudonym, without having to enter and\n+          // then leave persona mode as that pseudonym. See the [choose_persona] fns.)\n+          // (We do consider any explicitly choosen Persona Mode though — see\n+          // `anyAliasId` and `anyAliasPat` just below.)\n+        }\n+\n+        val anyAliasId: Opt[WhichAliasId] = anyChoosenJo flatMap { jo =>\n+          talkyard.server.parser.parseWhichAliasIdJson(jo) getOrIfBad { prob =>\n+            throwBadReq(\"TyEPERSHDRJSN\", s\"Bad persona header json: $prob\")\n+          }\n+        }\n+\n+        val anyAliasPat: Opt[WhichAliasPat] = anyAliasId flatMap {\n+          case WhichAliasId.Oneself =>\n+            None // oneself is the default\n+          case which: WhichAliasId.SameAnon =>\n+            val anon = dao.getTheParticipant(which.sameAnonId).asAnonOrThrow\n+            // If, later on, the requester and principal can be different,  [alias_4_principal]\n+            // we should compare w the principal's id instead.\n+            throwForbiddenIf(anon.anonForPatId != reqr.id,\n+                  \"TyE0YOURANON02\", \"No your anonym in persona header\")\n+            Some(WhichAliasPat.SameAnon(anon))\n+          case which: WhichAliasId.LazyCreatedAnon =>\n+            Some(WhichAliasPat.LazyCreatedAnon(which.anonStatus))\n+        }\n+\n+        // If the user is trying to do / change something, using an\n+        // alias — but this endpoint doesn't currently support that, then,\n+        // reject this request. Better than suddenly & surprisingly doing\n+        // something as the user hanself (not anonymously).\n+        throwForbiddenIf(rejectIfAlias && anyAliasPat.isDefined,\n+              \"TyEPERSONAUNSUP2\", o\"\"\"You cannot yet do this anonymously\n+              — you need to leave Anonymous mode, to do this, right now.\"\"\")\n+\n+        anyAliasPat\n+      }\n+\n+      // ----- Construct request (Ty's wrapper)\n+\n       val apiRequest = ApiRequest[A](\n-        site, anyTySession, sidStatus, xsrfOk, browserId, anyUser, dao, request)\n+            site, anyTySession, sidStatus, xsrfOk, browserId, anyUser,\n+            dao, request)(anyAliasPat, mayUseAlias = canUseAlias)\n+\n+      // ----- Rate limits, tracing\n \n       rateLimiter.rateLimit(rateLimits, apiRequest)\n \n@@ -772,10 +907,18 @@ class PlainApiActions(\n         if (user.isModerator) tracerSpan.setTag(\"isModerator\", true)\n       }\n \n+      // ----- Run request handler\n+\n       val timer = globals.metricRegistry.timer(request.path)\n       val timerContext = timer.time()\n       var result = try {\n-        block(apiRequest)\n+\n+        // Invoke the request handler, do the actually interesting thing.\n+        val res = block(apiRequest)\n+\n+        devDieIf(canUseAlias && !apiRequest.aliasRead, \"TyEALIAS0READ\", \"Forgot to use alias\")\n+        devDieIf(!canUseAlias && apiRequest.aliasRead, \"TyEALIASREAD2\", \"Tried to use alias\")\n+        res\n       }\n       catch {\n         // case ProblemException ?  NEXT [ADMERRLOG] + tracer tag?\n@@ -798,6 +941,8 @@ class PlainApiActions(\n         timerContext.stop()\n       }\n \n+      // ----- Handle async errors\n+\n       result.onComplete({\n         case Success(_) =>\n           //logger.debug("
    },
    {
      "sha": "e8267d4e15edce441ecf5035ead07ef2d5daa2e6",
      "filename": "appsv/server/talkyard/server/http/package.scala",
      "status": "modified",
      "additions": 14,
      "deletions": 1,
      "changes": 15,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2Fpackage.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2Fpackage.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2Fpackage.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -18,6 +18,7 @@\n package talkyard.server\n \n import com.debiki.core._\n+import com.debiki.core.Prelude.devDieIf\n import debiki.dao.SiteDao\n import talkyard.server.security.{BrowserId, SidStatus, XsrfOk}\n import play.api.http.{HeaderNames => play_HeaderNames}\n@@ -103,7 +104,19 @@ package object http {\n     browserId: Opt[BrowserId],\n     user: Opt[Pat],\n     dao: SiteDao,\n-    request: p_Request[A]) extends DebikiRequest[A] {\n+    request: p_Request[A],\n+    )(private val _aliasPat: Opt[WhichAliasPat], private val mayUseAlias: Bo)\n+     extends DebikiRequest[A] {\n+\n+    private var _aliasRead: Bo = false\n+\n+    def aliasRead: Bo = _aliasRead\n+\n+    override def anyAliasPat: Opt[WhichAliasPat] = {\n+      devDieIf(!mayUseAlias, \"TyEALIASREAD1\", \"Trying to use an alias, not allowed here\")\n+      _aliasRead = true\n+      _aliasPat\n+    }\n   }\n \n "
    },
    {
      "sha": "8233be25fe9755a745757bdd7ccf9f8e93cbc6ce",
      "filename": "appsv/server/talkyard/server/parser/package.scala",
      "status": "modified",
      "additions": 63,
      "deletions": 32,
      "changes": 95,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fparser%2Fpackage.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fparser%2Fpackage.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fparser%2Fpackage.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1,11 +1,10 @@\n package talkyard.server\n \n import com.debiki.core._\n-import com.debiki.core.Prelude.dieIf\n-import debiki.JsonUtils.parseOptJsObject\n-import debiki.EdHttp.throwBadReq\n+import com.debiki.core.Prelude._\n+import debiki.JsonUtils.{parseOptBo, parseOptInt32, parseOptJsObject}\n import org.scalactic.{Bad, Good, Or}\n-import play.api.libs.json.JsObject\n+import play.api.libs.json.{JsObject, JsValue, JsFalse}\n \n \n /** Parsers and serializers, e.g. from-to JSON or from PASETO token claims.\n@@ -56,51 +55,83 @@ package object parser {\n   }\n \n \n-  def parseDoAsAliasJsonOrThrow(jOb: JsObject): Opt[WhichAnon] = {\n-    parseWhichAnonJson(jOb) getOrIfBad { prob =>\n-      throwBadReq(\"TyEBADALIAS\", s\"Bad doAsAnon params: $prob\")\n+  val DoAsAnonFieldName = \"doAsAnon\"\n+\n+\n+  def parseDoAsAnonField(jOb: JsObject): Opt[WhichAliasId] Or ErrMsg = {\n+    import play.api.libs.json.JsDefined\n+    (jOb \\ DoAsAnonFieldName) match {\n+      case jsDef: JsDefined => parseWhichAliasIdJson(jsDef.value)\n+      case _ => Good(None)\n     }\n   }\n \n \n-  val DoAsAnonFieldName = \"doAsAnon\"\n-\n-  /** Sync w  parseWhichAnon(..)  in com.debiki.dao.rdb. */\n-  def parseWhichAnonJson(jsOb: JsObject): Opt[WhichAnon] Or ErrMsg = {\n-    import debiki.JsonUtils.parseOptInt32\n+  /** Sync w  parseWhichAliasId(..)  in com.debiki.dao.rdb. */\n+  def parseWhichAliasIdJson(jsVal: JsValue): Opt[WhichAliasId] Or ErrMsg = {\n+    val doAsJsOb: JsObject = jsVal match {\n+      case jOb: JsObject => jOb\n+      case JsFalse => return Good(Some(WhichAliasId.Oneself))  // [oneself_0_false]\n+      case x => return Bad(s\"Bad persona json, got a: ${classNameOf(x)}  [TyEPERSJSN]\")\n+    }\n \n-    val doAsJsOb = parseOptJsObject(jsOb, DoAsAnonFieldName, falseAsNone = true) getOrElse {\n-      return Good(None)\n+    val numFields = doAsJsOb.value.size\n+    if (numFields > 2)\n+      return Bad(s\"Too many which-persona json fields: ${doAsJsOb.toString}  [TyEPERSFIELDS1]\")\n+\n+    val self: Opt[Bo] = parseOptBo(doAsJsOb, \"self\")\n+    if (self is true) {\n+      // Any ambiguities because of unknown fields?\n+      if (numFields > 1)\n+        return Bad(s\"Too many fields in a { self: true } which-persona json object, this: ${\n+                  doAsJsOb.toString}  [TyEPERSFIELDS2]\")\n+      return Good(Some(WhichAliasId.Oneself))\n     }\n \n     val sameAnonId: Opt[AnonId] = parseOptInt32(doAsJsOb, \"sameAnonId\")\n+    val lazyCreate: Bo = parseOptBo(doAsJsOb, \"lazyCreate\") getOrElse false\n+    val createNew_tst: Bo = parseOptBo(doAsJsOb, \"createNew_tst\") getOrElse false\n+\n+    // Later, when pseudonyms implemented, anonStatus might be absent. [pseudonyms_later]\n+    val anyAnonStatus: Opt[AnonStatus] = parseOptInt32(doAsJsOb, \"anonStatus\") map { int =>\n+      if (int == AnonStatus.NotAnon.IntVal) {\n+        if (numFields > 1)\n+          return Bad(s\"Anon fields, but anonStatus is NotAnon  [TyEPERS0ANON]\")\n \n-    val newAnonStatus: Opt[AnonStatus] = parseOptInt32(doAsJsOb, \"newAnonStatus\") map { int =>\n-      if (int == AnonStatus.NotAnon.IntVal)\n         return Good(None)\n+      }\n \n       AnonStatus.fromInt(int) getOrElse {\n-        return Bad(s\"Invalid newAnonStatus: $int\")\n+        return Bad(s\"Invalid anonStatus: $int  [TyEPERSANONSTS]\")\n       }\n     }\n \n-    if (sameAnonId.isDefined && newAnonStatus.isDefined)\n-      return Bad(\"Both sameAnonId and newAnonStatus specified\")\n+    anyAnonStatus match {\n+      case None =>\n+        if (numFields > 0)\n+          return Bad(\"anonStatus missing but there are anon fields  [TyEPERS0ANONSTS]\")\n \n-    Good {\n-      if (sameAnonId.isDefined) {\n-        val id = sameAnonId.get\n-        if (id > Pat.MaxAnonId)\n-          return Bad(s\"Bad anon id: $id, it's > MaxAnonId = ${Pat.MaxAnonId} [TyEBADANIDJSN]\")\n+        return Good(None)\n \n-        Some(WhichAnon.SameAsBefore(id))\n-      }\n-      else if (newAnonStatus.isDefined) {\n-        Some(WhichAnon.NewAnon(newAnonStatus.get))\n-      }\n-      else {\n-        None\n-      }\n+      case Some(anonStatus) =>\n+        if (sameAnonId.isDefined) {\n+          val id = sameAnonId.get\n+          if (id > Pat.MaxAnonId)\n+            return Bad(s\"Bad anon id: $id, it's > MaxAnonId = ${Pat.MaxAnonId}  [TyEPERSANONID]\")\n+\n+          COULD // remember anonStatus and verify later, when looking up the anon,\n+          // that it has the same anonStatus. [chk_alias_status]\n+          Good(Some(WhichAliasId.SameAnon(id)))\n+        }\n+        else if (lazyCreate) {\n+          Good(Some(WhichAliasId.LazyCreatedAnon(anonStatus)))\n+        }\n+        else if (createNew_tst) {\n+          Bad(\"Unimplemented: createNew_tst  [TyEPERSUNIMP]\")\n+        }\n+        else {\n+          Bad(\"Anon fields missing: Reuse or create anon?  [TyEPERS0FLDS]\")\n+        }\n     }\n   }\n }"
    },
    {
      "sha": "938c371f3a7eb553fea79650c6f19180c7980e05",
      "filename": "appsv/server/talkyard/server/plugins/utx/UsabilityTestingExchangeController.scala",
      "status": "modified",
      "additions": 18,
      "deletions": 3,
      "changes": 21,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fplugins%2Futx%2FUsabilityTestingExchangeController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fplugins%2Futx%2FUsabilityTestingExchangeController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fplugins%2Futx%2FUsabilityTestingExchangeController.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -20,6 +20,7 @@ package talkyard.server.plugins.utx\n import com.debiki.core._\n import com.debiki.core.Prelude._\n import debiki._\n+import debiki.dao.CreatePageResult\n import debiki.EdHttp._\n import talkyard.server._\n import talkyard.server.http.ApiRequest\n@@ -79,9 +80,23 @@ class UsabilityTestingExchangeController @Inject()(cc: ControllerComponents, tyC\n     val category = request.dao.getCategoryBySlug(categorySlug).getOrThrowBadArgument(\n       \"EsE0FYK42\", s\"No category with slug: $categorySlug\")\n \n-    val pagePath = request.dao.createPage(pageType, PageStatus.Published, Some(category.id),\n-      anyFolder = None, anySlug = None, titleSourceAndHtml, bodyTextAndHtml,\n-      showId = true, deleteDraftNr = None, request.who, request.spamRelatedStuff)\n+    val res: CreatePageResult = dao.createPageIfAuZ(\n+          pageType,\n+          PageStatus.Published,\n+          inCatId = Some(category.id),\n+          withTags = Nil,\n+          anyFolder = None,\n+          anySlug = None,\n+          title = titleSourceAndHtml,\n+          bodyTextAndHtml = bodyTextAndHtml,\n+          showId = true,\n+          deleteDraftNr = None,\n+          reqrAndCreator = request.reqrTargetSelf,\n+          spamRelReqStuff = request.spamRelatedStuff,\n+          asAlias = None,\n+          discussionIds = Set.empty,\n+          embeddingUrl = None,\n+          refId = None)\n \n     Ok\n   }"
    },
    {
      "sha": "b0eb02ff83312c6b46356621eb3668e2a1536dad",
      "filename": "appsv/server/talkyard/server/security/package.scala",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsecurity%2Fpackage.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsecurity%2Fpackage.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsecurity%2Fpackage.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -181,6 +181,9 @@ object EdSecurity {\n     */\n   private val XsrfTokenHeaderName = \"X-XSRF-TOKEN\"\n \n+  //private val PersonaCookieName = \"TyCoPersona\"\n+  val PersonaHeaderName = \"X-Ty-Persona\"\n+\n   private val BrowserIdCookieName = \"dwCoBrId\"\n \n   def tooLowEntropy(value: St): Bo = {\n@@ -1419,6 +1422,9 @@ class EdSecurity(globals: Globals) {\n     throwNotFound(\"TyE404_\" + suffix, \"Not found\")\n   }\n \n+  /** Throws 404 Not Found if pat may not see the post, or 403 Forbidden if\n+    * han may see it, but lacks permissions to do whatever han is up to.\n+    */\n   def throwNoUnless(mayMaybe: MayMaybe, errorCode: String): Unit = {\n     import MayMaybe._\n     mayMaybe match {"
    },
    {
      "sha": "67a648ad879985d88a6fab76abb329bc1dfb8ee1",
      "filename": "appsv/server/talkyard/server/sitepatch/SitePatchParser.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatchParser.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatchParser.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatchParser.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1433,8 +1433,8 @@ case class SitePatchParser(context: TyContext) {\n         return Bad(s\"Bad DraftLocator json: ${ex.getMessage} [TyE603KUTDGJ]\")\n       }\n \n-      UNTESTED; TESTS_MISSING // exp imp anons?  True ids are incl in json dumps?\n-      val doAsAnon: Opt[WhichAnon] = parser.parseWhichAnonJson(jsObj) getOrIfBad { prob =>\n+      UNTESTED; TESTS_MISSING // exp imp anons?  True ids are incl in json dumps? [export_privid]\n+      val doAsAnon: Opt[WhichAliasId] = parser.parseDoAsAnonField(jsObj) getOrIfBad { prob =>\n         return Bad(s\"Bad anon params: $prob [TyEANONPARDFT]\")\n       }\n "
    },
    {
      "sha": "425f2301fcbc8af200e67f7cd1a9779b37317aa3",
      "filename": "client/app-editor/editor/editor.editor.ts",
      "status": "modified",
      "additions": 249,
      "deletions": 78,
      "changes": 327,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-editor%2Feditor%2Feditor.editor.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-editor%2Feditor%2Feditor.editor.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-editor%2Feditor%2Feditor.editor.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -130,14 +130,23 @@ export const listUsernamesTrigger = {\n \n interface EditorState {\n   inFrame?: DiscWin,\n-  inFrameStore?: DiscStore;\n+  inFrameStore?: DiscStore & Origins;\n   store: Store;\n   visible: boolean;\n   replyToPostNrs: PostNr[];\n   anyPostType?: PostType;\n+\n+  // If posting anonymously or using a pseudonym.\n   doAsAnon?: MaybeAnon;\n+\n+  // Any pseudonyms and anonyms pat can choose among, when posting. (\"Opts\" = options)\n   myAliasOpts?: MaybeAnon[]\n+\n+  // Properties of the page where the post will appear. [_new_disc_props] Can be different\n+  // than `store.curDiscProps`, if composing a new page in a category with different\n+  // settings than the forum homepage. So, can't use `EditorState.store.discProps`.\n   discProps?: DiscPropsDerived;\n+\n   authorId?: PatId; // remove?\n   editorsCategories?: Category[];\n   editorsPageId?: PageId;\n@@ -214,7 +223,7 @@ export const Editor = createFactory<any, EditorState>({\n   },\n \n \n-  getDiscStore(): DiscStore {\n+  getDiscStore(): DiscStore & Origins {\n     const state: EditorState = this.state;\n     return state.inFrameStore || state.store; // [many_embcom_iframes]\n   },\n@@ -226,7 +235,7 @@ export const Editor = createFactory<any, EditorState>({\n   /// we just return the React store of the current window as is (which is then\n   /// the top window).\n   ///\n-  getOrCloneDiscStore(inFrame?: DiscWin): DiscStore {\n+  getOrCloneDiscStore(inFrame?: DiscWin): DiscStore & Origins {\n     if (!eds.isInIframe) {\n       // @ifdef DEBUG\n       dieIf(inFrame, 'TyE507MWEG25');\n@@ -245,7 +254,7 @@ export const Editor = createFactory<any, EditorState>({\n     // `inFrame` is sometimes available before this.state has been updated, so\n     // try to use it first.\n     const state: EditorState = this.state;\n-    const discFrameStore: Partial<DiscStore> =\n+    const discFrameStore: Partial<DiscStore & Origins> =\n         inFrame?.theStore || (    // [ONESTORE]  [many_embcom_iframes]\n               state.inFrame ? state.inFrame.theStore : (\n                   // This'd be weird, would mean the comments iframe was deleted\n@@ -264,17 +273,30 @@ export const Editor = createFactory<any, EditorState>({\n     // And 2) so that the data won't get changed at any time by code in the other iframe\n     // — React.js wouldn't like that.\n     //\n-    let storeClone: DiscStore;\n+    let storeClone: DiscStore & Origins;\n     try {\n+      // [break_out_clone_store_fn]?\n       storeClone = _.cloneDeep({\n+        // SessWinStore\n         me: discFrameStore.me,\n+\n+        // Origins\n         embeddedOriginOrEmpty: discFrameStore.embeddedOriginOrEmpty,\n+        anyCdnOrigin: discFrameStore.anyCdnOrigin,\n+        anyUgcOrigin: discFrameStore.anyUgcOrigin,\n+        pubSiteId: discFrameStore.pubSiteId,\n+\n+        // DiscStore\n         currentPage: discFrameStore.currentPage,\n         currentPageId: discFrameStore.currentPageId,\n         currentCategories: discFrameStore.currentCategories,\n         curCatsById: {}, // updated below (actually not needed? feels better, oh well)\n         usersByIdBrief: discFrameStore.usersByIdBrief || {},\n         pagesById: {},  // updated below\n+\n+        curPersonaOptions: discFrameStore.curPersonaOptions,\n+        curDiscProps: discFrameStore.curDiscProps,\n+        indicatedPersona: discFrameStore.indicatedPersona,\n       });\n       storeClone.curCatsById = groupByKeepOne(storeClone.currentCategories, c => c.id);\n     }\n@@ -884,7 +906,7 @@ export const Editor = createFactory<any, EditorState>({\n     // with only the editor).\n     // We'll then clone the parts we need of that other store, and remember\n     // in this.state.inFrameStore.\n-    const discStore: DiscStore = this.getOrCloneDiscStore(inFrame);\n+    const discStore: DiscStore & Origins = this.getOrCloneDiscStore(inFrame);\n \n     if (inclInReply && postNrs.length) {\n       // This means we've started replying to a post, and then clicked Reply\n@@ -952,7 +974,7 @@ export const Editor = createFactory<any, EditorState>({\n       postType = PostType.Flat;\n     }\n \n-    let inFrameStore: DiscStore | U;\n+    let inFrameStore: (DiscStore & Origins) | U;\n     if (eds.isInEmbeddedEditor && inFrame?.eds) {\n       // [many_embcom_iframes]\n       inFrameStore = discStore;\n@@ -964,14 +986,6 @@ export const Editor = createFactory<any, EditorState>({\n \n     const editorsPageId = discStore.currentPageId || eds.embeddedPageId;\n \n-    // Annoying! Try to get rid of eds.embeddedPageId? So can remove discStore2.\n-    const discStore2: DiscStore = { ...discStore, currentPageId: editorsPageId };\n-\n-    const discProps: DiscPropsDerived = page_deriveLayout(\n-            discStore.currentPage, discStore, LayoutFor.PageNoTweaks);\n-\n-    const choosenAnon = anon.maybeChooseAnon({ store: discStore2, discProps, postNr });\n-\n     const newState: Partial<EditorState> = {\n       inFrame,\n       inFrameStore,\n@@ -981,9 +995,7 @@ export const Editor = createFactory<any, EditorState>({\n       // [editorsNewLazyPageRole] = PageRole.EmbeddedComments if eds.isInEmbeddedEditor?\n       replyToPostNrs: postNrs,\n       text: state.text || makeDefaultReplyText(discStore, postNrs),\n-      myAliasOpts: choosenAnon.myAliasOpts,\n-      doAsAnon: choosenAnon.doAsAnon,\n-      discProps,\n+      discProps: discStore.curDiscProps,\n     };\n \n     this.showEditor(newState);\n@@ -996,7 +1008,6 @@ export const Editor = createFactory<any, EditorState>({\n     const draftType = postType === PostType.BottomComment ?\n         DraftType.ProgressPost : DraftType.Reply;\n \n-\n     const draftLocator: DraftLocator = {\n       draftType,\n       pageId: newState.editorsPageId,\n@@ -1012,7 +1023,6 @@ export const Editor = createFactory<any, EditorState>({\n       draftLocator.discussionId = eds.embeddedPageAltId;  // [draft_diid]\n     }\n \n-\n     let writingWhat = WritingWhat.ReplyToNotOriginalPost;\n     if (_.isEqual([BodyNr], postNrs)) writingWhat = WritingWhat.ReplyToOriginalPost;\n     else if (_.isEqual([NoPostId], postNrs)) writingWhat = WritingWhat.ChatComment;\n@@ -1037,7 +1047,7 @@ export const Editor = createFactory<any, EditorState>({\n       eds.embeddingUrl = inFrame.eds.embeddingUrl;\n       eds.embeddedPageAltId = inFrame.eds.embeddedPageAltId;\n       delete eds.lazyCreatePageInCatId; // page already exists\n-      const inFrameStore: DiscStore = this.getOrCloneDiscStore(inFrame);\n+      const inFrameStore: DiscStore & Origins = this.getOrCloneDiscStore(inFrame);\n       const newState: Partial<EditorState> = { inFrame, inFrameStore };\n       this.setState(newState);\n     }\n@@ -1050,7 +1060,7 @@ export const Editor = createFactory<any, EditorState>({\n       const draft: Draft | U = response.draft;\n \n       // In case the draft was created when one wasn't logged in, then, now, set a user id.\n-      const discStore: DiscStore = this.getDiscStore();\n+      const discStore: DiscStore & Origins = this.getDiscStore();\n       if (draft && discStore.me) {\n         draft.byUserId = discStore.me.id;\n       }\n@@ -1059,29 +1069,45 @@ export const Editor = createFactory<any, EditorState>({\n       // gets a new postNr. Then do what? Show a \"this post was moved to: ...\" dialog?\n       dieIf(postNr !== response.postNr, 'TyE23GPKG4');\n \n-      const editorsDiscStore: DiscStore = { ...discStore, currentPageId: response.pageId };\n-      const discProps: DiscPropsDerived = page_deriveLayout(\n-              discStore.currentPage, discStore, LayoutFor.PageNoTweaks);\n-\n-      const choosenAnon = anon.maybeChooseAnon({ store: editorsDiscStore, discProps, postNr });\n-\n-      const newState: Partial<EditorState> = {\n-        anyPostType: null,\n-        editorsCategories: discStore.currentCategories, // [many_embcom_iframes]\n-        editorsPageId: response.pageId,\n-        editingPostNr: postNr,\n-        editingPostUid: response.postUid,\n-        editingPostRevisionNr: response.currentRevisionNr,\n-        text: draft ? draft.text : response.currentText,\n-        onDone: onDone,\n-        draftStatus: DraftStatus.NothingHappened,\n-        draft,\n-        doAsAnon: choosenAnon.doAsAnon,\n-        myAliasOpts: choosenAnon.myAliasOpts,\n-        discProps,\n-      };\n+      // If showing any which-persona message, it should appear close to the edit button\n+      // just clicked. So, find its coordinates. — But this won't work if the editor is in its\n+      // own iframe. Then, we need to load the draft, and get the edit button coordinates, in the\n+      // comments iframe, show the `chooseEditorPersona()` in the comments iframe, and\n+      // pass the result to the editor iframe. [find_persona_diag_atRect]\n+      // Right now, anon blog comments not supported anyway. [anon_blog_comments]\n+      //\n+      let atRect = { top: 100, left: 100, right: 200, bottom: 200 };\n+      if (!inFrame) {\n+        // Later: Use  `cloneEventTargetRect(mouse-click-event)`  instead.\n+        const elm: HElm | N = $first(`#post-${postNr} + .esPA .dw-a-edit`);\n+        if (elm) {\n+          atRect = elm.getBoundingClientRect();\n+        }\n+        else {\n+          // The post just disappeared?   D_DIE\n+          // Let's just use the above hardcoded `atRect` for now.\n+        }\n+      }\n \n-      this.showEditor(newState);\n+      persona.chooseEditorPersona({ store: discStore, postNr, draft, atRect }, doAsOpts => {\n+        const newState: Partial<EditorState> = {\n+          anyPostType: null,\n+          editorsCategories: discStore.currentCategories, // [many_embcom_iframes]\n+          editorsPageId: response.pageId,\n+          editingPostNr: postNr,\n+          editingPostUid: response.postUid,\n+          editingPostRevisionNr: response.currentRevisionNr,\n+          text: draft ? draft.text : response.currentText,\n+          onDone: onDone,\n+          draftStatus: DraftStatus.NothingHappened,\n+          draft,\n+          doAsAnon: doAsOpts.doAsAnon,\n+          myAliasOpts: doAsOpts.myAliasOpts,\n+          discProps: discStore.curDiscProps,\n+        };\n+\n+        this.showEditor(newState);\n+      });\n     });\n   },\n \n@@ -1119,17 +1145,17 @@ export const Editor = createFactory<any, EditorState>({\n \n     const text = state.text || '';\n \n+    // Bit dupl code. [_new_disc_props]\n     const futurePage: PageDiscPropsSource = {\n       categoryId,\n       pageRole: newPageRole,\n     };\n \n     // Props for the future page, with settings inherited from the ancestor categories.\n+    // (Can't use `store.curDiscProps` — it's for the forum homepage, not the new page.)\n     const discProps: DiscPropsDerived = page_deriveLayout(\n             futurePage, store, LayoutFor.PageNoTweaks);\n \n-    const choosenAnon = anon.maybeChooseAnon({ store, discProps });\n-\n     const newState: Partial<EditorState> = {\n       discProps,\n       anyPostType: null,\n@@ -1141,8 +1167,6 @@ export const Editor = createFactory<any, EditorState>({\n       text: text,\n       showSimilarTopics: true,\n       searchResults: null,\n-      doAsAnon: choosenAnon.doAsAnon,\n-      myAliasOpts: choosenAnon.myAliasOpts,\n     };\n \n     this.showEditor(newState);\n@@ -1331,26 +1355,56 @@ export const Editor = createFactory<any, EditorState>({\n         }\n       }\n \n-      logD(\"Setting draft and guidelines: !!anyDraft: \" + !!anyDraft +\n-          \" !!draft: \" + !!draft +\n-          \" !!anyGuidelines: \" + !!anyGuidelines);\n-      const newState: Partial<EditorState> = {\n-        draft,\n-        draftStatus: DraftStatus.NothingHappened,\n-        text: draft ? draft.text : '',\n-        title: draft ? draft.title : '',\n-        // For now, skip guidelines, for blog comments — they would break e2e tests,\n-        // and maybe are annoying?\n-        guidelines: eds.isInIframe ? undefined : anyGuidelines,\n-      };\n-      if (draft && draft.doAsAnon) {\n-        // TESTS_MISSING  TyTANONDFLOAD\n-        newState.doAsAnon = draft.doAsAnon;\n-      }\n-      this.setState(newState, () => {\n-        this.focusInputFields();\n-        this.scrollToPreview = true;\n-        this.updatePreviewSoon();\n+\n+      // Post anonymously?\n+      // If new forum page, use its props.\n+      const discStore0: DiscStore = inFrameStore || state.store;\n+      const discStore: DiscStore = { ...discStore0, curDiscProps: state.discProps }\n+\n+      // Open any persona dialog, where? This'll be good enough for now. Later,\n+      // this find-atRect code will be moved to the more-bundle and discussion iframe\n+      // anyway. [find_persona_diag_atRect]\n+      const selector = draftLocator.postNr && !state.inFrame\n+              ? `#post-${draftLocator.postNr} + .esPA .dw-a-reply`\n+              : '.s_E_DoingRow';\n+      const elm: HElm | N = $first(selector);\n+      const atRect = elm ? elm.getBoundingClientRect() :\n+                { top: 100, left: 100, right: 200, bottom: 200 }; // whatever\n+\n+      // TESTS_MISSING  TyTANONDFLOAD  draft\n+      logD(\"Maybe choosing persona...\");\n+      persona.choosePosterPersona({ me: discStore.me, origins: state.store, discStore,\n+                postNr: draftLocator.postNr, draft, atRect },\n+                (doAsOpts: DoAsAndOpts | 'CANCEL') => {\n+\n+        const state: EditorState = this.state;\n+        if (this.isGone || !state.visible) return;\n+\n+        if (doAsOpts === 'CANCEL') {\n+          this.clearAndCloseFineIfGone({ keepDraft: !!draft, upToDateDraft: draft });\n+          return;\n+        }\n+\n+        logD(\"Setting draft and guidelines: !!anyDraft: \" + !!anyDraft +\n+            \" !!draft: \" + !!draft +\n+            \" !!anyGuidelines: \" + !!anyGuidelines);\n+        const newState: Partial<EditorState> = {\n+          draft,\n+          draftStatus: DraftStatus.NothingHappened,\n+          text: draft ? draft.text : '',\n+          title: draft ? draft.title : '',\n+          myAliasOpts: doAsOpts.myAliasOpts,\n+          doAsAnon: doAsOpts.doAsAnon,\n+          // For now, skip guidelines, for blog comments — they would break e2e tests,\n+          // and maybe are annoying?\n+          guidelines: eds.isInIframe ? undefined : anyGuidelines,\n+        };\n+\n+        this.setState(newState, () => {\n+          this.focusInputFields();\n+          this.scrollToPreview = true;\n+          this.updatePreviewSoon();\n+        });\n       });\n     };\n \n@@ -1436,6 +1490,21 @@ export const Editor = createFactory<any, EditorState>({\n   // in a modal dialog instead — guidelines are supposedly fairly important.\n   perhapsShowGuidelineModal: function() {\n     const state: EditorState = this.state;\n+\n+    // For now: If anon comments, for sensitive discussions (rather than\n+    // temp anon, for ideation), tell the user that anon comments are\n+    // experimental.  (Since this code will be removed later, we might as well\n+    // place it here. Works, & it's just for now.)\n+    if (state.doAsAnon && !this._hasShownAnonTips) {\n+      const isTempAnon = state.doAsAnon.anonStatus === AnonStatus.IsAnonCanAutoDeanon;\n+      if (!isTempAnon) {\n+        this._hasShownAnonTips = true;\n+        setTimeout(function() {\n+          debiki2.help.openHelpDialogUnlessHidden(anonExperimentalMsg);\n+        }, 0);\n+      }\n+    }\n+\n     if (!this.refs.guidelines || state.showGuidelinesInModal)\n       return;\n \n@@ -1609,7 +1678,76 @@ export const Editor = createFactory<any, EditorState>({\n   },\n \n   changeCategory: function(categoryId: CategoryId) {\n-    this.setState({ newForumTopicCategoryId: categoryId });\n+    const state: EditorState = this.state;\n+    const me: Me = state.store.me;\n+\n+    // ----- Derive disc props\n+\n+    // Changing category, might change discussion properties, e.g. if anonymity is allowed.\n+    // Bit dupl code. [_new_disc_props]\n+\n+    const futurePage: PageDiscPropsSource = {\n+      categoryId,\n+      pageRole: state.newPageRole,\n+    };\n+\n+    const discProps: DiscPropsDerived = page_deriveLayout(\n+            futurePage, state.store, LayoutFor.PageNoTweaks);\n+\n+    // ----- Can be anonymous?\n+\n+    // Could [ask_if_needed] which persona to use, if can't be the same in the new cat?\n+    const newDoAsOpts = persona.choosePosterPersona({\n+            me, origins: state.store, discStore: { ...state.store, curDiscProps: discProps }});\n+\n+    if (!any_isDeepEqIgnUndef(newDoAsOpts.doAsAnon, state.doAsAnon)) {\n+      // Was but won't be anonymous? Then, inform the user – so they won't mistakenly\n+      // post something anonymously, they thought, but appears under their real name.\n+      // If was-using/will-use a pseudonym, need to edit the `msg` below. [pseudonyms_later]\n+      // (`false` means oneself, not anon. Will refactor [oneself_0_false])\n+      const canBeAnon = newDoAsOpts.myAliasOpts.some(x => x !== false);\n+      const wasAnon = !!state.doAsAnon;  // [oneself_0_false]\n+      const willBeAnon = !!newDoAsOpts.doAsAnon; // [oneself_0_false]\n+      const msg = willBeAnon\n+            ? (wasAnon\n+                // Less important, but still good to know: (and happens very rarely)\n+                ? \"This category has different anonymity settings\"  // I18N & just below\n+                : \"You are anonymous in this category, by default\")\n+            :  (canBeAnon\n+                // UX, COULD: Would be good if Anonymous remained as the selected option,\n+                // if the category allows anonymity.\n+                ? \"You aren't anonymous by default, in this category\"\n+                : \"You cannot be anonymous in this category\");\n+\n+      // Show `msg` in a notification box under the \"Create new topic [anonymously v]\"\n+      // text & button, but not at the very left edge – add some margin:\n+      const doingRowElm = document.getElementsByClassName('s_E_DoingRow');\n+      if (doingRowElm.length) {\n+        const atRect = doingRowElm[0].getBoundingClientRect();\n+        atRect.x = atRect.x + 75;\n+        morekit.openSimpleProxyDiag({ atRect, showCloseButton: false,\n+            // It can be important that people read this text, and don't accidentally\n+            // close the dialog.\n+            closeOnClickOutside: false,\n+            body: r.p({}, msg),\n+            });\n+      }\n+    }\n+\n+    // ----- Update state\n+\n+    const newState: Partial<EditorState> = {\n+      discProps,\n+      newForumTopicCategoryId: categoryId,\n+      doAsAnon: newDoAsOpts.doAsAnon,\n+      myAliasOpts: newDoAsOpts.myAliasOpts,\n+    };\n+\n+    // (Currently no need to patch the main store, by calling call onEditorOpen() – the\n+    // EditorStorePatch doesn't need any of the Partial<EditorState> fields above —\n+    // those fields are for the not-yet-existing page, not for the current store.)\n+\n+    this.setState(newState);\n   },\n \n   changeNewForumPageRole: function(pageRole: PageRole) {\n@@ -1992,7 +2130,7 @@ export const Editor = createFactory<any, EditorState>({\n \n   postChatMessage: function() {\n     const state: EditorState = this.state;\n-    // ANON_UNIMPL: send state.doAsAnon,\n+    // [anon_chats]: send state.doAsAnon,\n     ReactActions.insertChatMessage(state.text, state.draft, () => {\n       this.callOnDoneCallback(true);\n       this.clearAndCloseFineIfGone();\n@@ -2588,6 +2726,7 @@ export const Editor = createFactory<any, EditorState>({\n \n     // By default, anon posts are disabled, and the \"post as ...\" dropdown left out.\n \n+    // Break out component? [choose_alias_btn]\n     let maybeAnonymously: RElm | U;\n     if (!me.isAuthenticated) {\n       // Only logged in users can post anonymously. (At least for now.)\n@@ -2597,14 +2736,14 @@ export const Editor = createFactory<any, EditorState>({\n           // a draft, as anon, but then an admin changed the settings, so cannot\n           // be anon any more.  Then it's nevertheless ok to continue, anonymously.\n           // (That's what \"continue\" in NeverAlways.NeverButCanContinue means.)\n-          // ANON_UNIMPL, UNPOLITE, SHOULD add some server side check, so no one toggles\n-          // this in the browser only, and the server accepts?  [derive_node_props_on_server]\n-          // But pretty harmless.\n-          state.doAsAnon) {\n+          // (There's a server side check [derive_node_props_on_server], in case of\n+          // misbehaving clients, or sbd taking really long until they submit a post,\n+          // and an admin disables anon comments in between.)\n+          state.doAsAnon) {  // [oneself_0_false]\n       maybeAnonymously =\n-          Button({ className: 'c_AliasB', ref: 'aliasB', onClick: () => {\n-            const atRect = reactGetRefRect(this.refs.aliasB);\n-            anon.openAnonDropdown({ atRect, open: true, \n+          Button({ className: 'c_AliasB', onClick: (event: MouseEvent) => {\n+            const atRect = cloneEventTargetRect(event);\n+            persona.openAnonDropdown({ atRect, open: true,\n                 curAnon: state.doAsAnon, me,\n                 myAliasOpts: state.myAliasOpts,\n                 discProps: state.discProps,\n@@ -2617,7 +2756,7 @@ export const Editor = createFactory<any, EditorState>({\n                   this.updatePreviewSoon();\n                 } });\n           } },\n-          anon.whichAnon_titleShort(state.doAsAnon, { me }),\n+          persona.whichAnon_titleShort(state.doAsAnon, { me }),\n           ' ', r.span({ className: 'caret' }));\n     }\n \n@@ -3075,6 +3214,38 @@ export function DraftStatusInfo(props: { draftStatus: DraftStatus, draftNr: numb\n }\n \n \n+// Later, when more tested:  Remove this message,  and show instead a warning/tips\n+// only to mods & admins, since when they're in Anonymous mode, they can (as of now)\n+// still see some things only they can see, e.g. unapproved comments. And by e.g.\n+// approving & replying anonymously to a to others not-visible unapproved comment,\n+// they might accidentally reveal that their anonymous comments are by a mod or admin.\n+// (If a comment got approved & visible, and then there's an anonymous reply a second\n+// later.) [deanon_risk] [mod_deanon_risk]\n+//\n+// Even later, an intro guide that explains anon comments? [anon_comts_guide]\n+//\n+const anonExperimentalMsg: HelpMessage = {\n+  id: 'TyHANOX1',\n+  version: 1,\n+  isWarning: true,\n+  // Can be important to read this (and not close by mistake).\n+  closeOnClickOutside: false,\n+  // Let's show it many times, until they tick \"Hide this tips\".\n+  defaultHide: false,\n+  content: rFr({},\n+      r.h3({} ,\n+        \"You're anonymous  (hopefully)\"),  // the space \"  \" before the '(' is a &thinsp;.\n+      r.p({},\n+        \"Do \", r.b({}, \"not\"), \" write anything sensitive!\"),\n+      r.p({},\n+        \"Anonymous comments are pretty new. There might be bugs\"),\n+      r.p({ style: { marginLeft: '2em' }},\n+        \"— including ways to find out who you are.\"),\n+      r.br(),\n+      r.p({},\n+        \"Anyway.  Look in the upper right corner — you should see the text \" +\n+        \"\\\"Anonymous\\\", if you're in an anonymous section of this forum.\")),\n+};\n \n //------------------------------------------------------------------------------\n    }"
    },
    {
      "sha": "0b634e1e54c0033d416e349b85adb9be51d357f8",
      "filename": "client/app-more/editor/title-editor.more.ts",
      "status": "modified",
      "additions": 33,
      "deletions": 1,
      "changes": 34,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Feditor%2Ftitle-editor.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Feditor%2Ftitle-editor.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Feditor%2Ftitle-editor.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -32,9 +32,11 @@ const MaxSlugLength = 100;  // sync with Scala [MXPGSLGLN]\n interface TitleEditorPops {\n   closeEditor: () => V;\n   store: Store;\n+  doAsOpts?: DoAsAndOpts;\n }\n \n interface TitleEditorState {\n+  doAsOpts?: DoAsAndOpts;\n   categoryId: CatId;\n   pageRole: PageRole;\n   editorScriptsLoaded?: Bo;\n@@ -65,6 +67,7 @@ export const TitleEditor = createComponent({\n     return {\n       pageRole: page.pageRole,\n       categoryId: page.categoryId,\n+      doAsOpts: _.clone(props.doAsOpts),\n     };\n   },\n \n@@ -188,6 +191,7 @@ export const TitleEditor = createComponent({\n       htmlTagCssClasses: state.htmlTagCssClasses,\n       htmlHeadTitle: state.htmlHeadTitle,\n       htmlHeadDescription: state.htmlHeadDescription,\n+      doAsAnon: state.doAsOpts?.doAsAnon,\n     };\n     return settings;\n   },\n@@ -209,6 +213,33 @@ export const TitleEditor = createComponent({\n       return r.div({ style: { height: 80 }});\n     }\n \n+    // Break out component? [choose_alias_btn]\n+    let maybeAnonymously: RElm | U;\n+    if (!me.isAuthenticated || !state.doAsOpts) {\n+      // Only logged in users can post anonymously. (At least for now.)\n+    }\n+    else if (store.curDiscProps?.comtsStartAnon >= NeverAlways.Allowed ||\n+          state.doAsOpts.doAsAnon) {  // [oneself_0_false]\n+      maybeAnonymously = rFr({},\n+          r.span({ className: 's_E_DoingWhat' }, \"Edit title and page: \"),  // I18N\n+          Button({ className: 'c_AliasB', onClick: (event: MouseEvent) => {\n+            const atRect = cloneEventTargetRect(event);\n+            persona.openAnonDropdown({ atRect, open: true,\n+                curAnon: state.doAsOpts.doAsAnon, me,\n+                myAliasOpts: state.doAsOpts.myAliasOpts,\n+                discProps: store.curDiscProps,\n+                saveFn: (doAsAnon: MaybeAnon) => {\n+                  const newState: Partial<TitleEditorState> = { doAsOpts: {\n+                    doAsAnon,\n+                    myAliasOpts: state.doAsOpts.myAliasOpts\n+                  }};\n+                  this.setState(newState);\n+                } });\n+          } },\n+          persona.whichAnon_titleShort(state.doAsOpts.doAsAnon, { me }),\n+          ' ', r.span({ className: 'caret' })));\n+    }\n+\n     let layoutAndSettings: RElm | U;\n     if (simpleChanges) {\n       const layoutBtnTitle = r.span({},\n@@ -368,7 +399,8 @@ export const TitleEditor = createComponent({\n \n     return (\n       r.div({ className: 'dw-p-ttl-e' },\n-        Input({ type: 'text', ref: 'titleInput', className: 'dw-i-title', id: 'e2eTitleInput',\n+        maybeAnonymously,\n+        Input({ type: 'text', ref: 'titleInput', className: 'c_TtlE_TtlI',\n             defaultValue: titlePost.unsafeSource, onChange: this.onTitleChanged }),\n         r.div({ className: 'form-horizontal' }, selectCategoryInput),\n         r.div({ className: 'form-horizontal' }, selectTopicType),"
    },
    {
      "sha": "a4933af637c50d0aeb326bc4f8ade8723c2e6140",
      "filename": "client/app-more/editor/title-editor.styl",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Feditor%2Ftitle-editor.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Feditor%2Ftitle-editor.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Feditor%2Ftitle-editor.styl?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1,4 +1,7 @@\n \n+.c_AliasB + div .c_TtlE_TtlI\n+  margin-top: 10px;\n+\n .esTtlEdtr_urlSettings\n   background: hsl(0, 0%, 99%);\n   border: 1px solid hsl(0, 0%, 92%);"
    },
    {
      "sha": "13816330989b40b0e2a66d33fdbc11d68d9a1ed3",
      "filename": "client/app-more/help/help-dialog.more.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fhelp%2Fhelp-dialog.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fhelp%2Fhelp-dialog.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fhelp%2Fhelp-dialog.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -37,6 +37,8 @@ let helpDialog;\n \n function getHelpDialog() {\n   if (!helpDialog) {\n+    // Apparently, if you're somewhere in a React componentDidUpdate() handler, then,\n+    // `helpDialog` becomes null. Then you can wrap getHelpDialog() in setTimeout().\n     helpDialog = ReactDOM.render(HelpDialog(), utils.makeMountNode());\n   }\n   return helpDialog;\n@@ -86,6 +88,9 @@ const HelpDialog = createComponent({\n         onChange: (event) => this.setState({ hideNextTime: event.target.checked }),\n         label: \"Hide this tips\" });\n \n+    const maybeClose =\n+        !message || message.closeOnClickOutside === false ? undefined : this.close;\n+\n     content = !content ? null :\n         ModalBody({ className: message.className },\n           r.div({ className: 'esHelpDlg_body_wrap'},\n@@ -95,7 +100,7 @@ const HelpDialog = createComponent({\n               PrimaryButton({ onClick: this.close, className: 'e_HelpOk' }, \"Okay\"))));\n \n     return (\n-      Modal({ show: this.state.isOpen, onHide: this.close, dialogClassName: 'esHelpDlg' },\n+      Modal({ show: this.state.isOpen, onHide: maybeClose, dialogClassName: 'esHelpDlg' },\n        content));\n   }\n });"
    },
    {
      "sha": "3c49c48a53409ed3ed5b9d3a392a0083408cf54d",
      "filename": "client/app-more/login/login-dialog.more.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Flogin%2Flogin-dialog.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Flogin%2Flogin-dialog.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Flogin%2Flogin-dialog.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -199,6 +199,7 @@ const LoginDialog = createClassAndFactory({\n     getSetCookie('dwCoMayCreateUser', null);\n     getSetCookie('dwCoOAuth2State', null);\n     getSetCookie('esCoImp', null);\n+    //getSetCookie('TyCoPersona', null);\n \n     if (!eds.isInLoginWindow) {\n       // We're in a login popup, not in a dedicated \"full screen\" login window."
    },
    {
      "sha": "5978a9f0fdabc0366345ccbca8c0d36ff21da2e1",
      "filename": "client/app-more/more-bundle-already-loaded.d.ts",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fmore-bundle-already-loaded.d.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fmore-bundle-already-loaded.d.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fmore-bundle-already-loaded.d.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -32,6 +32,7 @@ declare namespace debiki2 {\n \n   namespace morekit {\n     function openProxyDiag(ps: ProxyDiagParams, childrenFn: (close: () => V) => RElm);\n+    function openSimpleProxyDiag(ps: ProxyDiagParams & { body: RElm });\n   }\n \n   var Expandable;\n@@ -73,7 +74,7 @@ declare namespace debiki2.pagedialogs {\n \n   function openAddPeopleDialog(ps: { curPatIds?: PatId[], curPats?: Pat[],\n         mayClear?: Bo, onChanges: (PatsToAddRemove) => Vo });\n-  function openDeletePostDialog(post: Post, at: Rect);\n+  function openDeletePostDialog(ps: { post: Post, at: Rect, doAsAnon?: MaybeAnon });\n   function openFlagDialog(postId: PostId, at: Rect);\n   function openMovePostsDialog(store: Store, post: Post, closeCaller, at: Rect);\n   function openSeeWrenchDialog();\n@@ -87,18 +88,17 @@ declare namespace debiki2.pagedialogs {\n   function getProgressBarDialog();\n }\n \n-declare namespace debiki2.anon {\n-  function maybeChooseModAlias(ps: MaybeChooseAnonPs, then?: (res: ChoosenAnon) => V);\n-  function maybeChooseAnon(ps: MaybeChooseAnonPs, then?: (_: ChoosenAnon) => V): ChoosenAnon;\n-  function openAnonDropdown(ps: ChooseAnonDlgPs): V;\n+declare namespace debiki2.persona {\n+  function chooseEditorPersona(ps: ChooseEditorPersonaPs, then?: (_: DoAsAndOpts) => V): V;\n+  function choosePosterPersona(ps: ChoosePosterPersonaPs, then?: (_: DoAsAndOpts | 'CANCEL') => V)\n+        : DoAsAndOpts;\n+  function openAnonDropdown(ps: ChoosePersonaDlgPs): V;\n   function whichAnon_titleShort(doAsAnon: MaybeAnon, ps: { me: Me, pat?: Pat }): RElm;\n   function whichAnon_title(doAsAnon: MaybeAnon, ps: { me: Me, pat?: Pat }): St | RElm;\n   function whichAnon_descr(doAsAnon: MaybeAnon, ps: { me: Me, pat?: Pat }): St | RElm;\n-}\n \n-declare namespace debiki2 {\n-  function disc_findAnonsToReuse(discStore: DiscStore, ps: {\n-            forWho: Pat | Me | U, startAtPostNr?: PostNr }): MyPatsOnPage;\n+  function openPersonaInfoDiag(ps: { atRect: Rect, isSectionPage: Bo,\n+        me: Me, personaOpts: PersonaOptions, discProps: DiscPropsDerived }): V;\n }\n \n declare namespace debiki2.subcommunities {"
    },
    {
      "sha": "21acf21e97d91c75749c0baa5643dd1e16eb9c61",
      "filename": "client/app-more/morekit/proxy-diag.more.ts",
      "status": "modified",
      "additions": 36,
      "deletions": 1,
      "changes": 37,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fmorekit%2Fproxy-diag.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fmorekit%2Fproxy-diag.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fmorekit%2Fproxy-diag.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -35,6 +35,37 @@ interface ProxyDiagState {\n let setDropdownStateFromOutside: U | ((_: ProxyDiagState | N) => V);\n \n \n+// Much later, support all StupidDialogStuff, and [replace_stupid_diag_w_simple_proxy_diag].\n+//\n+export function openSimpleProxyDiag(ps: SimpleProxyDiagParams) {\n+  openProxyDiag({ ...ps, flavor: DiagFlavor.Dropdown }, closeDiag => {\n+\n+    const primaryButton = PrimaryButton({ className: 'e_SPD_OkB',\n+          ref: (e: HElm | N) => e && e.focus(),\n+          onClick: () => {\n+            closeDiag();\n+            if (ps.onPrimaryClick) ps.onPrimaryClick();\n+            if (ps.onCloseOk) ps.onCloseOk(1);\n+          }},\n+          ps.primaryButtonTitle || t.Okay);\n+\n+    const secondaryButton = !ps.secondaryButonTitle ? null : Button({\n+              onClick: () => {\n+                closeDiag();\n+                if (ps.onCloseOk) ps.onCloseOk(2);\n+              },\n+              className: 'e_SPD_2ndB' },\n+            ps.secondaryButonTitle);\n+\n+    return rFr({},\n+        r.div({ style: { marginBottom: '2em' }}, ps.body),\n+        r.div({ style: { float: 'right' }},\n+          primaryButton,\n+          secondaryButton));\n+  });\n+}\n+\n+\n export function openProxyDiag(params: ProxyDiagParams, childrenFn: (close: () => V) => RElm) {\n   if (!setDropdownStateFromOutside) {\n     ReactDOM.render(ProxyDiag(), utils.makeMountNode());\n@@ -61,8 +92,11 @@ const ProxyDiag = React.createFactory<{}>(function() {\n \n   const state: ProxyDiagState = diagState;\n   const ps: ProxyDiagParams = state.params;\n-  const close = () => setDiagState(null);\n   const flavorClass = ps.flavor === DiagFlavor.Dropdown ? 'c_PrxyD-Drpd ' : '';\n+  const close = () => {\n+    setDiagState(null);\n+    if (diagState.params.onHide) diagState.params.onHide();\n+  };\n \n   return utils.DropdownModal({\n         show: true,\n@@ -74,6 +108,7 @@ const ProxyDiag = React.createFactory<{}>(function() {\n         className: ps.contentClassName,\n         allowFullWidth: ps.allowFullWidth,\n         showCloseButton: ps.showCloseButton !== false,\n+        closeOnClickOutside: ps.closeOnClickOutside,\n         // bottomCloseButton: not yet impl\n         onContentClick: !ps.closeOnButtonClick ? null : (event: MouseEvent) => {\n           // Don't close if e.g. clicking a <p>, maybe to select text — only if"
    },
    {
      "sha": "b87f6740cceb3892c0f950f1293df209d0bcf5cf",
      "filename": "client/app-more/morekit/proxy-diag.styl",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fmorekit%2Fproxy-diag.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fmorekit%2Fproxy-diag.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fmorekit%2Fproxy-diag.styl?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -4,6 +4,8 @@\n .c_PrxyD\n   .esDropModal_content\n     padding: 30px 20px 20px 20px;\n+  .esDropModal_header\n+    margin: 7px 0 7px 11px;  // less margin-top – already 30px padding-top, see above\n \n .c_PrxyD-Drpd\n   // The dropdown items have their own padding, so, could use less padding-left,"
    },
    {
      "sha": "cd6a2b7e411942e4d77ec6780aea4188cc478f64",
      "filename": "client/app-more/oop.more.ts",
      "status": "removed",
      "additions": 0,
      "deletions": 229,
      "changes": 229,
      "blob_url": "https://github.com/debiki/talkyard/blob/a941015db661e13ac3e5523d2ab5a3e600275acc/client%2Fapp-more%2Foop.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/a941015db661e13ac3e5523d2ab5a3e600275acc/client%2Fapp-more%2Foop.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Foop.more.ts?ref=a941015db661e13ac3e5523d2ab5a3e600275acc",
      "patch": "@@ -1,229 +0,0 @@\n-/*\n- * Copyright (c) 2023 Kaj Magnus Lindberg\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Affero General Public License as\n- * published by the Free Software Foundation, either version 3 of the\n- * License, or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU Affero General Public License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-/// <reference path=\"more-prelude.more.ts\" />\n-\n-//------------------------------------------------------------------------------\n-   namespace debiki2 {\n-//------------------------------------------------------------------------------\n-\n-\n-/// disc_findAnonsToReuse()\n-///\n-/// If pat is posting a reply anonymously, then, if han has posted or voted earlier\n-/// anonymously on the same page, usually han wants hens new reply, to be\n-/// by the same anonym, so others see they're talking with the same person\n-/// (although they don't know who it is, just that it's the same).\n-///\n-/// This fn finds anonyms a pat has used, so the pat can reuse them. First it\n-/// looks for anonyms-to-reuse in the sub thread where pats reply will appear,\n-/// thereafter anywhere on the same page.\n-///\n-/// Returns sth like this, where 200 is pat's id, and 2001, 2002, 2003, 2004 are\n-/// anons pat has used on the current page:  (just nice looking numbers)\n-/// {\n-///   // Just an example\n-///   byId: {\n-///     2001: patsAnon2001,  // = { id: 2001, forPatId: 200, ... }\n-///     2002: patsAnon2002,  // = { id: 2002, forPatId: 200, ... }\n-///     2003: patsAnon2003,  // = { id: 2003, forPatId: 200, ... }\n-///     2004: patsAnon2004,  // = { id: 2004, forPatId: 200, ... }\n-///   },\n-///   sameThread: [\n-///     patsAnon2002,  // pat's anon (or pat henself) who made pat's last comment\n-//                     // in the path from  startAtPostNr, back to the orig post.\n-///     patHenself,    // here pat posted using hens real account (not anonymously)\n-///     patsAnon2001,  // pat upvoted a comment using anon 2001, along this path\n-///   ],\n-///   outsideThread: [\n-///     // If pat has posted earlier in the thread (closer to the orig post), using\n-///     // any of the above (anon 2002, 2001, or as henself), those comments are\n-///     // ignored: we don't add an anon more than once to the list.)\n-///\n-///     patsAnon2004, // Pat replied elsewhere on the page using hens anon 2004\n-///     patsAnon2003, // ... and before that, han posted as anon 2003, also\n-///                   //     elsewhere on the same page.\n-///   ]\n-/// }\n-///\n-/// In the above example, patsAnon2003 didn't post anything in the thread from\n-/// startAtPostNr up to the orig post — but that anon did post something,\n-/// *elsewhere* in the same discussion. So that anon is still in the list of anons\n-/// pat might want to use again, on this page.\n-///\n-export function disc_findAnonsToReuse(discStore: DiscStore, ps: {\n-            forWho: Pat | Me | U, startAtPostNr?: PostNr }): MyPatsOnPage {\n-\n-  const result: MyPatsOnPage = {\n-    sameThread: [],\n-    outsideThread: [],\n-    byId: {},\n-  };\n-\n-  const forWho: Pat | Me | U = ps.forWho;\n-  if (!forWho)\n-    return result;\n-\n-  const forWhoId: PatId = ps.forWho.id;\n-  const curPage: Page | U = discStore.currentPage;\n-\n-  if (!forWhoId || !curPage)\n-    return result;\n-\n-  // ----- Same thread\n-\n-  // Find out if pat was henself, or was anonymous, in any earlier posts by hen,\n-  // in the path from ps.startAtPostNr and back towards the orig post.\n-  // (patsAnon2002, patHenself, and patsAnon2001 in the example above (i.e. in\n-  // the docs comment to this fn)).\n-\n-  const startAtPost: Post | U = ps.startAtPostNr && curPage.postsByNr[ps.startAtPostNr];\n-  const nrsSeen = {};\n-  let myVotesByPostNr: { [postNr: PostNr]: Vote[] } = {};\n-\n-  const isMe = pat_isMe(forWho);\n-  if (isMe) {\n-    myVotesByPostNr = forWho.myDataByPageId[curPage.pageId]?.votesByPostNr || {};\n-  }\n-  else {\n-    die('TyE0MYVOTS'); // [_must_be_me]\n-  }\n-\n-  let nextPost: Post | U = startAtPost;\n-  const myAliasesInThread = [];\n-\n-  for (let i = 0; i < StructsAndAlgs.TooLongPath && nextPost; ++i) {\n-    // Cycle? (Would be a bug somewhere.)\n-    if (nrsSeen[nextPost.nr])\n-      break;\n-    nrsSeen[nextPost.nr] = true;\n-\n-    // Bit dupl code:  [.find_anons]\n-\n-    // We might have added this author, already.\n-    if (result.byId[nextPost.authorId])\n-      continue;\n-\n-    const author: Pat | U = discStore.usersByIdBrief[nextPost.authorId];\n-    if (!author)\n-      continue; // would be a bug somewhere, or a rare & harmless race? Oh well.\n-\n-    const postedAsSelf = author.id === forWhoId;\n-    const postedAnonymously = author.anonForId === forWhoId;\n-\n-    if (postedAsSelf || postedAnonymously) {\n-      // This places pat's most recently used anons first.\n-      myAliasesInThread.push(author);\n-      result.byId[author.id] = author;\n-    }\n-    else {\n-      // This comment is by someone else. If we've voted anonymously, let's\n-      // continue using the same anonym. Or using our main user account, if we've\n-      // voted not-anonymously.\n-      const votes: Vote[] = myVotesByPostNr[nextPost.nr] || [];\n-      for (const myVote of votes) {\n-        // If myVote.byId is absent, it's our own vote (it's not anonymous). [_must_be_me]\n-        const voterId = myVote.byId || forWho.id;\n-        // Have we added this alias (or our real account) already?\n-        if (result.byId[voterId])\n-          continue;\n-        const voter: Pat = discStore.usersByIdBrief[voterId];\n-        myAliasesInThread.push(voter);\n-        result.byId[voter.id] = voter;\n-      }\n-    }\n-\n-    nextPost = curPage.postsByNr[nextPost.parentNr];\n-  }\n-\n-  // ----- Same page\n-\n-  // If pat posted outside [the thread from the orig post to ps.startAtPostNr],\n-  // then include any anons pat used, so Pat can choose to use those anons, now\n-  // when being active in sub thread startAtPostNr.  (See patsAnon2003 and patsAnon2004\n-  // in this fn's docs above.)\n-\n-  // Sleeping BUG:, ANON_UNIMPL: What if it's a really big page, and we don't have\n-  // all parts here, client side?  Maybe this ought to be done server side instead?\n-  // Or the server could incl all one's anons on the current page, in a list  [fetch_alias]\n-\n-  const myAliasesOutsideThread: Pat[] = [];\n-\n-  _.forEach(curPage.postsByNr, function(post: Post) {\n-    if (nrsSeen[post.nr])\n-      return;\n-\n-    // Bit dupl code:  [.find_anons]\n-\n-    // Each anon pat has used, is to be included at most once.\n-    if (result.byId[post.authorId])\n-      return;\n-\n-    const author: Pat | U = discStore.usersByIdBrief[post.authorId];\n-    if (!author)\n-      return;\n-\n-    const postedAsSelf = author.id === forWhoId;\n-    const postedAnonymously = author.anonForId === forWhoId;\n-\n-    if (postedAsSelf || postedAnonymously) {\n-      myAliasesOutsideThread.push(author);\n-      result.byId[author.id] = author;\n-    }\n-  });\n-\n-  _.forEach(myVotesByPostNr, function(votes: Vote[], postNrSt: St) {\n-    if (nrsSeen[postNrSt])\n-      return;\n-\n-    for (const myVote of votes) {\n-      // The voter is oneself or one's anon or pseudonym. [_must_be_me]\n-      const voterId = myVote.byId || forWho.id;\n-\n-      if (result.byId[voterId])\n-        return;\n-\n-      const voter: Pat | U = discStore.usersByIdBrief[voterId];  // [voter_needed]\n-      if (!voter)\n-        return;\n-\n-      myAliasesOutsideThread.push(voter);\n-      result.byId[voter.id] = voter;\n-    }\n-  });\n-\n-\n-  // Sort, newest first. Could sort votes by voted-at, not the comment posted-at — but\n-  // doesn't currently matter, not until [many_anons_per_page].\n-  // Old — now both comments and votes, so won't work:\n-  //myPostsOutsideThread.sort((p: Post) => -p.createdAtMs);\n-  //const myPatsOutside = myPostsOutsideThread.map(p => discStore.usersByIdBrief[p.authorId]);\n-\n-  // ----- The results\n-\n-  result.sameThread = myAliasesInThread;\n-  result.outsideThread = myAliasesOutsideThread;\n-\n-  return result;\n-}\n-\n-\n-\n-//------------------------------------------------------------------------------\n-   }\n-//------------------------------------------------------------------------------\n-// vim: fdm=marker et ts=2 sw=2 tw=0 fo=r list"
    },
    {
      "sha": "5b0a0d5daed3e5a1e9e1dbeece8a16b324629f44",
      "filename": "client/app-more/page-dialogs/ChangePageModal.more.ts",
      "status": "modified",
      "additions": 10,
      "deletions": 15,
      "changes": 25,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2FChangePageModal.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2FChangePageModal.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fpage-dialogs%2FChangePageModal.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -112,15 +112,19 @@ const ChangePageDialog = createComponent({\n     const savePage = (changes: EditPageRequestData) => {\n       // E.g. EditPageRequestData.showId and .htmlTagCssClasses can be edited by admins only,\n       // and should be grayed out if one is in Anon Mode for example? [alias_mode]\n-      anon.maybeChooseModAlias({ store, atRect: state.atRect }, (choices: ChoosenAnon) => {\n+      // (A [pick_persona_click_handler] could save a few lines of code?)\n+      persona.chooseEditorPersona({ store, atRect: state.atRect, isInstantAction: true },\n+              (choices: DoAsAndOpts) => {\n         ReactActions.editTitleAndSettings({ ...changes, doAsAnon: choices.doAsAnon },\n                 this.close, null);\n       });\n     }\n \n     const togglePageClosed = () => {\n-      anon.maybeChooseModAlias({ store, atRect: state.atRect }, (choices: ChoosenAnon) => {\n-        ReactActions.togglePageClosed(choices.doAsAnon, this.close);\n+      persona.chooseEditorPersona({ store, atRect: state.atRect, isInstantAction: true },\n+              (choices: DoAsAndOpts) => {\n+        const pageId = Server.getPageId();\n+        ReactActions.togglePageClosed({ pageId, doAsAnon: choices.doAsAnon }, this.close);\n       });\n     };\n \n@@ -294,23 +298,14 @@ const ChangePageDialog = createComponent({\n         deletePageListItem = rFr({},\n             r.div({ className: 's_ExplDrp_Ttl' }, \"Delete page\" + '?'),  // I18N\n             r.div({ className: 's_ExplDrp_ActIt' },\n-              Button({ className: 'e_DelPgB',\n-                  onClick: () => {\n-                    // ANON_UNIMPL Do as (mod) alias?\n-                    ReactActions.deletePages([page.pageId], this.close);\n-                  } },\n-                \"Delete\")));  // I18N\n+              DeletePageBtn({ pageIds: [page.pageId], store, close: this.close })));\n       }\n       else if (store_canUndeletePage(store)) {  // [.store_or_state_pg]\n         undeletePageListItem = rFr({},\n             r.div({ className: 's_ExplDrp_Ttl' }, \"Undelete page\" + '?'),  // I18N\n             r.div({ className: 's_ExplDrp_ActIt' },\n-              Button({ className: 'e_UndelPgB',\n-                  onClick: () => {\n-                    // ANON_UNIMPL Do as (mod) alias?\n-                    ReactActions.undeletePages([page.pageId], this.close);\n-                  } },\n-                \"Undelete\")));  // I18N\n+              DeletePageBtn({ pageIds: [store.currentPageId], store,\n+                    undel: true, close: this.close })));\n       }\n     }\n "
    },
    {
      "sha": "bd8940037965d6ab50d7ebf0b158e342dbe4be98",
      "filename": "client/app-more/page-dialogs/about-user-dialog.more.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2Fabout-user-dialog.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2Fabout-user-dialog.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fpage-dialogs%2Fabout-user-dialog.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -333,7 +333,7 @@ const AboutAnon = React.createFactory<AboutAnonymProps>(function(props) {\n       r.div({ className: 'dw-about-user-actions' },\n         LinkButton({ href: linkToUserProfilePage(anon) }, t.aud.ViewComments)),\n       r.p({},\n-        t.Anonym)));\n+        anonStatus_toStr(anon.anonStatus))));\n });\n \n "
    },
    {
      "sha": "da4ab0e504bba1caadcfa96fb4f4be4b77a674f9",
      "filename": "client/app-more/page-dialogs/choose-author-owner.more.ts",
      "status": "modified",
      "additions": 349,
      "deletions": 126,
      "changes": 475,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2Fchoose-author-owner.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2Fchoose-author-owner.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fpage-dialogs%2Fchoose-author-owner.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2023 Kaj Magnus Lindberg\n+ * Copyright (c) 2024 Kaj Magnus Lindberg\n  *\n  * This program is free software: you can redistribute it and/or modify\n  * it under the terms of the GNU Affero General Public License as\n@@ -16,177 +16,398 @@\n  */\n \n /// <reference path=\"../more-prelude.more.ts\" />\n+/// <reference path=\"../morekit/proxy-diag.more.ts\" />\n \n //------------------------------------------------------------------------------\n-   namespace debiki2.anon {\n+   namespace debiki2.persona {\n //------------------------------------------------------------------------------\n \n const r = ReactDOMFactories;\n const DropdownModal = utils.DropdownModal;\n const ExplainingListItem = util.ExplainingListItem;\n \n \n-export function maybeChooseModAlias(ps: MaybeChooseAnonPs, then?: (res: ChoosenAnon) => V) {\n+/// Figures out, or asks, what persona to use when editing a post.  [choose_persona]\n+///\n+/// Ensures pat will continue using the same persona, when editing a post, as when\n+/// creating it. E.g. if posting a question, and later on, accepting an answer.\n+/// \n+/// If pat were to use a different persona when editing a post of hans,\n+/// others might guess that the two personas (pat, and hans alias)\n+/// are in fact the same (sine they were able to edit the same thing). [deanon_risk]\n+/// (E.g. pat creates a page anonymously, and then edits it as hanself,\n+/// without being a moderator. This function makes sure han will instead\n+/// reuse the anonym, when editing the page.)\n+/// \n+/// If a moderator edits someone else's page, then, if han uses a persona\n+/// (e.g. a pseudonym), others might guess that that persona is a moderator\n+/// (since that persona was able to edit other's posts).\n+/// And that's no good. So, for now, one can't use an alias when altering\n+/// someone else's page — one has to do that as oneself. [deanon_risk]\n+/// Later on, if a moderator really wants to alter sbd elses page using\n+/// an alias, maybe that should by default be a different alias, e.g.\n+/// a new anonym, than what they use if they're part of the discussion\n+/// on the page and trying to be anonymous. [anon_mods]\n+///\n+/// If trying to do sth not-allowed, shows an error dialog and won't call `then`.\n+///\n+export function chooseEditorPersona(ps: ChooseEditorPersonaPs, then?: (res: DoAsAndOpts) => V) {\n+\n+  // TESTS_MISSING  TyTALIALTERPG\n+\n   const page: Page = ps.store.currentPage;\n   dieIf(!page, 'TyE56032MWJ');\n   const post = page.postsByNr[ps.postNr || BodyNr];\n   const author = ps.store.usersByIdBrief[post.authorId];\n   const me: Me = ps.store.me;\n \n+  const dp: DiscPropsDerived | U = ps.store.curDiscProps;\n+\n+  const pseudonymsAllowed = false; // [pseudonyms_later]\n+  const anonsAllowed = dp && dp.comtsStartAnon >= NeverAlways.Allowed;\n+  const mustBeAnon = dp && dp.comtsStartAnon >= NeverAlways.AlwaysButCanContinue;\n+\n+  const switchedToPseudonym = false; // [pseudonyms_later]\n+  const switchedToAnonym = me.usePersona && !!me.usePersona.anonStatus;\n+  const switchedToSelf = me.usePersona && me.usePersona.self;\n+\n   const postedAsSelf = author.id === me.id;\n   const postedAsAlias = author.anonForId === me.id;\n \n-  // ANON_UNIMPL  Might want to do anonymously, or using a pseudonym, regardless\n-  // of history.  [alias_mode]\n   if (!postedAsSelf && !postedAsAlias) {\n     // Ask the server for any existing anon, or create a new one?\n-    // But for now, continue as oneself (don't use an alias) — only works if is\n-    // mod or admin, otherwise the server will return a permission error. [anon_mods]\n-    then({ doAsAnon: false, myAliasOpts: [false] });\n+    // For now, continue as oneself (don't use an alias) — only works if is\n+    // pat has `mayEditPage` or `mayEditComment` or `mayEditWiki` permissions,\n+    // otherwise the server will return a permission error. Later, could create\n+    // a new anon for any moderator actions (so others can't know that some anonymous\n+    // comments in the discussion, are by a moderator). [anon_mods]\n+\n+    if (ps.draft) {\n+      if (!ps.draft.doAsAnon) {  // [oneself_0_false]\n+        // Pat has already started editing as hanself —  don't pop up any dialog again.\n+        editAsSelf();\n+        return;\n+      }\n+      else {\n+        // Pat started editing using an alias, but that's not supported / allowed.\n+        // Continue below: Show the info message, and edit as hanself.\n+      }\n+    }\n+\n+    // COULD allow if is wiki  [alias_ed_wiki] [alias_0_ed_others]\n+    const errMsg: St | N = !mustBeAnon ? null :\n+          \"You cannot edit other people's posts here. This is an anonymous-\" +\n+          \"only secttion, but you cannot edit others' posts anonymously, as of now.\";\n+    if (errMsg) {\n+      morekit.openSimpleProxyDiag({ atRect: ps.atRect, body: rFr({}, errMsg) });\n+      return;\n+    }\n+\n+    const infoMsg: St | N =\n+        switchedToAnonym ? \"You cannot edit other people's posts anonymously\" : (\n+        switchedToPseudonym ? \"You cannot edit other people's posts under \" +\n+                                                      \"a pseudonymous name\" : (\n+        // For clarity, if it's possible to be anonymous, then require that pat has\n+        // explicitly chooses to post as hanself.\n+        // UX COULD [alias_ux] If pat has commented or done sth on/with the\n+        // page as hanself, then, don't ask, just continue as pat hanself.\n+        // Look in `store.curPersonaOptions.optsList[0]` — if it's pat hanself\n+        // (not an alias), and it's also the best guess, the that's enough\n+        // (set infoMsg to null).\n+        (anonsAllowed || pseudonymsAllowed) && !switchedToSelf ?\n+                          \"You cannot edit other people's posts anonymously\" : (\n+        // Need not show any message (continue with `editAsSelf()` below).\n+        null)));\n+    if (infoMsg) {\n+      // If it's a one-click thing, like accepting an answer, \"Edit post as\" is confusing?\n+      // There's no editor involved. \"Do as: ...\" is better, right.\n+      const editAs = ps.isInstantAction ? \"Do as\" : \"Edit post as\";  // I18N\n+      const body = rFr({},\n+        r.p({}, `${editAs} yourself, ${pat_name(me)}?`),  // I18N\n+        infoMsg);\n+      morekit.openSimpleProxyDiag({ atRect: ps.atRect, body,\n+            primaryButtonTitle: \"Yes, do as me\",  // I18N\n+            secondaryButonTitle: t.Cancel,\n+            onPrimaryClick: () => {\n+              editAsSelf();\n+            }});\n+      return;\n+    }\n+\n+    function editAsSelf() {\n+      // _Only_one_item (`false`) in the list —  must edit as oneself.\n+      then({ doAsAnon: false, myAliasOpts: [false] });  // [oneself_0_false]\n+    }\n+\n+    editAsSelf();\n   }\n   else {\n-    // [deanon_risk] Might not want to do mod-only things using an anonym that has\n-    // also posted comments (so won't show that that anon is a mod).\n-    const anyAlias = postedAsSelf\n-        ? false\n-        : { sameAnonId: author.id, anonStatus: author.anonStatus } as SameAnon;\n-\n-    then({ doAsAnon: anyAlias, myAliasOpts: [anyAlias] })\n+    // Continue using the same persona, as when creating the page. (See the descr\n+    // of this fn.)\n+    const anyAlias: MaybeAnon = postedAsSelf\n+        ? false  // [oneself_0_false]\n+        : { sameAnonId: author.id, anonStatus: author.anonStatus } satisfies SameAnon;\n+\n+    const modeAuthorMismatch =\n+            postedAsSelf && switchedToAnonym || postedAsAlias && switchedToSelf;\n+\n+    // If draft author != post author, pat needs to continue editing as the *post author*.\n+    // (If using the draft author persona, others might guess that that one, and the\n+    // post author, are the same. For example, if you posted as Anonym A (post author),\n+    // then somehow managed to save a draft with yourself as author, then, when you resume\n+    // the draft, you'll be editing as Anon A again, so others can't see that both\n+    // you and Anon A can edit the same post.) [true_0_ed_alias] [alias_0_ed_others]\n+    if (ps.draft && isVal(ps.draft.doAsAnon) && ps.draft.doAsAnon !== anyAlias // [oneself_0_false]\n+          || modeAuthorMismatch) {\n+      // TESTS_MISSING  TyTDRAFTALI\n+      // [pseudonyms_later]\n+      const edit = ps.isInstantAction ? \"do\" : \"edit\";\n+      const asWho = // I18N and below\n+              anyAlias === false ?  // [oneself_0_false]\n+                    rFr({}, r.b({}, \"yourself\"), \" (not anonymously)\") : (\n+              anyAlias.anonStatus ?\n+                    r.b({}, anonStatus_toStr(anyAlias.anonStatus, Verbosity.Full)) :\n+              \"unknown [TyEUNKALI]\");  // D_DIE\n+      // [close_cross_css]\n+      const body = r.p({ style: { marginRight: '30px' }},\n+              `You will ${edit} as `, asWho);\n+      const asMeOrAnon = anyAlias === false ? \"as me\" : \"anonymously\";\n+\n+      morekit.openSimpleProxyDiag({ atRect: ps.atRect, body,\n+            primaryButtonTitle: `Ok, I'll ${edit} ${asMeOrAnon}`,\n+            secondaryButonTitle: t.Cancel,\n+            onPrimaryClick: () => {\n+              then({ doAsAnon: anyAlias, myAliasOpts: [anyAlias] });\n+            }});\n+    }\n+    else {\n+      // _Only_one_item (`anyAlias`) in the list.\n+      then({ doAsAnon: anyAlias, myAliasOpts: [anyAlias] });\n+    }\n   }\n }\n \n \n \n-/// Figures out which alias to use (if any), when replying, voting, editing one's\n-/// page, etc. Uses the same anon as most recently in the same sub thread, if any,\n-/// otherwise the same as elsewhere on the page. ANON_UNIMPL:  But if a moderator does sth\n-/// only mods may do, creates a new anon for moderator actions (to not show that\n-/// any anon used for comments, is a moderator). [anon_mods]\n-/// [alias_mode] If one is in e.g. Anon Mode, does things anonymously if allowed,\n-/// or pops up a dialog and says it's not allowed here (e.g. this category).\n+/// Figures out, or pops up a dialog and asks, which alias to use (if any), when\n+/// posting comments or pages, or voting (\"posting\" a vote).  [choose_persona]\n ///\n-/// Later: if `then` specified, might ask the server to suggest which alias to\n-/// use and/or pop up a dialog. Otherwise, suggests something directly\n-/// (which can be good, if opening the editor — there's an alias dropdown there,\n-/// so can change later, no need for another dialog).\n+/// Prefers the same alias as most recently in the same sub thread, if any,\n+/// Then the same as elsewhere on the page. (See findPersonaOptions().)\n+/// Then any persona mode alias [alias_mode],  then any per category default persona,\n+/// e.g. anonymous in anon-by-default cats.\n ///\n-export function maybeChooseAnon(ps: MaybeChooseAnonPs, then?: (_: ChoosenAnon) => V)\n-      : ChoosenAnon {\n-\n-  const discStore: DiscStore = ps.store;\n-  const postNr: PostNr | U = ps.postNr;\n-  const discProps: DiscPropsDerived = ps.discProps || page_deriveLayout(\n-          discStore.currentPage, discStore, LayoutFor.PageNoTweaks);\n+/// Later: Might ask the server to suggest which alias to use  [fetch_alias].\n+///\n+export function choosePosterPersona(ps: ChoosePosterPersonaPs,\n+      then?: (_: DoAsAndOpts | 'CANCEL') => V)\n+      : DoAsAndOpts {\n \n-  const myAliasesHere: MyPatsOnPage | U = postNr && disc_findAnonsToReuse(discStore, {\n-          forWho: discStore.me, startAtPostNr: postNr });\n+  // @ifdef DEBUG\n+  dieIf(then && !ps.atRect, \"Wouldn't know where to open dialog [TyE70WJE35]\");\n+  // @endif\n \n-  const anonsAllowed = discProps.comtsStartAnon >= NeverAlways.Allowed;\n-  const anonsRecommended = discProps.comtsStartAnon >= NeverAlways.Recommended;\n+  // ----- Derive persona options list\n \n-  // When someone starts posting on the relevant page, must they be anonymous?\n-  const mustBeAnon = discProps.comtsStartAnon >= NeverAlways.AlwaysButCanContinue;\n+  // (We can't use `DiscStore.curPersonaOptions`: We want persona options for the\n+  // comments thread ending at `ps.postNr`, but `curPersonaOptions` is for the whole\n+  // page, no specific sub thread.)\n \n-  // It is ok to *continue* posting using one's real account, on\n-  // this page, if  comments-start-anon is  Always-**But-Can-Continue**  posting\n-  // using one's real name.\n-  const canContinueAsSelf =\n-          discProps.comtsStartAnon <= NeverAlways.AlwaysButCanContinue;\n+  const myPersonasThisPage = disc_findMyPersonas(\n+          ps.discStore, { forWho: ps.me, startAtPostNr: ps.postNr });\n+  const personaOpts: PersonaOptions = findPersonaOptions({\n+          myPersonasThisPage, me: ps.me, discProps: ps.discStore.curDiscProps });\n \n-  // @ifdef DEBUG\n-  dieIf(mustBeAnon, \"Unimpl: mustBeAnon [TyE602MKG1]\");\n-  dieIf(!canContinueAsSelf, \"Unimpl: !canContinueAsSelf [TyE602MKG2]\");\n-  dieIf(anonsAllowed && discProps.newAnonStatus === AnonStatus.NotAnon, \"TyE6@NJ04\");\n-  // @endif\n+  const res: DoAsAndOpts = {\n+    doAsAnon: personaOpts ? personaOpts.optsList[0].doAs : false, // [oneself_0_false]\n+    myAliasOpts: personaOpts ? personaOpts.optsList.map(a => a.doAs) : [false],\n+  }\n \n-  if (myAliasesHere &&\n-        !myAliasesHere.sameThread.length &&\n-        myAliasesHere.outsideThread.length >= 2) {\n-    // UX: ask which alias to use? [choose_alias]   unless it's clear from any\n-    // current [alias_mode] which one to use.  ANON_UNIMPL\n-    // Pat has commented or voted using two or more different aliases, or hans real\n-    // account and an alias, on this page, but not in this thread. — Then, hard to know\n-    // which alias han wants to continue using.\n-    // If asking, and pat wants to use hans real name, maybe show an extra\n-    // \"Use your real name? (That is, @your_username)  [yes / no]\"  dialog?\n-    //\n-    // For now, default to doing things anonymously if pat has been anon\n-    // anywhere on this page.\n-    // So:  noop()   here, for now.\n+  if (ps.draft && isVal(ps.draft.doAsAnon)) {\n+    addDraftAuthor_inPl(ps.draft, res);\n+    personaOpts.isAmbiguous = false; // will use the author of the draft\n   }\n \n-  // The user accounts the current has used on this page — first looking higher up in\n-  // the same sub thread, then looking at the whole page.\n-  const patsByThreadThenLatest = !myAliasesHere ? [] :\n-          [...myAliasesHere.sameThread, ...myAliasesHere.outsideThread];\n-\n-  // Only looking at the same sub thread (parent comment, grandparent etc).\n-  const lastPatSameThread: Pat | U = myAliasesHere?.sameThread[0];\n-\n-  const lastAnonPat: Pat | U = patsByThreadThenLatest.find(p => p.isAnon);\n-  const lastAnon: WhichAnon | N = !lastAnonPat ? null :\n-              { sameAnonId: lastAnonPat.id, anonStatus: lastAnonPat.anonStatus } as SameAnon;\n-\n-  const doAsAnon: WhichAnon | false = !patsByThreadThenLatest.length\n-      ? (\n-        // We haven't posted or voted on this page before.\n-        // Create a new anonym, iff recommended.\n-        anonsRecommended\n-              ? { newAnonStatus: discProps.newAnonStatus } as NewAnon\n-              : false  // don't do as anon, use real account\n-        )\n-      : (\n-        // We have posted on this page before. But in the same sub thread?\n-        lastPatSameThread\n-              ? (\n-                // Continue using our earlier account, from the same sub thread.\n-                // (Either an anonym, or ourself.)\n-                lastPatSameThread.isAnon ? lastAnon : false)\n-              :\n-                // If we've posted or commented anonymously anywhere else\n-                // on the page, continue anonymously.\n-                // Otherwise, continue using our real name (since we've used our\n-                // real name previously, on this page).\n-                // Here, could make sense to explicitly [choose_alias] or derive\n-                // based on the [alias_mode].\n-                lastAnon || false\n-        );\n-\n-  // Even if we'll by default continue as ourself (!doAsAnon), we might need an anonym\n-  // to show in the ChooseAnonModal dropdown.\n-  const anyAnon = doAsAnon || lastAnon ||\n-          anonsAllowed && ({ newAnonStatus: discProps.newAnonStatus } as NewAnon);\n-\n-  // Distant future: [pseudonyms_later]\n-  // const anyPseudonyms: WhichPseudonym[] = ...\n-  // and also a way to:\n-  //    openCreatePseudonymsDialog(..) ?\n-  //  — there could be a Create Pseudonym button?\n-\n-  const res: ChoosenAnon = {\n-    doAsAnon,\n-    myAliasOpts: anyAnon\n-          ? [false, anyAnon]  // options are: ourself, or the anonym `anyAnon`\n-          : [false],          // option is: we can only be ourself\n-  };\n-\n-  if (then) {\n+  // ----- Choose persona\n+\n+  // If we're unsure which alias (if any) the user wants to use, we'll open a dialog\n+  // and ask.  But if the caller didn't pass any `then()` fn, then, return the\n+  // result immediately.\n+\n+  if (!then)\n+    return res;\n+\n+  if (personaOpts.isAmbiguous) {\n+    openChoosePersonaDiag({ atRect: ps.atRect,\n+          personaOpts, me: ps.me, origins: ps.origins,\n+          }, then);\n+  }\n+  else {\n     then(res);\n   }\n-  return res;\n }\n \n \n-let setStateExtFn: (_: ChooseAnonDlgPs) => Vo;\n+/// A next-to-the-button-clicked dialog that asks the user which alias to use,\n+/// if it's unclear. E.g. han has switched to Anonmous mode, but has commented\n+/// on the page as hanself already. When posting another comment, does\n+/// han want to be anonymous (because of Anonymous mode), or continue commenting\n+/// as hanself?  We'd better ask, not guess.\n+///\n+function openChoosePersonaDiag(ps: { atRect: Rect,\n+        personaOpts: PersonaOptions, me: Me, origins: Origins, },\n+        then?: (_: (DoAsAndOpts | 'CANCEL')) => V) {\n+  morekit.openProxyDiag({ atRect: ps.atRect, flavor: DiagFlavor.Dialog,\n+          onHide: () => { if (then) then('CANCEL'); }, dialogClassName: 'c_' },\n+          (closeDiag: () => V) => {\n+\n+    const opts = ps.personaOpts.optsList.map(a => a.doAs);\n+\n+    function closeAndThen(doAsAnon: MaybeAnon) {\n+      closeDiag();\n+      then({ doAsAnon, myAliasOpts: opts });\n+    }\n+\n+    let debugJson = null;\n+    // @ifdef DEBUG\n+    //debugJson = r.pre({}, JSON.stringify(ps, undefined, 3));\n+    // @endif\n+\n+    // (This list might include more than one type of anonymous user, say, 1) temporarily\n+    // anonymous and 2) permanently anonymous. This can happen if a user U replies as\n+    // perm anon on a page in a perm anon category. But then an admin moves the page to\n+    // a temp anon category. Now, user U replies again, but chooses to be temp anon, this\n+    // time (which is allowed in this different category). [move_anon_page] [dif_anon_status])\n+    return rFr({},\n+        r.div({ className: 'esDropModal_header' },\n+            `Do as ...`),\n+        r.ol({},\n+            ps.personaOpts.optsList.map((opt: PersonaOption) => {\n+              const avatarElm = avatar.Avatar({\n+                    user: opt.alias, origins: ps.origins, ignoreClicks: true,\n+                    size: AvatarSize.Small });\n+              return ExplainingListItem({\n+                  key: opt.alias.id,\n+                  title: pat_name(opt.alias),\n+                  img: avatarElm,\n+                  text: ambiguityToDescr(opt, ps.me),\n+                  tabIndex: 100,\n+                  onClick: () => closeAndThen(opt.doAs),\n+              });\n+            })),\n+        debugJson);\n+  });\n+}\n+\n+\n+function ambiguityToDescr(opt: PersonaOption, me: Me): RElm {\n+  // UX SHOULD require 2 clicks to choose? At different coordinates. [deanon_risk] [mouse_slip]\n+  const isMe = opt.alias.id === me.id;\n+  const selfOrAnon = isMe ? \"Yourself\" : anonStatus_toStr(  // [pseudonyms_later]  I18N\n+            opt.alias.anonStatus, Verbosity.Full);\n+  const selfOrAnonLower = selfOrAnon.toLowerCase();\n+\n+  const part1 =\n+      opt.inSameThread ?\n+          // \"Earlier\", but not necessarily \"above\" (as in higher up on the page). Depends\n+          // on the sort order.\n+          r.span({}, `You are ${selfOrAnonLower} earlier in this thread`) : (\n+      opt.onSamePage ?\n+          r.span({}, `You are ${selfOrAnonLower} elsewhere on this page`) : (\n+      null));\n+\n+  let part2 = part1 ? '.' : '';\n+  if (opt.isFromMode) {\n+    if (!part1) part2 = `You're in ${selfOrAnon} mode.`;\n+    else part2 = `, and you're in ${selfOrAnon} mode.`;\n+  }\n+\n+  // Skip this — \"You're recommended ...\" sounds a bit paternalistic?\n+  // (Would make sense if  [the *recommended* persona] being different from e.g.  [any previously\n+  // *used* persona] made the choose-persona dialog to appear (`PersonaOptions.isAmbiguous`)\n+  // —  but that's no longer the case.)\n+  //if (opt.isRecommended) {\n+  //  part3 = ` You're recommended to be ${selfOrAnon} here.`;\n+  //}\n+\n+  const part4 = part2 || !isMe ? '' : \"Yourself\";\n+\n+  const part5 = opt.isNotAllowed ?\n+      ` However, you cannot be ${selfOrAnonLower} here.` : '';\n+\n+  return rFr({}, part1, part2, part4, part5);\n+}\n+\n+\n+function addDraftAuthor_inPl(draft: Draft, doAsOpts: DoAsAndOpts) {\n+  dieIf(!isVal(draft.doAsAnon), 'TyE3076MSRDw')  // [oneself_0_false]\n+\n+  // Let's add the persona pat has already choosen as the author, to doAsOpts, if missing.\n+  // (Not impossible the server will refuse to save the post —  maybe anonymous\n+  // comments have been disabled, for example. Then, the user can choose another persona,\n+  // and try again.)\n+  let optFound: MaybeAnon | U;\n+  for (let opt of doAsOpts.myAliasOpts) {\n+    if (opt === false || draft.doAsAnon === false) { // false is oneself [oneself_0_false]\n+      if (opt === draft.doAsAnon) {\n+        optFound = opt;\n+        break;\n+      }\n+    }\n+    else {\n+      // We know it's WhichAnon, since is not oneself (tested above). [pseudonyms_later]\n+      const optAlias = opt as WhichAnon;\n+      const draftAlias = draft.doAsAnon as WhichAnon;\n+      if (optAlias.sameAnonId || draftAlias.sameAnonId) {\n+        if (optAlias.sameAnonId === draftAlias.sameAnonId) {\n+          optFound = opt;\n+          break;\n+        }\n+      }\n+      else if (optAlias.anonStatus || draftAlias.anonStatus) {\n+        if (optAlias.anonStatus === draftAlias.anonStatus) {\n+          // Must be `WhichAnon.lazyCreate` — `createNew_tst` hasn't been implemented.\n+          optFound = opt;\n+          break;\n+        }\n+      }\n+      else {\n+        // Can't happen, until later when implementing pseudonyms.\n+      }\n+    }\n+  }\n+\n+  // If [the alias pat is using as author of the draft] isn't among the current options,\n+  // add it.\n+  if (!isVal(optFound)) { // [oneself_0_false]\n+    doAsOpts.myAliasOpts.push(draft.doAsAnon);\n+    optFound = draft.doAsAnon;\n+  }\n \n-export function openAnonDropdown(ps: ChooseAnonDlgPs) {\n+  // Continue using the same author, for this draft, as before.\n+  // (`optFound` also includes any anon status, so use it. But `draft.doAsAnon`\n+  // might not incl the anon status —  it'd be better if it did, see [chk_alias_status].)\n+  doAsOpts.doAsAnon = optFound;\n+}\n+\n+\n+\n+// ----------------------------------------------------------------------------\n+// REFACTOR:\n+// The rest of this file, should be in its own file?  ChoosePersonaDropdown.ts?\n+\n+\n+let setStateExtFn: (_: ChoosePersonaDlgPs) => V;\n+\n+export function openAnonDropdown(ps: ChoosePersonaDlgPs) {\n   if (!setStateExtFn) {\n     ReactDOM.render(ChooseAnonModal(), utils.makeMountNode());  // or [use_portal] ?\n   }\n   setStateExtFn(ps);\n }\n \n \n+\n /// Some dupl code? [6KUW24]  but this with React hooks.\n ///\n ///  Or use instead:  client/app-more/page-dialogs/add-remove-people-dialogs.more.ts  ?\n@@ -200,7 +421,7 @@ const ChooseAnonModal = React.createFactory<{}>(function() {\n \n   // TESTS_MISSING\n \n-  const [state, setState] = React.useState<ChooseAnonDlgPs | N>(null);\n+  const [state, setState] = React.useState<ChoosePersonaDlgPs | N>(null);\n \n   setStateExtFn = setState;\n \n@@ -223,7 +444,8 @@ const ChooseAnonModal = React.createFactory<{}>(function() {\n       const active =\n           // `whichAnon` and `state.curAnon` can be false, or a WhichAnon object.\n           any_isDeepEqIgnUndef(whichAnon, state.curAnon);\n-      const status = whichAnon && (whichAnon.anonStatus || whichAnon.newAnonStatus);\n+      // [oneself_0_false] `&&` won't work with `{ self: true }`.\n+      const status = whichAnon && whichAnon.anonStatus;\n       return (\n           ExplainingListItem({\n             title, text, active, key: whichAnon ? whichAnon.sameAnonId || 'new' : 'self',\n@@ -239,7 +461,7 @@ const ChooseAnonModal = React.createFactory<{}>(function() {\n           }));\n     }\n \n-    items = state.myAliasOpts.map(makeItem);\n+    items = state.myAliasOpts.map(makeItem);// [ali_opts_only_needed_here]\n   }\n \n   return (\n@@ -277,7 +499,8 @@ const enum TitleDescr {\n \n function whichAnon_titleDescrImpl(doAs: MaybeAnon, ps: { me: Me, pat?: Pat },  // I18N\n         what: TitleDescr): St | RElm {\n-  const anonStatus = doAs ? doAs.anonStatus || doAs.newAnonStatus : AnonStatus.NotAnon;\n+  // [oneself_0_false] `?` won't work with `{ self: true }`.\n+  const anonStatus = doAs ? doAs.anonStatus : AnonStatus.NotAnon;\n   // UX SHOULD if doAs.sameAnonId, then, show which anon (one might have > 1 on the\n   // same page) pat will continue posting as / using.\n   // But not a hurry? Right now one cannot have more than one anon per"
    },
    {
      "sha": "c6ee5421244b8e4976cb9ee06cd4c011f0f653d1",
      "filename": "client/app-more/page-dialogs/delete-post-dialog.more.ts",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2Fdelete-post-dialog.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-dialogs%2Fdelete-post-dialog.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fpage-dialogs%2Fdelete-post-dialog.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -31,11 +31,11 @@ const ModalFooter = rb.ModalFooter;\n \n let deletePostDialog;\n \n-export function openDeletePostDialog(post: Post, at: Rect) {\n+export function openDeletePostDialog(ps: { post: Post, at: Rect, doAsAnon?: MaybeAnon }) {\n   if (!deletePostDialog) {\n     deletePostDialog = ReactDOM.render(DeletePostDialog(), utils.makeMountNode());\n   }\n-  deletePostDialog.open(post, at);\n+  deletePostDialog.open(ps);\n }\n \n \n@@ -48,11 +48,12 @@ const DeletePostDialog = createComponent({\n     };\n   },\n \n-  open: function(post: Post, at: Rect) {\n+  open: function(ps: { post: Post, at: Rect, doAsAnon?: MaybeAnon }) {\n     this.setState({\n       isOpen: true,\n-      post: post,\n-      atRect: at,\n+      post: ps.post,\n+      atRect: ps.at,\n+      doAsAnon: ps.doAsAnon,\n       windowWidth: window.innerWidth,\n     });\n   },\n@@ -62,7 +63,7 @@ const DeletePostDialog = createComponent({\n   },\n \n   doDelete: function() {\n-    ReactActions.deletePost(this.state.post.nr, this._delRepls, this.close);\n+    ReactActions.deletePost(this.state.post.nr, this._delRepls, this.state.doAsAnon, this.close);\n   },\n \n   render: function () {"
    },
    {
      "sha": "7e5463455e401ea7c40bff321097e12f2e466ff7",
      "filename": "client/app-more/page-tools/page-tools.more.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 14,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-tools%2Fpage-tools.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpage-tools%2Fpage-tools.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fpage-tools%2Fpage-tools.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -66,16 +66,6 @@ const PageToolsDialog = createComponent({\n     ReactActions.unpinPage(this.close);\n   },\n \n-  deletePage: function() {\n-    const store: Store = this.state.store;\n-    ReactActions.deletePages([store.currentPageId], this.close);\n-  },\n-\n-  undeletePage: function() {\n-    const store: Store = this.state.store;\n-    ReactActions.undeletePages([store.currentPageId], this.close);\n-  },\n-\n   render: function () {\n     const store: Store = this.state.store;\n     const me: Myself = store.me;\n@@ -88,8 +78,8 @@ const PageToolsDialog = createComponent({\n     //let selectPostsButton = !store_canSelectPosts(store) ? null :\n       //Button({ onClick: this.selectPosts }, \"Select posts\");\n \n-    let pinPageButton;\n-    let pinPageDialog;\n+    let pinPageButton: RElm | U;\n+    let pinPageDialog: RElm | U;\n     if (store_canPinPage(store)) {\n       pinPageDialog = PinPageDialog(_.assign({ ref: 'pinPageDialog' }, childProps));\n       pinPageButton =\n@@ -101,10 +91,12 @@ const PageToolsDialog = createComponent({\n       Button({ onClick: this.unpinPage, className: 'e_UnpinPg'  }, \"Unpin Topic\");\n \n     const deletePageButton = !store_canDeletePage(store) ?  null :\n-      Button({ onClick: this.deletePage, className: 'e_DelPg' }, \"Delete Topic\");\n+      DeletePageBtn({ pageIds: [store.currentPageId], store,\n+            verb: Verbosity.Full, close: this.close });\n \n     const undeletePageButton = !store_canUndeletePage(store) ?  null :\n-      Button({ onClick: this.undeletePage, className: 'e_RstrPg' }, \"Restore Topic\");\n+      DeletePageBtn({ pageIds: [store.currentPageId], store, undel: true,\n+            verb: Verbosity.Full, close: this.close });\n \n     const idsAndUrlsButton = page.pageRole !== PageRole.EmbeddedComments || !me.isAdmin ?  null :\n       Button({ onClick: () => openPageIdsUrlsDialog(page.pageId), className: 'e_PgIdsUrls' },"
    },
    {
      "sha": "628868bef28308fe6ec6423c08dc5788fd421071",
      "filename": "client/app-more/persona/persona-info-diag.ts",
      "status": "added",
      "additions": 297,
      "deletions": 0,
      "changes": 297,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpersona%2Fpersona-info-diag.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fpersona%2Fpersona-info-diag.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fpersona%2Fpersona-info-diag.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2024 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+/// <reference path=\"../../macros/macros.d.ts\" />\n+/// <reference path=\"../more-prelude.more.ts\" />\n+\n+//------------------------------------------------------------------------------\n+   namespace debiki2.persona {\n+//------------------------------------------------------------------------------\n+\n+const r = ReactDOMFactories;\n+\n+\n+export function openPersonaInfoDiag(ps: { atRect: Rect, isSectionPage: Bo,\n+        me: Me, personaOpts: PersonaOptions, discProps: DiscPropsDerived }): V {\n+\n+  const discProps: DiscPropsDerived = ps.discProps;\n+  const me: Me = ps.me;\n+\n+  // This'll be  page_users3.prefer_alias_id_c  once implemented.\n+  //const thisPagePrefAlias: KnownAnonym | Me | N = null;\n+\n+  //const pseudonymsRecommended = false; [pseudonyms_later]\n+  const anonsAllowed = discProps.comtsStartAnon >= NeverAlways.Allowed;\n+  const anonsRecommended = discProps.comtsStartAnon >= NeverAlways.Recommended;\n+  const mustBeAnon = discProps.comtsStartAnon >= NeverAlways.AlwaysButCanContinue;\n+  const switchedToPseudonym = false;\n+  const switchedToAnonStatus: AnonStatus | U = me.usePersona && me.usePersona.anonStatus;\n+  const switchedToSelf = me.usePersona && me.usePersona.self;\n+\n+  morekit.openProxyDiag({ atRect: ps.atRect, flavor: DiagFlavor.Dialog,\n+            dialogClassName: 'e_PersInfD' }, (closeDiag: () => V) => {\n+\n+    const inThisPlace = ps.isSectionPage ? \"in this category\" : \"on this page\";\n+    const thereforeIllAsk = \"Therefore, I'll ask you if you want to be yourself, \" +\n+              \"or be anonymous, if you post something here.\";\n+\n+    // Either:  \"But you  have also  posted       as ...\"\n+    //     Or:  \"You      have       posted  both as ... and as ...\"\n+    const hasBeenBoth = ps.personaOpts.hasBeenAnon &&  ps.personaOpts.hasBeenSelf;\n+    const butYou = hasBeenBoth ? \"You\" : \"But you\";\n+    const also = hasBeenBoth ? '' : \"also \";\n+    const both = hasBeenBoth ? \"both \" : '';\n+\n+    let whatMode: St | U;\n+    let content: RElm;\n+    let enterSelfModeBtn: RElm | U;\n+    let enterAnonModeBtn: RElm | U;\n+    let okPersona = true;\n+\n+    if (switchedToSelf) {  // [alias_mode]\n+      whatMode = \"Yourself\";  // I18N, this whole fn\n+\n+      const youreInSelfMode = rFr({}, \"You're in \", r.b({}, \"Yourself mode\"));\n+      const colonPostingAsSelf = \": You're posting and voting as yourself.\";\n+\n+      const ambigMsg = !ps.personaOpts.hasBeenAnon ? null : rFr({},\n+            r.p({},\n+              `${butYou} have ${also}posted ${both}anonymously${\n+                  both ? \", and as yourself,\" : ''} ${inThisPlace}.`),\n+            r.p({},\n+              thereforeIllAsk));\n+\n+      if (mustBeAnon && ps.personaOpts.hasBeenSelf) {\n+        // 1: _May_not_but_can_continue\n+        // One can continue as oneself, if one has commented as oneself already before\n+        // this page/category became anonymous-only.\n+        content = rFr({},\n+            r.p({}, youreInSelfMode, '.'),\n+            r.p({},\n+              `Normally, you cannot post as yourself ${inThisPlace}, ` +\n+              \"but you have done that already; therefore you can continue as yourself.\"));\n+      }\n+      else if (mustBeAnon) {\n+        // 2: _May_not\n+        okPersona = false;\n+        content = r.p({},\n+              youreInSelfMode, \". But you \", r.b({}, \"cannot\"),\n+              \" post as yourself here — everyone needs to be anonymous.\");\n+      }\n+      else if (anonsAllowed) { // [pseudonyms_later]\n+        // 3: _Can_choose\n+        content = rFr({},\n+              r.p({}, youreInSelfMode, colonPostingAsSelf),\n+              ambigMsg || r.p(\"You can be anonymous, though, if you want.\"));\n+      }\n+      else {\n+        // 4: _Everyone_is\n+        content = rFr({},\n+            r.p({}, youreInSelfMode, colonPostingAsSelf),\n+            ambigMsg ||\n+                // Maybe a bit interesting that Yourself mode isn't needed, here:\n+                // (But one can continue posting anonymously if one has done that already,\n+                // on the current page.)\n+                r.p({}, \"(On this page, you cannot be anonymous anyway.)\"),\n+            );\n+      }\n+    }\n+    else if (switchedToAnonStatus) {\n+      whatMode = anonStatus_toStr(switchedToAnonStatus);\n+      const youreInAnonMode = rFr({}, \"You're in \", r.b({}, whatMode + \" mode\"));\n+      const colonPostingAnonly = \": You're posting and voting anonymously.\";\n+      const ambigMsg = !ps.personaOpts.hasBeenSelf ? null : rFr({},\n+          r.p({},\n+            `${butYou} have ${also}posted ${both}as yourself${\n+                  both ? \", and anonymously,\" : ''} ${inThisPlace}.`),\n+          r.p({},\n+            thereforeIllAsk));\n+\n+      // (Maybe not the same anon status.  [dif_anon_status])\n+      if (!anonsAllowed && ps.personaOpts.hasBeenAnon) {\n+        // 1: _May_not_but_can_continue\n+        // One can continue anonymously if one has been anonymous on this page already,\n+        // some time ago when that was allowed (or if the page got moved to another category?).\n+        content = rFr({},\n+            r.p({}, youreInAnonMode, '.',\n+            r.p({},\n+              `Normally, you cannot post anonymously ${inThisPlace}, ` +\n+              `but you have done that already; therefore you can continue.`)));\n+      }\n+      else if (!anonsAllowed) {\n+        // 2: _May_not\n+        okPersona = false;\n+        content = r.p({},\n+              youreInAnonMode, \". But you \", r.b({}, \"cannot\"), \" be anonymous here.\");\n+      }\n+      else if (!mustBeAnon) { // [pseudonyms_later]\n+        // 3: _Can_choose\n+        // (Maybe not the same type of anonyms?  [dif_anon_status])\n+        content = rFr({},\n+              r.p({}, youreInAnonMode, colonPostingAnonly),\n+              ambigMsg || (!anonsRecommended ? '' :\n+                  r.p({}, ` Everyone is anonymous ${inThisPlace} by default.`)));\n+      }\n+      else {\n+        // 4: _Everyone_is\n+        // (Maybe not the same type of anonyms?  [dif_anon_status])\n+        content = rFr({},\n+              r.p({}, youreInAnonMode, colonPostingAnonly),\n+              ambigMsg ||\n+                  r.p({}, `Everyone is anonymous ${inThisPlace} anyway.`));\n+      }\n+    }\n+    else if (switchedToPseudonym) {\n+\n+      // @ifdef DEBUG\n+      die('TyE206MFKG'); // [pseudonyms_later]\n+      // @endif\n+      void 0;\n+      /*\n+      whatMode = \"Pseudonymous Mode as user (S) Some Psuedonym\";\n+      if (mustBeAnon || !pseudonymsAllowed) {\n+        okAlias = false;\n+        content = rFr({}, \"You're in pseudonymous mode, but you cannot use pseudonyms here\" +\n+              (mustBeAnon ? \" — everyone must be anonymous.\" : '.'));\n+      }\n+      else {\n+        content = r.span({}, \"You're using a pseudonym, (P) some_pseudonym, which will \" +\n+              \"be used if you post topics or comments, or upvote anything.\" +\n+              (!ambiguity ? '' : \"However, you have also posted anonymously here, \" +\n+              \"and I'll need to ask you if you want to use the pseudonym, or \" +\n+              \"continue anonymously.\"));\n+      }\n+      */\n+    }\n+    else {\n+      const whenYouBlaBla = \"when you post comments or upvote others.\";\n+      if (ps.personaOpts.hasBeenSelf && ps.personaOpts.hasBeenAnon) {\n+        content = rFr({},\n+              r.p({}, \"You have been both anonymous and yourself on this page. \"),\n+              r.p({}, thereforeIllAsk));\n+      }\n+      else if (ps.personaOpts.hasBeenSelf) {\n+        content = rFr({},\n+            r.p({},\n+              \"You have been yourself on this page, so, you'll continue \" +\n+              \"being yourself, \" + whenYouBlaBla),\n+            !anonsAllowed ? null : r.p({},\n+              \"You can be anonymous instead, if you want.\"));\n+        // There'll be an [Enter Anonymous mode] button below (if allowed here)\n+        // – that's clear enough? (No need for \"Click ... below if ...\".)\n+      }\n+      else if (ps.personaOpts.hasBeenAnon) {\n+        // COULD: If has been both temp anon and permanently anon, say sth like:\n+        // \"You have been both temporarily and permanently anonymous on this page.\"\n+        // + thereforeIllAsk.  [dif_anon_status]\n+        content = rFr({},\n+            r.p({},\n+              \"You have been anonymous on this page, so, you'll continue \" +\n+              \"being anonymous, \" + whenYouBlaBla),\n+            mustBeAnon ? null: r.p({},\n+              \"You can post as yourself instead, if you want.\"));\n+        // There'll be an [Enter Yourself mode] button below (if allowed).\n+      }\n+      else if (anonsRecommended) {\n+        // Say \"temporarily anonymous\" if temp anon. [dif_anon_status]\n+        content = r.p({},\n+              `You and others are anonymous by default, ${inThisPlace}.`);\n+      } /*\n+      else if (pseudonymsRecommended) {\n+        // [pseudonyms_later]\n+        // How's this going to work?  Can't create pseudonyms automatically – pat needs\n+        // to choose a pseudonym name, hmm. Maybe a pop-up question like:\n+        //   \"Create a pseudonym? If you don't want to use your real name, ... [Yes] [No]\"\n+      } */\n+      else if (anonsAllowed) {\n+        content = rFr({},\n+            r.p({},\n+              // Say \"temporarily anonymous\" if temp anon. [dif_anon_status]\n+              `You can post anonymously here, if you want.`),\n+            r.p({},\n+              \"By default, your posting as yourself though.\"));\n+      }\n+      else {\n+        // Dead code? The personas info button shouldn't appear, if one cannot\n+        // be and hasn't been anonymous.\n+        content = r.p({},\n+              `You're yourself — you cannot post anonymously here.`);\n+      }\n+\n+      if (!mustBeAnon) enterSelfModeBtn =\n+            mkBtn(r.span({},\n+                \"Enter \", r.u({}, \"Yourself\"), \" mode\"),\n+                { self: true } satisfies Oneself);\n+\n+      if (anonsAllowed) enterAnonModeBtn =\n+            mkBtn(r.span({},\n+                \"Enter \", r.u({}, anonStatus_toStr(discProps.newAnonStatus)), \" mode\"),\n+                { anonStatus: discProps.newAnonStatus,\n+                  lazyCreate: true } satisfies LazyCreatedAnon);\n+\n+      // [pseudonyms_later] More buttons:\n+      //   [ Switch to (P) pseudonym_of_yours  ]\n+      //   [ Switch to (S) some_other_pseudonym]\n+      //   [ Create Pseudonym  ]\n+    }\n+\n+    /* Sometimes incl cur page aliases in content? But when? Maybe if clicking a [More v]\n+    // button, then, could show a list of all one's aliases on the current page, in the\n+    // contextbar —  there's already a \"Users on this page\" list there, see [users_here],\n+    // and filtering out only one's own personas can make sense?\n+    if (me.myAliasCurPage.length >= 1) {\n+      const user = me.myAliasCurPage.length === 1 ? \"user \" : \"users \";\n+      content = rFr({},\n+          \"You are anonymous \" + user,\n+          rFr({},\n+              me.myAliasCurPage.map((alias: KnownAnonym) =>\n+                  rFr({},\n+                      avatar.Avatar({ key: alias.id, user: alias, origins: store }),\n+                      r.span({ className: '' }, alias.username || alias.fullName)))),\n+          \"on this page.\" + everyoneIs);\n+    } */\n+\n+    const leaveModeBtn = !whatMode ? null :\n+            mkBtn(r.span({}, \"Leave \", r.u({}, whatMode), \" mode\"), null);\n+\n+    function mkBtn(title: St | RElm, usePersona: Oneself | LazyCreatedAnon | N): RElm {\n+      return Button({ onClick: () => {\n+          ReactActions.patchTheStore({ me: { usePersona } });\n+          closeDiag();\n+        }}, title);\n+    }\n+\n+    return rFr({},\n+        // Better without any header. The mode is in bold in the first sentence already,\n+        // feels like enough.\n+        // r.div({ className: 'esDropModal_header' }, !whatMode ? '' : whatMode + \" Mode\"),\n+        r.div({}, content),\n+        r.div({ className: 'c_PersInfD_Bs' },\n+          leaveModeBtn,\n+          enterSelfModeBtn,\n+          enterAnonModeBtn),\n+        );\n+  });\n+}\n+\n+\n+\n+\n+//------------------------------------------------------------------------------\n+   }\n+//------------------------------------------------------------------------------\n+// vim: fdm=marker et ts=2 sw=2 tw=0 fo=tcqwn list"
    },
    {
      "sha": "9b7b4a5080000158a4935f26124c1db4a9bc4883",
      "filename": "client/app-more/users/users-page.more.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fusers%2Fusers-page.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fusers%2Fusers-page.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fusers%2Fusers-page.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -455,7 +455,7 @@ const PatTopPanel = createComponent({\n \n     let isWhatInfo: St | N = null;\n     if (user.isAnon) {\n-      isWhatInfo = t.Anonym || \"Anonym\";\n+      isWhatInfo = anonStatus_toStr(user.anonStatus);\n     }\n     else if (isGuest(user)) {\n       isWhatInfo = t.upp.isGuest;"
    },
    {
      "sha": "6de8f9b599ddf74197df91af39780a9383d07057",
      "filename": "client/app-more/util/stupid-dialog.more.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Futil%2Fstupid-dialog.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Futil%2Fstupid-dialog.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Futil%2Fstupid-dialog.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -64,6 +64,7 @@ export function openDefaultStupidDialog(stuff: StupidDialogStuff) {\n }\n \n \n+// Much later: Remove, and [replace_stupid_diag_w_simple_proxy_diag].\n export const StupidDialog = createComponent({\n   displayName: 'StupidDialog',\n "
    },
    {
      "sha": "937f1ca9f6211655b299014bb5d7be6fd9010594",
      "filename": "client/app-more/widgets.more.ts",
      "status": "modified",
      "additions": 22,
      "deletions": 1,
      "changes": 23,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fwidgets.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fwidgets.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fwidgets.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -94,7 +94,7 @@ export const GroupList = function(member: UserDetailsStatsGroups, groupsMaySee:\n export const Expandable = (\n       props: { header: any, onHeaderClick: any, isOpen?: boolean,\n         className?: string, openButtonId?: string },\n-      ...children) => {\n+      ...children): RElm => {\n \n   let body = !props.isOpen ? null :\n     r.div({ className: 's_Expandable_Body' }, children);\n@@ -115,6 +115,27 @@ export const Expandable = (\n };\n \n \n+\n+// Wouldn't it be better with a [pick_persona_click_handler]?\n+export function DeletePageBtn(ps: { pageIds: PageId[], store: Store, undel?: true,\n+        verb?: Verbosity, close: () => V }): RElm {\n+\n+  const page = ps.verb > Verbosity.Full ? \" page\" : '';\n+  const title = (ps.undel ? \"Undelete\" : \"Delete\") + page;  // I18N\n+\n+  return Button({ className: ps.undel ? 'e_UndelPgB' : 'e_DelPgB',\n+        onClick: (event: MouseEvent) => {\n+          const atRect = cloneEventTargetRect(event);\n+          persona.chooseEditorPersona({ store: ps.store, atRect,\n+                  isInstantAction: true }, (doAsOpts: DoAsAndOpts) => {\n+            const delOrUndel = ps.undel ? ReactActions.undeletePages : ReactActions.deletePages;\n+            delOrUndel({\n+                  pageIds: ps.pageIds, doAsAnon: doAsOpts.doAsAnon }, ps.close);\n+          });\n+        } },\n+      title);\n+}\n+\n //------------------------------------------------------------------------------\n    }\n //------------------------------------------------------------------------------"
    },
    {
      "sha": "8a7f5c4076c99342b5cb77c446c2185fd4226cdd",
      "filename": "client/app-more/widgets/anon-purpose-btn.more.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fwidgets%2Fanon-purpose-btn.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-more%2Fwidgets%2Fanon-purpose-btn.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fwidgets%2Fanon-purpose-btn.more.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -72,7 +72,7 @@ function openAnonPurposeDiag(ps: DiscLayoutDiagState) {\n               dialogClassName: 'e_AnonPurpD' },\n       (closeDiag) => {\n \n-    const layout: DiscPropsSource | NU = ps.layout;\n+    const layout: DiscPropsSource = ps.layout;\n \n     let diagTitle: St | RElm | U;\n     let sensitiveItem: RElm | U;\n@@ -86,7 +86,7 @@ function openAnonPurposeDiag(ps: DiscLayoutDiagState) {\n     function makeItem(itemValue: AnonStatus, e2eClass: St): RElm {\n       let active: Bo;\n       let title: St | RElm;\n-      active = itemValue === ps.layout.newAnonStatus;\n+      active = itemValue === layout.newAnonStatus;\n       title = anonPurpose_title(itemValue);\n \n       return ExplainingListItem({"
    },
    {
      "sha": "0cc5af0a32eb24cbde56dedec394f1da7d235c63",
      "filename": "client/app-slim/ReactActions.ts",
      "status": "modified",
      "additions": 33,
      "deletions": 18,
      "changes": 51,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2FReactActions.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2FReactActions.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2FReactActions.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -262,31 +262,31 @@ export function unpinPage(success: () => void) {\n }\n \n \n-export function deletePages(pageIds: PageId[], success: () => void) {\n-  Server.deletePages(pageIds, () => {\n-    success();\n+export function deletePages(ps: { pageIds: PageId[], doAsAnon: MaybeAnon }, onOk: () => V) {\n+  Server.deletePages(ps, () => {\n+    onOk();\n     // CLEAN_UP  REFACTOR  use patchTheStore( StorePatch.deletedPageIds )  instead\n     ReactDispatcher.handleViewAction({\n       actionType: actionTypes.DeletePages,\n-      pageIds: pageIds,\n+      pageIds: ps.pageIds,\n     });\n   });\n }\n \n \n-export function undeletePages(pageIds: PageId[], success: () => void) {\n-  Server.undeletePages(pageIds, () => {\n-    success();\n+export function undeletePages(ps: { pageIds: PageId[], doAsAnon: MaybeAnon }, onOk: () => V) {\n+  Server.undeletePages(ps, () => {\n+    onOk();\n     ReactDispatcher.handleViewAction({\n       actionType: actionTypes.UndeletePages,\n-      pageIds: pageIds,\n+      pageIds: ps.pageIds,\n     });\n   });\n }\n \n \n-export function togglePageClosed(doAsAnon: MaybeAnon, onDone?: () => V) {\n-  Server.togglePageClosed(doAsAnon, (closedAtMs) => {\n+export function togglePageClosed(ps: { pageId: PageId, doAsAnon: MaybeAnon }, onDone?: () => V) {\n+  Server.togglePageClosed(ps, (closedAtMs) => {\n     ReactDispatcher.handleViewAction({\n       actionType: actionTypes.TogglePageClosed,\n       closedAtMs: closedAtMs\n@@ -298,19 +298,19 @@ export function togglePageClosed(doAsAnon: MaybeAnon, onDone?: () => V) {\n }\n \n \n-export function acceptAnswer(postId: number, doAsAnon: MaybeAnon) {\n-  Server.acceptAnswer(postId, doAsAnon, (answeredAtMs) => {\n+export function acceptAnswer(ps: { pageId: PageId, postId: PostId, doAsAnon: MaybeAnon }) {\n+  Server.acceptAnswer(ps, (answeredAtMs) => {\n     ReactDispatcher.handleViewAction({\n       actionType: actionTypes.AcceptAnswer,\n       answeredAtMs: answeredAtMs,\n-      answerPostUniqueId: postId,\n+      answerPostUniqueId: ps.postId,\n     });\n   });\n }\n \n \n-export function unacceptAnswer(doAsAnon: MaybeAnon) {\n-  Server.unacceptAnswer(doAsAnon, () => {\n+export function unacceptAnswer(ps: { pageId: PageId, doAsAnon: MaybeAnon }) {\n+  Server.unacceptAnswer(ps, () => {\n     unacceptAnswerClientSideOnly();\n   });\n }\n@@ -392,9 +392,10 @@ export function setPostHidden(postNr: number, hide: boolean, success?: () => voi\n }\n \n \n-export function deletePost(postNr: number, repliesToo: boolean, success: () => void) {\n-  Server.deletePostInPage(postNr, repliesToo, (response: { deletedPost, answerGotDeleted }) => {\n-    success();\n+export function deletePost(postNr: PostNr, repliesToo: Bo,\n+          doAsAnon: MaybeAnon | U, onOk: () => V) {\n+  Server.deletePostInPage(postNr, repliesToo, doAsAnon, (response: { deletedPost, answerGotDeleted }) => {\n+    onOk();\n     ReactDispatcher.handleViewAction({\n       actionType: actionTypes.UpdatePost,\n       post: response.deletedPost\n@@ -997,6 +998,8 @@ function markAnyNotificationAsSeen(postNr: number) {\n }\n \n \n+// A separate function here, so accessible also via embedded iframes (rather than\n+// inlined in editor.editor.ts)\n export function onEditorOpen(ps: EditorStorePatch, onDone?: () => void) {\n   if (eds.isInEmbeddedEditor) {\n     sendToCommentsIframe(['onEditorOpen', ps]);\n@@ -1578,6 +1581,18 @@ function loadAndShowNewPage(newUrlPath: St, history: ReactRouterHistory) {\n     const pats = _.values(newStore.usersByIdBrief);\n     const pubCats = newStore.publicCategories;\n \n+    // COULD_OPTIMIZE  If listing recently active topics, they're already\n+    // included in the page json:\n+    //  - newStore.topics,\n+    //  - newStore.me.restrictedTopics\n+    //  - newStore.me.restrictedTopicsUsers\n+    // Add them to the store, as is done here: [add_restr_topics], then, can skip\n+    // a request to the server to list recent topics.\n+    //\n+    // Currently we do add `newStore.me.restrictedCategories` (see\n+    // store_addRestrictedCurCatsInPl()) – otherwise access restricted pages\n+    // wouldn't render (would be category missing errors).\n+\n     // This'll trigger ReactStore onChange() event; everything will redraw to show the new page.\n     showNewPage({\n       newPage,"
    },
    {
      "sha": "13e099bb0df3580ec50729b76771fa4a95f53be5",
      "filename": "client/app-slim/ReactStore.ts",
      "status": "modified",
      "additions": 182,
      "deletions": 8,
      "changes": 190,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2FReactStore.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2FReactStore.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2FReactStore.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -59,6 +59,16 @@ const storeEventListeners: StoreEventListener[] = [];\n // Read-only hooks based store state. WOULD REFACTOR make it read-write and delete ReactActions,\n // and remove EventEmitter too? [4WG20ABG2]  Have all React code use `useStoreState`\n // instead of that old \"flux\" stuff.\n+//\n+// This is similar to useReducer() and accessing the state via useContext() — see:\n+// https://react.dev/learn/scaling-up-with-reducer-and-context,\n+// `useStoreState()` corresponds to `useTasks()` in their example.\n+// Hmm, they've separated only-*using*-the-state and *changing* the state into\n+// `useTasks()` and `useTasksDispatch()`.  Then it could be nice if `useStoreState()`\n+// also was only for *using* the state — which is how it already works actually,\n+// I'll just need to remove the can't-use-anyway `setState()` return value.\n+// And a new hook function, `useStoreActions()` for *doing* things?\n+//\n export function useStoreState(): [Store, () => void] {\n   const [state, setState] = React.useState<Store>(store);\n \n@@ -779,6 +789,8 @@ ReactStore.activateMyself = function(anyNewMe: Myself | NU, stuffForMe?: StuffFo\n   // Show the user's own unapproved posts, or all, for admins.\n   store_addAnonsAndUnapprovedPosts(store, myPageData);  // TyTE2E603SKD\n \n+  // Add any topics not included in the cached json, because they're access\n+  // restricted (but the current user can see them). [add_restr_topics]\n   if (_.isArray(store.topics)) {\n     const currentPage: Page = store.currentPage;\n     store.topics = store.topics.concat(store.me.restrictedTopics);\n@@ -827,6 +839,22 @@ ReactStore.activateMyself = function(anyNewMe: Myself | NU, stuffForMe?: StuffFo\n     }, 0);\n   }\n \n+  // ----- Personas [update_personas]\n+\n+  // Later, if remembering any persona mode across page reloads, and different\n+  // browser tabs: [remember_persona_mode]\n+  // const asPersona = Server.getPersonaCookie();\n+  // if (asPersona) {\n+  //   store.me.usePersona = asPersona;\n+  // }\n+\n+  // Remember which aliases pat has used when posting or voting on the current page,\n+  // so we can know who pat wants to be now, or if we need to ask.\n+  // Do here, after `me.usePersona`, unapproved posts and access restricted cats inited.\n+  store_updatePersonaOpts(store);\n+\n+  // ----- Websocket\n+\n   debiki2.pubsub.subscribeToServerEvents(store.me);\n   store.quickUpdate = false;\n };\n@@ -1091,6 +1119,8 @@ function updatePost(post: Post, pageId: PageId, isCollapsing?: boolean) {\n   // Add or update the post itself.\n   page.postsByNr[post.nr] = post;\n \n+  // Should remember any new persona, if new post? Or earlier, when adding pat? [update_personas]\n+\n   const layout: DiscPropsDerived = page_deriveLayout(page, store, LayoutFor.PageWithTweaks);\n \n   // In case this is a new post, update its parent's child id list.\n@@ -1161,7 +1191,7 @@ function voteOnPost(action: {\n     doWhat: 'DeleteVote' | 'CreateVote',\n     voteType: PostVoteType,\n     postNr: PostNr,\n-    voter: Pat}) {\n+    voter: Pat}) { // CLEAN_UP: redundant, already in the storePatch.yourAnon, or is `me`.\n \n   const postNr: PostNr = action.postNr;\n \n@@ -1174,14 +1204,32 @@ function voteOnPost(action: {\n   }\n \n   if (action.doWhat === 'CreateVote') {\n+    const voter: Pat = action.voter;\n     votes.push({\n       // The voter might be the current user's anonym, so we need the voter id.\n-      byId: action.voter.id,\n+      byId: voter.id,\n       type: action.voteType,\n     });\n+\n+    // The voter might be a just-now lazy-created anonym – then remember it. [lazy_anon_voter]\n+    if (voter.isAnon && voter.anonForId) {\n+      // @ifdef DEBUG\n+      dieIf(!voter.anonStatus, 'TyE206MLP4');\n+      // Page id currently not added server side, so skip: [see_own_alias]\n+      // dieIf(voter.anonOnPageId !== myPageData.pageId, 'TyE206MLP5');\n+      // @endif\n+\n+      const isNewAnon = !myPageData.knownAnons.find(a => a.id === voter.id);\n+      if (isNewAnon) {\n+        myPageData.knownAnons.push(voter as KnownAnonym);\n+      }\n+    }\n   }\n   else {\n     _.remove(votes, v => v.type === action.voteType);\n+\n+    // (We could update myPageData.knownAnons, if this vote was the only thing\n+    // the anon has done on the page. But not really needed.)\n   }\n \n   // If this vote is the user's first action on the page, and han is voting\n@@ -1725,13 +1773,15 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n \n   if (storePatch.me) {\n     // [redux] modifying the store in place, again.\n+    let personaBefore = store.me.usePersona;\n     let patchedMe: Myself | U;\n     if (eds.isInIframe) {\n       // Don't forget [data about pat] loaded by other frames.  [mny_ifr_pat_dta]\n       try {\n         const sessWin = getMainWin();\n         const sessStore: SessWinStore = sessWin.theStore;\n         if (_.isObject(sessStore.me)) {\n+          personaBefore ||= sessStore.me.usePersona;\n           patchedMe = me_merge(sessStore.me, store.me, storePatch.me);  // [emb_ifr_shortcuts]\n           sessStore.me = _.cloneDeep(patchedMe);\n         }\n@@ -1744,6 +1794,12 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n       patchedMe = _.assign(store.me || {} as Myself, storePatch.me);\n     }\n     store.me = patchedMe;\n+\n+    // Maybe later: [remember_persona_mode]\n+    // const personaAfter = patchedMe.usePersona;\n+    // if (!any_isDeepEqIgnUndef(personaBefore, personaAfter)) {\n+    //   Server.setPersonaCookie(personaAfter);\n+    // }\n   }\n \n   // ----- Drafts\n@@ -1797,6 +1853,11 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n     addBackRecentTopicsInPl(oldCurCats, store.curCatsById);\n   }\n \n+  // If we're on a forum homepage (or other topic index page), and selected a different\n+  // forum category to list topics in.\n+  if (storePatch.listingCatId)\n+    store.listingCatId = storePatch.listingCatId;\n+\n   // ----- Tag types\n \n   // @ifdef DEBUG\n@@ -1864,6 +1925,9 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n     dieIf(store.currentPageId !== currentPage.pageId, 'EdE7GBW2');\n     currentPage.pageId = storePatch.newlyCreatedPageId;\n     store.currentPageId  = storePatch.newlyCreatedPageId;\n+    // This not needed though – we didn't jump to a different page; we just got an\n+    // id for the current page, which didn't exist but now does.\n+    //store.currentPage = currentPage;  // not needed\n \n     // This'll make the page indexed by both EmptyPageId and newlyCreatedPageId:\n     // (Could remove the NoPageId key? But might cause some bug?)\n@@ -1936,16 +2000,16 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n     store_relayoutPageInPlace(store, currentPage, layoutAfter);\n   }\n \n+  // ----- Posts, new or edited?\n+\n   // Update the current page.\n   if (!storePatch.pageVersionsByPageId) {\n     // No page. Currently storePatch.usersBrief is for the current page (but there is none)\n     // so ignore it too.\n-    return;\n   }\n-\n-  // ----- Posts, new or edited?\n-\n-  _.each(store.pagesById, patchPage);\n+  else {\n+    _.each(store.pagesById, patchPage);\n+  }\n \n   function patchPage(page: Page) {\n     const storePatchPageVersion = storePatch.pageVersionsByPageId[page.pageId];\n@@ -1979,6 +2043,10 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n       Server.markCurrentPageAsSeen();\n     }\n   }\n+\n+  // [update_personas], here after both comments & the user's persona mode\n+  // have been patched.\n+  store_updatePersonaOpts(store);\n }\n \n \n@@ -2033,9 +2101,16 @@ function showNewPage(ps: ShowNewPageParams) {\n \n   delete store.curPageTweaks;\n \n+  if (isSection(newPage)) {\n+    store.listingCatId = newPage.categoryId;\n+  }\n+  else {\n+    delete store.listingCatId;\n+  }\n+\n   // Forget any topics from the original page load. Maybe we're now in a different sub community,\n   // or some new topics have been created. Better reload.\n-  store.topics = null;\n+  delete store.topics;\n \n   let myData: MyPageData;\n   if (ps.me) {\n@@ -2071,6 +2146,8 @@ function showNewPage(ps: ShowNewPageParams) {\n   const oldCurCats = store.currentCategories;\n   store_initCurCatsFromPubCats(store);\n \n+  // Could add access restricted topics & users too  [add_restr_topics],\n+  // iff we're listing the most recently active topics.\n   if (ps.me) {\n     store_addRestrictedCurCatsInPl(store, ps.me.restrictedCategories);\n     // Not needed? But anyway, less confusing if is updated too:\n@@ -2171,6 +2248,12 @@ function showNewPage(ps: ShowNewPageParams) {\n   // Like:  addLocalStorageDataTo(me, isNewPage = true);\n   addMyDraftPosts(store, store.me.myCurrentPageData);\n \n+  // ----- Personas [update_personas]\n+\n+  // Remember which aliases pat has used when posting or voting on the current page,\n+  // so we can know who pat wants to be now, or if we need to ask.\n+  store_updatePersonaOpts(store);\n+\n   // ----- Misc & \"hacks\"\n \n   // Make Back button work properly.\n@@ -2198,6 +2281,96 @@ function showNewPage(ps: ShowNewPageParams) {\n }\n \n \n+/// REFACTOR: Split this fn into two:  store_updateDiscProps(), and  store_updatePersonaOpts()?\n+/// The former makes sense also if not logged in; the latter does not (in effect, a \"big noop\").\n+///\n+function store_updatePersonaOpts(store: Store) {\n+  if (!store.userSpecificDataAdded)\n+    return;\n+\n+  const me = store.me;\n+\n+  // Later: The server incls this in the show-page response?  [fetch_alias]\n+  const myPersonasThisPage: MyPersonasThisPage =\n+          disc_findMyPersonas(store, { forWho: me });\n+\n+  // Use which category properties?\n+  // If we're on a forum homepage, and viewing topics in an anonymous-by-default\n+  // category, we'd want the persona options to include posting-anonymously,\n+  // so we need that category's properties.\n+  const isSectionPage = !store.currentPage ? false : isSection(store.currentPage.pageRole);\n+  const listingCat = store.listingCatId && store.currentCategories.find(\n+                                              c => c.id === store.listingCatId);\n+  const discProps: DiscPropsDerived | U = isSectionPage\n+          ? (listingCat\n+              ? // We're on a forum homepage, looking at a specific category to see\n+                // topics in that cat.\n+                cat_deriveLayout(listingCat, store, LayoutFor.PageNoTweaks)\n+              : // If we don't have access to the category (then, `listingCat` missing).\n+                // Or on initial page load, until startStuff() more done.\n+                // Or if on  All Cats  page:  [site_disc_props]\n+                undefined)\n+          : (store.currentPage\n+              ? page_deriveLayout(store.currentPage, store, LayoutFor.PageNoTweaks)\n+              : // [pseudonyms_later]  Let people switch to a pseudonym also when they\n+                // post direct messages?  Look at a whole-site-default setting, to know\n+                // if that should be allowed or not? [site_disc_props]\n+                // (Since then they're on a user profile page, which\n+                // isn't a discussion page so `currentPage` is absent.)\n+                undefined);  // if no page\n+\n+  const anonsRecommended = discProps && discProps.comtsStartAnon >= NeverAlways.Recommended;\n+\n+  const switchedToPseudonym = false; // [pseudonyms_later]\n+  const switchedToAnonStatus: AnonStatus | NU = me.usePersona && me.usePersona.anonStatus;\n+  const switchedToSelf = me.usePersona && (me.usePersona as Oneself).self;\n+\n+  const curPersonaOptions =\n+          findPersonaOptions({ myPersonasThisPage, me, discProps });\n+\n+  const numOpts = curPersonaOptions.optsList.length;\n+  const firstOpt: PersonaOption = curPersonaOptions.optsList[0];\n+\n+  let debug = false;\n+  // @ifdef DEBUG\n+  debug = true;\n+  dieIf(numOpts < 1, 'TyEPSLS2M63');\n+  // @endif\n+\n+  const mode: PersonaMode | U =\n+          !me.id ? undefined : (\n+          switchedToSelf ? { self: true } satisfies PersonaMode : (\n+          switchedToAnonStatus ? { anonStatus: switchedToAnonStatus } satisfies PersonaMode : (\n+          switchedToPseudonym ? die('TyE206MFKG') as any : (\n+          // Anon or self, if we've been that before on this page?\n+          firstOpt.alias.isAnon ?\n+                  { anonStatus: firstOpt.alias.anonStatus } satisfies PersonaMode : (\n+          firstOpt.isSelf ? (\n+                // If can't use, hasn't used, and hasn't switched to any alias,\n+                // then, don't show any persona info – it's more likely off-topic\n+                // and confusing.\n+                numOpts <= 1 ? undefined : { self: true } satisfies PersonaMode) : (\n+          anonsRecommended ? { anonStatus: discProps.newAnonStatus } satisfies PersonaMode :\n+                // Dead code? Either `isSelf` or `isAnon` above should be tue.\n+                (debug ? die(`TyE206SWl4`) : undefined)\n+          // Could show \"Self\" if anons allowed, but not recommended?\n+          // anonsAllowed ? { autoSelf: true } satisfies PersonaMode : undefined\n+          ))))));\n+\n+  store.me.myCurrentPageData.myPersonas = myPersonasThisPage;\n+  store.curDiscProps = discProps;\n+\n+  if (mode) {\n+    store.curPersonaOptions = curPersonaOptions;\n+    store.indicatedPersona = mode;\n+  }\n+  else {\n+    delete store.curPersonaOptions;\n+    delete store.indicatedPersona;\n+  }\n+}\n+\n+\n function watchbar_markAsUnread(watchbar: Watchbar, pageId: PageId) {\n   watchbar_markReadUnread(watchbar, pageId, false);\n }\n@@ -2288,6 +2461,7 @@ function watchbar_copyUnreadStatusFromTo(old: Watchbar, newWatchbar: Watchbar) {\n function makeStranger(store: Store): Myself {\n   const stranger = {\n     dbgSrc: '5BRCW27',\n+    id: Pats.NoPatId,\n     isStranger: true,\n     trustLevel: TrustLevel.Stranger,\n     threatLevel: ThreatLevel.HopefullySafe,"
    },
    {
      "sha": "8fd51148b367c69aa8ce7c13c4e98523f04cabf0",
      "filename": "client/app-slim/Server.ts",
      "status": "modified",
      "additions": 109,
      "deletions": 29,
      "changes": 138,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2FServer.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2FServer.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2FServer.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -28,14 +28,34 @@\n    namespace debiki2.Server {\n //------------------------------------------------------------------------------\n \n-const d: any = { i: debiki.internal };\n-\n const BadNameOrPasswordErrorCode = '_TyE403BPWD';\n const NoPasswordErrorCode = '_TyMCHOOSEPWD';\n \n const XsrfTokenHeaderName = 'X-XSRF-TOKEN'; // CLEAN_UP rename to X-Ty-Xsrf-Token\n const SessionIdHeaderName = 'X-Ty-Sid';\n const AvoidCookiesHeaderName = 'X-Ty-Avoid-Cookies';\n+//const PersonaCookieName = \"TyCoPersona\";\n+const PersonaHeaderName = 'X-Ty-Persona';\n+\n+\n+// Mayble later. [remember_persona_mode]\n+/*\n+export function setpersonacookie(asPersona: Oneself | LazyCreatedAnon | N) {\n+  // Or remember in local storage instead?\n+  getSetCookie(PersonaCookieName, asPersona ? JSON.stringify(asPersona) : null);\n+}\n+\n+export function getPersonaCookie(): Oneself | LazyCreatedAnon | NU {\n+  const cookieVal: St | N = getCookie(PersonaCookieName);\n+  if (!cookieVal) return undefined;\n+  const persona = JSON.parse(cookieVal);\n+  // @ifdef DEBUG\n+  dieIf(!(persona as Oneself).self && !(persona as LazyCreatedAnon).anonStatus,\n+        `Bad persona cookie value: [[ ${cookieVal} ]] [TyE320JVMR4]`);\n+  // @endif\n+  return persona;\n+}\n+*/\n \n export function getPageId(): PageId | U {   // move elsewhere?\n   return !isNoPage(eds.embeddedPageId) ? eds.embeddedPageId : // [4HKW28]\n@@ -754,6 +774,11 @@ export function addAnyNoCookieHeaders(headers: { [headerName: string]: St }) {\n   const typs: PageSession = mainWin.typs;\n   const currentPageXsrfToken: St | U = typs.xsrfTokenIfNoCookies;\n   const currentPageSid: St | U = typs.weakSessionId;\n+  const asPersona: WhichPersona | NU = mainWin.theStore && mainWin.theStore.me.usePersona;\n+  const curPersonaOptions: PersonaOptions | U =\n+          mainWin.theStore && mainWin.theStore.curPersonaOptions;\n+  const indicatedPersona: PersonaMode | U =\n+          mainWin.theStore && mainWin.theStore.indicatedPersona;\n \n   if (!win_canUseCookies(mainWin)) {\n     headers[AvoidCookiesHeaderName] = 'Avoid';\n@@ -766,9 +791,61 @@ export function addAnyNoCookieHeaders(headers: { [headerName: string]: St }) {\n   if (currentPageSid) {\n     headers[SessionIdHeaderName] = currentPageSid;\n   }\n+\n+  // ----- Persona mode?\n+\n+  // Any Persona Mode is included in each request, so a cookie would have been a good idea\n+  // — but cookies are often blocked, nowadays, if in an iframe (embedded comments).  So,\n+  // let's use a header instead.\n+  const personaHeaderVal: St | U =\n+        // If the user has choosen to use a persona, e.g. a pseudonym.\n+        asPersona ? persModeToHeaderVal('choosen', asPersona) : (\n+        // If the user is automatically anonymous, e.g. because of category settings,\n+        // or because they replied anonymously before on the same page.\n+        // For a server side safety check, so won't accidentally do sth as oneself.\n+        // [persona_indicator_chk]\n+        indicatedPersona ? persModeToHeaderVal(\n+              'indicated', indicatedPersona, curPersonaOptions.isAmbiguous) :\n+        // No alias in use.\n+        // Pat has not entered Anonymous or Self mode, and isn't anonymous by default.\n+        undefined);\n+\n+  if (personaHeaderVal) {\n+    headers[PersonaHeaderName] = personaHeaderVal;\n+  }\n }\n \n \n+/// Won't stringify any not-needed fields in `mode`.\n+/// Parsed by the server here: [parse_pers_mode_hdr].\n+///\n+/// Json in a header value is ok — all visible ascii chars are ok, see:\n+///   https://www.rfc-editor.org/rfc/rfc7230#section-3.2\n+///\n+function persModeToHeaderVal(field: 'choosen' | 'indicated', mode: WhichPersona | PersonaMode,\n+        ambiguous?: Bo): St {\n+  //D_DIE_IF(isVal(mode.anonStatus) && !_.isNumber(mode.anonStatus), 'TyEANONSTATUSNAN');\n+  const modeValue: WhichPersona =\n+          mode.self ? { self : true } : (\n+          mode.anonStatus ? { anonStatus: mode.anonStatus, lazyCreate: true } : (\n+          // [pseudonyms_later]\n+          'TyEUNKINDPERS' as any));\n+  const obj = {} as any;\n+  obj[field] = modeValue;\n+  if (ambiguous) obj.ambiguous = true;\n+  return JSON.stringify(obj as PersonaHeaderVal);\n+}\n+\n+\n+type PersonaHeaderVal =\n+      { choosen: PersonaHeaderValVal } |\n+      { indicated: PersonaHeaderValVal; ambiguous?: true };\n+\n+type PersonaHeaderValVal =\n+      { self: true } |\n+      { anonStatus: AnonStatus, lazyCreate: true };\n+\n+\n function appendE2eAndForbiddenPassword(url: string) {\n   let newUrl = url;\n   const e2eTestPassword = anyE2eTestPassword();\n@@ -1543,21 +1620,21 @@ export function listDrafts(userId: UserId,\n \n \n export function loadNotifications(userId: UserId, upToWhenMs: number,\n-      success: (notfs: Notification[]) => void, error: () => void) {\n+      onOk: (notfs: Notification[]) => void, error: () => void) {\n   const query = '?userId=' + userId + '&upToWhenMs=' + upToWhenMs;\n-  get('/-/load-notifications' + query, success, error);\n+  get('/-/load-notifications' + query, (resp: NotfSListResponse) => onOk(resp.notfs), error);\n }\n \n \n export function markNotfsRead() {\n-  postJsonSuccess('/-/mark-all-notfs-as-seen', (notfs) => {\n+  postJsonSuccess('/-/mark-all-notfs-as-seen', (resp: NotfSListResponse) => {\n     // Should be the same as [7KABR20], server side.\n     const myselfPatch: MyselfPatch = {\n       numTalkToMeNotfs: 0,\n       numTalkToOthersNotfs: 0,\n       numOtherNotfs: 0,\n       thereAreMoreUnseenNotfs: false,\n-      notifications: notfs,\n+      notifications: resp.notfs,\n     };\n     ReactActions.patchTheStore({ me: myselfPatch });\n   }, null, {});\n@@ -1679,10 +1756,15 @@ export function loadForumCategoriesTopics(forumPageId: St, topicFilter: St,\n // Change the reply\n // 'users' field to 'usersBrief', no, 'patsBr'? 'Tn = Tiny, Br = Brief, Vb = Verbose?  [.get_n_patch]\n export function loadForumTopics(categoryId: CatId, orderOffset: OrderOffset,\n-    onOk: (resp: LoadTopicsResponse) => Vo) {\n+      onOk: (resp: LoadTopicsResponse) => V) {\n   const url = '/-/list-topics?categoryId=' + categoryId + '&' +\n       ServerApi.makeForumTopicsQueryParams(orderOffset);\n-  getAndPatchStore(url, onOk);  // [2WKB04R]\n+  return get(url, function(resp: LoadTopicsResponse) {\n+    // (Alternatively, the server could incl `listingCatId` in its response.)\n+    const patch: StorePatch = { ...resp.storePatch, listingCatId: categoryId };\n+    ReactActions.patchTheStore(patch);  // [2WKB04R]\n+    onOk(resp);\n+  });\n }\n \n \n@@ -1807,14 +1889,7 @@ export function fetchLinkPreview(url: St, inline: Bo, /* later: curPageId: PageI\n }\n \n \n-export function saveVote(data: {\n-    pageId: PageId,\n-    postNr: PostNr,\n-    vote: PostVoteType,\n-    action: 'DeleteVote' | 'CreateVote',\n-    postNrsRead: PostNr[],\n-    doAsAnon?: MaybeAnon,\n-}, onDone: (storePatch: StorePatch) => Vo) {\n+export function saveVote(data: SaveVotePs, onDone: (storePatch: StorePatch) => V) {\n   // Specify altPageId and embeddingUrl, so any embedded page can be created lazily. [4AMJX7]\n   // @ifdef DEBUG\n   dieIf(data.pageId && data.pageId !== EmptyPageId && data.pageId !== getPageId(), 'TyE2ABKSY7');\n@@ -2155,12 +2230,13 @@ export function hidePostInPage(postNr: number, hide: boolean, success: (postAfte\n }\n \n \n-export function deletePostInPage(postNr: number, repliesToo: boolean,\n-      success: (deletedPost) => void) {\n-  postJsonSuccess('/-/delete-post', success, {\n+export function deletePostInPage(postNr: PostNr, repliesToo: Bo, doAsAnon: MaybeAnon | U,\n+      onOk: (deletedPost) => V) {\n+  postJsonSuccess('/-/delete-post', onOk, {\n     pageId: getPageId(),\n     postNr: postNr,\n     repliesToo: repliesToo,\n+    doAsAnon,\n   });\n }\n \n@@ -2311,26 +2387,30 @@ export function loadPageJson(path: string, success: (response) => void) {\n }\n \n \n-export function acceptAnswer(postId: PostNr, doAsAnon: MaybeAnon,\n+export function acceptAnswer(ps: { pageId: PageId, postId: PostId, doAsAnon: MaybeAnon },\n         onOk: (answeredAtMs: Nr) => V) {\n-  postJsonSuccess('/-/accept-answer', onOk, { pageId: getPageId(), postId, doAsAnon });\n+  postJsonSuccess('/-/accept-answer', onOk, ps);\n }\n \n \n-export function unacceptAnswer(doAsAnon: MaybeAnon, onOk: () => V) {\n-  postJsonSuccess('/-/unaccept-answer', onOk, { pageId: getPageId(), doAsAnon });\n+export function unacceptAnswer(ps: { pageId: PageId, doAsAnon: MaybeAnon }, onOk: () => V) {\n+  postJsonSuccess('/-/unaccept-answer', onOk, ps);\n }\n \n-export function togglePageClosed(doAsAnon: MaybeAnon, onOk: (closedAtMs: Nr) => V) {\n-  postJsonSuccess('/-/toggle-page-closed', onOk, { pageId: getPageId(), doAsAnon });\n+\n+export function togglePageClosed(ps: { pageId: PageId, doAsAnon: MaybeAnon },\n+        onOk: (closedAtMs: Nr) => V) {\n+  postJsonSuccess('/-/toggle-page-closed', onOk, ps);\n }\n \n-export function deletePages(pageIds: PageId[], success: () => void) {\n-  postJsonSuccess('/-/delete-pages', success, { pageIds: pageIds });\n+\n+export function deletePages(ps: { pageIds: PageId[], doAsAnon: MaybeAnon }, onOk: () => V) {\n+  postJsonSuccess('/-/delete-pages', onOk, ps);\n }\n \n-export function undeletePages(pageIds: PageId[], success: () => void) {\n-  postJsonSuccess('/-/undelete-pages', success, { pageIds: pageIds });\n+\n+export function undeletePages(ps: { pageIds: PageId[], doAsAnon: MaybeAnon }, onOk: () => V) {\n+  postJsonSuccess('/-/undelete-pages', onOk, ps);\n }\n \n "
    },
    {
      "sha": "8fc62ebad7285e6bbb0e837c82c98611db394193",
      "filename": "client/app-slim/avatar/avatar.ts",
      "status": "modified",
      "additions": 18,
      "deletions": 15,
      "changes": 33,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Favatar%2Favatar.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Favatar%2Favatar.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Favatar%2Favatar.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -37,22 +37,25 @@ export function resetAvatars() {\n }\n \n \n-export const Avatar = createComponent({\n+export const Avatar = createFactory<AvatarProps, {}>({\n   displayName: 'Avatar',\n \n-  onClick: function(event) {\n+  onClick: function(event: MouseEvent) {\n     event.stopPropagation();\n     event.preventDefault();\n-    morebundle.openAboutUserDialog(this.props.user.id, event.target, this.props.title);\n+    const props: AvatarProps = this.props;\n+    morebundle.openAboutUserDialog(props.user.id, event.target, props.title);\n   },\n \n   tiny: function() {\n-    return !this.props.size || this.props.size === AvatarSize.Tiny;\n+    const props: AvatarProps = this.props;\n+    return !props.size || props.size === AvatarSize.Tiny;\n   },\n \n   makeTextAvatar: function() {\n-    const user: BriefUser = this.props.user;\n-    const hidden: boolean = this.props.hidden;\n+    const props: AvatarProps = this.props;\n+    const user: BriefUser = props.user;\n+    const hidden = props.hidden;\n     let result = textAvatarsByUserId[user.id];\n     if (result)\n       return result;\n@@ -157,9 +160,9 @@ export const Avatar = createComponent({\n   },\n \n   render: function() {\n-    const props = this.props;\n-    const user: BriefUser | MemberInclDetails = this.props.user;\n-    const ignoreClicks = this.props.ignoreClicks ||\n+    const props: AvatarProps = this.props;\n+    const user: BriefUser | MemberInclDetails = props.user;\n+    const ignoreClicks = props.ignoreClicks ||\n         // The user is unknow when rendering the author avatar, in\n         // the new reply preview, if we haven't logged in. [305KGWGH2]\n         user.id === UnknownUserId;\n@@ -179,16 +182,16 @@ export const Avatar = createComponent({\n     if (largestPicPath) {\n       // If we don't know the hash path to the avatar of the requested size, then use another size.\n       let picPath;\n-      if (this.props.size === AvatarSize.Medium) {\n+      if (props.size === AvatarSize.Medium) {\n         picPath = largestPicPath;\n       }\n-      else if (this.props.size === AvatarSize.Small) {\n+      else if (props.size === AvatarSize.Small) {\n         picPath = smlPath || tnyPath || medPath;\n       }\n       else {\n         picPath = tnyPath || smlPath || medPath;\n       }\n-      const origins: Origins = this.props.origins;\n+      const origins: Origins = props.origins;\n       content = r.img({ src: linkToUpload(origins, picPath) });\n     }\n     else {\n@@ -200,8 +203,8 @@ export const Avatar = createComponent({\n       }\n     }\n     let title = user.username || user.fullName;\n-    if (this.props.title) {\n-      title += ' — ' + this.props.title;\n+    if (props.title) {\n+      title += ' — ' + props.title;\n     }\n \n     if (props.showIsMine) {\n@@ -215,7 +218,7 @@ export const Avatar = createComponent({\n     const elemName = ignoreClicks ? 'span' : 'a';\n     const elemFn = <any> r[elemName];\n     const href = ignoreClicks ? null : linkToUserProfilePage(user);\n-    const onClick = ignoreClicks || this.props.clickOpensUserProfilePage ?\n+    const onClick = ignoreClicks || props.clickOpensUserProfilePage ?\n         null : this.onClick;\n \n     return ("
    },
    {
      "sha": "8c9d035b621c843da5f2c14473babc410fa29252",
      "filename": "client/app-slim/forum/forum.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fforum%2Fforum.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fforum%2Fforum.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fforum%2Fforum.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -988,6 +988,7 @@ const LoadAndListTopics = createFactory({\n     // can continue reading at the top of the newly loaded topics.\n     $byId('esPageColumn').classList.add('s_NoScrlAncr');\n \n+    // This updates `store.listingCatId`.\n     Server.loadForumTopics(categoryId, orderOffset, (response: LoadTopicsResponse) => { // (4AB2D)\n       if (this.isGone) return;\n       let topics: any = isNewView ? [] : (this.state.topics || []);"
    },
    {
      "sha": "291ba0261111db394096e137586d973d1e7ab9b8",
      "filename": "client/app-slim/model.ts",
      "status": "modified",
      "additions": 326,
      "deletions": 77,
      "changes": 403,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fmodel.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fmodel.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fmodel.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -256,6 +256,16 @@ interface Vote {\n }\n \n \n+interface SaveVotePs {\n+  pageId: PageId,\n+  postNr: PostNr,\n+  vote: PostVoteType,\n+  action: 'DeleteVote' | 'CreateVote',\n+  postNrsRead: PostNr[],\n+  doAsAnon?: MaybeAnon,\n+}\n+\n+\n interface DraftLocator {\n   draftType: DraftType;\n   categoryId?: number;\n@@ -283,7 +293,7 @@ interface DraftDeletor {\n \n interface Draft {\n   byUserId: UserId;\n-  doAsAnon?: MaybeAnon;  // not yet impl [doAsAnon_draft]\n+  doAsAnon?: MaybeAnon;\n   draftNr: DraftNr;\n   forWhat: DraftLocator;\n   createdAt: WhenMs;\n@@ -363,11 +373,17 @@ interface ShowPostOpts extends ScrollIntoViewOpts {\n \n interface Post {\n   // Client side only ------\n+  // [drafts_as_posts] Later, the drafts3 table will get deleted, and drafts moved to\n+  // posts3 / nodes_t instead. These fields are in fact for drafts / previews:\n+\n   // If this post / these changes don't yet exist — it's a preview.\n   isPreview?: boolean;\n   // Is a number if the draft has been saved server side (then the server has\n   // assigned it a number).\n   isForDraftNr?: DraftNr | true;\n+  // If this post is a draft and we need to lazy-create an anonym, this tells us what type\n+  // of anonym: temporarily or permanently anonymous (its AnonStatus).\n+  doAsAnon?: MaybeAnon,\n   // If we're editing this post right now.\n   isEditing?: boolean;\n   // -----------------------\n@@ -485,6 +501,10 @@ interface MyPageData {\n \n   // For the current page only.\n   marksByPostId: { [postId: number]: any }; // sleeping BUG: probably using with Nr (although the name implies ID), but should be ID\n+\n+  // Needed for deriving Store.curPersonaOptions.\n+  // Currently derived client side. Later: The server can include in response. [fetch_alias]\n+  myPersonas?: MyPersonasThisPage;\n }\n \n \n@@ -505,13 +525,16 @@ interface OwnPageNotfPrefs {  // RENAME to MembersPageNotfPrefs?\n \n // Extend Pat, set id to a new StrangerId if not logged in?\n type Myself = Me; // renaming to Me\n-interface Me extends OwnPageNotfPrefs {   // + extends Pat?\n+interface Me extends OwnPageNotfPrefs, Pat {\n   dbgSrc?: string;\n   // This is not the whole session id — it's the first 16 chars only [sid_part1];\n   // the remaining parts have (a lot) more entropy than necessary.\n   mySidPart1?: St | N;\n-  id?: UserId;\n-  //useAlias?: Pat;  // maybe?  [alias_mode]  and this.id is one's true id\n+  // Is Pats.NoPatId (0, zero) for strangers, so this Me interface fullfills the Pat interface.\n+  id: PatId;\n+\n+  usePersona?: Oneself | LazyCreatedAnon | N;\n+\n   isStranger?: Bo;\n   // missing?: isGuest?: Bo\n   isGroup?: boolean; // currently always undefined (i.e. false)\n@@ -706,6 +729,7 @@ interface HelpMessage {\n   version: number;\n   content: any;\n   defaultHide?: boolean;\n+  closeOnClickOutside?: false; // default true\n   doAfter?: () => void;\n   type?: number;\n   className?: string;\n@@ -1195,13 +1219,20 @@ interface SessWinStore {\n /// Can be 1) the main ('top') browser win (incl topbar, editor, sidebars etc), or\n /// 2) a copy of the store in an embedded comments iframe.  [many_embcom_iframes]\n ///\n+/// Maybe should [break_out_clone_store_fn]?\n+///\n interface DiscStore extends SessWinStore {\n   currentPage?: Page;\n   currentPageId?: PageId;\n   currentCategories: Cat[];   // RENAME [concice_is_nice] curCats — or remove, use curCatsById.values instead?\n   curCatsById: { [catId: CatId]: Cat };\n   usersByIdBrief: { [userId: number]: Pat };  // = PatsById\n   pagesById: { [pageId: string]: Page };\n+\n+  // Derived client side from: MyPageData.myPersonas and Me.usePersona.\n+  curPersonaOptions?: PersonaOptions  // ? move to SessWinStore ?\n+  curDiscProps?: DiscPropsDerived\n+  indicatedPersona?: PersonaMode      // ? move to SessWinStore ?\n }\n \n \n@@ -1235,6 +1266,18 @@ interface Store extends Origins, DiscStore, PartialEditorStoreState {\n   publicCategories: Category[];   // RENAME [concice_is_nice] pubCats\n   newCategorySlug: string; // for temporarily highlighting a newly created category\n   topics?: Topic[];\n+\n+  // Says which category we're listing topics in, if we're on a forum homepage (or\n+  // other topic index page). Could be the forum root category, or a base category,\n+  // or sub category, or sub sub ...).\n+  //\n+  // This is good to know, when composing a new forum topic, because new topics inherit\n+  // some properties from the currently listed category. For example, if you're on a\n+  // forum homepage, and view an anonymous-by-default category and click Create Topic,\n+  // the new topic will be anonymous.\n+  //\n+  listingCatId?: CatId;\n+\n   user: Myself; // try to remove, use 'me' instead:\n   me: Myself;\n   userSpecificDataAdded?: boolean; // is always false, server side\n@@ -1356,6 +1399,47 @@ type PropsFromRefs<Type> = {\n \n \n // RENAME to DiscLayoutDerived?  There's an interface Layout_not_in_use too (below) merging all layouts.\n+/// Discussion properties, intherited from the page, ancestor categories, site defaults,\n+/// built-in defaults.\n+///\n+/// The `from` fields says from where each property got inherited, so admins can know what\n+/// they might want to change, if sth isn't to their satisfaction.\n+///\n+/// Example: {\n+///   comtOrder: 3,\n+///   comtNesting: -1,\n+///   comtsStartHidden :2,\n+///   comtsStartAnon: 3,        <——  modified, and\n+///   opStartsAnon:2,\n+///   newAnonStatus: 65535,     <——  modified ...\n+///   pseudonymsAllowed: 2,\n+///   from: {\n+///     comtsStartAnon: {\n+///       // ... in this category:\n+///       id: 5,\n+///       parentId: 1,\n+///       name: \"AA\",\n+///       ...\n+///       comtsStartAnon: 3,     <——  category setting changed\n+///       newAnonStatus: 65535,\n+///       ...\n+///     },\n+///     newAnonStatus: {\n+///       // Same category, again: (just an example)\n+///       id:5,\n+///       parentId: 1,\n+///       ...\n+///       comtsStartAnon: 3,\n+///       newAnonStatus\":65535,    <——\n+///       ...\n+///     },\n+///     comtOrder: \"BuiltIn\",\n+///     comtNesting: \"BuiltIn\",\n+///     comtsStartHidden: \"BuiltIn\",\n+///     opStartsAnon: \"BuiltIn\",\n+///     pseudonymsAllowed: \"BuiltIn\",\n+///  }\n+/// }'\n interface DiscPropsDerived extends DiscPropsBase {\n   from: DiscPropsComesFrom;\n }\n@@ -1528,52 +1612,21 @@ type PpsById = { [ppId: number]: Participant };  // RENAME to PatsById\n \n \n interface Anonym extends GuestOrAnon {\n-  isAnon: true;\n+  anonStatus: AnonStatus\n+  //anonOnPageId: PageId; // not yet incl server side\n+  isAnon: true;  // REMOVE\n   isGuest?: false;  // = !isAuthenticated — no!  BUG RISK ensure ~isGuest isn't relied on\n                                          // anywhere, to \"know\" it's a user / group\n }\n \n \n interface KnownAnonym extends Anonym {\n-  isAnon: true;\n   anonForId: PatId;\n-  anonStatus: AnonStatus;\n-  anonOnPageId: PageId;\n-}\n-\n-/// `false` means don't-do-anonymously, use one's real account instead.\n-type MaybeAnon = WhichAnon | false;\n-\n-// For choosing an anonym. Maybe rename to ChooseAnon? Or ChoosenAnon / SelectedAnon?\n-interface WhichAnon {\n-  sameAnonId?: PatId;  // Either this ...\n-  anonStatus?: AnonStatus; // and this,\n-  newAnonStatus?: AnonStatus; // ... or this.\n }\n \n-interface SameAnon extends WhichAnon {\n-  sameAnonId: PatId;\n-  anonStatus: AnonStatus.IsAnonOnlySelfCanDeanon | AnonStatus.IsAnonCanAutoDeanon;\n-  newAnonStatus?: U;\n-}\n \n-interface NewAnon extends WhichAnon {\n-  sameAnonId?: U;\n-  newAnonStatus: AnonStatus.IsAnonOnlySelfCanDeanon | AnonStatus.IsAnonCanAutoDeanon;\n-}\n-\n-/* Confusing!  type MaybeAnon   above, is better?\n-interface NotAnon extends WhichAnon {\n-  sameAnonId?: U;\n-  newAnonStatus?: U;\n-  anonStatus: AnonStatus.NotAnon;\n-} */\n-\n-interface MyPatsOnPage {\n-  // Each item can be an anonym or pseudonym of pat, or pat henself. No duplicates.\n-  sameThread: Pat[];\n-  outsideThread: Pat[]\n-  byId: { [patId: PatId]: Pat | SameAnon }\n+interface FutureAnon extends KnownAnonym {\n+  id: Pats.FutureAnonId,\n }\n \n \n@@ -1711,6 +1764,204 @@ interface PatVvb extends UserInclDetailsWithStats {\n }\n type UserDetailsStatsGroups = PatVvb; // old name\n \n+\n+\n+// =========================================================================\n+// Personas\n+// =========================================================================\n+\n+\n+/// Anonyms, pseudonyms, and oneself, are personas.\n+///\n+interface WhichPersona {\n+  self?: Bo\n+  anonStatus?: AnonStatus;\n+}\n+\n+\n+interface Oneself extends WhichPersona {\n+  self: true\n+  anonStatus?: U;\n+};\n+\n+\n+/// Anonyms and pseudonyms are aliases. (But oneself is not an alias.)\n+///\n+interface AsAlias extends WhichPersona {\n+  self?: false\n+}\n+\n+\n+interface SamePseudonym extends AsAlias {\n+  pseudonymId: UserId;\n+  anonStatus?: U;\n+}\n+\n+\n+/// `false` means don't-do-anonymously, use one's real account instead.\n+/// REFACTOR: Use `Oneself` instead of `false`? Better: just use type WhichPersona?\n+/// Here: [oneself_0_false] and at maaany other places.\n+type MaybeAnon = WhichAnon | false;\n+\n+/// Which anonym to use (if any) when doing something, e.g. posting a comment.\n+/// See [one_anon_per_page] in tyworld.adoc.\n+///\n+interface WhichAnon extends AsAlias {\n+  anonStatus: AnonStatus\n+  sameAnonId?: PatId  // either this\n+  lazyCreate?: Bo     // or this\n+  createNew_tst?: Bo  // or this\n+}\n+\n+/// The anonym with id `sameAnonId` should be looked up server side, and reused.\n+///\n+interface SameAnon extends WhichAnon {\n+  sameAnonId: PatId  // RENAME to just `id`?\n+  lazyCreate?: false\n+  createNew_tst?: false\n+}\n+\n+/// If there's an anonym with the same `anonStatus`, on the same page, for the\n+/// same user, then, that anonym should be reused (the server looks in the database\n+/// to find out, see `SiteTransaction.loadAnyAnon()`). Otherwise, a new created.\n+///\n+interface LazyCreatedAnon extends WhichAnon {\n+  sameAnonId?: U\n+  lazyCreate: true\n+  createNew_tst?: U\n+}\n+\n+/// Always creates a new anonym, even if one exists with the same status.\n+/// Not currently in use. [one_anon_per_page]\n+interface NewAnon extends WhichAnon {\n+  sameAnonId?: U\n+  lazyCreate?: false\n+  createNew_tst: true\n+}\n+\n+\n+interface MyPersonasThisPage {\n+  // Each item can be an anonym or pseudonym of pat, or pat hanself. No duplicates.\n+  sameThread: Pat[];\n+  // Pats in `sameThread` are not also in `outsideThread` (not needed).\n+  outsideThread: Pat[]\n+  byId: { [patId: PatId]: Pat }\n+}\n+\n+\n+/// Which anonyms and pseudonyms, and oneself, the user can choose among when\n+/// posting something or voting, or editing. Is just one item, if anonyms and pseudonyms\n+/// haven't been enabled: the user hanself.\n+///\n+interface PersonaOptions {\n+  // If we should ask the user which persona they want to use, before\n+  // doing anything (e.g. voting or commenting). So they don't accidentally\n+  // use the wrong persona.\n+  isAmbiguous: Bo\n+\n+  // If has commented or voted or sth as oneself, on the current page.\n+  hasBeenSelf?: Bo\n+  // If has commented or voted or sth anonymously, on the current page.\n+  // Could split into two: `hasBeenTempAnon` and `hasBeenPermAnon`, [dif_anon_status]\n+  // (or even some kind of Set, if there'll be many anon status types).\n+  hasBeenAnon?: Bo\n+  hasBeenPseudo?: Bo\n+\n+  // Never empty — would be oneself, if nothing else.\n+  optsList: PersonaOption[]\n+}\n+\n+\n+interface PersonaOption {\n+  alias: Pat /*me*/ | KnownAnonym | FutureAnon // | Pseudonym\n+  // RENAME to whichPersonaId?\n+  doAs: MaybeAnon;\n+  isBestGuess?: Bo  // then should be first in PersonaOptions.list.\n+  inSameThread?: Bo\n+  onSamePage?: Bo\n+  // If is from any Persona Mode, e.g. Anonymous Mode.\n+  isFromMode?: Bo\n+  // If is from the category or page properties.\n+  isFromProps?: Bo\n+  // If recommended by the cat or page properties.\n+  isRecommended?: Bo\n+  // If persona not allowed, e.g. anon comments used to be enabled and we posted an\n+  // anonymous comment, but anon comments then got disabled.\n+  isNotAllowed?: Bo\n+  isSelf?: Bo\n+}\n+\n+// Exactly one set.\n+type PersonaMode = { pat?: Pat, self?: true, anonStatus?: AnonStatus };\n+\n+\n+/// The persona the user has choosen to use, and the ones han can choose among (can\n+/// depend on the current page, since anonyms are per page).\n+///\n+interface DoAsAndOpts {\n+  doAsAnon: MaybeAnon\n+  /// Which participants the current usr can choose among: hanself (`false`),\n+  /// hans anonyms and pseudonyms.\n+  /// CLEAN_UP: Is this field really needed? Can't `PersonaOptions.optsList` be used\n+  /// instead somehow? (`optsList.map(_.doAs)`) should be the same as `myAliasOpts`.\n+  myAliasOpts: MaybeAnon[]  // [ali_opts_only_needed_here]\n+}\n+\n+\n+/// For choosing which persona to use, if editing / altering a comment or a page.\n+///\n+interface ChooseEditorPersonaPs {\n+  // [Origins_needed_for_avatar_images].\n+  store: DiscStore & Origins\n+  postNr?: PostNr\n+  atRect: Rect\n+  draft?: Draft\n+  isInstantAction?: true\n+}\n+\n+\n+/// For choosing which persona to use, when posting comments or pages, or voting.\n+///\n+interface ChoosePosterPersonaPs {\n+  atRect?: Rect\n+  me: Me\n+  // [Origins_needed_for_avatar_images] — so can show one's pseudonyms' avatars (which\n+  // might be images hosted by a CDN — origin needed) if listing pseudonyms (to select one).\n+  origins: Origins\n+  // Might be different from the current store — if pat is composing a new page in\n+  // a category with different settings (`DiscPropsDerived`) than the forum root category.\n+  // CLEAN_UP: `store: DiscStore & Origins` instead, like in ChooseEditorPersonaPs?\n+  discStore: DiscStore\n+  postNr?: PostNr\n+  draft?: Draft\n+}\n+\n+\n+/// A dropdown for choosing which persona to use (e.g. if posting anonymous comments).\n+///\n+/// CLEAN_UP: Would it be possible/better to use ChooseEditorPersonaPs or\n+/// ChoosePosterPersonaPs instead?\n+///\n+interface ChoosePersonaDlgPs {\n+  atRect: Rect;\n+  open?: Bo;\n+  pat?: Pat;\n+  me: Me,\n+  // Any currently selected alias.\n+  curAnon?: MaybeAnon;\n+  // Which anonyms and pseudonyms to list in the choose-alias menu. (The options.)\n+  myAliasOpts?: MaybeAnon[];\n+  discProps: DiscPropsDerived;\n+  saveFn: (_: MaybeAnon) => V;\n+}\n+\n+\n+\n+// =========================================================================\n+//\n+// =========================================================================\n+\n+\n interface CreateUserParams {\n   idpName?: St;\n   idpHasVerifiedEmail?: Bo;\n@@ -1961,6 +2212,8 @@ interface StorePatch\n   publicCategories?: Category[];\n   restrictedCategories?: Category[];\n \n+  listingCatId?: CatId;\n+\n   pageVersionsByPageId?: { [pageId: string]: PageVersion };\n   postsByPageId?: { [pageId: string]: Post[] };\n \n@@ -2300,6 +2553,20 @@ interface IdentityProviderSecretConf extends IdentityProviderPubFields {\n // =========================================================================\n \n \n+/// For rendering a (A) text/image circle with one's first letter or tiny profile pic.\n+interface AvatarProps {\n+  user: BriefUser\n+  origins: Origins\n+  size?: AvatarSize\n+  title?: any\n+  hidden?: Bo\n+  showIsMine?: Bo\n+  ignoreClicks?: Bo\n+  clickOpensUserProfilePage?: Bo\n+  key?: St | Nr;\n+}\n+\n+\n /// For rendering a new page.\n interface ShowNewPageParams {\n   newPage: Page;  // | AutoPage;\n@@ -2356,40 +2623,6 @@ interface AuthnDlgIf {\n }\n \n \n-/// If clicking e.g. Like, one might need to choose if the like vote should\n-/// be anonymous or not.\n-interface MaybeChooseAnonPs {\n-  store: DiscStore\n-  discProps?: DiscPropsDerived\n-  postNr?: PostNr\n-  atRect?: Rect\n-}\n-\n-interface ChoosenAnon {\n-  doAsAnon: MaybeAnon\n-  /// Which participants the current usr can choose among: hanself (`false`),\n-  /// hans anonyms and pseudonyms.\n-  myAliasOpts: MaybeAnon[]\n-}\n-\n-\n-/// A dropdown for choosing which anonym to use (e.g. if posting anonymous comments).\n-/// DlgPs = dialog parameters, hmm.\n-///\n-interface ChooseAnonDlgPs {\n-  atRect: Rect;\n-  open?: Bo;\n-  pat?: Pat;\n-  me: Me,\n-  // Any currently selected alias.\n-  curAnon?: MaybeAnon;\n-  // Which anonyms and pseudonyms to list in the choose-alias menu. (The options.)\n-  myAliasOpts?: MaybeAnon[];\n-  discProps: DiscPropsDerived;\n-  saveFn: (_: MaybeAnon) => V;\n-}\n-\n-\n /// For rendering category trees.\n interface CatsTree {\n   rootCats: CatsTreeCat[];\n@@ -2512,6 +2745,7 @@ interface PatsToAddRemove {\n \n interface ExplainingTitleText {\n   iconUrl?: St;\n+  img?: any; // RElm;\n   title: any; // St | RElm; —> compil err in server & blog comments bundles\n   text?: any; // St | RElm;\n   key?: any;\n@@ -2542,10 +2776,20 @@ interface ExplainingListItemProps extends ExplainingTitleText {\n }\n \n \n+interface SimpleProxyDiagParams extends ProxyDiagParams {\n+  body: any // RElm\n+  primaryButtonTitle?: any // RElm\n+  secondaryButonTitle?: any // RElm\n+  closeButtonTitle?: any;\n+  onPrimaryClick?: () => V\n+  onCloseOk?: (whichBtn: Nr) => V;\n+}\n+\n+\n interface ProxyDiagParams extends SharedDiagParams {\n   atRect: Rect; // required (optional in SharedDiagParams)\n   flavor?: DiagFlavor;\n-  showCloseButton?: Bo; // default true\n+  showCloseButton?: Bo; // default true,  RENAME to showCloseCross? (upper right corner)\n   dialogClassName?: St;\n   contentClassName?: St;\n   closeOnButtonClick?: Bo; // default false\n@@ -2559,8 +2803,6 @@ interface DropdownProps extends SharedDiagParams {\n   show: Bo;\n   showCloseButton?: true;\n   //bottomCloseButton?: true; — not yet impl\n-  onHide: () => Vo;\n-  closeOnClickOutside?: false; // default true\n   onContentClick?: (event: MouseEvent) => Vo;\n   atX?: Nr;\n   atY?: Nr;\n@@ -2573,6 +2815,8 @@ interface SharedDiagParams {\n   atRect?: Rect;\n   pullLeft?: Bo;\n   allowFullWidth?: Bo;\n+  closeOnClickOutside?: false; // default true\n+  onHide?: () => V;\n }\n \n \n@@ -2975,6 +3219,11 @@ interface TerminateSessionsResponse {\n }\n \n \n+interface NotfSListResponse {\n+  notfs: Notification[]\n+}\n+\n+\n // COULD also load info about whether the user may apply and approve the edits.\n interface LoadDraftAndTextResponse {\n   pageId: PageId;"
    },
    {
      "sha": "47eab0e8b4897ad7ab9decbb510e0037df2d3b1a",
      "filename": "client/app-slim/more-bundle-not-yet-loaded.ts",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "changes": 19,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fmore-bundle-not-yet-loaded.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fmore-bundle-not-yet-loaded.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fmore-bundle-not-yet-loaded.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -58,19 +58,26 @@ export function showCreateUserDialog(params: CreateUserParams) {\n }\n \n \n-export function maybeChooseModAlias(ps: MaybeChooseAnonPs, then?: (_: ChoosenAnon) => V) {\n+export function chooseEditorPersona(ps: ChooseEditorPersonaPs, then?: (_: DoAsAndOpts) => V) {\n   Server.loadMoreScriptsBundle(() => {\n-    anon.maybeChooseModAlias(ps, then);\n+    persona.chooseEditorPersona(ps, then);\n   });\n }\n \n \n-export function maybeChooseAnon(ps: MaybeChooseAnonPs, then: (_: ChoosenAnon) => V) {\n+export function choosePosterPersona(ps: ChoosePosterPersonaPs,\n+          then: (_: DoAsAndOpts | 'CANCEL') => V) {\n   Server.loadMoreScriptsBundle(() => {\n-    anon.maybeChooseAnon(ps, then);\n+    persona.choosePosterPersona(ps, then);\n   });\n }\n \n+export function openPersonaInfoDiag(ps: { atRect: Rect, isSectionPage: Bo,\n+        me: Me, personaOpts: PersonaOptions, discProps: DiscPropsDerived }): V {\n+  Server.loadMoreScriptsBundle(() => {\n+    persona.openPersonaInfoDiag(ps);\n+  });\n+}\n \n export function openAboutUserDialog(who: number | string | BriefUser, at, extraInfo?: string) {\n   Server.loadMoreScriptsBundle(() => {\n@@ -99,9 +106,9 @@ export function openAddPeopleDialog(ps: { curPatIds?: PatId[], curPats?: Pat[],\n }\n \n \n-export function openDeletePostDialog(post: Post, at: Rect) {\n+export function openDeletePostDialog(ps: { post: Post, at: Rect, doAsAnon?: MaybeAnon }) {\n   Server.loadMoreScriptsBundle(() => {\n-    debiki2.pagedialogs.openDeletePostDialog(post, at);\n+    debiki2.pagedialogs.openDeletePostDialog(ps);\n   });\n }\n "
    },
    {
      "sha": "769107a004a077b1444c4abd700df1af5b90da00",
      "filename": "client/app-slim/oop-methods.ts",
      "status": "modified",
      "additions": 67,
      "deletions": 11,
      "changes": 78,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Foop-methods.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Foop-methods.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Foop-methods.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -198,6 +198,7 @@ export function pageNotfPrefTarget_findEffPref(\n   // unapproved replies (and edit them).\n   // The real fix would be to include a `MyPageData.iHaveReplied` field server side?\n   // Like so: ownPrefs.myDataByPageId[target.pageId].iHaveReplied ?\n+  // That's also needed for finding out which alias (if any) to use. [fetch_alias]\n   const anyReplyByPat =\n           _.find(store.pagesById[target.pageId]?.postsByNr,   // [On1]\n               (p: Post) => p.authorId === store.me.id);\n@@ -688,9 +689,13 @@ export function member_isBuiltIn(member: Member): Bo {\n \n \n // Dupl code [disp_name]\n-export function pat_name(pat: Me | Pat): St {\n+export function pat_name(patOrLazyAnon: Me | Pat | LazyCreatedAnon | NewAnon): St {\n+  if (patOrLazyAnon.anonStatus)\n+    return anonStatus_toStr(patOrLazyAnon.anonStatus);  // [anon_2_str]\n+\n   // Or prioritize username? Did, in the annon posts branch:\n   // if (pat.username) return '@' + pat.username;\n+  const pat = patOrLazyAnon as Pat;\n   return pat.fullName || (pat.username ? '@' + pat.username : \"_no_name_\");\n }\n \n@@ -766,6 +771,60 @@ export function pat_mayEditTags(me: Me, ps: { forPost?: Post, forPat?: Pat,\n \n \n \n+// Anonyms\n+//----------------------------------\n+\n+\n+export function anon_create(ps: { anonForId: UserId, anonStatus: AnonStatus,\n+        isMe?: true }): FutureAnon {\n+  const fullName = anonStatus_toStr(ps.anonStatus) + (ps.isMe ? \" (you)\" : '');  // I18N\n+  return {\n+    id: Pats.FutureAnonId,\n+    anonForId: ps.anonForId,\n+    fullName,\n+    isAnon: true,\n+    anonStatus: ps.anonStatus,\n+  } satisfies FutureAnon;\n+}\n+\n+\n+export function anonStatus_toStr(anonStatus: AnonStatus, verb: Verbosity = Verbosity.Brief): St {\n+  //  [dif_anon_status]\n+  if (anonStatus === AnonStatus.IsAnonCanAutoDeanon)\n+    return verb >= Verbosity.Full ? \"Temporarily Anonymous\" : (  // I18N [anon_2_str]\n+            verb >= Verbosity.Brief ? \"Temp Anonymous\" : (\n+            verb >= Verbosity.Terse ? \"Temp Anon\" :\n+            \"Temp\")); // Verbosity.VeryTerse\n+\n+  let prefix = '';\n+  // @ifdef DEBUG\n+  prefix = \"P\"; // for \"Permanently\". Nice in dev mode.\n+  // @endif\n+  if (anonStatus === AnonStatus.IsAnonOnlySelfCanDeanon)\n+    return prefix + (verb >= Verbosity.Brief ? \"Anonymous\" : (  // I18N\n+                      verb >= Verbosity.Terse ? \"Anonym\" :\n+                      \"Anon\")); // Verbosity.VeryTerse\n+\n+  // Unknown status.\n+  return `TyEUNKANSTA-${anonStatus}`;\n+}\n+\n+\n+// Persona mode\n+//----------------------------------\n+\n+export function persMode_toStr(mode: PersonaMode, verb: Verbosity): St {\n+  return mode.pat ?\n+              // This might be pretty long! Not Verbosity.Brief at all, depending\n+              // on the name. [pseudonyms_later]\n+              mode.pat.username || mode.pat.fullName : (\n+          mode.self ? (verb <= Verbosity.Terse ? \"Self\" : \"Yourself\") : (  // I18N\n+          mode.anonStatus ? anonStatus_toStr(mode.anonStatus, verb) :\n+          // Unknown mode.\n+          \"TyEUNKPERMODE\"));\n+}\n+\n+\n // Settings\n //----------------------------------\n \n@@ -1300,7 +1359,7 @@ export function store_makeNewPostPreviewPatch(store: Store, page: Page,\n   // make an anonym with '?' as sequence number appear.\n   const authorId = doAsAnon ? doAsAnon.sameAnonId || Pats.FutureAnonId : store.me.id;\n   const previewPost = store_makePreviewPost({\n-      authorId, parentPostNr, safePreviewHtml, newPostType, isEditing: true });\n+      authorId, doAsAnon, parentPostNr, safePreviewHtml, newPostType, isEditing: true });\n   return page_makePostPatch(page, previewPost);\n }\n \n@@ -1353,8 +1412,8 @@ export function store_makePostForDraft(authorId: PatId, draft: Draft): Post | Nl\n   // For now, use the CommonMark source instead.\n \n   const previewPost = store_makePreviewPost({\n-      authorId, parentPostNr, unsafeSource: draft.text, newPostType: postType,\n-      isForDraftNr: draft.draftNr || true });\n+      authorId, doAsAnon: draft.doAsAnon, parentPostNr, unsafeSource: draft.text,\n+      newPostType: postType, isForDraftNr: draft.draftNr || true });\n   return previewPost;\n }\n \n@@ -1379,6 +1438,7 @@ export function post_makePreviewIdNr(parentNr: PostNr, newPostType: PostType): P\n \n interface MakePreviewParams {\n   authorId: PatId;\n+  doAsAnon?: MaybeAnon;\n   parentPostNr?: PostNr;\n   safePreviewHtml?: string;\n   unsafeSource?: string;\n@@ -1391,7 +1451,7 @@ interface MakePreviewParams {\n \n \n function store_makePreviewPost({\n-    authorId, parentPostNr, safePreviewHtml, unsafeSource,\n+    authorId, doAsAnon, parentPostNr, safePreviewHtml, unsafeSource,\n     newPostType, isForDraftNr, isEditing }: MakePreviewParams): Post {\n \n   dieIf(!newPostType, \"Don't use for edit previews [TyE4903KS]\");\n@@ -1403,6 +1463,7 @@ function store_makePreviewPost({\n   const previewPost: Post = {\n     isPreview: true,\n     isForDraftNr,\n+    doAsAnon,\n     isEditing,\n \n     uniqueId: previewPostIdNr,\n@@ -1883,12 +1944,6 @@ function deriveLayoutImpl(page: PageDiscPropsSource, cat: Cat, store: DiscStore,\n }\n \n \n-export function page_authorId(page: Page): PatId | U {\n-  const origPost = page.postsByNr[BodyNr];\n-  return origPost && origPost.authorId;\n-}\n-\n-\n export function page_isClosedUnfinished(page: Page | Topic): Bo {\n   return page_isClosed(page) && !page_isSolved(page) && !page_isDone(page);\n }\n@@ -2032,6 +2087,7 @@ export function page_canChangeCategory(page: Page): boolean {\n export function page_mostRecentPostNr(page: Page): number {\n   // BUG not urgent. COULD incl the max post nr in Page, so even if not yet loaded,\n   // we'll know its nr, and can load and scroll to it, from doUrlFragmentAction().\n+  // Related to: [fetch_alias]\n   let maxNr = -1;\n   _.values(page.postsByNr).forEach((post: Post) => {  // COULD use _.reduce instead\n     maxNr = Math.max(post.nr, maxNr);"
    },
    {
      "sha": "68f05a035ee9b6f425474bb7bf28a472e05bf625",
      "filename": "client/app-slim/page/chat.ts",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpage%2Fchat.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpage%2Fchat.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fchat.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -176,13 +176,15 @@ const ChatMessage = createComponent({\n   edit: function() {\n     this.setState({ isEditing: true });\n     const post: Post = this.props.post;\n+    // Later: Pass alias, if any.  [anon_chats]\n     editor.openToEditPostNr(post.nr, (wasSaved, text) => {\n       this.setState({ isEditing: false });\n     });\n   },\n \n-  delete_: function(event) {\n-    morebundle.openDeletePostDialog(this.props.post, cloneEventTargetRect(event));\n+  delete_: function(event: MouseEvent) {\n+    // Later: [anon_chats].\n+    morebundle.openDeletePostDialog({ post: this.props.post, at: cloneEventTargetRect(event) });\n   },\n \n   render: function() {"
    },
    {
      "sha": "cbd54019b72af8dcf94df664ec454ff1f851368e",
      "filename": "client/app-slim/page/discussion.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpage%2Fdiscussion.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpage%2Fdiscussion.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fdiscussion.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -360,9 +360,12 @@ export const Title = createComponent({\n     return { editingPageId: null };\n   },\n \n-  editTitle: function() {\n+  editTitle: function(event: MouseEvent) {\n     const store: Store = this.props.store;\n-    this.setState({ editingPageId: store.currentPageId });\n+    const atRect = cloneEventTargetRect(event);\n+    morebundle.chooseEditorPersona({ store, atRect, postNr: TitleNr }, doAsOpts => {\n+      this.setState({ editingPageId: store.currentPageId, doAsOpts });\n+    });\n   },\n \n   closeEditor: function() {\n@@ -428,6 +431,7 @@ export const Title = createComponent({\n     if (this.state.editingPageId) {\n       const editorProps = _.clone(this.props);\n       editorProps.closeEditor = this.closeEditor;\n+      editorProps.doAsOpts = this.state.doAsOpts;\n       contents = morebundle.TitleEditor(editorProps);\n     }\n     else {"
    },
    {
      "sha": "6cdd958d49d07fceb2f94d8690dad9b9ba650e24",
      "filename": "client/app-slim/page/post-actions.ts",
      "status": "modified",
      "additions": 60,
      "deletions": 28,
      "changes": 88,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpage%2Fpost-actions.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpage%2Fpost-actions.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fpost-actions.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -145,16 +145,23 @@ function makeReplyBtnTitle(store: Store, post: Post) {\n export const PostActions = createComponent({\n   displayName: 'PostActions',\n \n-  onAcceptAnswerClick: function() {\n-    morebundle.maybeChooseModAlias({ store: this.props.store, atRect: undefined },\n-            (choices: ChoosenAnon) => {\n-      ReactActions.acceptAnswer(this.props.post.uniqueId, choices.doAsAnon);\n+  onAcceptAnswerClick: function(event: MouseEvent) {\n+    const atRect: Rect = cloneEventTargetRect(event);\n+    // A [pick_persona_click_handler] could save a few lines of code?\n+    morebundle.chooseEditorPersona({ store: this.props.store, atRect, isInstantAction: true },\n+            (doAsOpts: DoAsAndOpts) => {\n+      const pageId = Server.getPageId();\n+      const postId = this.props.post.uniqueId;\n+      ReactActions.acceptAnswer({ pageId, postId, doAsAnon: doAsOpts.doAsAnon });\n     });\n   },\n-  onUnacceptAnswerClick: function() {\n-    morebundle.maybeChooseModAlias({ store: this.props.store, atRect: undefined },\n-            (choices: ChoosenAnon) => {\n-      ReactActions.unacceptAnswer(choices.doAsAnon);\n+\n+  onUnacceptAnswerClick: function(event: MouseEvent) {\n+    const atRect: Rect = cloneEventTargetRect(event);\n+    morebundle.chooseEditorPersona({ store: this.props.store, atRect, isInstantAction: true },\n+            (doAsOpts: DoAsAndOpts) => {\n+      const pageId = Server.getPageId();\n+      ReactActions.unacceptAnswer({ pageId, doAsAnon: doAsOpts.doAsAnon });\n     });\n   },\n \n@@ -557,25 +564,25 @@ const MoreVotesDropdownModal = createComponent({\n     const atRect = cloneEventTargetRect(event);\n     const post: Post = this.state.post;\n     loginIfNeededThen(LoginReason.LoginToDisagree, post.nr, () => {\n-      toggleVote(this.state.store, post, PostVoteType.Disagree, !this.hasVoted(PostVoteType.Disagree), atRect);\n-      this.closeSoon();\n+      toggleVote(this.state.store, post, PostVoteType.Disagree, !this.hasVoted(PostVoteType.Disagree),\n+            atRect, this.closeSoon);\n     });\n   },\n   onBuryClick: function(event: MouseEvent) {\n     const atRect = cloneEventTargetRect(event);\n     const post: Post = this.state.post;\n     // Not visible unless logged in.\n     // [anon_mods]\n-    toggleVote(this.state.store, post, PostVoteType.Bury, !this.hasVoted(PostVoteType.Bury), atRect);\n-    this.closeSoon();\n+    toggleVote(this.state.store, post, PostVoteType.Bury, !this.hasVoted(PostVoteType.Bury),\n+            atRect, this.closeSoon);\n   },\n   onUnwantedClick: function(event: MouseEvent) {\n     const atRect = cloneEventTargetRect(event);\n     const post: Post = this.state.post;\n     // Not visible unless logged in.\n     // [anon_mods]\n-    toggleVote(this.state.store, post, PostVoteType.Unwanted, !this.hasVoted(PostVoteType.Unwanted), atRect);\n-    this.closeSoon();\n+    toggleVote(this.state.store, post, PostVoteType.Unwanted, !this.hasVoted(PostVoteType.Unwanted),\n+            atRect, this.closeSoon);\n   },\n \n   makeVoteButtons: function() {\n@@ -633,8 +640,8 @@ const MoreVotesDropdownModal = createComponent({\n });\n \n \n-// CLEAN_UP use enum PostVoteType for voteType, instead of string.\n-function toggleVote(store: Store, post: Post, voteType: PostVoteType, toggleOn: Bo, atRect: Rect) {\n+function toggleVote(store: Store, post: Post, voteType: PostVoteType, toggleOn: Bo, atRect: Rect,\n+        closeSoon?: () => V) {\n   const page: Page = store.currentPage;\n   let action: 'DeleteVote' | 'CreateVote';\n   let postNrsRead: PostNr[];\n@@ -646,21 +653,39 @@ function toggleVote(store: Store, post: Post, voteType: PostVoteType, toggleOn:\n     postNrsRead = findPostNrsRead(page.postsByNr, post);\n   }\n \n-  morebundle.maybeChooseAnon({ store, postNr: post.nr, atRect }, (choices: ChoosenAnon) => {\n-    const data = {\n-      pageId: store.currentPageId,\n-      postNr: post.nr,\n-      vote: voteType,\n-      action,\n-      postNrsRead,\n-      doAsAnon: choices.doAsAnon,\n-    };\n+  const data: SaveVotePs = {\n+    pageId: store.currentPageId,\n+    postNr: post.nr,\n+    vote: voteType,\n+    action,\n+    postNrsRead,\n+  };\n+\n+  if (toggleOn) {\n+    morebundle.choosePosterPersona({ me: store.me, origins: store,\n+            discStore: store, postNr: post.nr, atRect,\n+            }, (doAsOpts: DoAsAndOpts | 'CANCEL') => {\n+      if (closeSoon) closeSoon();\n+      if (doAsOpts === 'CANCEL')\n+        return;\n+      data.doAsAnon = doAsOpts.doAsAnon;\n+      save();\n+    });\n+  }\n+  else {\n+    // The server will delete the vote, no matter which one of pat's aliases (if any) voted.\n+    // Later: Incl the id of the alias who voted, if one can create be > 1 anonym/alias\n+    // per page. [one_anon_per_page].\n+    if (closeSoon) closeSoon();\n+    save();\n+  }\n \n+  function save() {\n     debiki2.Server.saveVote(data, function(storePatch: StorePatch) {\n       const by = storePatch.yourAnon || me_toBriefUser(store.me);\n       ReactActions.vote(storePatch, action, voteType, post.nr, by);\n     });\n-  });\n+  }\n }\n \n \n@@ -760,8 +785,15 @@ const MoreDropdownModal = createComponent({\n     this.close();\n   },\n \n-  onDeleteClick: function(event) {\n-    morebundle.openDeletePostDialog(this.state.post, this.state.buttonRect);\n+  onDeleteClick: function(event: MouseEvent) {\n+    const atRect: Rect = cloneEventTargetRect(event);\n+    const state = this.state;\n+    const post: Post = state.post;\n+    morebundle.chooseEditorPersona({ store: state.store, postNr: post.nr, atRect,\n+            isInstantAction: true }, (doAsOpts: DoAsAndOpts) => {\n+      morebundle.openDeletePostDialog({ post: this.state.post,\n+            at: atRect, doAsAnon: doAsOpts.doAsAnon });\n+    });\n     this.close();\n   },\n "
    },
    {
      "sha": "8acd203707a715bcc663b4590cd5a6bd4c0bfe36",
      "filename": "client/app-slim/personas/PersonaIndicator.ts",
      "status": "added",
      "additions": 72,
      "deletions": 0,
      "changes": 72,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpersonas%2FPersonaIndicator.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpersonas%2FPersonaIndicator.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpersonas%2FPersonaIndicator.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright (c) 2024 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+/// <reference path=\"../../macros/macros.d.ts\" />\n+/// <reference path=\"../ReactActions.ts\" />\n+/// <reference path=\"../widgets.ts\" />\n+/// <reference path=\"../page-methods.ts\" />\n+/// <reference path=\"../utils/utils.ts\" />\n+/// <reference path=\"../avatar/avatar.ts\" />\n+/// <reference path=\"../more-bundle-not-yet-loaded.ts\" />\n+\n+//------------------------------------------------------------------------------\n+   namespace debiki2.personas {\n+//------------------------------------------------------------------------------\n+\n+// [persona_indicator]\n+export function PersonaIndicator(ps: { store: Store, isSectionPage: Bo }): RElm | N {\n+  const store = ps.store;\n+  const me = store.me;\n+  const personaOpts: PersonaOptions | U = store.curPersonaOptions;\n+  const discProps: DiscPropsDerived | U = store.curDiscProps;\n+  const mode: PersonaMode | U = store.indicatedPersona;\n+\n+  if (!personaOpts || !discProps || !mode)\n+    return null;\n+\n+  const fullName = persMode_toStr(mode, Verbosity.Brief);\n+  const shortName = persMode_toStr(mode, Verbosity.VeryTerse);\n+\n+  const title: RElm = rFr({},\n+      // If using a pseudonym, show it's avatar image, if any: [pseudonyms_later]\n+      !mode.pat ? null : avatar.Avatar({ user: mode.pat, origins: store, ignoreClicks: true }),\n+      // If screen wide:\n+      r.span({ className: 'esAvtrName_name' }, fullName),\n+      // If screen narrow, always visible if narrow:  [narrow]\n+      r.span({ className: 'esAvtrName_Anon' }, shortName),\n+      // If we'll need to ask pat which persona to use, then, show a question mark:\n+      !personaOpts.isAmbiguous ? null : r.span({ className: 'c_AliAmbig' }, ' ?'));\n+\n+  const aliasElm =\n+      Button({ className: 'esAvtrName esMyMenu s_MMB c_Tb_Ali' +\n+                            (!me.usePersona ? '' : ' c_Tb_Ali-Switched'),\n+          onClick: (event: MouseEvent) => {\n+            const atRect: Rect = cloneEventTargetRect(event);\n+            morebundle.openPersonaInfoDiag({ atRect, isSectionPage: ps.isSectionPage,\n+                me, personaOpts, discProps });\n+          }},\n+      title);\n+\n+  return aliasElm;\n+}\n+\n+\n+\n+//------------------------------------------------------------------------------\n+   }\n+//------------------------------------------------------------------------------\n+// vim: fdm=marker et ts=2 sw=2 tw=0 fo=tcqwn list"
    },
    {
      "sha": "59409baf7dd0019a6e8d1fd8558cc665a70d33ea",
      "filename": "client/app-slim/personas/personas.ts",
      "status": "added",
      "additions": 533,
      "deletions": 0,
      "changes": 533,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpersonas%2Fpersonas.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fpersonas%2Fpersonas.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpersonas%2Fpersonas.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,533 @@\n+/*\n+ * Copyright (c) 2023 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+/// <reference path=\"../prelude.ts\" />\n+\n+//------------------------------------------------------------------------------\n+   namespace debiki2 {\n+//------------------------------------------------------------------------------\n+\n+\n+/// disc_findMyPersonas()\n+///\n+/// If pat is posting a reply anonymously, then, if han has posted or voted earlier\n+/// anonymously on the same page, usually han wants hens new reply, to be\n+/// by the same anonym, so others see they're talking with the same person\n+/// (although they don't know who it is, just that it's the same).\n+///\n+/// This fn finds anonyms a pat has used, so the pat can reuse them. First it\n+/// looks for anonyms-to-reuse in the sub thread where pats reply will appear,\n+/// thereafter anywhere on the same page.\n+///\n+/// Returns sth like this, where 200 is pat's id, and 2001, 2002, 2003, 2004 are\n+/// anons pat has used on the current page:  (just nice looking numbers)\n+/// {\n+///   // Just an example\n+///   byId: {\n+///     2001: patsAnon2001,  // = { id: 2001, forPatId: 200, ... }\n+///     2002: patsAnon2002,  // = { id: 2002, forPatId: 200, ... }\n+///     2003: patsAnon2003,  // = { id: 2003, forPatId: 200, ... }\n+///     2004: patsAnon2004,  // = { id: 2004, forPatId: 200, ... }\n+///   },\n+///   sameThread: [\n+///     patsAnon2002,  // pat's anon (or pat henself) who made pat's last comment\n+//                     // in the path from  startAtPostNr, back to the orig post.\n+///     patHenself,    // here pat posted using hens real account (not anonymously)\n+///     patsAnon2001,  // pat upvoted a comment using anon 2001, along this path\n+///   ],\n+///   outsideThread: [\n+///     // If pat has posted earlier in the thread (closer to the orig post), using\n+///     // any of the above (anon 2002, 2001, or as henself), those comments are\n+///     // ignored: we don't add an anon more than once to the list.)\n+///\n+///     patsAnon2004, // Pat replied elsewhere on the page using hens anon 2004\n+///     patsAnon2003, // ... and before that, han posted as anon 2003, also\n+///                   //     elsewhere on the same page.\n+///   ]\n+/// }\n+///\n+/// In the above example, patsAnon2003 didn't post anything in the thread from\n+/// startAtPostNr up to the orig post — but that anon did post something,\n+/// *elsewhere* in the same discussion. So that anon is still in the list of anons\n+/// pat might want to use again, on this page.\n+///\n+export function disc_findMyPersonas(discStore: DiscStore, ps: {\n+            forWho: Pat | Me | U, startAtPostNr?: PostNr }): MyPersonasThisPage {\n+\n+  const result: MyPersonasThisPage = {\n+    sameThread: [],\n+    outsideThread: [],\n+    byId: {},\n+  };\n+\n+  const forWho: Pat | Me | U = ps.forWho;\n+  if (!forWho || !forWho.id)\n+    return result;\n+\n+  const curPage: Page | U = discStore.currentPage;\n+  if (!curPage)\n+    return result;\n+\n+  // ----- Same thread\n+\n+  // Find out if pat was henself, or was anonymous, in any earlier posts by hen,\n+  // in the path from ps.startAtPostNr and back towards the orig post.\n+  // (patsAnon2002, patHenself, and patsAnon2001 in the example above (i.e. in\n+  // the docs comment to this fn)).\n+  // (Much later: Should fetch from server, if page big – an 999 comments long thread\n+  // – maybe not all comments in the middle were included by the server?  [fetch_alias])\n+\n+  const startAtPost: Post | U = ps.startAtPostNr && curPage.postsByNr[ps.startAtPostNr];\n+  const nrsSeen = {};\n+  let myVotesByPostNr: { [postNr: PostNr]: Vote[] } = {};\n+\n+  const isMe = pat_isMe(forWho);\n+  if (isMe) {\n+    myVotesByPostNr = forWho.myDataByPageId[curPage.pageId]?.votesByPostNr || {};\n+  }\n+  else {\n+    die('TyE0MYVOTS'); // [_must_be_me]\n+  }\n+\n+  let nextPost: Post | U = startAtPost;\n+  const myAliasesInThread = [];\n+\n+  for (let i = 0; i < StructsAndAlgs.TooLongPath && nextPost; ++i) {\n+    // Cycle? (Would be a bug somewhere.)\n+    if (nrsSeen[nextPost.nr])\n+      break;\n+    nrsSeen[nextPost.nr] = true;\n+\n+    // Bit dupl code:  [_find_anons]\n+\n+    // We might have added this author, already.\n+    if (result.byId[nextPost.authorId])\n+      continue;\n+\n+    const author: Pat | U = discStore.usersByIdBrief[nextPost.authorId];\n+    if (!author)\n+      continue; // would be a bug somewhere, or a rare & harmless race? Oh well.\n+\n+    const postedAsSelf = author.id === forWho.id;\n+    const postedAnonymously = author.anonForId === forWho.id;\n+\n+    if (postedAsSelf || postedAnonymously) {\n+      // This places pat's most recently used anons first.\n+      myAliasesInThread.push(author);\n+      result.byId[author.id] = author;\n+    }\n+    else {\n+      // This comment is by someone else. If we've voted anonymously, let's\n+      // continue using the same anonym. Or using our main user account, if we've\n+      // voted not-anonymously.\n+      const votes: Vote[] = myVotesByPostNr[nextPost.nr] || [];\n+      for (const myVote of votes) {\n+        // If myVote.byId is absent, it's our own vote (it's not anonymous). [_must_be_me]\n+        const voterId = myVote.byId || forWho.id;\n+        // Have we added this alias (or our real account) already?\n+        if (result.byId[voterId])\n+          continue;\n+        const voter: Pat = discStore.usersByIdBrief[voterId];\n+        // Sometimes voters are lazy-created and added. Might be some bug. [lazy_anon_voter]\n+        // @ifdef DEBUG\n+        dieIf(!voter, `Voter ${voterId} missing [TyE502SRKJ5]`);\n+        // @endif\n+        myAliasesInThread.push(voter);\n+        result.byId[voter.id] = voter;\n+      }\n+    }\n+\n+    nextPost = curPage.postsByNr[nextPost.parentNr];\n+  }\n+\n+  // ----- Same page\n+\n+  // If pat posted outside [the thread from the orig post to ps.startAtPostNr],\n+  // then include any anons pat used, so Pat can choose to use those anons, now\n+  // when being active in sub thread startAtPostNr.  (See patsAnon2003 and patsAnon2004\n+  // in this fn's docs above.)\n+\n+  // Sleeping BUG:, ANON_UNIMPL: What if it's a really big page, and we don't have\n+  // all parts here, client side?  Maybe this ought to be done server side instead?\n+  // Or the server could incl all one's anons on the current page, in a list  [fetch_alias]\n+\n+  const myAliasesOutsideThread: Pat[] = [];\n+\n+  _.forEach(curPage.postsByNr, function(post: Post) {\n+    if (nrsSeen[post.nr])\n+      return;\n+\n+    // Bit dupl code:  [_find_anons]\n+\n+    // Each anon pat has used, is to be included at most once.\n+    if (result.byId[post.authorId])\n+      return;\n+\n+    const author: Pat | U = discStore.usersByIdBrief[post.authorId];\n+    if (!author)\n+      return;\n+\n+    const postedAsSelf = author.id === forWho.id;\n+    const postedAnonymously = author.anonForId === forWho.id;\n+\n+    if (postedAsSelf || postedAnonymously) {\n+      myAliasesOutsideThread.push(author);\n+      result.byId[author.id] = author;\n+    }\n+  });\n+\n+  _.forEach(myVotesByPostNr, function(votes: Vote[], postNrSt: St) {\n+    if (nrsSeen[postNrSt])\n+      return;\n+\n+    for (const myVote of votes) {\n+      // The voter is oneself or one's anon or pseudonym. [_must_be_me]\n+      const voterId = myVote.byId || forWho.id;\n+\n+      if (result.byId[voterId])\n+        return;\n+\n+      const voter: Pat | U = discStore.usersByIdBrief[voterId];  // [voter_needed]\n+      if (!voter)\n+        return;\n+\n+      myAliasesOutsideThread.push(voter);\n+      result.byId[voter.id] = voter;\n+    }\n+  });\n+\n+\n+  // Sort, newest first. Could sort votes by voted-at, not the comment posted-at — but\n+  // doesn't currently matter, not until [many_anons_per_page].\n+  // Old — now both comments and votes, so won't work:\n+  //myPostsOutsideThread.sort((p: Post) => -p.createdAtMs);\n+  //const myPatsOutside = myPostsOutsideThread.map(p => discStore.usersByIdBrief[p.authorId]);\n+\n+  // ----- The results\n+\n+  result.sameThread = myAliasesInThread;\n+  result.outsideThread = myAliasesOutsideThread;\n+\n+  return result;\n+}\n+\n+\n+\n+/// Makes a list of personas pat can use, for replying or voting. The first\n+/// item in the list is the one to use by default, and if it's unclear what\n+/// pat might want, sets `PersonaOptions.isAmbiguous` in the response to true.\n+///\n+/// Ambiguity matrix:\n+///\n+///   D = the persona in the left column is automatically used (has priority).\n+///   d = We'll ask which persona pat wants to use, and this persona (the one in\n+///       the left column) is the default, listed first.\n+///       Not totally implemented for the editor though?\n+///   - = ignored, doesn't have priority\n+///   A = ambiguous, should ask the user\n+///  (AP = ambiguous, should ask and update the Preferred-persona-on-page.\n+///       But not implemented – means A instead, for now.)\n+///\n+///                              None Thread (PrfOnP) Page  Recom   Pers Mode\n+///                         None  n/a      -      -      -      -      -\n+///            Persona in Thread*   D    n/a      A      d      D      d\n+///  (Preferred Persona on Page)**  D      d    n/a      D      D      d\n+///              Persona on Page    D      -      -    n/a      D      A\n+///          Recommended Persona    d      -      -      -     n/a     -\n+///         Persona mode persona    D      A      A      A      D    n/a\n+///\n+///   * \"Persona in Thread\" means that pat has replied or voted earlier in the same\n+///     page, same sub thread, as that persona. Example:\n+///\n+///       A comment by Alice\n+///       `—> A comment by this user as anonym A   <—— this persona (anonym A) is in\n+///           |                                        `MyPersonasThisPage.sameThread`\n+///           `—> A comment by Bob\n+///               `—> Here our user starts replying to Bob,\n+///                   and findPersonaOptions() gets called.\n+///                   Our user likely wants to reply as anonym A again.\n+///       Some other comment, same page but not same sub thread\n+///       `—> A reply\n+///           `——> A comment by our      <— this persona (the user hanself) is\n+///                user, as hanself         in  `MyPersonasThisPage.outsideThread`, and\n+///                                         that's \"Persona on Page\" in the table above\n+///\n+///   ** \"Preferred Persona on Page\" is if in the future it'll be possible to\n+///      remember \"Always use this persona, on this page\" — so won't have to choose,\n+///      repeatedly. But maybe that's just an over complicated idea.\n+///\n+export function findPersonaOptions(ps: {\n+        // Missing, if on a forum homepage (no discussions directly on such pages).\n+        myPersonasThisPage?: MyPersonasThisPage,\n+        me: Me,\n+        // Missing, if on an auto generated page (rather than a discussion page).\n+        // Would be good with site-default props [site_disc_props] instead of `undefined`.\n+        discProps?: DiscPropsDerived,\n+        }): PersonaOptions {\n+\n+  const dp: DiscPropsDerived | U = ps.discProps;\n+  const anonsAllowed = dp && dp.comtsStartAnon >= NeverAlways.Allowed;\n+  const anonsRecommended = dp && dp.comtsStartAnon >= NeverAlways.Recommended;\n+  //nst pseudonymsRecommended = false; // [pseudonyms_later]\n+  const mustBeAnon = dp  && dp.comtsStartAnon >= NeverAlways.AlwaysButCanContinue;\n+  const newAnonStatus = dp && dp.newAnonStatus;\n+  const selfRecommended = !anonsRecommended; // later: dp.comtsStartAnon <= AllowedMustChoose\n+\n+  // @ifdef DEBUG\n+  dieIf(anonsAllowed && !newAnonStatus, `[TyE4WJE281]`);\n+  dieIf(anonsRecommended && !anonsAllowed, `[TyE4WJE282]`);\n+  dieIf(mustBeAnon && !anonsRecommended, `[TyE4WJE282]`);\n+  // @endif\n+\n+  const myPersThisPage: MyPersonasThisPage | U = ps.myPersonasThisPage;\n+  const me = ps.me;\n+\n+  const result: PersonaOptions = { isAmbiguous: false, optsList: [] };\n+  let selfAdded = false;\n+  let anonFromPropsAdded = false;\n+  let modePersonaAdded = false;\n+  let recommendedAdded = false;\n+\n+  // ----- Personas from the current discussion\n+\n+  if (!myPersThisPage) {\n+    // We're on a forum homeage, or user profile page, or sth like that, which\n+    // itself has no discussions or comments.\n+  }\n+  else {\n+    // We're on some discussion page, with comments, authors, votes.\n+\n+    // Same sub thread has priority – so we continue replying as the same person,\n+    // won't become sbd else in the middle of a thread.\n+    for (let ix = 0; ix < myPersThisPage.sameThread.length; ++ix) {\n+      const pat = myPersThisPage.sameThread[ix];\n+      const opt: PersonaOption = {\n+        alias: pat,\n+        doAs: patToMaybeAnon(pat, me),\n+        // The first item is who pat most recently replied or voted as, in the relevant sub thread.\n+        isBestGuess: ix === 0,\n+        inSameThread: true,\n+      }\n+      initOption(opt);\n+      result.optsList.push(opt);\n+    }\n+\n+    // Thereafter, elsewhere on the same page, but not in the same sub thread.\n+    for (let ix = 0; ix < myPersThisPage.outsideThread.length; ++ix) {\n+      const pat = myPersThisPage.outsideThread[ix];\n+      const opt: PersonaOption = {\n+        alias: pat,\n+        doAs: patToMaybeAnon(pat, me),\n+        isBestGuess:\n+            !myPersThisPage.sameThread.length &&\n+            // If pat has commented using different aliases on this page, we can't\n+            // know which one is the best guess?  Maybe the most recently used one?\n+            // Or the most frequently used one? Who knows.\n+            myPersThisPage.outsideThread.length === 1,\n+        onSamePage: true,\n+      }\n+      initOption(opt);\n+      result.optsList.push(opt);\n+    }\n+  }\n+\n+  // ----- Persona mode\n+\n+  // The user might be in e.g. anon mode also on pages without any discussions.\n+\n+  if (me.usePersona && !modePersonaAdded) {\n+    let opt: PersonaOption;\n+    if (me.usePersona.self) {\n+      opt = {\n+        alias: me,\n+        doAs: false, // not anon, be oneself [oneself_0_false]\n+        isFromMode: true,\n+        isSelf: true,\n+      };\n+      if (mustBeAnon) {\n+        opt.isNotAllowed = true;\n+      }\n+      if (selfRecommended) {\n+        opt.isRecommended = true;\n+        recommendedAdded = true;\n+      }\n+      selfAdded = true;\n+    }\n+    else if (me.usePersona.anonStatus) {\n+      // Since not added above (!modePersonaAdded), this'd be a new anon.\n+      const anonStatus = me.usePersona.anonStatus;\n+      const anonPat = anon_create({ anonStatus, anonForId: me.id });\n+      opt = {\n+        alias: anonPat,\n+        doAs: patToMaybeAnon(anonPat, me),\n+        isFromMode: true,\n+      };\n+      if (!anonsAllowed) {\n+        opt.isNotAllowed = true;\n+      }\n+      if (anonStatus === newAnonStatus) {\n+        if (anonsRecommended) {\n+          opt.isRecommended = true;\n+          recommendedAdded = true;\n+        }\n+        opt.isFromProps = true;\n+        anonFromPropsAdded = true;  // [dif_anon_status]\n+      }\n+    }\n+    else {\n+      // [pseudonyms_later] ?\n+    }\n+\n+    result.optsList.push(opt);\n+  }\n+\n+  // Are there more than two persona options? Then we don't know which one to use.\n+  //\n+  // (We ignore additional options added below. Only any Persona Mode option (added above),\n+  // and personas pat has been on the current page (also added above), can make us unsure\n+  // about who pat wants to be now.  But not just because anonymity or posting as oneself\n+  // is the default / recommended on the page.)\n+  //\n+  result.isAmbiguous = result.optsList.length >= 2;\n+\n+  // Add Anonymous as an option, if not done already.\n+  if (!anonFromPropsAdded && anonsAllowed) {\n+    const anonPat = anon_create({ anonStatus: newAnonStatus, anonForId: me.id });\n+    const opt: PersonaOption = {\n+      alias: anonPat,\n+      doAs: patToMaybeAnon(anonPat, me),\n+    };\n+    if (!recommendedAdded && anonsRecommended) {\n+      // (It's the recommended type of anon — we created it with newAnonStatus just above.)\n+      opt.isRecommended = true;\n+      recommendedAdded = true;\n+    }\n+    result.optsList.push(opt);\n+\n+    // If not in alias mode, maybe it's good to tell the user that han can be anonymous\n+    // if han wants? – No, this feels just annoying. If someone started commenting\n+    // on a page as hanself, then it's pretty pointless to suddenly have han replaced by\n+    // \"Anon 123\" in subsequent comments, when \"everyone\" can guess who Anon 123 is anyway.\n+    // if (ambiguities2.aliases.length >= 2 && !me.usePersona && anonsRecommended) {\n+    //   ambiguities2.isAmbiguous = true;\n+    // }\n+  }\n+\n+  // Add oneself as an option, if not done already. (But don't consider this an ambiguity.)\n+  if (!selfAdded && !mustBeAnon) {\n+    const opt: PersonaOption = {\n+      alias: me,\n+      doAs: false, // not anon [oneself_0_false]\n+      isSelf: true,\n+    };\n+    if (!recommendedAdded && selfRecommended) {\n+      opt.isRecommended = true;\n+      recommendedAdded = true;\n+    }\n+    result.optsList.push(opt);\n+  }\n+\n+  result.optsList.sort((a: PersonaOption, b: PersonaOption) => {\n+    if (a.isNotAllowed !== b.isNotAllowed)\n+      return a.isNotAllowed ? +1 : -1; // place `a` last\n+\n+    if (a.isBestGuess !== b.isBestGuess)\n+      return a.isBestGuess ? -1 : +1; // place `a` first\n+\n+    if (a.isFromMode !== b.isFromMode)\n+      return a.isFromMode ? -1 : +1;\n+\n+    if (a.isRecommended !== b.isRecommended)\n+      return a.isRecommended ? -1 : +1;\n+\n+    if (a.isSelf !== b.isSelf)\n+      return a.isSelf ? -1 : +1;\n+  })\n+\n+  function initOption(opt: PersonaOption) {\n+    const pat: Pat = opt.alias;\n+    const isMe = pat.id === me.id;\n+    const isAnonFromProps = pat.anonStatus && pat.anonStatus === newAnonStatus;\n+\n+    if (isMe) {\n+      opt.isSelf = true;\n+      selfAdded = true;\n+      result.hasBeenSelf = true;\n+    }\n+\n+    if (pat.isAnon) {\n+      // (opt.isAnon not needed —  opt.alias.isAnon is enough.)\n+      if (isAnonFromProps) {\n+        opt.isFromProps = true;\n+        anonFromPropsAdded = true;  // [dif_anon_status]\n+      }\n+      result.hasBeenAnon = true;\n+    }\n+\n+    // if (...) [pseudonyms_later]\n+\n+    // Is the same persona as any current Persona Mode?\n+    if (me.usePersona) {\n+      const isSelfFromMode = me.usePersona.self && isMe;\n+      const isAnonFromMode = me.usePersona.anonStatus === pat.anonStatus && pat.anonStatus;\n+      if (isSelfFromMode || isAnonFromMode) {\n+        opt.isFromMode = true;\n+        modePersonaAdded = true;\n+      }\n+    }\n+\n+    // Any persona mode anonym, might not be of the recommended anonymity status. [dif_anon_status]\n+    // But one from the category properties, would be.\n+    if ((isAnonFromProps && anonsRecommended) || (isMe && selfRecommended)) {\n+      opt.isRecommended = true;\n+      recommendedAdded = true;\n+    }\n+\n+    if ((pat.isAnon && !anonsAllowed) || (isMe && mustBeAnon)) {\n+      opt.isNotAllowed = true;\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+\n+export function patToMaybeAnon(p: Pat | KnownAnonym | NewAnon, me: Me): MaybeAnon {\n+  if ((p as WhichAnon).createNew_tst) {\n+    // Then `p` is a WhichAnon already, not a Pat.\n+    return p as NewAnon;\n+  }\n+\n+  const pat = p as Pat;\n+\n+  if (pat.id === me.id) {\n+    return false; // means not anon, instead, oneself [oneself_0_false]\n+  }\n+  else if (pat.id === Pats.FutureAnonId) {\n+    // Skip `NewAnon.createNew_tst` for now. [one_anon_per_page]\n+    return { anonStatus: pat.anonStatus, lazyCreate: true } satisfies LazyCreatedAnon;\n+  }\n+  else {\n+    return { anonStatus: pat.anonStatus, sameAnonId: pat.id } as SameAnon;\n+  }\n+}\n+\n+\n+//------------------------------------------------------------------------------\n+   }\n+//------------------------------------------------------------------------------\n+// vim: fdm=marker et ts=2 sw=2 tw=0 fo=r list"
    },
    {
      "sha": "9fb9486c709c10ea8a389182cda5cc5f60006039",
      "filename": "client/app-slim/sidebar/sidebar.ts",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fsidebar%2Fsidebar.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fsidebar%2Fsidebar.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fsidebar%2Fsidebar.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -241,6 +241,7 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n \n     // Find 1) all unread comments, sorted in the way they appear on the page\n     // And 2) all visible comments.\n+    // Should fetch from server, if page big. [fetch_alias]\n     const addRecursively = (postNrs: number[]) => {\n       _.each(postNrs, (postNr) => {\n         const post: Post = page.postsByNr[postNr];\n@@ -281,7 +282,7 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n     const rootPost = page.postsByNr[store.rootPostId];\n     addRecursively(rootPost.childNrsSorted);\n \n-    _.each(page.postsByNr, (child: Post, childId) => {\n+    _.each(page.postsByNr, (child: Post) => {\n       if (child.postType === PostType.Flat) {\n         addPost(child);\n       }\n@@ -407,7 +408,7 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n           title = ''; // \"People here recently:\"  // I18N, unimplemented\n         }\n         else {\n-          const titleText = isChat ? t.cb.UsersInThisChat : t.cb.UsersInThisTopic;\n+          const titleText = isChat ? t.cb.UsersInThisChat : t.cb.UsersInThisTopic; // [users_here]\n           title = r.div({},\n             titleText,\n             r.span({ className: 'esCtxbar_onlineCol' }, t.Online));"
    },
    {
      "sha": "506e6f314ecdb2dd11dadd8fe61a1d41b4c02cc9",
      "filename": "client/app-slim/slim-bundle.d.ts",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fslim-bundle.d.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fslim-bundle.d.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fslim-bundle.d.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -389,7 +389,8 @@ declare namespace debiki2 {\n   function user_isTrustMinNotThreat(me: UserInclDetails | Myself, trustLevel: TrustLevel): boolean;\n   //function threatLevel_toString(threatLevel: ThreatLevel): [St, St];\n   function threatLevel_toElem(threatLevel: ThreatLevel);\n-  function pat_name(pat: Me | Pat): St;\n+  function persMode_toStr(mode: PersonaMode, verb: Verbosity): St;\n+  function pat_name(pat: Me | Pat | LazyCreatedAnon | NewAnon): St;\n   function pat_isMe(pat: UserInclDetails | Me | Pat | PatId): pat is Me;\n   function pat_isMember(pat: UserInclDetails | Me | Pat | PatId): Bo;\n   var isGuest;\n@@ -401,11 +402,18 @@ declare namespace debiki2 {\n   function store_maySendDirectMessageTo(store: Store, user: UserInclDetails): boolean;\n   function pat_isBitAdv(pat: PatVb | Me): Bo;\n   function pat_isMoreAdv(pat: PatVb | Me): Bo;\n+  function anonStatus_toStr(anonStatus: AnonStatus, verb?: Verbosity): St;\n   var page_isGroupTalk;\n \n   function store_getAuthorOrMissing(store: DiscStore, post: Post): Pat;\n   function store_getUserOrMissing(store: DiscStore, userId: PatId, errorCode2?: St): Pat;\n-  var store_thisIsMyPage;\n+  function store_thisIsMyPage(store: DiscStore): Bo;\n+  function disc_findMyPersonas(discStore: DiscStore, ps: {\n+                forWho: Pat | Me | U, startAtPostNr?: PostNr }): MyPersonasThisPage;\n+\n+  function findPersonaOptions(ps: { myPersonasThisPage?: MyPersonasThisPage, me: Me,\n+        discProps: DiscPropsDerived }): PersonaOptions;\n+  function patToMaybeAnon(p: Pat | KnownAnonym | NewAnon, me: Me): MaybeAnon;\n \n   function draftType_toPostType(draftType: DraftType): PostType | U;\n   function postType_toDraftType(postType: PostType): DraftType | U;\n@@ -511,7 +519,7 @@ declare namespace debiki2 {\n   function timeExact(whenMs: number, clazz?: string);\n \n   namespace avatar {\n-    var Avatar;\n+    function Avatar(props: AvatarProps): RElm;\n   }\n \n   function pageNotfPrefTarget_findEffPref(target: PageNotfPrefTarget, store: Store, ownPrefs: OwnPageNotfPrefs): EffPageNotfPref;"
    },
    {
      "sha": "ee04005bfb6ff13d1d062cc5584d05a862782cb2",
      "filename": "client/app-slim/start-page.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fstart-page.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fstart-page.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fstart-page.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -282,6 +282,7 @@ function renderPageInBrowser() {\n   debiki2.processTimeAgo(numPosts > 20 ? '.dw-ar-p-hd' : '');\n   const timeAfterTimeAgo = performance.now();\n \n+  // (Also calls ReactStore.activateMyself().)\n   debiki2.ReactStore.activateVolatileData();\n   const timeAfterUserData = performance.now();\n "
    },
    {
      "sha": "6a1b921cd5e39008589e531af45adc9dac2b29a7",
      "filename": "client/app-slim/start-stuff.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fstart-stuff.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fstart-stuff.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fstart-stuff.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -100,4 +100,4 @@ debiki2.dieIf(location.port && eds.debugOrigin.indexOf(':' + location.port) ===\n \n }\n \n-// vim: fdm=marker et ts=2 sw=2 fo=tcqwn list\n\\ No newline at end of file\n+// vim: fdm=marker et ts=2 sw=2 fo=tcqwn list"
    },
    {
      "sha": "894f4772f37130641acba36684f449839976e46b",
      "filename": "client/app-slim/store-getters.ts",
      "status": "modified",
      "additions": 14,
      "deletions": 13,
      "changes": 27,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fstore-getters.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fstore-getters.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fstore-getters.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -35,7 +35,7 @@ export function pat_isAuthorOf(pat: Me | Pat, post: Post, patsById: PpsById): Bo\n   // @ifdef DEBUG\n   dieIf(!post, 'TyE2065MRTJ3');\n   // @endif\n-  // If pat typeof Me, and not logged in, .id is undefined.\n+  // If pat typeof Me, and not logged in, pat.id is Pats.NoPatId == 0, zero.\n   if (!pat.id || !post) return false;\n   // If pat used hens real account (or if pat is an anonym and the post author too).\n   if (pat.id === post.authorId) return true;\n@@ -45,7 +45,7 @@ export function pat_isAuthorOf(pat: Me | Pat, post: Post, patsById: PpsById): Bo\n }\n \n \n-export function store_thisIsMyPage(store: Store): boolean {\n+export function store_thisIsMyPage(store: DiscStore): Bo {\n   const page: Page = store.currentPage;\n   if (!page || !store.me.id) return false;\n   const me: Me = store.me;\n@@ -75,14 +75,14 @@ export function store_getAuthorOrMissing(store: DiscStore, post: Post): Pat {\n   }\n \n   // If replying using a new anonym, its future id is not yet konw:\n+  // (This happens when *previewing* one's first anonymous comments on a page. Once\n+  // the comment gets saved, an anonym is created and gets an id.)\n   if (post.authorId === Pats.FutureAnonId) {\n-    return {\n-       id: Pats.FutureAnonId,\n-       // We don't know for sure what name sequence number this anonym will get,\n-       // so let's use '?' instead of A1 or A2 etc.\n-       fullName: \"Anonym (you)\",\n-       isAnon: true,\n-    };\n+    // @ifdef DEBUG\n+    dieIf(!post.doAsAnon, 'TyE6032SKGN4');\n+    // @endif\n+    const anonStatus = post.doAsAnon && post.doAsAnon.anonStatus;\n+    return anon_create({ anonStatus, anonForId: store.me.id, isMe: true });\n   }\n \n   const user = store_getUserOrMissing(store, post.authorId);\n@@ -108,7 +108,7 @@ export function store_getUserOrMissing(store: DiscStore, userId: PatId,\n       // so it'll be easier to debug-find-out that something is amiss.\n       fullName: `□ missing, id: ${userId} [EsE4FK07_]`,\n       isMissing: true,\n-    };\n+    } satisfies Pat;\n   }\n   return user;\n }\n@@ -129,6 +129,7 @@ export function store_getUsersOnThisPage(store: Store): BriefUser[] {\n   const page: Page = store.currentPage;\n   const users: BriefUser[] = [];\n   _.each(page.postsByNr, (post: Post) => {\n+    // Isn't this [On2]? Or rather num-authors*num-posts?\n     if (_.every(users, u => u.id !== post.authorId)) {\n       const user = store_getAuthorOrMissing(store, post);\n       users.push(user);\n@@ -195,15 +196,14 @@ export function store_canDeletePage(store: Store): Bo {\n           !isSection(page.pageRole) || store_numSubCommunities(store) > 1);\n   return someoneCanDelete && (\n           isStaff(store.me) || (\n-          page_authorId(page) === store.me.id &&\n-              page.numRepliesVisible == 0));\n+          store_thisIsMyPage(store) && page.numRepliesVisible == 0));\n }\n \n \n export function store_canUndeletePage(store: Store): Bo {\n   const page: Page = store.currentPage;\n   const pat = store.me;\n-  return !!page.pageDeletedAtMs && (isStaff(pat) || page_authorId(page) === pat.id);\n+  return !!page.pageDeletedAtMs && (isStaff(pat) || store_thisIsMyPage(store));\n                         // later, change to:  page.deletedById === pat.id\n }\n // -------\n@@ -253,6 +253,7 @@ export function store_numSubCommunities(store: Store): number {\n \n \n export function store_thereAreFormReplies(store: Store): boolean {\n+  // Should fetch from server, if page big.  [fetch_alias]\n   const page: Page = store.currentPage;\n   return _.some(page.postsByNr, (post: Post) => {\n     return post.postType === PostType.CompletedForm;"
    },
    {
      "sha": "e25f50eaebc7c5332cfe6b960ab55f0eb9350f0a",
      "filename": "client/app-slim/topbar/topbar.styl",
      "status": "modified",
      "additions": 47,
      "deletions": 6,
      "changes": 53,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Ftopbar%2Ftopbar.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Ftopbar%2Ftopbar.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Ftopbar%2Ftopbar.styl?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -295,9 +295,12 @@ html.c_Html-EdLeft #esPageColumn\n     margin-top: 0;\n \n \n-.esTB_SearchBtn\n-  padding: 2px 5px 0px 4px;\n+.DW.DW.DW .esTB_SearchBtn\n+  padding: 5px 5px 5px 4px\n   margin: 0;\n+  vertical-align: middle;\n+\n+.esTB_SearchBtn\n   .icon-search\n     color: hsl(0, 0%, 50%);\n     font-size: 21px;\n@@ -357,19 +360,22 @@ html.c_Html-EdLeft #esPageColumn\n         opacity: 1;\n \n   .esAvtrName_you,\n-  .esAvtrName_name\n+  .esAvtrName_name,\n+  .esAvtrName_Anon\n     color: #666;\n     letter-spacing: 0.2px;\n     vertical-align: middle;\n     font-size: 13.5px;\n \n   // Replace the user's perhaps long username with \"You\" if screen too narrow.\n-  .esAvtrName_you\n+  .esAvtrName_you,\n+  .esAvtrName_Anon\n     display: none;\n   @media (max-width: 640px)\n     .esAvtrName_name\n       display: none;\n-    .esAvtrName_you\n+    .esAvtrName_you,\n+    .esAvtrName_Anon\n       display: inline-block;\n   @media (max-width: 480px)\n     .esAvtrName_you\n@@ -477,11 +483,17 @@ $snoozeIconSize = 28px;\n   position: relative;\n   top: 1px;\n \n+// What's this? Adds padding without breaking right-alignment with things below in\n+// <divs> of the same width?\n .esMyMenu\n   padding-right: 6px;\n   position: relative;\n   right: -6px;\n \n+// Dim one's true account, if using an alias (so the alias becomes more prominent).\n+.s_MMB.n_AliOn\n+  opacity: 0.83;\n+\n .esMyMenu .esAvtr\n   margin-right: 5px;\n \n@@ -514,6 +526,32 @@ $snoozeIconSize = 28px;\n     left: 0;\n     top: 6px;\n \n+.c_Tb_AliAw\n+  font-size: 150%;\n+  margin: 0 -6px 0 4px;\n+  @media (max-width: 640px)\n+    margin: 0 -9px 0 0px;\n+\n+.DW .c_Tb_Ali.s_MMB.btn\n+  padding: 16px 6px;\n+  margin-left: -6px; // cancel padding (+padding -margin —> button larger)\n+\n+.c_Tb_Ali-Switched.btn\n+  font-weight: bold;\n+  text-decoration: underline;\n+  text-underline-offset: 6px;\n+\n+// Make [the question mark indicating an alias ambiguity] simpler to spot.\n+.c_AliAmbig\n+  font-size: 110%;\n+  vertical-align: middle;\n+\n+.c_PersInfD_Bs\n+  margin: 23px 0px 9px;\n+  .btn\n+    margin: 0 15px 10px 0;\n+\n+\n .esTopbar\n   position: relative;\n   z-index: 5;\n@@ -587,12 +625,15 @@ html.esSidebarsOverlayPage\n   .s_Tb_CuNv,\n   .s_Tb_Pg_Cs,\n   .s_Tb_MyBs\n-    margin-top: 15px;\n+    margin-top: 17px;\n \n .s_Tb\n   .s_Tb_MyBs\n     white-space: nowrap;\n     .btn\n+      vertical-align: baseline;\n+      padding-top: 2px;\n+      line-height: 1;\n       border-radius: 0;\n       border: none;\n "
    },
    {
      "sha": "481c0f4efbb79f2bb09bb6dc9f57e190640bb956",
      "filename": "client/app-slim/topbar/topbar.ts",
      "status": "modified",
      "additions": 28,
      "deletions": 7,
      "changes": 35,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Ftopbar%2Ftopbar.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Ftopbar%2Ftopbar.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Ftopbar%2Ftopbar.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -15,6 +15,7 @@\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n \n+/// <reference path=\"../../macros/macros.d.ts\" />\n /// <reference path=\"../ReactStore.ts\" />\n /// <reference path=\"../ReactActions.ts\" />\n /// <reference path=\"../links.ts\" />\n@@ -30,6 +31,7 @@\n /// <reference path=\"../page/cats-or-home-link.ts\" />\n /// <reference path=\"../Server.ts\" />\n /// <reference path=\"../more-bundle-not-yet-loaded.ts\" />\n+/// <reference path=\"../personas/PersonaIndicator.ts\" />\n \n //------------------------------------------------------------------------------\n    namespace debiki2.topbar {\n@@ -316,17 +318,32 @@ export const TopBar = createComponent({\n     const otherNotfs = makeNotfIcon('other', me.numOtherNotfs);\n \n     let isImpersonatingClass = '';\n-    let impersonatingStrangerInfo;\n+    let impersonatingStrangerInfo: St | U;\n     if (store.isImpersonating) {\n       isImpersonatingClass = ' s_MMB-IsImp';\n       if (!me.isLoggedIn) {\n         isImpersonatingClass += ' s_MMB-IsImp-Stranger';\n-        impersonatingStrangerInfo = \"Viewing as stranger\"; // (skip i18n, is for staff)\n+        impersonatingStrangerInfo = \"Viewing as stranger\"; // (0I18N, is for staff)\n         // SECURITY COULD add a logout button, so won't need to first click stop-viewing-as,\n         // and then also click Logout. 2 steps = a bit risky, 1 step = simpler, safer.\n       }\n     }\n \n+\n+    // ------- Alias info\n+\n+    // Shows if we're anonymous or have switched to any pseudonym.\n+\n+    const aliasInfo: RElm | N = !store.userSpecificDataAdded ? null :\n+            personas.PersonaIndicator({ store, isSectionPage });\n+\n+    // @ifdef DEBUG\n+    // COULD_OPTIMIZE: This actually happens —  we're rerendering at least once too much?\n+    //dieIf(me.usePersona && !aliasInfo, 'TyE60WMJLS256');\n+    // @endif\n+\n+    // ------- Username  (click opens: ../../app-more/topbar/my-menu.more.ts)\n+\n     const myAvatar = !me.isLoggedIn ? null :\n         avatar.Avatar({ user: me, origins: store, ignoreClicks: true });\n \n@@ -351,10 +368,11 @@ export const TopBar = createComponent({\n \n     const avatarNameDropdown = !me.isLoggedIn && !impersonatingStrangerInfo ? null :\n       utils.ModalDropdownButton({\n-          // RENAME 'esMyMenu' to 's_MMB' (my-menu button).\n-          className: 'esAvtrName esMyMenu s_MMB' + isImpersonatingClass,  // CLEAN_UP RENAME to s_MMB\n+          // RENAME 'esMyMenu' to 'c_MMB' (my-menu button).\n+          className: 'esAvtrName esMyMenu s_MMB' +  // CLEAN_UP RENAME to c_MMB\n+                       isImpersonatingClass +\n+                       (me.usePersona ? ' n_AliOn' : ''),\n           dialogClassName: 's_MM',\n-          ref: 'myMenuButton',\n           showCloseButton: true,\n           bottomCloseButton: true,\n           // MyMenu might list many notifications, and people Command-Click to open\n@@ -375,7 +393,8 @@ export const TopBar = createComponent({\n             talkToMeNotfs,\n             talkToOthersNotfs,\n             otherNotfs,\n-            snoozeIcon) },\n+            snoozeIcon,\n+            ) },\n         MyMenuContentComponent({ store }));\n \n \n@@ -533,7 +552,9 @@ export const TopBar = createComponent({\n           // We don't know when CSS hides or shows the 2nd row, so better to\n           // include always.\n           toolsButton,\n-          avatarNameDropdown);\n+          avatarNameDropdown,\n+          aliasInfo && r.span({ className: 'c_Tb_AliAw' }, \"→ \"),\n+          aliasInfo);\n           // No:\n           //(!use2Rows || justOneRow) && toolsButton,\n           //(!use2Rows || justOneRow) && avatarNameDropdown);"
    },
    {
      "sha": "d7e7c052a854799215bd878d25c824a76138e818",
      "filename": "client/app-slim/translations.d.ts",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Ftranslations.d.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Ftranslations.d.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Ftranslations.d.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -26,7 +26,16 @@ interface TalkyardTranslations {\n   AddComment?: string;\n   Admin: string;\n   AdvSearch: string;\n+  // Wrap all these \"Temp\", \"Temp Anon\", \"Perma.. Anon..\" in an `anon: {...}` obj, [anon_2_str]\n+  // so they'll end up next to each other?\n+  //Temp?: string;\n+  //TempAnon?: string;\n+  //TempAnonym?: string;\n+  //TemporarilyAnonymous?: string;\n+  //Anon?: string;\n   Anonym?: string;\n+  //Anonymous?: string;\n+  //PermanentlyAnonymous?: string;\n   Away: string;\n   Back: string;\n   BlogN: string;"
    },
    {
      "sha": "4d5a62e0f2e8a2acee54b5a3ae6b88778cba3c3d",
      "filename": "client/app-slim/util/ExplainingDropdown.styl",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futil%2FExplainingDropdown.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futil%2FExplainingDropdown.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Futil%2FExplainingDropdown.styl?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -78,3 +78,21 @@ $sideSpace = 20px;\n \n .esExplDrp_entry_sub\n   margin: 8px 20px 16px;\n+\n+// If there's an image/icon to the left of the tilte & text.\n+.esExplDrp_entry:has(.esExplDrp_entry_img) button\n+  display: flex;\n+  // The images a bit function as padding-left, so reduce from $sideSpace = 20px\n+  // to just .esDropModal_header's padding-left = 11px. [proxy_diag_padding]\n+  padding-left: 11px;\n+\n+.esExplDrp_entry_img\n+  flex: 0\n+\n+  .esAvtr\n+    position: static;\n+    margin-right: 15px;\n+\n+.esExplDrp_entry_TtlTxt\n+  flex: 1\n+"
    },
    {
      "sha": "2fd931739be109c70a7c8528f4d79e63cbe08040",
      "filename": "client/app-slim/util/ExplainingDropdown.ts",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futil%2FExplainingDropdown.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futil%2FExplainingDropdown.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Futil%2FExplainingDropdown.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -81,6 +81,15 @@ export var ExplainingListItem = createComponent({\n \n     const elemFn = isButton ? r.button : (props.linkTo ? LinkUnstyled : r.a);\n \n+    let imgTitleText = rFr({},\n+          r.div({ className: 'esExplDrp_entry_title' }, entry.title),\n+          r.div({ className: 'esExplDrp_entry_expl' }, entry.text));\n+    if (props.img) {\n+      imgTitleText = rFr({},\n+            r.div({ className: 'esExplDrp_entry_img' }, props.img),\n+            r.div({ className: 'esExplDrp_entry_TtlTxt' }, imgTitleText));\n+    }\n+\n     return (\n       r.li({ className: 'esExplDrp_entry' + activeClass + disabledClass },\n         elemFn.apply(this, [\n@@ -96,8 +105,7 @@ export var ExplainingListItem = createComponent({\n                 },\n                 tabIndex: props.tabIndex || 1000,\n             },\n-            r.div({ className: 'esExplDrp_entry_title' }, entry.title),\n-            r.div({ className: 'esExplDrp_entry_expl' }, entry.text)]),\n+            imgTitleText]),\n         subStuff));\n   },\n });"
    },
    {
      "sha": "8ae87214ffd35cd5e135e20554814a9210723c5f",
      "filename": "client/app-slim/utils/DropdownModal.styl",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futils%2FDropdownModal.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futils%2FDropdownModal.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Futils%2FDropdownModal.styl?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -17,6 +17,8 @@\n       max-width: 560px; // or annoyingly wide. [dropdown_width]\n \n .esDropModal_CloseB\n+  // This doesn't work well: sometimes overlaps long contents.\n+  // Wouldn't float: right be better? But need one extra <div>?  [close_cross_css]\n   position: absolute;\n   right: 0;\n   top: 0;\n@@ -36,7 +38,7 @@\n .esDropModal_header\n   font-style: italic;\n   font-size: 14px;\n-  margin: 14px 0 4px 11px;\n+  margin: 14px 0 4px 11px; // [proxy_diag_padding]\n   &:first-child\n     margin-top: 3px;\n "
    },
    {
      "sha": "243fbce3de1fb53fdbbe879591ea3a7230eea5ef",
      "filename": "client/app-slim/utils/DropdownModal.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futils%2FDropdownModal.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Futils%2FDropdownModal.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Futils%2FDropdownModal.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -224,6 +224,7 @@ export const DropdownModal = createComponent({\n     const props: DropdownProps = this.props;\n     let content;\n     if (props.show) {\n+      // Need one more <div> to be able to use float: right for the close [x]? [close_cross_css]\n       const closeButton = !props.showCloseButton ? null :\n         r.div({ className: 'esDropModal_CloseB esCloseCross', onClick: props.onHide });\n "
    },
    {
      "sha": "f2cbbfa80ef5cd3f0593423dddccbb2846b18341",
      "filename": "client/app-slim/widgets.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fwidgets.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fapp-slim%2Fwidgets.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fwidgets.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -300,8 +300,7 @@ export function UserName(props: {\n   let namePartTwo: St | RElm | U;\n \n   if (user.isAnon) {\n-    // There's already \"By\" before, and \"anonym\" isn't a name, so use lowercase.\n-    namePartOne = r.span({className: 'esP_By_F esP_By_F-G' }, t.Anonym);\n+    namePartOne = r.span({className: 'esP_By_F esP_By_F-G' }, anonStatus_toStr(user.anonStatus));\n     if (props.store && user.anonForId) {  // maybe always take a DiscStore as fn props?\n       const store = props.store;\n       if (store.me.id === user.anonForId) {"
    },
    {
      "sha": "90daf470f830bd0a1c4b0b380bc0542c7c5d1a46",
      "filename": "client/server/personas/PersonaIndicator.ts",
      "status": "added",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fserver%2Fpersonas%2FPersonaIndicator.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Fserver%2Fpersonas%2FPersonaIndicator.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fserver%2Fpersonas%2FPersonaIndicator.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,16 @@\n+/// <reference path=\"../prelude.ts\" />\n+\n+//------------------------------------------------------------------------------\n+   namespace debiki2.personas {\n+//------------------------------------------------------------------------------\n+\n+\n+export function PersonaIndicator(ps: any): RElm | N {\n+  return null;\n+}\n+\n+\n+//------------------------------------------------------------------------------\n+   }\n+//------------------------------------------------------------------------------\n+// vim: fdm=marker et ts=2 sw=2 tw=0 fo=tcqwn list"
    },
    {
      "sha": "a0ef058c05d76403d40b65394cf33655836ba6e5",
      "filename": "client/types-and-const-enums.ts",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Ftypes-and-const-enums.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/client%2Ftypes-and-const-enums.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Ftypes-and-const-enums.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -755,6 +755,17 @@ const enum DiagFlavor {\n }\n \n \n+const enum Verbosity {\n+  // Can be nice for [power_users], e.g. \"T\" or \"TA\" for \"Temporarily Anonymous\",\n+  // and they'd know what it means.\n+  //Letters = 1,\n+  VeryTerse = 2,\n+  Terse = 3,\n+  Brief = 4,\n+  Full = 6,\n+}\n+\n+\n const enum Time {\n   OneDayInMillis = 24 * 3600 * 1000,\n }"
    },
    {
      "sha": "4a7bbbedd4d6a400c5a68cd0b8add6694c5238c0",
      "filename": "docs/abbreviations.txt",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fabbreviations.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fabbreviations.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fabbreviations.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -86,10 +86,15 @@ And  t_  —>  i_  for 'id' attr.\n s_w-X = wraps an X, i.e., somewhere inside, there's an X. Or \"'W'ith a X inside\".\n w_X   = wraps X. Always a class, not an id.\n \n+0I18N:  Internationalization not needed (0 = zero = not), that is, no need to\n+  translate to different languages – only English is fine for now. (Typically because\n+  the message is for admins only, who are supposed to know some English.)\n+\n In-the-middle or at-a-word-end abbreviations: (but not at the start of the selector)\n Ab  = about\n Adm = admin\n Aft = after\n+Ali = alias (anonym or pseudonym)\n Alw = allow(ed)\n Ann, An = announcement, also see SAn: Server Announcement\n Asg  = assign\n@@ -180,6 +185,7 @@ Nv  = navigation, e.g. NvLs_Ln = Navigation-List Link\n Nw  = new\n Op  = Original post\n Ord = order\n+Par = parenhtesis? Maybe sth else too\n Pat = participant\n Pb  = pagebar\n Pf  = preference, e.g. NfPfs = notification preferences"
    },
    {
      "sha": "c8a078f666ea95713d562b1b8e84078782921832",
      "filename": "docs/db-schema/README.txt",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2FREADME.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2FREADME.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2FREADME.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -9,14 +9,14 @@ for table_name in $(docker-compose exec -T rdb psql -c '\\d' talkyard talkyard \\\n    | awk '{ print $3 }')\n do\n     docker-compose exec -T rdb psql talkyard talkyard -c '\\d '\"$table_name\" \\\n-          | tee ./docs/db-schema-dump/$table_name.txt\n+          | tee ./docs/db-schema/$table_name.txt\n done\n \n # Custom domains, with and without comments:\n docker-compose exec -T rdb psql talkyard talkyard -c '\\dD+' \\\n-          | tee ./docs/db-schema-dump/domains.txt\n+          | tee ./docs/db-schema/domains.txt\n docker-compose exec -T rdb psql talkyard talkyard -c '\\dD' \\\n-          | tee ./docs/db-schema-dump/domains-no-comments.txt\n+          | tee ./docs/db-schema/domains-no-comments.txt\n ```\n \n Details:  \\d lists all tables and sequences, this format:"
    },
    {
      "sha": "a992ef88b8b0c09f7e1a3ecb487180a9ab6cacb0",
      "filename": "docs/db-schema/drafts3.txt",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fdrafts3.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fdrafts3.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2Fdrafts3.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -19,6 +19,7 @@\n  text              | character varying           |           | not null | \n  new_anon_status_c | anonym_status_d             |           |          | \n  post_as_id_c      | pat_id_d                    |           |          | \n+ order_c           | f32_d                       |           |          | \n Indexes:\n     \"drafts_byuser_nr_p\" PRIMARY KEY, btree (site_id, by_user_id, draft_nr)\n     \"drafts_byuser_deldat_i\" btree (site_id, by_user_id, deleted_at DESC) WHERE deleted_at IS NOT NULL"
    },
    {
      "sha": "ec8f081e163df11875cfc10dc6b505f861366d5f",
      "filename": "docs/db-schema/notifications3.txt",
      "status": "modified",
      "additions": 19,
      "deletions": 11,
      "changes": 30,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fnotifications3.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fnotifications3.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2Fnotifications3.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -21,32 +21,38 @@\n  about_tag_id_c       | tag_id_d                    |           |          | \n  about_thing_type_c   | thing_type_d                |           |          | \n  about_sub_type_c     | sub_type_d                  |           |          | \n+ by_true_id_c         | pat_id_d                    |           |          | \n+ to_true_id_c         | pat_id_d                    |           |          | \n Indexes:\n-    \"dw1_notfs_id__p\" PRIMARY KEY, btree (site_id, notf_id)\n-    \"dw1_ntfs_createdat_email_undecided__i\" btree (created_at) WHERE email_status = 1\n-    \"dw1_ntfs_emailid\" btree (site_id, email_id)\n-    \"dw1_ntfs_postid__i\" btree (site_id, about_post_id_c) WHERE about_post_id_c IS NOT NULL\n-    \"dw1_ntfs_seen_createdat__i\" btree ((\n-CASE\n-    WHEN seen_at IS NULL THEN created_at + '100 years'::interval\n-    ELSE created_at\n-END) DESC)\n+    \"notfs_p_notfid\" PRIMARY KEY, btree (site_id, notf_id)\n     \"notfs_i_aboutcat_topat\" btree (site_id, about_cat_id_c, to_user_id) WHERE about_cat_id_c IS NOT NULL\n     \"notfs_i_aboutpage_topat\" btree (site_id, about_page_id_str_c, to_user_id) WHERE about_page_id_str_c IS NOT NULL\n     \"notfs_i_aboutpat_topat\" btree (site_id, about_pat_id_c, to_user_id) WHERE about_pat_id_c IS NOT NULL\n     \"notfs_i_aboutpost_patreltype_frompat_subtype\" btree (site_id, about_post_id_c, action_type, by_user_id, action_sub_id) WHERE about_post_id_c IS NOT NULL\n+    \"notfs_i_aboutpostid\" btree (site_id, about_post_id_c) WHERE about_post_id_c IS NOT NULL\n     \"notfs_i_abouttag_topat\" btree (site_id, about_tag_id_c, to_user_id) WHERE about_tag_id_c IS NOT NULL\n     \"notfs_i_aboutthingtype_subtype\" btree (site_id, about_thing_type_c, about_sub_type_c) WHERE about_thing_type_c IS NOT NULL\n     \"notfs_i_bypat\" btree (site_id, by_user_id) WHERE by_user_id IS NOT NULL\n-    \"notfs_touser_createdat__i\" btree (site_id, to_user_id, created_at DESC)\n-    \"notfs_touser_post__i\" btree (site_id, to_user_id, about_post_id_c)\n+    \"notfs_i_bytrueid\" btree (site_id, by_true_id_c) WHERE by_true_id_c IS NOT NULL\n+    \"notfs_i_createdat_but_unseen_first\" btree ((\n+CASE\n+    WHEN seen_at IS NULL THEN created_at + '100 years'::interval\n+    ELSE created_at\n+END) DESC)\n+    \"notfs_i_createdat_if_undecided\" btree (created_at) WHERE email_status = 1\n+    \"notfs_i_emailid\" btree (site_id, email_id)\n+    \"notfs_i_totrueid_createdat\" btree (site_id, to_true_id_c, created_at DESC) WHERE to_true_id_c IS NOT NULL\n+    \"notfs_i_touserid_aboutpostid\" btree (site_id, to_user_id, about_post_id_c)\n+    \"notfs_i_touserid_createdat\" btree (site_id, to_user_id, created_at DESC)\n Check constraints:\n     \"dw1_notfs_emailstatus__c_in\" CHECK (email_status >= 1 AND email_status <= 20)\n     \"dw1_notfs_seenat_ge_createdat__c\" CHECK (seen_at > created_at)\n     \"dw1_ntfs__c_action\" CHECK ((action_type IS NOT NULL) = (action_sub_id IS NOT NULL))\n     \"dw1_ntfs_by_to__c_ne\" CHECK (by_user_id::text <> to_user_id::text)\n     \"notfs_c_aboutthingtype_subtype_null\" CHECK ((about_thing_type_c IS NULL) = (about_sub_type_c IS NULL))\n+    \"notfs_c_byuserid_ne_bytrueid\" CHECK (by_user_id <> by_true_id_c::integer)\n     \"notfs_c_notftype_range\" CHECK (notf_type >= 101 AND notf_type <= 999)\n+    \"notfs_c_touserid_ne_totrueid\" CHECK (to_user_id <> to_true_id_c::integer)\n     \"notifications_c_id_not_for_imp\" CHECK (notf_id < 2000000000)\n Foreign-key constraints:\n     \"notfs_aboutcat_r_cats\" FOREIGN KEY (site_id, about_cat_id_c) REFERENCES categories3(site_id, id) DEFERRABLE\n@@ -55,6 +61,8 @@ Foreign-key constraints:\n     \"notfs_aboutpost_reltype_frompat_subtype_r_patrels\" FOREIGN KEY (site_id, about_post_id_c, action_type, by_user_id, action_sub_id) REFERENCES post_actions3(site_id, to_post_id_c, rel_type_c, from_pat_id_c, sub_type_c) DEFERRABLE\n     \"notfs_abouttag_r_tags\" FOREIGN KEY (site_id, about_tag_id_c) REFERENCES tags_t(site_id_c, id_c) DEFERRABLE\n     \"notfs_bypat_r_pats\" FOREIGN KEY (site_id, by_user_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n+    \"notfs_bytrueid_r_pats\" FOREIGN KEY (site_id, by_true_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n+    \"notfs_totrueid_r_pats\" FOREIGN KEY (site_id, to_true_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     \"ntfs_post_r_posts\" FOREIGN KEY (site_id, about_post_id_c) REFERENCES posts3(site_id, unique_post_id) DEFERRABLE\n     \"ntfs_r_emails\" FOREIGN KEY (site_id, email_id) REFERENCES emails_out3(site_id, email_id_c) DEFERRABLE\n     \"ntfs_r_sites\" FOREIGN KEY (site_id) REFERENCES sites3(id) DEFERRABLE"
    },
    {
      "sha": "64b42b346083bc07147cad91e39a766192437dac",
      "filename": "docs/db-schema/post_actions3.txt",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fpost_actions3.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fpost_actions3.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2Fpost_actions3.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -16,14 +16,16 @@\n  to_post_rev_nr_c | rev_nr_d                    |           |          | \n  dormant_status_c | dormant_status_d            |           |          | \n  val_i32_c        | i32_d                       |           |          | \n- as_pat_id_c      | pat_id_d                    |           |          | \n+ from_true_id_c   | pat_id_d                    |           |          | \n  added_by_id_c    | member_id_d                 |           |          | \n+ order_c          | f32_d                       |           |          | \n Indexes:\n     \"dw2_postacs__p\" PRIMARY KEY, btree (site_id, to_post_id_c, rel_type_c, from_pat_id_c, sub_type_c)\n     \"dw2_postacs_deletedby__i\" btree (site_id, deleted_by_id) WHERE deleted_by_id IS NOT NULL\n-    \"dw2_postacs_page_byuser\" btree (site_id, page_id, from_pat_id_c)\n+    \"patnoderels_i_pageid_frompatid\" btree (site_id, page_id, from_pat_id_c)\n+    \"patnoderels_i_pageid_fromtrueid\" btree (site_id, page_id, from_true_id_c) WHERE from_true_id_c IS NOT NULL\n     \"patnodesinrels_i_addedbyid\" btree (site_id, added_by_id_c) WHERE added_by_id_c IS NOT NULL\n-    \"patnodesinrels_i_aspatid\" btree (site_id, as_pat_id_c) WHERE as_pat_id_c IS NOT NULL\n+    \"patnodesinrels_i_aspatid\" btree (site_id, from_true_id_c) WHERE from_true_id_c IS NOT NULL\n     \"patrels_i_frompat_reltype_addedat\" btree (site_id, from_pat_id_c, rel_type_c, created_at DESC)\n     \"patrels_i_frompat_reltype_addedat_0dormant\" btree (site_id, from_pat_id_c, rel_type_c, created_at DESC) WHERE dormant_status_c IS NULL\n Check constraints:\n@@ -35,8 +37,8 @@ Check constraints:\n     \"postactions_c_postnr_not_for_imp\" CHECK (post_nr < 2000000000)\n     \"postactions_c_subid_not_for_imp\" CHECK (sub_type_c < 2000000000)\n Foreign-key constraints:\n+    \"patnoderels_fromtrueid_r_pats\" FOREIGN KEY (site_id, from_true_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     \"patnodesinrels_addedbyid_r_pats\" FOREIGN KEY (site_id, added_by_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n-    \"patnodesinrels_aspatid_r_pats\" FOREIGN KEY (site_id, as_pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     \"postacs_createdby_r_people\" FOREIGN KEY (site_id, from_pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     \"postacs_deletedby_r_people\" FOREIGN KEY (site_id, deleted_by_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n     \"postacs_r_posts\" FOREIGN KEY (site_id, to_post_id_c) REFERENCES posts3(site_id, unique_post_id) DEFERRABLE"
    },
    {
      "sha": "1b3ea9781d4bbfa2f7c4a0da261164e54024e9d3",
      "filename": "docs/db-schema/posts3.txt",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fposts3.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fposts3.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2Fposts3.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -65,10 +65,12 @@\n  index_prio_c             | index_prio_d                |           |          | \n  private_status_c         | private_status_d            |           |          | \n  creator_status_c         | creator_status_d            |           |          | \n+ order_c                  | f32_d                       |           |          | \n Indexes:\n     \"dw2_posts_id__p\" PRIMARY KEY, btree (site_id, unique_post_id)\n     \"dw2_posts_page_postnr__u\" UNIQUE, btree (site_id, page_id, post_nr)\n     \"posts_u_extid\" UNIQUE, btree (site_id, ext_id)\n+    \"posts_u_patid_pageid_parentnr_if_bookmark_0deld\" UNIQUE, btree (site_id, created_by_id, page_id, parent_nr) WHERE type::smallint = 51 AND deleted_status = 0\n     \"dw2_posts_approvedbyid__i\" btree (site_id, approved_by_id) WHERE approved_by_id IS NOT NULL\n     \"dw2_posts_closedbyid__i\" btree (site_id, closed_by_id) WHERE closed_by_id IS NOT NULL\n     \"dw2_posts_collapsedbyid__i\" btree (site_id, collapsed_by_id) WHERE collapsed_by_id IS NOT NULL\n@@ -84,6 +86,8 @@ Indexes:\n     \"posts_i_createdat_id\" btree (site_id, created_at DESC, unique_post_id DESC)\n     \"posts_i_createdby_createdat_id\" btree (site_id, created_by_id, created_at DESC, unique_post_id DESC)\n     \"posts_i_lastapprovedat_0deld\" btree (site_id, GREATEST(approved_at, last_approved_edit_at)) WHERE approved_at IS NOT NULL AND deleted_status = 0\n+    \"posts_i_patid_createdat_postid_if_bookmark_0deld\" btree (site_id, created_by_id, created_at, unique_post_id) WHERE type::smallint = 51 AND deleted_status = 0\n+    \"posts_i_patid_createdat_postid_if_bookmark_deld\" btree (site_id, created_by_id, created_at, unique_post_id) WHERE type::smallint = 51 AND deleted_status <> 0\n     \"posts_i_privatepatsid\" btree (site_id, private_pats_id_c) WHERE private_pats_id_c IS NOT NULL\n Check constraints:\n     \"dw2_posts__c_approved\" CHECK ((approved_rev_nr IS NULL) = (approved_at IS NULL) AND (approved_rev_nr IS NULL) = (approved_by_id IS NULL) AND (approved_rev_nr IS NULL) = (approved_source IS NULL))\n@@ -111,11 +115,15 @@ Check constraints:\n     \"dw2_posts_multireply__c_num\" CHECK (multireply::text ~ '^([0-9]+,)*[0-9]+$'::text)\n     \"dw2_posts_parent__c_not_title\" CHECK (parent_nr <> 0)\n     \"posts__c_first_rev_by_creator\" CHECK (curr_rev_by_id = created_by_id OR curr_rev_nr > 1)\n+    \"posts_c_bookmark_neg_nr\" CHECK (type::smallint <> 51 OR post_nr <= '-1001'::integer)\n+    \"posts_c_bookmark_not_appr\" CHECK (type::smallint <> 51 OR approved_at IS NULL)\n     \"posts_c_currevnr_not_for_imp\" CHECK (curr_rev_nr < 2000000000)\n     \"posts_c_extid_ok\" CHECK (is_valid_ext_id(ext_id))\n     \"posts_c_id_not_for_imp\" CHECK (unique_post_id < 2000000000)\n     \"posts_c_nr_not_for_imp\" CHECK (post_nr < 2000000000)\n+    \"posts_c_order_only_bookmarks_for_now\" CHECK (order_c IS NULL OR type::smallint = 51)\n     \"posts_c_parentnr_not_for_imp\" CHECK (parent_nr < 2000000000)\n+    \"posts_c_privatecomt_neg_nr\" CHECK (private_status_c IS NULL OR post_nr <= '-1001'::integer)\n Foreign-key constraints:\n     \"posts_approvedby_r_people\" FOREIGN KEY (site_id, approved_by_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n     \"posts_closedby_r_people\" FOREIGN KEY (site_id, closed_by_id) REFERENCES users3(site_id, user_id) DEFERRABLE"
    },
    {
      "sha": "66aa9f67c0a04545efec1a7112c2efe3bc72b4e8",
      "filename": "docs/db-schema/settings3.txt",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fsettings3.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fsettings3.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2Fsettings3.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -130,6 +130,8 @@\n  ai_conf_c                             | jsonb_ste16000_d        |           |          | \n  enable_online_status_c                | boolean                 |           |          | \n  follow_links_to_c                     | text_nonempty_ste2000_d |           |          | \n+ own_domains_c                         | text_nonempty_ste2000_d |           |          | \n+ authn_diag_conf_c                     | jsonb_ste8000_d         |           |          | \n Indexes:\n     \"settings3_site_category\" UNIQUE, btree (site_id, category_id) WHERE category_id IS NOT NULL\n     \"settings3_site_page\" UNIQUE, btree (site_id, page_id) WHERE page_id IS NOT NULL"
    },
    {
      "sha": "d4f5393703d2eedeb14b58fe960233f35e087cfd",
      "filename": "docs/db-schema/tags_t.txt",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Ftags_t.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Ftags_t.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2Ftags_t.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -14,7 +14,7 @@\n  val_url_c       | http_url_ste_250_d             |           |          | \n  val_jsonb_c     | jsonb_ste1000_d                |           |          | \n  val_i32_b_c     | i32_d                          |           |          | \n- val_f64_b_c     | i32_d                          |           |          | \n+ val_f64_b_c     | f64_d                          |           |          | \n Indexes:\n     \"tags_p_id\" PRIMARY KEY, btree (site_id_c, id_c)\n     \"tags_u_id_patid\" UNIQUE CONSTRAINT, btree (site_id_c, id_c, on_pat_id_c)"
    },
    {
      "sha": "272315f773dfc0886927f4a906e6660a6fb76c46",
      "filename": "docs/db-schema/users3.txt",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fusers3.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fdb-schema%2Fusers3.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdb-schema%2Fusers3.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -219,6 +219,8 @@ Referenced by:\n     TABLE \"links_t\" CONSTRAINT \"links_toppid_r_pps\" FOREIGN KEY (site_id_c, to_pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"notifications3\" CONSTRAINT \"notfs_aboutpat_r_pats\" FOREIGN KEY (site_id, about_pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"notifications3\" CONSTRAINT \"notfs_bypat_r_pats\" FOREIGN KEY (site_id, by_user_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n+    TABLE \"notifications3\" CONSTRAINT \"notfs_bytrueid_r_pats\" FOREIGN KEY (site_id, by_true_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n+    TABLE \"notifications3\" CONSTRAINT \"notfs_totrueid_r_pats\" FOREIGN KEY (site_id, to_true_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"notices_t\" CONSTRAINT \"notices_r_pats\" FOREIGN KEY (site_id_c, to_pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"notifications3\" CONSTRAINT \"ntfs_touser_r_people\" FOREIGN KEY (site_id, to_user_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"page_notf_prefs_t\" CONSTRAINT \"pagenotfprefs_r_people\" FOREIGN KEY (site_id, pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n@@ -244,8 +246,8 @@ Referenced by:\n     TABLE \"page_users3\" CONSTRAINT \"pageusers_joinedby_r_people\" FOREIGN KEY (site_id, joined_by_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"page_users3\" CONSTRAINT \"pageusers_kickedby_r_people\" FOREIGN KEY (site_id, kicked_by_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"page_users3\" CONSTRAINT \"pageusers_user_r_people\" FOREIGN KEY (site_id, user_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n+    TABLE \"post_actions3\" CONSTRAINT \"patnoderels_fromtrueid_r_pats\" FOREIGN KEY (site_id, from_true_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"post_actions3\" CONSTRAINT \"patnodesinrels_addedbyid_r_pats\" FOREIGN KEY (site_id, added_by_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n-    TABLE \"post_actions3\" CONSTRAINT \"patnodesinrels_aspatid_r_pats\" FOREIGN KEY (site_id, as_pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"users3\" CONSTRAINT \"pats_trueid_r_pats\" FOREIGN KEY (site_id, true_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"perms_on_pages3\" CONSTRAINT \"permsonpages_r_people\" FOREIGN KEY (site_id, for_people_id) REFERENCES users3(site_id, user_id) DEFERRABLE\n     TABLE \"post_actions3\" CONSTRAINT \"postacs_createdby_r_people\" FOREIGN KEY (site_id, from_pat_id_c) REFERENCES users3(site_id, user_id) DEFERRABLE"
    },
    {
      "sha": "8b8ff18b047d010eddf2e72180e19cc730bedbf4",
      "filename": "docs/maybe-do-later.txt",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fmaybe-do-later.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Fmaybe-do-later.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fmaybe-do-later.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -142,6 +142,7 @@ regardless of how they inherited permissions from other groups.\n \n [granular_perms]\n E.g. may-see-others'-sessions. Currently only amdins may, but sometimes, good if mods could too?\n+Also see: [wiki_perms]\n \n [tags]\n Nice props / tags in Gerrit: https://chromium-review.googlesource.com/c/v8/v8/+/2537690\n@@ -214,6 +215,7 @@ Can start at 21 = lightweight mod, 22 = mod, 23 = admin, 24 = owner?\n Should there be a move-page-perm, not just alter-page?\n \n [power_mod]\n+[power_users]\n \n [inherit_group_priv_prefs]\n One should inherit privacy and noise settings from one's closest trust level group,"
    },
    {
      "sha": "8bb5f2501f198c07137d255ce9b3e471959c972a",
      "filename": "docs/tests-map.txt",
      "status": "modified",
      "additions": 68,
      "deletions": 7,
      "changes": 75,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Ftests-map.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Ftests-map.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Ftests-map.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -298,22 +298,83 @@ anonymous comments,\n anons:\n   partly impl:\n             - tests/app/debiki/dao/AnonymAppSpec.scala\n+  Make work again, and code review:\n+            - tests/e2e-wdio7/specs/alias-anons-basic.2br.f.e2e.ts\n+            - tests/e2e-wdio7/specs/alias-anons-true-mixed.2br.f.e2e.ts\n   TESTS_MISSING:\n+            - See  ../wip/aliases/auto-test-thoughts.txt\n+            - Anon mode, send priv msg?\n+            - Callers of  checkAliasOrThrowForbidden() & getAliasOrTruePat() [misc_alias_tests]\n             - Anons for drafts, UNTSETED.\n             - Load anon drafts, restore as anon. TyTANONDFLOAD\n             - Cannot move anon post to other page.  TyTMOVANONCOMT\n             - Notfs from anons (comments, votes, more?), don't include real user name  TyTNOTFFROMANON\n-            - UNTESTED; TESTS_MISSING // exp imp anons?  True ids are incl in json dumps?\n-            - Different anon statuses: Comts start anon / NeverAlways.AlwaysButCanContinue / etc\n+            - UNTESTED; TESTS_MISSING // exp imp anons?\n+                  True ids are incl in json dumps? [export_privid]\n+            - Can't vote many times using different personas TyTALIVOTES\n+            - Reuse anons: At most one per page & person [one_anon_per_page].\n+                Verify cannot create many, by opening many browser tabs\n+                & posting one anon comment in each?\n             - Edit & update the draft.  TyTEDUPDDFT04\n             - Save anon draft, reuse an anon.  TyTDFTREUSEANON.\n+            - Save draft using the wrong alias —  should work, but needs to choose an\n+                    ok alias before actually posting (not just saving a draft).\n+                - When editing own post  TyTDRAFTALI\n+                - When editing sbd else's post\n             - Edit comment as anon: Anon name in new edit revision, & email notfs. TyTANONEDIT\n             - Post pages as anon\n-            - Accept/unaccept answer\n-            - Close/reopen page\n-            - Delete/undelete own page\n-            - Rename page\n-            - Change page status   PageTitleSettingsController\n+            - Post page as anon,\n+                    edit as self\n+                    alter as self\n+            - Post page as self\n+                    edit as anon\n+                    alter as anon\n+            - Post comment as anon\n+                    edit as self\n+                    alter as self\n+            - Post comment as self\n+                    edit as anon\n+                    alter as anon\n+            - Change own anon post to wiki & back\n+                 others' not/anon post to wiki & back as anon / not-anon oneself\n+            - Edit other's page text\n+            - Alter other's page  TyTALIALTERPG,  PageTitleSettingsController\n+            - Alter =   \n+                - Accept/unaccept answer\n+                - Close/reopen page\n+                - Delete/undelete own anon page\n+                - Delete/undelete own anon comment\n+                - Rename page\n+                - Change page type, doing status, answer\n+                - Move to other category, where:\n+                    - Alias allowed\n+                    - Alias not allowed\n+            - Start composing new topic, change to/from anon cat, see Post As ...\n+              appear/disappear, and \"You cannot be anonymous ...\" etc info diags pop up.\n+            - Reply to oneself on anon-rec page where's been anon elsewhere —> self, etc\n+            - Reply anonly, go to sbd's profile page, compose priv msg: Should become oneself\n+            - Anon-by-def page, start composig a reply (as anon), cancel, go to sbd's profile page,\n+                  compose priv msg: Should now post as oneself (not anon any more).\n+            - Edit history: Proper names (e.g. Anon, not one's true name) shown?\n+                - Comments\n+                - Page title\n+                - Orig post\n+            - Different anon statuses: Comts start anon / NeverAlways.AlwaysButCanContinue / etc\n+            - Page with both Perm Anon and Temp Anon comments: [dif_anon_status]\n+                - Like-vote OP, gets to choose: Perm Anon or Temp Anon, or Self\n+                - Temp Anon in temp anon sub thread\n+                - Perm Anon in perm anon sub thread\n+            - Can't move anon comments to other pages\n+            - Persona indicator updated properly when: (lots of combinations!)\n+                starting on anon never / allowed / recommened / always page,\n+                  - navigating to anon recommended cat, then to not-anon\n+                  - navigating to not-anon cat, then recommended cat, then not-anon\n+                  back to anon / not-anon page\n+            - Anon posts enabled\n+                - tests/app/debiki/dao/AnonymAppSpec.scala  TyTANON0ENBL TyEM0MKANON_\n+                - in one cat, not in another\n+                - in sub cat\n+                - on specific page\n             - ... and more\n \n different users -"
    },
    {
      "sha": "d8f28fc9dfb5683c57ea8bcf2f9bf0d4ddde1910",
      "filename": "docs/tyworld.adoc",
      "status": "modified",
      "additions": 19,
      "deletions": 5,
      "changes": 24,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Ftyworld.adoc",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/docs%2Ftyworld.adoc",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Ftyworld.adoc?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -138,14 +138,23 @@ A new post gets a new id and can work as the new id for a new flag of the same t\n \n == Anonyms and Pseudonyms\n \n+Also see: ../wip/aliases/wip.txt. This section here in tyworld.adoc is out-of-date!\n+\n === Anonyms posts\n \n When you anonymously, then, a new anonym (anonymous user) is created, for you,\n-to use on that particular page. You can't use it outside that page\n+to use in the current discussion, on that specific page. You can't use it outside that page\n (instead, another then gets created).  Anon comments cannot be moved to\n other pages, and aren't visible to others (only to yourself) in the activity\n list on your user profile page, or in your posts counts. [list_anon_posts]\n \n+Currently, you can have only one anonym persona per page [one_anon_per_page].\n+(Actually, you can have more, if someone moves the page between categories that use\n+different types of anonyms (temporary anonyms or permanent anonyms), and you post\n+anonymous comments of each type. In such cases, you can have one anonym\n+per page and anonym type (`AnonStatus`))  It'd be confusing if people could create many\n+anonymous users and pretend to be many people, in a single discussion.\n+\n The software remembers if you want to be anonymous or not, per\n discussion page, by looking at your previous comments in that discussion\n and sub thread you're replying in — because maybe you're using using your\n@@ -169,10 +178,11 @@ Categories can be 1) always-anonymous, or 2) anon by default, or\n 3) real account by default but anon posts allowed. Or 4) anon posts\n not allowed (only real accounts). Edit: See `[NeverAlways]`.\n \n-A category can be configured to get _de-anonymized_ after a while (!).\n-That is, say two weeks after a new page has been posted in that category,\n-the real usernames are shown so everyone can see who wrote what.\n-\n+Not implemented: If, when enabling anonymity in a category, the admin selects\n+_Better ideas & decisions_ as the purpose (but not _Sensitive Discussions_), then,\n+the category can be configured to get _de-anonymized_ after a while (!).\n+For example, two weeks after a new page has been posted in that category,\n+the real usernames get shown so everyone can see who wrote what.\n In such categories, before posting, there's an obtrusive info box about this,\n so everyone will know how it works.\n \n@@ -209,8 +219,12 @@ your pseudonym's comments surprisingly often or infrequently — then, your pseu\n could get a different reputation than your main account. Although you're\n the same person.  `[pseudonyms_trust]`\n \n+Possibly, there'll be different types of pseudonyms. See\n+../wip/aliases/wip.txt [pseudonym_types].\n+\n === Tech notes\n \n+Not impl, and this'll change:\n Implementation wise, to show notifications from all one's pseudonyms,\n Talkyard does one lookup per pseudonym. So that's why you cannot\n have hundereds of pseudonyms (because then this'd be slow)."
    },
    {
      "sha": "9b9f590da473869c6bb9336b1226eaad545c23bc",
      "filename": "relchans/tyse-v0-dev",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": null,
      "raw_url": null,
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/relchans%2Ftyse-v0-dev?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1 +1 @@\n-Subproject commit 95021685184b96db8ebcca93f8b7e42dbf0547b2\n+Subproject commit 9b9f590da473869c6bb9336b1226eaad545c23bc"
    },
    {
      "sha": "56d41d66983342f446c2b9cdcd45fec78a8f2216",
      "filename": "s/run-e2e-tests.sh",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/s%2Frun-e2e-tests.sh",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/s%2Frun-e2e-tests.sh",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/s%2Frun-e2e-tests.sh?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -535,6 +535,13 @@ function runAllE2eTests {\n   $r s/wdio-7 --only may-see-email-adrs.2br.d --cd -i $args\n \n \n+  # Aliases (anonyms, pseudonyms)\n+  # ------------\n+\n+  #$r s/wdio-7 --only alias-anons-true-mixed.2br.f --cd -i $args\n+  #$r s/wdio-7 --only alias-anons-basic.2br.f --cd -i $args\n+\n+\n   # API\n   # ------------\n "
    },
    {
      "sha": "a46ff1ea191679a1c5331f8d4f3a4b8a07d6dd14",
      "filename": "tests/app/debiki/dao/AnonymAppSpec.scala",
      "status": "modified",
      "additions": 20,
      "deletions": 2,
      "changes": 22,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FAnonymAppSpec.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FAnonymAppSpec.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Fdebiki%2Fdao%2FAnonymAppSpec.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -74,12 +74,30 @@ class AnonymAppSpec extends DaoAppSuite(\n       userTwoS1 = createPasswordUser(\"mm33ww77\", site1.dao, trustLevel = TrustLevel.BasicMember)\n     }\n \n-    \"Try post anonymously — but anon posts are disabled, by default\" in {\n+    \"Try post anonymously — but anon posts not enabled, request rejected  TyTANON0ENBL\" in {\n+      val dao = site1.dao\n+      val ex = intercept[ResultException] {\n+        createPage2(PageType.Discussion, dao.textAndHtmlMaker.forTitle(\"Anon Test\"),\n+            bodyTextAndHtml = dao.textAndHtmlMaker.forBodyOrComment(\"Test anon post.\"),\n+            authorId = userOneS1.id, browserIdData, dao, anyCategoryId = Some(catA.id),\n+            asAlias = Some(WhichAliasPat.LazyCreatedAnon(AnonStatus.IsAnonOnlySelfCanDeanon)))\n+      }\n+      ex.getMessage must include(\"TyEM0MKANON_\")\n+    }\n+\n+    \"Enable anon posts\" in {\n+      val dao = site1.dao\n+      editCategory(catA, createCatAResult.permissionsWithIds,\n+            browserIdData, dao,\n+            comtsStartAnon = Some(Some(NeverAlways.Recommended)))\n+    }\n+\n+    \"Try post anonymously — now anon posts are enabled\" in {\n       val dao = site1.dao\n       createPageResult = createPage2(PageType.Discussion, dao.textAndHtmlMaker.forTitle(\"Anon Test\"),\n             bodyTextAndHtml = dao.textAndHtmlMaker.forBodyOrComment(\"Test anon post.\"),\n             authorId = userOneS1.id, browserIdData, dao, anyCategoryId = Some(catA.id),\n-            doAsAnon = Some(WhichAnon.NewAnon(AnonStatus.IsAnonOnlySelfCanDeanon)))\n+            asAlias = Some(WhichAliasPat.LazyCreatedAnon(AnonStatus.IsAnonOnlySelfCanDeanon)))\n       pageId = createPageResult.id\n     }\n "
    },
    {
      "sha": "853c9e1785e3aaf1d453bc72abdf961d6ae844a0",
      "filename": "tests/app/debiki/dao/DaoAppSuite.scala",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FDaoAppSuite.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FDaoAppSuite.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Fdebiki%2Fdao%2FDaoAppSuite.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -348,19 +348,20 @@ class DaoAppSuite(\n   def editCategory(cat: Cat, permissions: ImmSeq[PermsOnPages],\n           browserIdData: BrowserIdData, dao: SiteDao,\n           newParentId: Opt[CatId] = None,\n-          newSectPageId: Opt[PageId] = None): Cat = {\n+          newSectPageId: Opt[PageId] = None,\n+          comtsStartAnon: Opt[Opt[NeverAlways]] = None,\n+          ): Cat = {\n     var catToSave = CategoryToSave.initFrom(cat)\n-    newParentId map { parCatId =>\n-      catToSave = catToSave.copy(parentId = parCatId)\n-    }\n-    newSectPageId map { sectPageId =>\n-      catToSave = catToSave.copy(sectionPageId = sectPageId)\n-    }\n+    catToSave = catToSave.copy(\n+          parentId = newParentId.getOrElse(catToSave.parentId),\n+          sectionPageId = newSectPageId.getOrElse(catToSave.sectionPageId),\n+          comtsStartAnon = comtsStartAnon.getOrElse(catToSave.comtsStartAnon),\n+          )\n     dao.editCategory(catToSave, permissions, who = Who.System)\n   }\n \n \n-  REMOVE; CLEAN_UP // use createPage2 instead, and rename it to createPage().\n+  REMOVE; CLEAN_UP // use createPageSkipAuZ instead, and rename it to createPage().\n   def createPage(pageRole: PageType, titleTextAndHtml: TitleSourceAndHtml,\n         bodyTextAndHtml: TextAndHtml, authorId: UserId, browserIdData: BrowserIdData,\n         dao: SiteDao, anyCategoryId: Option[CategoryId] = None,\n@@ -374,15 +375,14 @@ class DaoAppSuite(\n   def createPage2(pageRole: PageType, titleTextAndHtml: TitleSourceAndHtml,\n         bodyTextAndHtml: TextAndHtml, authorId: UserId, browserIdData: BrowserIdData,\n         dao: SiteDao, anyCategoryId: Option[CategoryId] = None,\n-        doAsAnon: Opt[WhichAnon.NewAnon] = None,\n+        asAlias: Opt[WhichAliasPat.LazyCreatedAnon] = None,\n         extId: Option[ExtId] = None, discussionIds: Set[AltPageId] = Set.empty): CreatePageResult = {\n-    dao.createPage2(\n+    dao.createPageSkipAuZ(\n       pageRole, PageStatus.Published, anyCategoryId = anyCategoryId, withTags = Nil,\n       anyFolder = Some(\"/\"), anySlug = Some(\"\"),\n       title = titleTextAndHtml, bodyTextAndHtml = bodyTextAndHtml,\n       showId = true, deleteDraftNr = None, Who(authorId, browserIdData), dummySpamRelReqStuff,\n-      doAsAnon = doAsAnon,\n-      discussionIds = discussionIds, extId = extId)\n+      asAlias = asAlias, discussionIds = discussionIds, extId = extId)\n   }\n \n \n@@ -391,7 +391,7 @@ class DaoAppSuite(\n     val textAndHtml =\n       if (skipNashorn) textAndHtmlMaker.testBody(text)\n       else textAndHtmlMaker.forBodyOrComment(text)\n-    dao.insertReply(textAndHtml, pageId,\n+    dao.insertReplySkipAuZ(textAndHtml, pageId,\n       replyToPostNrs = Set(parentNr getOrElse PageParts.BodyNr), PostType.Normal, deleteDraftNr = None,\n       Who(TrueId(memberId), browserIdData), dummySpamRelReqStuff).post\n   }"
    },
    {
      "sha": "a93466680846f1e2e1aba012856c2d01da7132fc",
      "filename": "tests/app/debiki/dao/DeletePageAppSpec.scala",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FDeletePageAppSpec.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FDeletePageAppSpec.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Fdebiki%2Fdao%2FDeletePageAppSpec.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -56,7 +56,7 @@ class DeletePageAppSpec extends DaoAppSuite(disableScripts = true, disableBackgr\n \n       // Delete all pages.\n       dao.deletePagesIfAuth(Seq(discussionId, forumId, htmlPageId),\n-            Who(admin.trueId2, browserIdData), undelete = false)\n+            Who(admin.trueId2, browserIdData), asAlias = None, undelete = false)\n \n       // Verify marked as deleted.\n       dao.getPageMeta(discussionId).get.deletedAt mustBe defined\n@@ -66,7 +66,7 @@ class DeletePageAppSpec extends DaoAppSuite(disableScripts = true, disableBackgr\n \n       // Undelete, verify no longer marked as deleted.\n       dao.deletePagesIfAuth(Seq(discussionId, forumId, htmlPageId),\n-            Who(admin.trueId2, browserIdData), undelete = true)\n+            Who(admin.trueId2, browserIdData), asAlias = None, undelete = true)\n       dao.getPageMeta(discussionId).get.deletedAt mustBe None\n       dao.getPageMeta(forumId).get.deletedAt mustBe None\n       dao.getPageMeta(htmlPageId).get.deletedAt mustBe None\n@@ -79,7 +79,7 @@ class DeletePageAppSpec extends DaoAppSuite(disableScripts = true, disableBackgr\n       for (pageId <- Seq(discussionId, htmlPageId, otherPageId)) {\n         intercept[ResultException] {\n           dao.deletePagesIfAuth(\n-                Seq(pageId), Who(moderator.trueId2, browserIdData), undelete = false)\n+                Seq(pageId), Who(moderator.trueId2, browserIdData), None, undelete = false)\n           dao.getPageMeta(discussionId).get.deletedAt mustBe defined\n         }.getMessage must include(\"TyEM0SEEPG_\")\n       }\n@@ -90,7 +90,7 @@ class DeletePageAppSpec extends DaoAppSuite(disableScripts = true, disableBackgr\n     \"non-staff also may not delete pages they cannot see\" in {\n       intercept[ResultException] {\n         dao.deletePagesIfAuth(\n-              Seq(discussionId), Who(user.trueId2, browserIdData), undelete = false)\n+              Seq(discussionId), Who(user.trueId2, browserIdData), None, undelete = false)\n       }.getMessage must include(\"TyEM0SEEPG_\")\n     }\n \n@@ -113,49 +113,50 @@ class DeletePageAppSpec extends DaoAppSuite(disableScripts = true, disableBackgr\n     \"now mods can delete discussions — they may now see them\" - {\n       \"delete page\" in {\n         dao.deletePagesIfAuth(\n-              Seq(discussionId), Who(moderator.trueId2, browserIdData), undelete = false)\n+              Seq(discussionId), Who(moderator.trueId2, browserIdData), None, undelete = false)\n         dao.getPageMeta(discussionId).get.deletedAt mustBe defined\n       }\n \n       \"undelete page\" in {\n         dao.deletePagesIfAuth(\n-              Seq(discussionId), Who(moderator.trueId2, browserIdData), undelete = true)\n+              Seq(discussionId), Who(moderator.trueId2, browserIdData), None, undelete = true)\n         dao.getPageMeta(discussionId).get.deletedAt mustBe None\n       }\n \n       \"still cannot delete the *other* page, it's still not in the forum\" in {\n         intercept[ResultException] {\n           dao.deletePagesIfAuth(\n-                Seq(otherPageId), Who(moderator.trueId2, browserIdData), undelete = false)\n+                Seq(otherPageId), Who(moderator.trueId2, browserIdData), None, undelete = false)\n         }.getMessage must include(\"TyEM0SEEPG_\")\n       }\n \n       \"cannot delete forum\" in {\n         intercept[ResultException] {\n           dao.deletePagesIfAuth(\n-                Seq(forumId), Who(moderator.trueId2, browserIdData), undelete = false)\n+                Seq(forumId), Who(moderator.trueId2, browserIdData), None, undelete = false)\n         }.getMessage must include(\"EsE5GKF23_\")\n       }\n \n       \"cannot delete custom html page\" in {\n         intercept[ResultException] {\n           dao.deletePagesIfAuth(\n-                Seq(htmlPageId), Who(moderator.trueId2, browserIdData), undelete = false)\n+                Seq(htmlPageId), Who(moderator.trueId2, browserIdData), None, undelete = false)\n         }.getMessage must include(\"EsE5GKF23_\")\n       }\n     }\n \n     \"do nothing if page doesn't exist\" in {\n       val admin = createPasswordOwner(s\"dltr_adm2\", dao)\n       val badPageId = \"zzwwffpp\"\n-      dao.deletePagesIfAuth(Seq(badPageId), Who(admin.trueId2, browserIdData), undelete = false)\n+      dao.deletePagesIfAuth(\n+            Seq(badPageId), Who(admin.trueId2, browserIdData), None, undelete = false)\n       dao.getPageMeta(badPageId) mustBe None\n     }\n \n     \"non-staff users still cannot see the pages — they're in the staff cat\" in {\n       intercept[ResultException] {\n         dao.deletePagesIfAuth(\n-              Seq(discussionId), Who(user.trueId2, browserIdData), undelete = false)\n+              Seq(discussionId), Who(user.trueId2, browserIdData), None, undelete = false)\n       }.getMessage must include(\"TyEM0SEEPG_\")\n     }\n \n@@ -166,7 +167,7 @@ class DeletePageAppSpec extends DaoAppSuite(disableScripts = true, disableBackgr\n     \"non-staff can now see it — but still may not delete it\" in {\n       intercept[ResultException] {\n         dao.deletePagesIfAuth(\n-              Seq(discussionId), Who(user.trueId2, browserIdData), undelete = false)\n+              Seq(discussionId), Who(user.trueId2, browserIdData), None, undelete = false)\n       }.getMessage must include(\"TyEDELOTRSPG_\")\n     }\n "
    },
    {
      "sha": "90b1f7af5e70e4d53a0d3a6ad48c8ca904fbed30",
      "filename": "tests/app/debiki/dao/DraftsDaoAppSpec.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FDraftsDaoAppSpec.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FDraftsDaoAppSpec.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Fdebiki%2Fdao%2FDraftsDaoAppSpec.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -416,7 +416,7 @@ class DraftsDaoAppSpec extends DaoAppSuite(disableScripts = true, disableBackgro\n             createdAt = now,\n             forWhat = locator,\n             postType = Some(PostType.Normal),\n-            doAsAnon = Some(WhichAnon.NewAnon(AnonStatus.IsAnonCanAutoDeanon)),\n+            doAsAnon = Some(WhichAliasId.LazyCreatedAnon(AnonStatus.IsAnonCanAutoDeanon)),\n             title = \"\",\n             text = DraftSixAnonReplyText)\n "
    },
    {
      "sha": "3f28a1e0f932b932e30077ec95e1434c0ab7b2ef",
      "filename": "tests/app/debiki/dao/MovePostsAppSpec.scala",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FMovePostsAppSpec.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FMovePostsAppSpec.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Fdebiki%2Fdao%2FMovePostsAppSpec.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -188,7 +188,7 @@ class MovePostsAppSpec extends DaoAppSuite(disableScripts = true, disableBackgro\n \n       val pageTwoId = createPage(PageType.Discussion, textAndHtmlMaker.testTitle(\"Page Two\"),\n         textAndHtmlMaker.testBody(\"Body two.\"), SystemUserId, browserIdData, dao)\n-      val postOnPageTwo = dao.insertReply(textAndHtmlMaker.testBody(\"Post on page 2.\"), pageTwoId,\n+      val postOnPageTwo = dao.insertReplySkipAuZ(textAndHtmlMaker.testBody(\"Post on page 2.\"), pageTwoId,\n         replyToPostNrs = Set(PageParts.BodyNr), PostType.Normal, deleteDraftNr = None,\n         Who(SystemUserId, browserIdData = browserIdData), dummySpamRelReqStuff).post\n \n@@ -256,7 +256,7 @@ class MovePostsAppSpec extends DaoAppSuite(disableScripts = true, disableBackgro\n \n       val pageTwoId = createPage(PageType.Discussion, textAndHtmlMaker.testTitle(\"Page Two\"),\n         textAndHtmlMaker.testBody(\"Body two.\"), SystemUserId, browserIdData, dao)\n-      val postOnPageTwo = dao.insertReply(textAndHtmlMaker.testBody(\"Post on page 2.\"), pageTwoId,\n+      val postOnPageTwo = dao.insertReplySkipAuZ(textAndHtmlMaker.testBody(\"Post on page 2.\"), pageTwoId,\n         replyToPostNrs = Set(PageParts.BodyNr), PostType.Normal, deleteDraftNr = None,\n         Who(SystemUserId, browserIdData = browserIdData), dummySpamRelReqStuff).post\n \n@@ -299,7 +299,7 @@ class MovePostsAppSpec extends DaoAppSuite(disableScripts = true, disableBackgro\n       lastReplyOrigPage.nr mustBe (otherPost.nr + 1)\n \n       info(\"can add replies to the new page\")\n-      val lastPostPageTwo = dao.insertReply(textAndHtmlMaker.testBody(\"Last post, page 2.\"), pageTwoId,\n+      val lastPostPageTwo = dao.insertReplySkipAuZ(textAndHtmlMaker.testBody(\"Last post, page 2.\"), pageTwoId,\n         replyToPostNrs = Set(maxNewNr), PostType.Normal, deleteDraftNr = None,\n         Who(SystemUserId, browserIdData),\n         dummySpamRelReqStuff).post\n@@ -316,7 +316,7 @@ class MovePostsAppSpec extends DaoAppSuite(disableScripts = true, disableBackgro\n \n       val pageTwoId = createPage(PageType.Discussion, textAndHtmlMaker.testTitle(\"Page Two\"),\n         textAndHtmlMaker.testBody(\"Body two.\"), SystemUserId, browserIdData, dao)\n-      val postOnPageTwo = dao.insertReply(textAndHtmlMaker.testBody(\"Post on page 2.\"), pageTwoId,\n+      val postOnPageTwo = dao.insertReplySkipAuZ(textAndHtmlMaker.testBody(\"Post on page 2.\"), pageTwoId,\n         replyToPostNrs = Set(PageParts.BodyNr), PostType.Normal, deleteDraftNr = None,\n         Who(SystemUserId, browserIdData = browserIdData), dummySpamRelReqStuff).post\n "
    },
    {
      "sha": "73577cd785e1f9d1e1b65b339f319eaee256b45e",
      "filename": "tests/app/debiki/dao/ReviewStuffAppSuite.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FReviewStuffAppSuite.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Fdebiki%2Fdao%2FReviewStuffAppSuite.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Fdebiki%2Fdao%2FReviewStuffAppSuite.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -57,7 +57,7 @@ class ReviewStuffAppSuite(randomString: String)\n \n     def testAdminsRepliesApproved(adminId: UserId, pageId: PageId) {\n       for (i <- 1 to 10) {\n-        val result = dao.insertReply(textAndHtmlMaker.testBody(s\"reply_9032372 $r, i = $i\"), pageId,\n+        val result = dao.insertReplySkipAuZ(textAndHtmlMaker.testBody(s\"reply_9032372 $r, i = $i\"), pageId,\n           replyToPostNrs = Set(PageParts.BodyNr), PostType.Normal, deleteDraftNr = None,\n           Who(adminId, browserIdData), dummySpamRelReqStuff)\n         result.post.isCurrentVersionApproved mustBe true\n@@ -66,7 +66,7 @@ class ReviewStuffAppSuite(randomString: String)\n     }\n \n     def reply(memberId: UserId, text: String): InsertPostResult = {\n-      dao.insertReply(textAndHtmlMaker.testBody(text), thePageId,\n+      dao.insertReplySkipAuZ(textAndHtmlMaker.testBody(text), thePageId,\n         replyToPostNrs = Set(PageParts.BodyNr), PostType.Normal, deleteDraftNr = None,\n         Who(memberId, browserIdData), dummySpamRelReqStuff)\n     }"
    },
    {
      "sha": "382c314735bde5ca8941286518030c63ede4dd64",
      "filename": "tests/app/talkyard/server/links/LinksAppSpec.scala",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Ftalkyard%2Fserver%2Flinks%2FLinksAppSpec.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fapp%2Ftalkyard%2Fserver%2Flinks%2FLinksAppSpec.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Ftalkyard%2Fserver%2Flinks%2FLinksAppSpec.scala?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -401,7 +401,7 @@ class LinksAppSpec extends DaoAppSuite {\n     \"Links from deleted *pages* are ignored  TyT7RD3LM5\" - {\n       \"Delete page A\".inWriteTx(daoSite1) { (tx, staleStuff) =>\n         daoSite1.deletePagesImpl(\n-              Seq(pageA.id), systemWho)(tx, staleStuff)\n+              Seq(pageA.id), systemWho, asAlias = None)(tx, staleStuff)\n       }\n \n       \"Now only pages B, C and D links to Z\".inReadTx(daoSite1) { tx =>\n@@ -433,7 +433,7 @@ class LinksAppSpec extends DaoAppSuite {\n \n     \"Undelete page A\".inWriteTx(daoSite1) { (tx, staleStuff) =>\n       daoSite1.deletePagesImpl(\n-            Seq(pageA.id), systemWho, undelete = true)(tx, staleStuff)\n+            Seq(pageA.id), systemWho, asAlias = None, undelete = true)(tx, staleStuff)\n     }\n \n     \"Undelete category\".inWriteTx(daoSite1) { (tx, staleStuff) =>\n@@ -467,7 +467,7 @@ class LinksAppSpec extends DaoAppSuite {\n \n     \"Delete page Z\".inWriteTx(daoSite1) { (tx, staleStuff) =>\n       daoSite1.deletePagesImpl(\n-            Seq(pageZ.id), systemWho, undelete = true)(tx, staleStuff)\n+            Seq(pageZ.id), systemWho, asAlias = None, undelete = true)(tx, staleStuff)\n     }\n \n     \"Can find links to deleted page Z\".inReadTx(daoSite1) { tx =>"
    },
    {
      "sha": "fb14c395a1278e5a705b15446ef2e902c64537c1",
      "filename": "tests/e2e-wdio7/package.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fpackage.json",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fpackage.json",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fpackage.json?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -14,7 +14,7 @@\n     \"@wdio/spec-reporter\": \"^7.20.3\",\n     \"@wdio/types\": \"^7.20.3\",\n     \"axios\": \"^0.26.1\",\n-    \"chromedriver\": \"^126.0.3\",\n+    \"chromedriver\": \"^128.0.0\",\n     \"paseto.js\": \"^0.1.7\",\n     \"ts-node\": \"^10.9.1\",\n     \"wdio-chromedriver-service\": \"^7.3.2\""
    },
    {
      "sha": "d0bbbc52abb3a738feef1ac529801390b0e0cacf",
      "filename": "tests/e2e-wdio7/specs/page-type-problem-statuses.2br.d.e2e.ts",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fspecs%2Fpage-type-problem-statuses.2br.d.e2e.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fspecs%2Fpage-type-problem-statuses.2br.d.e2e.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fspecs%2Fpage-type-problem-statuses.2br.d.e2e.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -28,7 +28,7 @@ const mariasOpReplyReply = 'mariasOpReplyReply';\n \n // .Last_status_change post nr will be 5, and the first answer will be 5 + 1:\n const okaySolutionPostNr = 6;\n-const optimalSolutionPostNr = 7;\n+const optimalSolutionPostNr = 6 + 2;\n \n describe(\"page-type-problem-statuses.2br.d  TyT602AKK73\", () => {\n \n@@ -139,10 +139,13 @@ describe(\"page-type-problem-statuses.2br.d  TyT602AKK73\", () => {\n   });\n \n   it(`But Maria can — it's her page. She selects her comment as the solution`, async () => {\n+    // Generates meta comment nr = okaySolutionPostNr + 1: \"@maria accepted an answer\"\n     await mariasBrowser.topic.selectPostNrAsAnswer(okaySolutionPostNr);\n   });\n \n   it(`Maria posts an even better solution`, async () => {\n+    // Becomes nr = okaySolutionPostNr + 2.\n+    assert.eq(optimalSolutionPostNr, okaySolutionPostNr + 2);\n     await mariasBrowser.complex.replyToOrigPost(`Do it three times`)\n   });\n \n@@ -188,7 +191,6 @@ describe(\"page-type-problem-statuses.2br.d  TyT602AKK73\", () => {\n   });\n \n   it(`Corax, wisely, selects as solution Maria's best comment  TyTCORECAN`, async () => {\n-    assert.eq(optimalSolutionPostNr, okaySolutionPostNr + 1);\n     await corax_brB.topic.selectPostNrAsAnswer(optimalSolutionPostNr);\n   });\n "
    },
    {
      "sha": "1eed088f233a75a0d355c03c2bc55d2db09025d5",
      "filename": "tests/e2e-wdio7/specs/page-type-question-closed.2br.d.e2e.ts",
      "status": "modified",
      "additions": 51,
      "deletions": 26,
      "changes": 77,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fspecs%2Fpage-type-question-closed.2br.d.e2e.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fspecs%2Fpage-type-question-closed.2br.d.e2e.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fspecs%2Fpage-type-question-closed.2br.d.e2e.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -27,8 +27,9 @@ let mariasTopicUrl: string;\n \n const catAnserNr = c.FirstReplyNr;\n const otterAnserNr = c.SecondReplyNr;\n-const closeEventPostNr = 4;\n-const reopenEventPostNr = 7;\n+const selectAnswerPostNr = 4;\n+const closeEventPostNr = selectAnswerPostNr + 6;  // = 10\n+const reopenEventPostNr = closeEventPostNr + 3;   // = 13\n \n \n describe(`page-type-question-closed.2br.d  TyTPATYQUESTCLOSD`, () => {\n@@ -91,20 +92,21 @@ describe(`page-type-question-closed.2br.d  TyTPATYQUESTCLOSD`, () => {\n     await mariasBrowser.refresh2();\n     await mariasBrowser.topic.waitForPostNrVisible(catAnserNr);\n     assert.ok(await mariasBrowser.topic.canSelectAnswer()); // (2PR5PH)\n-    await mariasBrowser.topic.selectPostNrAsAnswer(2);   // a cat\n+    // Meta comment, nr 4 == selectAnswerPostNr\n+    await mariasBrowser.topic.selectPostNrAsAnswer(catAnserNr); // a cat\n   });\n \n   it(\"... unselects\", async () => {\n-    await mariasBrowser.topic.unselectPostNrAsAnswer(2); // no cat\n+    await mariasBrowser.topic.unselectPostNrAsAnswer(catAnserNr); // nr 5\n   });\n \n   it(\"... selects another\", async () => {\n-    await mariasBrowser.topic.selectPostNrAsAnswer(3);   // an otter\n+    await mariasBrowser.topic.selectPostNrAsAnswer(otterAnserNr); // nr 6\n   });\n \n   it(\"... unselects it, selects it again\", async () => {\n-    await mariasBrowser.topic.unselectPostNrAsAnswer(3);\n-    await mariasBrowser.topic.selectPostNrAsAnswer(3);\n+    await mariasBrowser.topic.unselectPostNrAsAnswer(otterAnserNr); // nr 7\n+    await mariasBrowser.topic.selectPostNrAsAnswer(otterAnserNr);   // nr 8\n   });\n \n   it(\"She can click the check mark icon next to the title, to view the answer\", async () => {\n@@ -118,8 +120,16 @@ describe(`page-type-question-closed.2br.d  TyTPATYQUESTCLOSD`, () => {\n     await owensBrowser.complex.loginWithPasswordViaTopbar(owen);\n   });\n \n+  it(\"... sees 5 select or unselect answer meta comments\", async () => {\n+    assert.that(await owensBrowser.topic.isPostNrVisible(selectAnswerPostNr));\n+    assert.that(await owensBrowser.topic.isPostNrVisible(selectAnswerPostNr + 1));\n+    assert.that(await owensBrowser.topic.isPostNrVisible(selectAnswerPostNr + 2));\n+    assert.that(await owensBrowser.topic.isPostNrVisible(selectAnswerPostNr + 3));\n+    assert.that(await owensBrowser.topic.isPostNrVisible(selectAnswerPostNr + 4));\n+  });\n+\n   it(\"... and unselects the answer\", async () => {\n-    await owensBrowser.topic.unselectPostNrAsAnswer(otterAnserNr);\n+    await owensBrowser.topic.unselectPostNrAsAnswer(otterAnserNr);  // nr 9\n   });\n \n   it(\"... and closes the topic\", async () => {\n@@ -130,54 +140,69 @@ describe(`page-type-question-closed.2br.d  TyTPATYQUESTCLOSD`, () => {\n   it(\"Maria wants to select Otter as answer again, but she cannot (page closed)\", async () => {\n     await mariasBrowser.topic.refreshUntilPostNrAppears(closeEventPostNr, { isMetaPost: true });\n     await mariasBrowser.topic.waitForPostNrVisible(c.FirstReplyNr);\n+    assert.not(await owensBrowser.topic.isPostNrVisible(closeEventPostNr + 1)); // ttt\n     assert.not(await mariasBrowser.topic.canSelectAnswer());  // (2PR5PH)\n   });\n \n   it(\"... instead she replies\", async () => {\n-    await mariasBrowser.complex.replyToPostNr(3, \"Thanks! Such a good idea\");  // becomes post nr 5\n+    await mariasBrowser.complex.replyToPostNr(otterAnserNr, \"Thanks! Such a good idea\"); // nr 11\n   });\n \n   it(\"... and post a progress reply\", async () => {\n-    await mariasBrowser.complex.addProgressReply(\"Thanks everyone! An otter then, a bath tube, and fish.\")\n+    await mariasBrowser.complex.addProgressReply(\n+          \"Thanks everyone! An otter then, a bath tube, and fish.\")  // nr 12\n   });\n \n   it(\"Owen reopens the topic\", async () => {\n     assert.not(await owensBrowser.topic.isPostNrVisible(reopenEventPostNr)); // ttt\n-    await owensBrowser.topic.reopenTopic();  // generates post nr 7 = reopenEventPostNr\n+    await owensBrowser.topic.reopenTopic();  // generates post nr `reopenEventPostNr` nr 13\n   });\n \n   it(\"Now Maria can select Otter — but oh no! She accidentally selects Cat\", async () => {\n     await mariasBrowser.refresh2();\n-    await mariasBrowser.topic.selectPostNrAsAnswer(catAnserNr);\n+    await mariasBrowser.topic.selectPostNrAsAnswer(catAnserNr); // nr 14\n   });\n \n   it(\"... Currently needs to refres for all posts to appear\", async () => {\n-    await mariasBrowser.topic.refreshUntilPostNrAppears(7, { isMetaPost: true });\n-    // There's no post nr 8 (accepting & unaccepting answers, don't currently\n-    // generate meta posts).\n-    assert.not(await owensBrowser.topic.isPostNrVisible(8)); // ttt\n+    await mariasBrowser.topic.refreshUntilPostNrAppears(reopenEventPostNr + 1, { isMetaPost: true });\n+    // There's no post nr `reopenEventPostNr + 2`.\n+    assert.not(await owensBrowser.topic.isPostNrVisible(reopenEventPostNr + 2)); // ttt\n   });\n \n   it(\"Everything is in the correct order\", async () => {\n     await mariasBrowser.topic.waitForPostAssertTextMatches(1, \"a cat or an otter?\");\n     await mariasBrowser.topic.assertPostTextMatches(2, \"Yes, a cat\");\n     await mariasBrowser.topic.assertPostTextMatches(3, \"Yes, an otter\");\n-    assert.eq(closeEventPostNr, 4);\n-    await mariasBrowser.topic.assertMetaPostTextMatches(4, \"closed\");\n-    await mariasBrowser.topic.assertPostTextMatches(5, \"good idea\");\n-    await mariasBrowser.topic.assertPostTextMatches(6, \"Thanks everyone!\");\n-    assert.eq(reopenEventPostNr, 7);\n-    await mariasBrowser.topic.assertMetaPostTextMatches(7, \"reopened\");\n \n+    await mariasBrowser.topic.assertMetaPostTextMatches(selectAnswerPostNr, /^accepted an answer/);\n+    await mariasBrowser.topic.assertMetaPostTextMatches(selectAnswerPostNr + 1, \"unaccepted an answer\");\n+    await mariasBrowser.topic.assertMetaPostTextMatches(closeEventPostNr, \"closed\");            // nr 10\n+    await mariasBrowser.topic.assertPostTextMatches(closeEventPostNr + 1, \"good idea\");         // nr 11\n+    await mariasBrowser.topic.assertPostTextMatches(closeEventPostNr + 2, \"Thanks everyone!\");  // nr 12\n+\n+    await mariasBrowser.topic.assertMetaPostTextMatches(reopenEventPostNr, \"reopened\");\n+  });\n+\n+  it(\"Everything is in the correct order\", async () => {\n     await mariasBrowser.topic.assertPostOrderIs([\n         c.TitleNr,\n         c.BodyNr,\n         2,   // cat\n         3,   // otter\n-        5,   //  `——— the \"Good idea\" reply\n-        4,   // the topic-closed event\n-        6,   // the \"Thanks everyone\" comment\n-        7]); // the topic-reopened event\n+       11,   //  `——— the \"Good idea\" reply\n+\n+        4,   // selects cat\n+        5,   // unselects\n+        6,   // selects otter\n+        7,   // unselects\n+        8,   // reselects\n+        9,   // Owen unselects\n+       10,   // Owen closes page\n+\n+       12,   // the \"Thanks everyone\" comment\n+       13,   // Owen reopens page\n+       14,   // Maria selects cat, accidentally\n+       ]);\n   });\n \n   it(\"Owen leaves, Corax arrives\", async () => {"
    },
    {
      "sha": "64bec67d9baacebf5171df172bcc8d026c373cdb",
      "filename": "tests/e2e-wdio7/utils/ty-e2e-test-browser.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Futils%2Fty-e2e-test-browser.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Futils%2Fty-e2e-test-browser.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Futils%2Fty-e2e-test-browser.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -3654,16 +3654,16 @@ export class TyE2eTestBrowser {\n \n         deletePage: async () => {\n           await this.waitAndClick('.dw-a-tools');\n-          await this.waitUntilDoesNotMove('.e_DelPg');\n-          await this.waitAndClick('.e_DelPg');\n+          await this.waitUntilDoesNotMove('.e_DelPgB');\n+          await this.waitAndClick('.e_DelPgB');\n           await this.waitUntilModalGone();\n           await this.topic.waitUntilPageDeleted();\n         },\n \n         restorePage: async () => {\n           await this.waitAndClick('.dw-a-tools');\n-          await this.waitUntilDoesNotMove('.e_RstrPg');\n-          await this.waitAndClick('.e_RstrPg');\n+          await this.waitUntilDoesNotMove('.e_UndelPgB');\n+          await this.waitAndClick('.e_UndelPgB');\n           await this.waitUntilModalGone();\n           await this.topic.waitUntilPageRestored();\n         },\n@@ -4921,7 +4921,7 @@ export class TyE2eTestBrowser {\n       },\n \n       editTitle: async (title: string) => {\n-        await this.waitAndSetValue('#e2eTitleInput', title);\n+        await this.waitAndSetValue('.c_TtlE_TtlI input', title);\n       },\n \n       save: async () => {\n@@ -6500,7 +6500,7 @@ export class TyE2eTestBrowser {\n         }\n       },\n \n-      assertMetaPostTextMatches: async (postNr: PostNr, text: St) => {\n+      assertMetaPostTextMatches: async (postNr: PostNr, text: St | RegExp) => {\n         await this.assertTextMatches(`#post-${postNr} .s_MP_Text`, text)\n       },\n "
    },
    {
      "sha": "ea7b9e43ab836d853702389476345a236b5cc31a",
      "filename": "tests/e2e-wdio7/yarn.lock",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fyarn.lock",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e-wdio7%2Fyarn.lock",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fyarn.lock?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -960,10 +960,10 @@ axios@^0.26.1:\n   dependencies:\n     follow-redirects \"^1.14.8\"\n \n-axios@^1.6.7:\n-  version \"1.6.8\"\n-  resolved \"https://registry.yarnpkg.com/axios/-/axios-1.6.8.tgz#66d294951f5d988a00e87a0ffb955316a619ea66\"\n-  integrity sha512-v/ZHtJDU39mDpyBoFVkETcd/uNdxrWRrg3bKpOKzXFA6Bvqopts6ALSMU3y6ijYxbw2B+wPrIv46egTzJXCLGQ==\n+axios@^1.7.4:\n+  version \"1.7.5\"\n+  resolved \"https://registry.yarnpkg.com/axios/-/axios-1.7.5.tgz#21eed340eb5daf47d29b6e002424b3e88c8c54b1\"\n+  integrity sha512-fZu86yCo+svH3uqJ/yTdQ0QHpQu5oL+/QE+QPSv6BZSkDAoky9vytxp7u5qk83OJFS3kEBcesWni9WTZAv3tSw==\n   dependencies:\n     follow-redirects \"^1.15.6\"\n     form-data \"^4.0.0\"\n@@ -1251,13 +1251,13 @@ chrome-launcher@^0.15.0:\n     is-wsl \"^2.2.0\"\n     lighthouse-logger \"^1.0.0\"\n \n-chromedriver@^126.0.3:\n-  version \"126.0.3\"\n-  resolved \"https://registry.yarnpkg.com/chromedriver/-/chromedriver-126.0.3.tgz#5c1c8f586b0832f00286391218a56460b2d605c5\"\n-  integrity sha512-4o+ZK8926/8lqIlnnvcljCHV88Z8IguEMB5PInOiS9/Lb6cyeZSj2Uvz+ky1Jgyw2Bn7qCLJFfbUslaWnvUUbg==\n+chromedriver@^128.0.0:\n+  version \"128.0.0\"\n+  resolved \"https://registry.yarnpkg.com/chromedriver/-/chromedriver-128.0.0.tgz#7f75a984101199e0bcc2c92fe9f91917fcd1f918\"\n+  integrity sha512-Ggo21z/dFQxTOTgU0vm0V59Mi79yyR+9AUk/KiVAsRfbDRdVZQYQWfgxnIvD/x8KOKn0oB7haRzDO/KfrKyvOA==\n   dependencies:\n     \"@testim/chrome-version\" \"^1.1.4\"\n-    axios \"^1.6.7\"\n+    axios \"^1.7.4\"\n     compare-versions \"^6.1.0\"\n     extract-zip \"^2.0.1\"\n     proxy-agent \"^6.4.0\""
    },
    {
      "sha": "143e2247e87d34daf8e65c8ab857dd90d52d486f",
      "filename": "tests/e2e/utils/pages-for.ts",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e%2Futils%2Fpages-for.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/tests%2Fe2e%2Futils%2Fpages-for.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e%2Futils%2Fpages-for.ts?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -3269,16 +3269,16 @@ export class TyE2eTestBrowser {\n \n         deletePage: () => {\n           this.waitAndClick('.dw-a-tools');\n-          this.waitUntilDoesNotMove('.e_DelPg');\n-          this.waitAndClick('.e_DelPg');\n+          this.waitUntilDoesNotMove('.e_DelPgB');\n+          this.waitAndClick('.e_DelPgB');\n           this.waitUntilModalGone();\n           this.topic.waitUntilPageDeleted();\n         },\n \n         restorePage: () => {\n           this.waitAndClick('.dw-a-tools');\n-          this.waitUntilDoesNotMove('.e_RstrPg');\n-          this.waitAndClick('.e_RstrPg');\n+          this.waitUntilDoesNotMove('.e_UndelPgB');\n+          this.waitAndClick('.e_UndelPgB');\n           this.waitUntilModalGone();\n           this.topic.waitUntilPageRestored();\n         },\n@@ -4376,7 +4376,7 @@ export class TyE2eTestBrowser {\n       },\n \n       editTitle: (title: string) => {\n-        this.waitAndSetValue('#e2eTitleInput', title);\n+        this.waitAndSetValue('.c_TtlE_TtlI input', title);\n       },\n \n       save: () => {"
    },
    {
      "sha": "798315efb563b914a176935c1a44d9e9c5e8af79",
      "filename": "version.txt",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/version.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/version.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/version.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -1 +1 @@\n-v0.2024.005\n+v0.2024.006"
    },
    {
      "sha": "ee3c20d892541048244981ffcab2983a6f2e118a",
      "filename": "wip/aliases/auto-test-thoughts.txt",
      "status": "added",
      "additions": 64,
      "deletions": 0,
      "changes": 64,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Faliases%2Fauto-test-thoughts.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Faliases%2Fauto-test-thoughts.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Faliases%2Fauto-test-thoughts.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,64 @@\n+    Category:\n+      Anons always:\n+\n+      Self selected:\n+        Anons allowed / recommended:\n+\n+      Pseudonym selected:\n+        Anons allowed / recommended:\n+\n+      Anonym selected:\n+        Anons allowed / recommended:\n+\n+      Nothing selected:\n+        Anons allowed:\n+        Anons recommended:\n+\n+\n+    Page:\n+      Self selected:\n+        Has anon already:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+\n+        Has no anon:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+\n+\n+      Pseudonym selected:\n+        Has anon already:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+\n+        Has no anon:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+\n+\n+      Anonym selected:\n+        Has anon already:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+\n+        Has no anon:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+\n+      Nothing selected:\n+        Has anon already:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+\n+        Has no anon:\n+          Anons allowed:\n+          Anons recommended:\n+          Anons always:\n+"
    },
    {
      "sha": "6ff1011488aff68155e81c4042fd9ee695a276bd",
      "filename": "wip/aliases/wip.txt",
      "status": "modified",
      "additions": 93,
      "deletions": 55,
      "changes": 148,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Faliases%2Fwip.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Faliases%2Fwip.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Faliases%2Fwip.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -4,12 +4,12 @@ Alias = anonym or pseudonym\n \n Intro:\n \n-- Anonyms are per page. This is safer — can't track a single anonym accross different\n-  conversations. And more social? In that, if you want, you can show who you\n-  actually are, in one discussion, while staying anonymous in all others.\n+- Anonyms are per page. [one_anon_per_page] This is safer — can't track a single anonym\n+  accross different conversations. And more social? In that, if you want, you can show\n+  who you actually are, in one discussion, while remaining anonymous in all others.\n   And good for ideation: Anonymous, temporarily. See the Ideation section.\n - Pseduonyms (a.k.a pen names) can be reused accross pages and categories.\n-  They are more social, but less \"safe\".\n+  They are more social, but less \"safe\". (Not implemented.)\n - Both anonyms and pseudonyms inherit (some of) the permissions of the underlying\n   true user. (Later, this will be more configurable? But not initially?)\n   See [pseudonym_types] below.\n@@ -30,35 +30,53 @@ then, this is a big box of butterflies!\n Left to do\n -----------------------\n \n-Quick:\n+Now:\n+  - Save persona mode in ... localStorage? Cookie? [remember_persona_mode]\n+  - [hide_peoples_dates]  [deanon_risk]\n+  - Notifications: List notifications to all one's aliases (anonyms & pseudonyms),\n+    not just to oneself. [list_alias_things] [posts3_true_id]\n+  - Actions: List comments & pages by one's aliases, on one's recent comment page\n+    (but of course others, not even mods or admins, can see this). [list_by_alias]\n+  - Bind anonForPatId to ... Unknown user id? for now, in json dumps. [export_privid]\n+\n+\n+Later, quick:\n   - RENAME // to ...ByTrueId?\n     val anonsByRealId = anons.groupBy(_.anonForPatId)\n-\n-  - Code review:\n-    - tests/e2e-wdio7/specs/alias-anons-basic.2br.f.e2e.ts\n-    - tests/e2e-wdio7/specs/alias-anons-true-mixed.2br.f.e2e.ts\n+  - Rename def getAliasOrTruePat()  to getPersona()?  And \"nnnMaybeAnon\" to \"nnnPersona\"?\n \n Minor & medium:\n-  - Notifications: List notifications to all one's aliases (anonyms & pseudonyms),\n-    not just to oneself. [list_alias_things]\n-  - Actions: List comments & pages by one's aliases, on one's recent comment page\n-    (but of course others, not even mods or admins, can see this).\n-  - Authz.scala:  [_pass_alias] [deanon_risk]\n-  - Reuse getAliasOrTruePat() everywhere  [get_anon]\n-  - Accept/unaccept answer\n-  - Close/reopen page\n-  - Delete/undelete own page\n-  - Rename page\n-  - mayEditPage(.., asAlias, ...) in PageTitleSettingsController  [may_use_alias]\n-  - Flag (report) things anonymously?\n-  - Search for all DO_AS_ALIAS\n-  - Search for all ANON_UNIMPL\n \n-(Also see: [anon_pages])\n+  - Remember post-as-oneself in drafts3, use post_as_id_c, and,\n+  - Remember anon status, also when reusing anons, in drafts3.\n+  - Verify anonStatus is correct, when reusing an anon or resuming a draft  [chk_alias_status]\n+\n+  - Button title: \"Post as yourself\", \"Post anonymously]\",  in >= anon-allowed cats.\n+  - Require 2 clicks to choose anon, but not at the same coordinates? [deanon_risk] [mouse_slip]\n \n-Later:\n+  - Let aliases edit wikis [alias_ed_wiki] (normally, editing\n+      others' posts anonymously isn't allowed)\n+  - wikify-dialog.more.ts  choose persona  (if posted as anon, should wikify as same anon)\n+  - Flag (report) things anonymously? [anon_flags]\n+  - Search for all ANON_UNIMPL\n+  - Better error messages: [alias_ux] [dif_anon_status]\n+  - All audit log  doerTrueId   should be like:  doingAs.trueId2  not  reqr.trueId2\n+  - Let mods & admins edit their own anon posts as themselves?  See [true_0_ed_alias]\n+    and [mods_ed_own_anon] in _checkDeanonRiskOfEdit().\n+\n+  - An optional intro guide that explains anon comments? [anon_comts_guide]\n+    Like the admin intro tour, but about anon comments & votes, and for everyone.\n+    See  `staffTours: StaffTours`  in ../../client/app-staff/admin/staff-tours.staff.ts.\n+\n+  - Also maybe show a dialog if a mod or admin edits group settings or helps someone\n+    configure their settings: Clarify that such changes aren't anonymous.\n+    Basically any changes on the user and group profile pages.\n+\n+Even later:\n+  - A [see_alias] permission, so can choose to see who an anonym is,\n+       or can vote to see who an anon is.\n   - Ask the server which alias to use, instead of deriving client side [fetch_alias]\n-    e.g. if the page is big?  Also prevents any misbehaving clients.\n+    e.g. if the page is big?\n   - Incl true id in json dumps, depending on site sensitivity settings  [export_privid]\n     Maybe add sth like talkyard.server.parser.JsonConf that says if any doerId.privId\n     should be included or not?  SensitiveConf or PrivacyConf maybe?\n@@ -70,22 +88,39 @@ Later:\n   - Think about anonymous votes and how many have read this-or-that comment,\n     when the same person visits & comments sometimes as hanself, sometimes\n     using an alias.  See: PagePopularityCalculator  [alias_vote_stats]\n+    Answer: If sensitive discussions, each anonym has the same weight (doesn't matter who\n+    the true user is).  And if ideation, and temporary anon comments: Then, votes might even\n+    be hidden (to prevent anchoring bias and social biases), and later, when showing\n+    people's votes, people aren't temp-anonymous any more anyway (so, can calculate\n+    page popularity as usual).\n   - [pseudonyms_later] [pseudonyms_trust]\n-  - [anon_priv_msgs][anon_chats]\n+  - Later: Anonymous chat messages? [anon_chats]\n   - [sql_true_id_eq]\n     Look at later, realted to anonyms and pseudonyms (looking up on both true id & anon id).\n+  - Anonymous/pseudonymous direct messages [anon_priv_msgs]. (Disabled by default?)\n+  - Panic button\n+  - Ask which persona to use, if changing category when composing new topic. [ask_if_needed]\n+    (Not that important, now there's an info message.)\n+  - Pass doer (usually the author)  and  trueDoer  to NotificationGenerator,\n+    so won't need to lookup inside.    [notf_pass_doer]\n \n Tests missing:\n   /^alias/  in test-map.txt.\n \n Large:\n-  - Alias selector (see below)\n-  - Dim buttons\n+  - Alias selector (see below) ... Oh, now implemented alraedy.\n+\n+  - Dim buttons  [_dim_buttons] (that you cannot click if in Anon mode — but this requires\n+    the client to somehow reproduce all can-do-what permission calculations the server does,\n+    and for both (!)  oneself (does a button appear at all),  and one's current persona\n+    (should the button be dimmed, that is, one can click it using one's real account,\n+    but not as one's current persona).\n \n   - Anonymous moderator actions  [anon_mods]:  Let mods do things anonymously,\n     but using different per-page-&-user anons, so no one can see if\n     replies by an anon, are in fact by one of the mods (if that anon later did\n-    sth only mods can do). — Look at all `getAliasOrTruePat()` and [get_anon].\n+    sth only mods can do). — Look at all `getAliasOrTruePat()`.\n+    Or maybe post-as-group is better, all that's needed? (see just below)\n \n   - Group aliases / post as group?  [group_pseudonyms]\n     So many people can post, using the same name.\n@@ -98,12 +133,22 @@ Much later:\n   - More anonymous modes, e.g. one that doesn't remember who an anonym is — not in email logs,\n     audit logs, etc.\n \n+Skip?:\n+  - Anonymous embedded comments. Not that important — can comment as a guest instead?\n+    Would need to ask which persona to use, in the comments iframe, before opening editor,\n+    so can show dialog next to the reply/edit btns.\n+  - Optionally disallow moving a page with anonymous comments, to a category\n+    where anon comments aern't allowed.\n+    See:  mayEditPage(.., asAlias, ...) in PageTitleSettingsController  [move_anon_page]\n+  - One person with [many_anons_per_page].  (Except for anonymous moderation, but maybe\n+    a shared moderator pseudonym is better.)\n+\n \n For sensitive discussions\n =======================\n \n \n-Alias selector  [alias_mode] [choose_alias]\n+Alias selector  [persona_mode] [alias_mode]\n -----------------------\n A preferred-alias selector in one's upper right username menu, which determines\n which of one's aliases gets used, in places where one can post as:\n@@ -114,23 +159,19 @@ which of one's aliases gets used, in places where one can post as:\n If you comment or vote on a page where you have used another alias that the one\n currently selected (in the alias selector),  then, Talkyard asks:\n   \"You previously commented here as X,  but you've activated pseudonym Y.\n-    Continue commenting as X?   [yes, as X  /  no, as Y  /  cancel]\"\n+    Continue commenting as:  X?   Y?  [Cancel]\"\n \n-And, since Y is a somewhat unlikely answer, then dobuble check:\n+And, since Y is a somewhat unlikely answer, dobuble check:  (not impl)  [mouse_slip]\n   \"Ok, you'll appear as Y   [yes, fine  /  no, cancel]\"\n \n-Or, if the current mode is Anonymous, and you visit a discussion where you've\n-replied as yourself previously, and you hit Reply, then, a dialog:\n-\n-   \"Continue using your real name in this discussion? [y / n]\n-   You're in Anonymous mode but on this page you've used your real name previously.\"\n-\n (Might seem as if this double check question is an extra step, but it'll almost\n never happen that anyone replies as X and later on what to continue as Y in the\n same discussion. — Maybe shouldn't even be allowed; could be a config setting.)\n \n+Or, if the current mode is Anonymous, and you visit a discussion where you've\n+replied as yourself previously, then the choose-persona dialog appears too.\n \n-Dim buttons\n+Dim buttons  [_dim_buttons]\n -----------------------\n When a not-oneself alias has been selected, then, all buttons that don't work\n with alias mode, could be dimmed a bit?  For example, if one is a moderator,\n@@ -171,21 +212,23 @@ Think about\n   Can even make sense with different types of pseudonyms?\n     - One \"type\" that has the same access permissions as one's true account?\n     - Another that doesn't inherit anything from one's true account?\n-      But can instead be granted permissions independently of one's true account.\n+      But can optionally be granted permissions independently of one's true account.\n       This, though, is more like a completely separate account, but you access it\n       by first logging in to your true account, then switching accounts.\n \n \n-Guessing who is who?  [deanon_risk]\n+Guessing who is who?  [deanon_risk] [mod_deanon_risk]\n -----------------------\n - People's slightly unique writing style can be a \"problem\", can be mitigated by letting\n   an AI transform all anon comments to a similar writing style.\n - In a small forum: Sbd being active in the middle of the night, and some anonymous\n   comments from the same time span, otherwise just silence the whole night. Repeated a few\n   times, then, easy to make a good guess about who posted the anon comments. — Mitigated\n   by hiding last-active-at & posted-at timestamps, or making timestamps coarse-grained,\n-  e.g. showing only day or week (but not hour and minute).\n+  e.g. showing only day or week (but not hour and minute). [hide_peoples_dates]\n - Inherits permissions — see [pseudonym_types] below.\n+    - Posting anonymously in a category few people have access too.\n+    - Anonymously moving a page from one access restricted cat to another.\n - 9999 more things...\n \n When posting anonymously, often safer to [not_use_true_users]' permissions.\n@@ -203,19 +246,11 @@ Lots of work\n   good guesses about who the pseudonyms are?\n - If repeatedly doing very different things that few others can do,\n   using the same pseudonym, then what? Calculate total % likelihood that someone\n-  correctly guesses their true identidy, looking at all past actions, and if too high,\n+  correctly guesses their true identity, looking at all past actions\n+  (can use AI and spend a bunch of lifetimes, researching this?), and if too high,\n   consider switching to a new pseudonym?  — Maybe simpler to just suggest that\n   the user switches to a new pseudonym after N time units or M interactions/comments.\n \n-\n-Would be nice\n------------------------\n-- Pass doer (usually the author)  and  trueDoer  to NotificationGenerator,\n-  so won't need to lookup inside.    [notf_pass_doer]\n-\n-\n-Unnecessary\n------------------------\n - If an admin Alice impersonates Bob, then, even if Bob's list of aliases are hidden\n   (so Alice can't see them),  it can still be partly possible for Alice to figure out\n   which aliases are Bob's aliases — by looking at when Bob did *not* get notified about\n@@ -227,8 +262,11 @@ Unnecessary\n   to impersonate anyone  (say, >= 2 admins need to agree) combined with\n   impersonation notifications  [imp_notfs].\n \n-- One person with [many_anons_per_page].  (Except for anonymous moderation, but maybe\n-  a shared moderator pseudonym is better.)\n+  Or, hide notifications, if impersonating. Maybe could be different impersonation\n+  capabilities, e.g. see true user's comments / see anon comments. Can be nice if\n+  it's possible for an admin to help sbd out by impersonating their account and\n+  figure out why sth doesn't work, *without* any chance that the admin accidentally\n+  learns who that person are, anonymously.\n \n \n For ideation"
    },
    {
      "sha": "56117dcc9b7445b5cca0d70404b819544d0e3c91",
      "filename": "wip/bookmarks/bookmarks-wip.txt",
      "status": "added",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Fbookmarks%2Fbookmarks-wip.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Fbookmarks%2Fbookmarks-wip.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Fbookmarks%2Fbookmarks-wip.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,2 @@\n+\n+[dont_list_bookmarkers]"
    },
    {
      "sha": "6c879aac8fcb9b4e8c9140bc11fc47118e4c7993",
      "filename": "wip/joint-decisions/joint-decisions.txt",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Fjoint-decisions%2Fjoint-decisions.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Fjoint-decisions%2Fjoint-decisions.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Fjoint-decisions%2Fjoint-decisions.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -8,7 +8,7 @@ If cannot trust all admins, then, optionally (forum wide settings) require many\n to agree (e.g. two), and notify all other admins, if wants to do any of:\n \n - Impersonating anyone.  [imp_notfs]\n-- See who an anonymous user or pseudonym is\n+- See who an anonymous user or pseudonym is  [see_alias]\n - Looking at email addresses or IP addresses in email logs, request logs, audit logs\n   (e.g. when this anonym got a reply, to what email address did the notification get sent?).\n - Changing any related forum setting."
    },
    {
      "sha": "e9b578bd4d3ed2f2ebcfe237e6aef2bf2611b659",
      "filename": "wip/upgr-scala-2.13/upgr-scala-2.13.txt",
      "status": "added",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/debiki/talkyard/blob/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Fupgr-scala-2.13%2Fupgr-scala-2.13.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/07ac81a0578bbf15d0c4b95e7d464eec7be311fd/wip%2Fupgr-scala-2.13%2Fupgr-scala-2.13.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Fupgr-scala-2.13%2Fupgr-scala-2.13.txt?ref=07ac81a0578bbf15d0c4b95e7d464eec7be311fd",
      "patch": "@@ -0,0 +1,11 @@\n+\n+https://confadmin.trifork.com/dl/2018/GOTO_Berlin/Migrating_to_Scala_2.13.pdf\n+\n+https://github.com/guardian/maintaining-scala-projects/issues/2\n+\n+https://docs.scala-lang.org/overviews/core/collections-migration-213.html\n+\n+\n+https://www.playframework.com/documentation/3.0.x/Migration29\n+\n+"
    }
  ]
}
