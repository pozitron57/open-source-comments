{
  "sha": "f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
  "node_id": "C_kwDOCQOkhNoAKGY2Yzk5ZTk0OWJjYTMxOWE3YjUzZmY5ZjJkZjRmMWVmZGFkYTJjZjU",
  "commit": {
    "author": {
      "name": "qwqcode",
      "email": "22412567+qwqcode@users.noreply.github.com",
      "date": "2024-10-18T11:43:01Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2024-10-18T11:43:01Z"
    },
    "message": "feat(ui/eslint): update `eslint-plugin-artalk` to v1.0.2 (#1010)\n\n- Add new ESLint rules for ArtalkPlugin:\r\n  - Available rules: `noCycleDeps`, `noLifeCycleEventInNestedBlocks`, `noEventInWatchConf`, `noInjectInNestedBlocks`, `noInjectOutsidePlugin`, `onePluginPerFile`. For more details, see [eslint-plugin-artalk](https://github.com/ArtalkJS/Artalk/tree/master/ui/eslint-plugin-artalk).\r\n- Add tests for the new ESLint rules.\r\n- Implement Tarjan's algorithm for detecting SCCs in the `noCycleDeps` rule.\r\n- Improve code organization and maintainability.\r\n- Disable the 'import-x/namespace' rule for better performance. (https://github.com/import-js/eslint-plugin-import/issues/2340)",
    "tree": {
      "sha": "34bd6317420419bd5a1a784c05de66d4e0ba21a5",
      "url": "https://api.github.com/repos/ArtalkJS/Artalk/git/trees/34bd6317420419bd5a1a784c05de66d4e0ba21a5"
    },
    "url": "https://api.github.com/repos/ArtalkJS/Artalk/git/commits/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsFcBAABCAAQBQJnEknFCRC1aQ7uu5UhlAAAJbIQACjFOroLc9R4tlWyCK+DP24Z\n3935hi+WKnmCLJXmidwYaSsFfKPDiWLedk6D3wA2k6ozcekYGKfzICfl9RGr0keU\n3Qu43Hkkz9sPPkZa94qONnTcZLbyGeu61Y1VSwfo30sYs2KxNFu9H3DPZ1wG7srq\now7dBqBIJ8aECz8eg3nJD1xAzY6c/lA7iuXKl521B5unVkBEqXrvvb502M28BSH7\nY5kKn7VX2OlHFqF+BVock2rbskf37Bp1ZEf/yDQD8c4ZFf3C7LBfcF2W8cNJmSOs\non+wfv4SymYtUyM/Zz4cQzPtLSW1bIBc3p+pXAxIwqw/YimJ+USKWX2qS6RK4pta\nuybnhZYsXLpCjA6ovaQusKrEOhYDKrnnBhL+DapOTdDiF0BbKxtfsbu4NQzLP7Tw\nfeCOB1iyML2sJ6AaTz8izPDT+i/N5nzGVw/mhm0hhaWa9EOPDp4EQE9PHQDjbQdN\nsSU7d3BEAKHKbIvlI9RmHm8B91rJsV2xOHrTF1pBztKTARTAv36kdot11pOTTl1Q\nv+NV8X5zmF1SuZxs+I2qHUqXgraZNPzD6Xo8+LbtEfR2Z1vqqz5mLXE9LKrX0gG9\nPN9AdVlLYEn7gXiNAg5nTwuy0I4rUdDLzL1IELQfKeGBK0fr0b+xa/zyDWy8s/wX\nINF3yaIbrV3cWV4AXem4\n=h9NK\n-----END PGP SIGNATURE-----\n",
      "payload": "tree 34bd6317420419bd5a1a784c05de66d4e0ba21a5\nparent dcde53f8ad4023b50103cb62120c97d389f3beb3\nauthor qwqcode <22412567+qwqcode@users.noreply.github.com> 1729251781 +0800\ncommitter GitHub <noreply@github.com> 1729251781 +0800\n\nfeat(ui/eslint): update `eslint-plugin-artalk` to v1.0.2 (#1010)\n\n- Add new ESLint rules for ArtalkPlugin:\r\n  - Available rules: `noCycleDeps`, `noLifeCycleEventInNestedBlocks`, `noEventInWatchConf`, `noInjectInNestedBlocks`, `noInjectOutsidePlugin`, `onePluginPerFile`. For more details, see [eslint-plugin-artalk](https://github.com/ArtalkJS/Artalk/tree/master/ui/eslint-plugin-artalk).\r\n- Add tests for the new ESLint rules.\r\n- Implement Tarjan's algorithm for detecting SCCs in the `noCycleDeps` rule.\r\n- Improve code organization and maintainability.\r\n- Disable the 'import-x/namespace' rule for better performance. (https://github.com/import-js/eslint-plugin-import/issues/2340)"
    }
  },
  "url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
  "html_url": "https://github.com/ArtalkJS/Artalk/commit/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
  "comments_url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/comments",
  "author": {
    "login": "qwqcode",
    "id": 22412567,
    "node_id": "MDQ6VXNlcjIyNDEyNTY3",
    "avatar_url": "https://avatars.githubusercontent.com/u/22412567?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/qwqcode",
    "html_url": "https://github.com/qwqcode",
    "followers_url": "https://api.github.com/users/qwqcode/followers",
    "following_url": "https://api.github.com/users/qwqcode/following{/other_user}",
    "gists_url": "https://api.github.com/users/qwqcode/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/qwqcode/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/qwqcode/subscriptions",
    "organizations_url": "https://api.github.com/users/qwqcode/orgs",
    "repos_url": "https://api.github.com/users/qwqcode/repos",
    "events_url": "https://api.github.com/users/qwqcode/events{/privacy}",
    "received_events_url": "https://api.github.com/users/qwqcode/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dcde53f8ad4023b50103cb62120c97d389f3beb3",
      "url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/dcde53f8ad4023b50103cb62120c97d389f3beb3",
      "html_url": "https://github.com/ArtalkJS/Artalk/commit/dcde53f8ad4023b50103cb62120c97d389f3beb3"
    }
  ],
  "stats": {
    "total": 975,
    "additions": 719,
    "deletions": 256
  },
  "files": [
    {
      "sha": "333e96bbc5c86730e308c753408e16370e2ea607",
      "filename": "eslint.config.mjs",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/eslint.config.mjs",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/eslint.config.mjs",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/eslint.config.mjs?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -81,6 +81,7 @@ export default eslintTs.config(\n       'import-x/no-named-as-default-member': 'off',\n       'import-x/no-named-as-default': 'off',\n       'import-x/default': 'off', // fix https://github.com/import-js/eslint-plugin-import/issues/1800\n+      'import-x/namespace': 'off', // very slow, see https://github.com/import-js/eslint-plugin-import/issues/2340\n       'import-x/order': 'warn',\n     },\n     settings: {"
    },
    {
      "sha": "a78341b431f4775a0f17ea982833841b1565a8f2",
      "filename": "package.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/package.json",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/package.json",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/package.json?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -38,7 +38,7 @@\n     \"eslint\": \"^9.10.0\",\n     \"eslint-config-prettier\": \"9.1.0\",\n     \"eslint-import-resolver-typescript\": \"3.6.3\",\n-    \"eslint-plugin-artalk\": \"^1.0.1\",\n+    \"eslint-plugin-artalk\": \"^1.0.2\",\n     \"eslint-plugin-compat\": \"^6.0.1\",\n     \"eslint-plugin-import-x\": \"^4.2.1\",\n     \"eslint-plugin-react\": \"^7.36.1\","
    },
    {
      "sha": "2b1b80ded642b88297b98803559da36c3ec1ce5d",
      "filename": "pnpm-lock.yaml",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/pnpm-lock.yaml",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/pnpm-lock.yaml",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/pnpm-lock.yaml?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -45,8 +45,8 @@ importers:\n         specifier: 3.6.3\n         version: 3.6.3(@typescript-eslint/parser@8.6.0(eslint@9.10.0)(typescript@5.6.2))(eslint-plugin-import-x@4.2.1(eslint@9.10.0)(typescript@5.6.2))(eslint-plugin-import@2.30.0)(eslint@9.10.0)\n       eslint-plugin-artalk:\n-        specifier: ^1.0.1\n-        version: 1.0.1(eslint@9.10.0)(typescript@5.6.2)\n+        specifier: ^1.0.2\n+        version: 1.0.2(eslint@9.10.0)(typescript@5.6.2)\n       eslint-plugin-compat:\n         specifier: ^6.0.1\n         version: 6.0.1(eslint@9.10.0)\n@@ -2471,8 +2471,8 @@ packages:\n       eslint-import-resolver-webpack:\n         optional: true\n \n-  eslint-plugin-artalk@1.0.1:\n-    resolution: {integrity: sha512-mEgJj6kqfgDqHHmHVH6O06s3bhINyBb6TItYkbsASsO3+2WCB8CGHqFxz7vqoyymFH5n6x1GwevfPWlbOg3Kgw==}\n+  eslint-plugin-artalk@1.0.2:\n+    resolution: {integrity: sha512-NXWYEHzFMRDnykHsJWs0nWvYXINCqRZPnq5VbbMVmNbAT5rh/h4YfOeUUjCNW61y9bmuYbGvumsTsWw/U99DCQ==}\n     peerDependencies:\n       eslint: '>=9'\n \n@@ -7275,7 +7275,7 @@ snapshots:\n     transitivePeerDependencies:\n       - supports-color\n \n-  eslint-plugin-artalk@1.0.1(eslint@9.10.0)(typescript@5.6.2):\n+  eslint-plugin-artalk@1.0.2(eslint@9.10.0)(typescript@5.6.2):\n     dependencies:\n       '@typescript-eslint/utils': 8.8.0(eslint@9.10.0)(typescript@5.6.2)\n       eslint: 9.10.0"
    },
    {
      "sha": "dcd7794dac4598cb05fa063eca4c56fd76525b21",
      "filename": "ui/eslint-plugin-artalk/README.md",
      "status": "modified",
      "additions": 153,
      "deletions": 4,
      "changes": 157,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2FREADME.md",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2FREADME.md",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/ui%2Feslint-plugin-artalk%2FREADME.md?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -70,11 +70,69 @@ The ESLint rule `artalk/artalk-plugin` enforces the conventions for Artalk plugi\n \n The ESLint rule is only enabled when a TypeScript file imports the `ArtalkPlugin` type from the `artalk` package and defines an arrow function variable with the type `ArtalkPlugin`, such as `const TestPlugin: ArtalkPlugin = (ctx) => {}`. The variable type must be `ArtalkPlugin`.\n \n-#### `noLifeCycleEventInNestedBlocks`\n+#### `noCycleDeps`\n \n-Should not allow life-cycle event listeners to be defined inside nested blocks.\n+Circular dependencies should not be allowed in the `provide` method. The method must not inject a dependency that it also provides, including indirect circular references (e.g., `a` -> `b` -> `c` -> `a`).\n \n-The life-cycle event listeners are `created`, `mounted`, `updated`, and `destroyed` must be defined in the top-level scope of the ArtalkPlugin arrow function.\n+The best way to deal with this situation is to do some kind of refactor to avoid the cyclic dependencies.\n+\n+**⚠️ Fail**:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const TestPlugin: ArtalkPlugin = (ctx) => {\n+  ctx.provide('foo', (foo) => {}, ['foo'])\n+}\n+```\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+// foo.ts\n+const FooPlugin: ArtalkPlugin = (ctx) => {\n+  ctx.provide('foo', (bar) => {}, ['bar'])\n+}\n+\n+// bar.ts\n+const BarPlugin: ArtalkPlugin = (ctx) => {\n+  ctx.provide('bar', (foo) => {}, ['foo'])\n+}\n+```\n+\n+**✅ Pass**:\n+\n+You can introduce a mediator to resolve circular dependencies. The mediator will handle interactions between the dependencies, breaking the direct circular relationship while maintaining their communication through the mediator.\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+// foo.ts\n+const FooPlugin: ArtalkPlugin = (ctx) => {\n+  ctx.provide('foo', () => {})\n+}\n+\n+// bar.ts\n+const BarPlugin: ArtalkPlugin = (ctx) => {\n+  ctx.provide('bar', () => {})\n+}\n+\n+// mediator.ts\n+const MediatorPlugin: ArtalkPlugin = (ctx) => {\n+  ctx.provide(\n+    'mediator',\n+    (foo, bar) => {\n+      // ...\n+      // interact with foo and bar\n+    },\n+    ['foo', 'bar'],\n+  )\n+}\n+```\n+\n+#### `noLifeCycleEventInNestedBlocks`\n+\n+Life-cycle event listeners such as `created`, `mounted`, `updated`, and `destroyed` should not be defined inside nested blocks. They must be placed in the top-level scope of the `ArtalkPlugin` arrow function to ensure clarity and maintainability.\n \n **⚠️ Fail**:\n \n@@ -102,7 +160,7 @@ export const TestPlugin: ArtalkPlugin = (ctx) => {\n \n #### `noEventInWatchConf`\n \n-Should not allow event listeners to be defined inside watchConf effect function.\n+Event listeners should not be defined inside the `watchConf` effect function. They must be placed outside to ensure proper separation of concerns and to avoid unintended side effects.\n \n **⚠️ Fail**:\n \n@@ -116,6 +174,97 @@ export const TestPlugin: ArtalkPlugin = (ctx) => {\n }\n ```\n \n+**✅ Pass**:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const TestPlugin: ArtalkPlugin = (ctx) => {\n+  ctx.on('update', () => {})\n+\n+  ctx.watchConf(['el'], (conf) => {})\n+}\n+```\n+\n+#### `noInjectInNestedBlocks`\n+\n+The `inject` method should not be called inside nested blocks. It must be used at the top-level scope of the `ArtalkPlugin` arrow function. For better readability and maintainability, it is recommended to place the `inject` call at the beginning of the function.\n+\n+**⚠️ Fail**:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const TestPlugin: ArtalkPlugin = (ctx) => {\n+  const fn = () => {\n+    const foo = ctx.inject('foo')\n+  }\n+}\n+```\n+\n+**✅ Pass**:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const TestPlugin: ArtalkPlugin = (ctx) => {\n+  const foo = ctx.inject('foo')\n+}\n+```\n+\n+#### `noInjectOutsidePlugin`\n+\n+The `inject` method should not be called outside the `ArtalkPlugin` arrow function. It must be used in the top-level scope of the `ArtalkPlugin` function to ensure the dependency injection remains readable and maintainable.\n+\n+**⚠️ Fail**:\n+\n+```ts\n+function fn(ctx) {\n+  const foo = ctx.inject('foo')\n+}\n+```\n+\n+**✅ Pass**:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const TestPlugin: ArtalkPlugin = (ctx) => {\n+  const foo = ctx.inject('foo')\n+}\n+```\n+\n+#### `onePluginPerFile`\n+\n+Multiple plugins should not be defined in the same file. Each plugin must be defined in its own separate file to improve code organization and maintainability.\n+\n+**⚠️ Fail**:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const TestPlugin: ArtalkPlugin = (ctx) => {}\n+export const AnotherPlugin: ArtalkPlugin = (ctx) => {}\n+```\n+\n+**✅ Pass**:\n+\n+TestPlugin.ts:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const TestPlugin: ArtalkPlugin = (ctx) => {}\n+```\n+\n+AnotherPlugin.ts:\n+\n+```ts\n+import type { ArtalkPlugin } from 'artalk'\n+\n+export const AnotherPlugin: ArtalkPlugin = (ctx) => {}\n+```\n+\n ## License\n \n [MIT](https://github.com/ArtalkJS/Artalk/blob/master/LICENSE)"
    },
    {
      "sha": "1fdda8811ca65b23c5525acbaa727d159b8083f2",
      "filename": "ui/eslint-plugin-artalk/package.json",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fpackage.json",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fpackage.json",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/ui%2Feslint-plugin-artalk%2Fpackage.json?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"eslint-plugin-artalk\",\n-  \"version\": \"1.0.1\",\n+  \"version\": \"1.0.2\",\n   \"type\": \"module\",\n   \"license\": \"MIT\",\n   \"homepage\": \"https://github.com/ArtalkJS/Artalk/tree/master/ui/eslint-plugin-artalk\","
    },
    {
      "sha": "c9b669773bb1e207e75641ad93b5ea760fb68eb2",
      "filename": "ui/eslint-plugin-artalk/src/artalk-plugin-checkers.ts",
      "status": "added",
      "additions": 372,
      "deletions": 0,
      "changes": 372,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin-checkers.ts",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin-checkers.ts",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin-checkers.ts?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -0,0 +1,372 @@\n+import { AST_NODE_TYPES, TSESLint, TSESTree } from '@typescript-eslint/utils'\n+import type { ArtalkPluginCheckerContext, DepsData, DepsStore } from './artalk-plugin'\n+import { tarjan } from './scc'\n+\n+/** The event function names in Context */\n+const ctxEventFns = ['off', 'on', 'trigger']\n+\n+/** The life-cycle event names in Context */\n+const ctxLifeCycleEvents = ['mounted', 'destroyed', 'updated', 'list-fetched']\n+\n+/** Whether the given string is a ArtalkPlugin name */\n+export function isPluginName(s: string) {\n+  return s === 'ArtalkPlugin' || /Artalk[A-Z0-9].*Plugin/.test(s)\n+}\n+\n+/**\n+ * Get the references to Context in the top scope of the given scope\n+ */\n+const getCtxRefNamesInTopScope = (ctxArgName: string, scope: TSESLint.Scope.Scope) => {\n+  const ctxRefs = new Map<TSESTree.Node, string>()\n+\n+  const getFullMethodName = (node: TSESTree.Node) => {\n+    const methodNameArr: string[] = []\n+    let curr: TSESTree.Node | undefined = node\n+    const visited = new Set<TSESTree.Node>()\n+    while (curr) {\n+      if (visited.has(curr)) break\n+      visited.add(curr)\n+      if (curr.type === 'MemberExpression' && curr.property.type === 'Identifier')\n+        methodNameArr.push(curr.property.name)\n+      curr = curr.parent\n+    }\n+    return methodNameArr.join('.')\n+  }\n+\n+  scope.references.forEach((reference) => {\n+    const identifier = reference.identifier\n+    if (identifier.name !== ctxArgName) return\n+\n+    const methodName = getFullMethodName(identifier.parent)\n+    if (methodName) ctxRefs.set(identifier.parent, methodName)\n+  })\n+\n+  return ctxRefs\n+}\n+\n+/**\n+ * Get the references to Context in the nested scopes of the given\n+ */\n+const getCtxRefNamesInNestedScope = (\n+  ctxArgName: string,\n+  parentScope: TSESLint.Scope.Scope,\n+  keepTop = true,\n+) => {\n+  const ctxRefs = new Map<TSESTree.Node, string>()\n+  keepTop && getCtxRefNamesInTopScope(ctxArgName, parentScope).forEach((v, k) => ctxRefs.set(k, v))\n+  parentScope.childScopes.forEach((childScope) => {\n+    getCtxRefNamesInNestedScope(ctxArgName, childScope).forEach((v, k) => ctxRefs.set(k, v))\n+  })\n+  return ctxRefs\n+}\n+\n+/**\n+ * Check the set of all function names in Context\n+ *\n+ * (which is called in the top-level of ArtalkPlugin arrow-function scope)\n+ */\n+const checkTopLevelCtxRefs = (ctx: ArtalkPluginCheckerContext, m: Map<TSESTree.Node, string>) => {\n+  // console.debug('checkTopLevelCtxFnCalls', m.values())\n+  // ...\n+}\n+\n+const getDepsMap = (node: TSESTree.CallExpression): DepsData | void => {\n+  if (node.arguments.length < 3) return\n+\n+  // Get the dependencies\n+  let depsArg = node.arguments[2]\n+  if (depsArg.type === 'TSAsExpression') depsArg = depsArg.expression\n+  if (depsArg.type !== 'ArrayExpression') return\n+  const deps = depsArg.elements\n+    .map((e) => (e && e.type === 'Literal' && typeof e.value === 'string' ? e.value : ''))\n+    .filter((e) => !!e)\n+  if (deps.length === 0) return\n+\n+  // Get the provider name\n+  const providerNameArg = node.arguments[0]\n+  if (providerNameArg.type !== 'Literal') return\n+  const providerName = providerNameArg.value\n+  if (!providerName || typeof providerName !== 'string') return\n+\n+  // Record the dependency data for the file\n+  const depsMap: DepsData = new Map()\n+  deps.forEach((depName) => {\n+    if (!depsMap.has(depName)) depsMap.set(depName, new Set())\n+    depsMap.get(depName)!.add(providerName)\n+  })\n+\n+  return depsMap\n+}\n+\n+function removePath(graph: DepsData, path: string[]): DepsData {\n+  if (path.length < 2) {\n+    throw new Error('Path must have at least two nodes')\n+  }\n+\n+  // Clone the data\n+  const updatedGraph = new Map(graph)\n+  updatedGraph.forEach((value, key) => {\n+    updatedGraph.set(key, new Set(value))\n+  })\n+\n+  for (let i = 0; i < path.length - 1; i++) {\n+    const toNode = path[i]\n+    const fromNode = path[i + 1]\n+\n+    // Remove the edge from fromNode to toNode\n+    if (updatedGraph.has(fromNode)) {\n+      const edges = updatedGraph.get(fromNode)\n+      if (edges) {\n+        // Remove the edge to toNode from the adjacency set of fromNode\n+        edges.delete(toNode)\n+        if (edges.size === 0) {\n+          // If the node no longer has any edges, remove the node\n+          updatedGraph.delete(fromNode)\n+        }\n+      }\n+    }\n+  }\n+\n+  return updatedGraph\n+}\n+\n+const checkCircularDependency = (\n+  depsStore: DepsStore,\n+  ctx: ArtalkPluginCheckerContext,\n+  _node: TSESTree.CallExpression,\n+) => {\n+  const args = _node.arguments\n+  const node = args.length >= 3 ? args[2] : _node\n+\n+  // Merge all files' dependency data\n+  const depsGraph: DepsData = new Map()\n+  depsStore.forEach((depsData, filename) => {\n+    depsData.forEach((providers, depName) => {\n+      if (!depsGraph.has(depName)) depsGraph.set(depName, new Set())\n+      providers.forEach((provider) => depsGraph.get(depName)!.add(provider))\n+    })\n+  })\n+\n+  // console.log('\\n' + ctx.eslint.filename)\n+  // console.log('depsGraph', depsGraph)\n+  // console.log('tarjan', tarjan(depsGraph))\n+\n+  // Basic check (self-reference, a->a)\n+  for (const [depName, providers] of depsGraph) {\n+    if (providers.has(depName)) {\n+      ctx.eslint.report({\n+        node,\n+        messageId: 'noCycleDeps',\n+        data: { route: `${depName}->${depName}` },\n+      })\n+      return\n+    }\n+  }\n+\n+  // SCC (Strongly Connected Components) algorithm\n+  tarjan(depsGraph).forEach((scc) => {\n+    if (scc.size <= 1) return\n+    const route = [...scc, scc.values().next().value].slice(1).join('->')\n+\n+    ctx.eslint.report({\n+      node,\n+      messageId: 'noCycleDeps',\n+      data: { route },\n+    })\n+\n+    // Cleanup\n+    depsStore.forEach((depsData, filename) => {\n+      depsStore.set(filename, removePath(depsData, [...scc]))\n+    })\n+  })\n+}\n+\n+/**\n+ * Check the set of all function names in Context\n+ *\n+ * (which is called in the nested scopes of ArtalkPlugin arrow-function scope)\n+ */\n+const checkNestedCtxRefs = (ctx: ArtalkPluginCheckerContext, m: Map<TSESTree.Node, string>) => {\n+  // console.debug('checkAllCtxFnCalls', m.values())\n+  // ...\n+  // TODO: Event Circular trigger Check\n+\n+  const depsMap: DepsData = new Map()\n+\n+  m.forEach((methodName, node) => {\n+    // Check dependency providers via `ctx.provide`\n+    if (methodName === 'provide') {\n+      const callExpr = node.parent\n+      if (!callExpr || callExpr.type !== 'CallExpression') return\n+\n+      // Record\n+      const dm = getDepsMap(callExpr)\n+      if (!dm) return\n+\n+      // Merge\n+      dm.forEach((providers, depName) => {\n+        if (!depsMap.has(depName)) depsMap.set(depName, new Set())\n+        providers.forEach((provider) => depsMap.get(depName)!.add(provider))\n+      })\n+\n+      // Check\n+      const depsStoreShallowCopy = new Map(ctx.depsStore)\n+      depsStoreShallowCopy.set(ctx.eslint.filename, depsMap)\n+      checkCircularDependency(depsStoreShallowCopy, ctx, callExpr)\n+    }\n+  })\n+\n+  // Overwrite the historical dependency data\n+  ctx.depsStore.set(ctx.eslint.filename, depsMap)\n+}\n+\n+/**\n+ * Check the set of all function names in Context\n+ *\n+ * (which is called in the nested scopes of ArtalkPlugin arrow-function scope, excluding the top-level)\n+ */\n+const checkNestedCtxRefsNoTop = (\n+  ctx: ArtalkPluginCheckerContext,\n+  m: Map<TSESTree.Node, string>,\n+) => {\n+  m.forEach((methodName, node) => {\n+    // Disallow life-cycle events in nested blocks\n+    if (methodName === 'on') {\n+      // Get the call arguments\n+      const parent = node.parent\n+      if (!parent || parent.type !== 'CallExpression') return\n+      if (parent.arguments.length == 0) return\n+      const eventNameArg = parent.arguments[0]\n+      if (eventNameArg.type !== 'Literal') return\n+      const eventName = eventNameArg.value\n+      if (typeof eventName !== 'string') return\n+      if (ctxLifeCycleEvents.includes(eventName)) {\n+        ctx.eslint.report({\n+          node: parent,\n+          messageId: 'noLifeCycleEventInNestedBlocks',\n+          data: {\n+            eventName,\n+          },\n+        })\n+      }\n+    }\n+\n+    // Disallow inject in nested blocks\n+    if (methodName === 'inject') {\n+      ctx.eslint.report({\n+        node: node.parent || node,\n+        messageId: 'noInjectInNestedBlocks',\n+      })\n+    }\n+  })\n+}\n+\n+/**\n+ * Check the set of all function names in Context\n+ *\n+ * (which is called in the watchConf effect function scope)\n+ */\n+const checkWatchConfCalls = (ctx: ArtalkPluginCheckerContext, m: Map<TSESTree.Node, string>) => {\n+  const disallowedMethods = [...ctxEventFns]\n+  m.forEach((methodName, node) => {\n+    if (disallowedMethods.includes(methodName)) {\n+      ctx.eslint.report({\n+        node: node.parent || node,\n+        messageId: 'noEventInWatchConf',\n+        data: { functionName: `ctx.${methodName}` },\n+      })\n+    }\n+  })\n+}\n+\n+/**\n+ * Check the ArtalkPlugin variable declaration\n+ */\n+export const checkPluginFunction = (\n+  ctx: ArtalkPluginCheckerContext,\n+  pluginFn: TSESTree.ArrowFunctionExpression,\n+) => {\n+  // Get the first parameter name as the Context reference\n+  if (pluginFn.params.length === 0) return // No ctx reference\n+  const ctxArg = pluginFn.params[0]\n+  if (ctxArg.type !== 'Identifier') return\n+  const ctxArgName = ctxArg.name\n+\n+  // Visit the top-level scope of the ArtalkPlugin arrow-function\n+  const pluginFnScope = ctx.eslint.sourceCode.getScope(pluginFn.body)\n+  const topLevelCtxRefs = getCtxRefNamesInTopScope(ctxArgName, pluginFnScope)\n+  checkTopLevelCtxRefs(ctx, topLevelCtxRefs)\n+\n+  // Visit all nested scopes (including the top-level) of the ArtalkPlugin arrow-function\n+  const nestedCtxRefsIncludeTop = getCtxRefNamesInNestedScope(ctxArgName, pluginFnScope, true)\n+  checkNestedCtxRefs(ctx, nestedCtxRefsIncludeTop)\n+\n+  // Visit all nested scopes (excluding the top-level) of the ArtalkPlugin arrow-function\n+  const nestedCtxRefsExcludeTop = getCtxRefNamesInNestedScope(ctxArgName, pluginFnScope, false)\n+  checkNestedCtxRefsNoTop(ctx, nestedCtxRefsExcludeTop)\n+\n+  // Visit watchConf effect function scope\n+  const watchConfCalls = new Map<TSESTree.Node, string>()\n+  topLevelCtxRefs.forEach((v, k) => {\n+    if (v === 'watchConf') {\n+      // Get the watchConf call expression\n+      const watchConfCall = k.parent\n+      if (!watchConfCall || watchConfCall.type !== AST_NODE_TYPES.CallExpression) return\n+\n+      // Get the watchConf effect function\n+      if (watchConfCall.arguments.length < 2) return\n+      const watchConfEffectFn = watchConfCall.arguments[1]\n+      if (\n+        watchConfEffectFn.type !== 'ArrowFunctionExpression' &&\n+        watchConfEffectFn.type !== 'FunctionExpression'\n+      )\n+        return\n+\n+      // Get the references to Context in the watchConf effect function top scope\n+      const scope = ctx.eslint.sourceCode.getScope(watchConfEffectFn.body)\n+      getCtxRefNamesInTopScope(ctxArgName, scope).forEach((v, k) => watchConfCalls.set(k, v))\n+    }\n+  })\n+  checkWatchConfCalls(ctx, watchConfCalls)\n+}\n+\n+export const checkInjectCallOutsideArtalkPlugin = (\n+  ctx: ArtalkPluginCheckerContext,\n+  node: TSESTree.Identifier,\n+) => {\n+  if (node.name !== 'inject') return\n+  const parent = node.parent\n+  if (parent.type !== 'MemberExpression') return\n+  if (parent.object.type !== 'Identifier') return\n+  if (!['ctx', 'context'].includes(parent.object.name)) return\n+\n+  // traverse up to find the ArtalkPlugin arrow-function\n+  let curr: TSESTree.Node | undefined = parent\n+  let pluginFn: TSESTree.ArrowFunctionExpression | undefined\n+  const visited = new Set<TSESTree.Node>()\n+  while (curr) {\n+    if (visited.has(curr)) break\n+    visited.add(curr)\n+    if (curr.type === 'ArrowFunctionExpression') {\n+      pluginFn = curr\n+    }\n+    curr = curr.parent\n+  }\n+\n+  const fail = () => {\n+    ctx.eslint.report({\n+      node,\n+      messageId: 'noInjectOutsidePlugin',\n+    })\n+  }\n+\n+  // check if the ArtalkPlugin arrow-function is found\n+  if (!pluginFn) return fail()\n+  const varDecl = pluginFn.parent\n+  if (varDecl.type !== 'VariableDeclarator') return fail()\n+  const typeRef = varDecl.id.typeAnnotation?.typeAnnotation\n+  if (!typeRef || typeRef.type !== 'TSTypeReference') return fail()\n+  const typeNameId = typeRef.typeName\n+  if (typeNameId.type !== 'Identifier') return fail()\n+  if (typeNameId.name !== 'ArtalkPlugin') return fail()\n+}"
    },
    {
      "sha": "75329b6916908df617abe7cc256b84b22a6ba2dd",
      "filename": "ui/eslint-plugin-artalk/src/artalk-plugin.test.ts",
      "status": "modified",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin.test.ts",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin.test.ts",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin.test.ts?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -32,6 +32,50 @@ const invalid = [\n     `,\n     errorId: 'noEventInWatchConf',\n   },\n+  {\n+    name: \"should not allow 'inject' call in nested blocks\",\n+    code: `\n+      import type { ArtalkPlugin } from 'artalk'\n+\n+      export const TestPlugin: ArtalkPlugin = (ctx) => {\n+        const fn = () => {\n+          const foo = ctx.inject('foo')\n+        }\n+      }\n+    `,\n+    errorId: 'noInjectInNestedBlocks',\n+  },\n+  {\n+    name: \"should not allow 'inject' call outside ArtalkPlugin\",\n+    code: `\n+      function fn(ctx) {\n+        const foo = ctx.inject('foo')\n+      }\n+    `,\n+    errorId: 'noInjectOutsidePlugin',\n+  },\n+  {\n+    name: 'should not allow circular dependency providing',\n+    code: `\n+      import type { ArtalkPlugin } from 'artalk'\n+\n+      export const TestPlugin: ArtalkPlugin = (ctx) => {\n+        ctx.provide('foo', (foo) => {}, ['foo'])\n+      }\n+    `,\n+    errorId: 'noCycleDeps',\n+  },\n+  {\n+    name: 'should not allow multiple ArtalkPlugin in a single file',\n+    code: `\n+      import type { ArtalkPlugin } from 'artalk'\n+\n+      export const TestPlugin: ArtalkPlugin = (ctx) => {}\n+\n+      export const TestPlugin2: ArtalkPlugin = (ctx) => {}\n+    `,\n+    errorId: 'onePluginPerFile',\n+  },\n ]\n \n for (const { name, code, errorId } of invalid) {"
    },
    {
      "sha": "a683fc23c9337a59e753b91567d8de5bfb22e38d",
      "filename": "ui/eslint-plugin-artalk/src/artalk-plugin.ts",
      "status": "modified",
      "additions": 65,
      "deletions": 242,
      "changes": 307,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin.ts",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin.ts",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/ui%2Feslint-plugin-artalk%2Fsrc%2Fartalk-plugin.ts?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -1,276 +1,99 @@\n-import { AST_NODE_TYPES, TSESLint, TSESTree } from '@typescript-eslint/utils'\n-import type { ContextApi } from '../../artalk/src/types/context'\n+import type { Context } from '../../artalk'\n+import {\n+  isPluginName,\n+  checkPluginFunction,\n+  checkInjectCallOutsideArtalkPlugin,\n+} from './artalk-plugin-checkers'\n import { createRule } from './helper'\n-type _ = ContextApi // for IDE jump-to-definition\n+type _ = Context // for IDE jump-to-definition\n \n-/** Whether the given string is a ArtalkPlugin name */\n-function isPluginName(s: string) {\n-  return s === 'ArtalkPlugin' || /Artalk[A-Z0-9].*Plugin/.test(s)\n-}\n-\n-/** The event function names in ContextApi */\n-const ctxEventFns = ['off', 'on', 'trigger']\n-\n-/** The life-cycle event names in ContextApi */\n-const ctxLifeCycleEvents = ['mounted', 'destroyed', 'updated', 'list-fetched']\n+const depsMap: DepsStore = new Map()\n \n export const artalkPlugin = createRule({\n   name: 'artalk-plugin',\n   meta: {\n     type: 'problem',\n     docs: {\n       description:\n-        'Enforce best practices for ArtalkPlugin arrow functions, including ContextApi usage.',\n+        'Enforce best practices for ArtalkPlugin arrow functions, including Context usage.',\n     },\n     messages: {\n       noLifeCycleEventInNestedBlocks:\n         'The life-cycle event `{{ eventName }}` listeners should only be defined in the top-level scope of the ArtalkPlugin.',\n       noEventInWatchConf: 'Avoid calling `{{ functionName }}` inside the `ctx.watchConf` effect.',\n+      noInjectInNestedBlocks:\n+        'The `ctx.inject` method should only be called in the top-level scope of the ArtalkPlugin.',\n+      noInjectOutsidePlugin:\n+        'The `ctx.inject` method should only be called inside the ArtalkPlugin arrow function.',\n+      noCycleDeps: 'Dependency cycle via `ctx.provide` ({{ route }}) in the ArtalkPlugin.',\n+      onePluginPerFile: 'There is more than one ArtalkPlugin in this file.',\n     },\n     schema: [],\n   },\n   defaultOptions: [],\n   create(context) {\n-    // Initialize the TypeScript parser services\n-    const parserServices = context.sourceCode.parserServices\n-    if (!parserServices || !parserServices.program) {\n-      console.error('[eslint-plugin-artalk] Missing typescript parser services.')\n-      return {}\n-    }\n-    const checker = parserServices.program.getTypeChecker()\n-\n-    // -------------------------------------------------------------------\n-    //  Utility functions\n-    // -------------------------------------------------------------------\n-    const getTypeName = (node: TSESTree.Node) => {\n-      const tsNode = parserServices?.esTreeNodeToTSNodeMap?.get(node)\n-      const tsType = tsNode ? checker.getTypeAtLocation(tsNode) : null\n-      const typeName = tsType ? checker.typeToString(tsType) : ''\n-      return typeName\n-    }\n-\n-    const getArrowFunctionType = (node: TSESTree.Node) => {\n-      if (node.type === 'ArrowFunctionExpression') return getTypeName(node)\n-      return ''\n-    }\n-\n-    const isInsideArtalkPlugin = (node: TSESTree.Node) => {\n-      let curr: TSESTree.Node | undefined = node\n-      while (curr) {\n-        if (isPluginName(getArrowFunctionType(curr))) return true\n-        curr = curr.parent\n-      }\n-      return false\n-    }\n-\n-    /**\n-     * Get the references to ContextApi in the top scope of the given scope\n-     */\n-    const getCtxRefNamesInTopScope = (ctxArgName: string, scope: TSESLint.Scope.Scope) => {\n-      const ctxRefs = new Map<TSESTree.Node, string>()\n-\n-      const getFullMethodName = (node: TSESTree.Node) => {\n-        const methodNameArr: string[] = []\n-        let curr: TSESTree.Node | undefined = node\n-        while (curr) {\n-          if (curr.type === 'MemberExpression' && curr.property.type === 'Identifier')\n-            methodNameArr.push(curr.property.name)\n-          curr = curr.parent\n-        }\n-        return methodNameArr.join('.')\n-      }\n-\n-      scope.references.forEach((reference) => {\n-        const identifier = reference.identifier\n-        if (identifier.name !== ctxArgName) return\n-\n-        const methodName = getFullMethodName(identifier.parent)\n-        if (methodName) ctxRefs.set(identifier.parent, methodName)\n-      })\n-\n-      return ctxRefs\n-    }\n-\n-    /**\n-     * Get the references to ContextApi in the nested scopes of the given\n-     */\n-    const getCtxRefNamesInNestedScope = (\n-      ctxArgName: string,\n-      parentScope: TSESLint.Scope.Scope,\n-      keepTop = true,\n-    ) => {\n-      const ctxRefs = new Map<TSESTree.Node, string>()\n-      keepTop &&\n-        getCtxRefNamesInTopScope(ctxArgName, parentScope).forEach((v, k) => ctxRefs.set(k, v))\n-      parentScope.childScopes.forEach((childScope) => {\n-        getCtxRefNamesInNestedScope(ctxArgName, childScope).forEach((v, k) => ctxRefs.set(k, v))\n-      })\n-      return ctxRefs\n+    const checkerContext: ArtalkPluginCheckerContext = {\n+      eslint: context,\n+      depsStore: depsMap,\n     }\n \n-    // -------------------------------------------------------------------\n-    //  Checker functions\n-    // -------------------------------------------------------------------\n-\n-    /**\n-     * Check the set of all function names in ContextApi\n-     *\n-     * (which is called in the top-level of ArtalkPlugin arrow-function scope)\n-     */\n-    const checkTopLevelCtxRefs = (m: Map<TSESTree.Node, string>) => {\n-      // console.debug('checkTopLevelCtxFnCalls', m.values())\n-      // ...\n-    }\n-\n-    /**\n-     * Check the set of all function names in ContextApi\n-     *\n-     * (which is called in the nested scopes of ArtalkPlugin arrow-function scope)\n-     */\n-    const checkNestedCtxRefs = (m: Map<TSESTree.Node, string>) => {\n-      // console.debug('checkAllCtxFnCalls', m.values())\n-      // ...\n-      // TODO: Event Circular trigger Check\n-    }\n-\n-    /**\n-     * Check the set of all function names in ContextApi\n-     *\n-     * (which is called in the nested scopes of ArtalkPlugin arrow-function scope, excluding the top-level)\n-     */\n-    const checkNestedCtxRefsNoTop = (m: Map<TSESTree.Node, string>) => {\n-      m.forEach((methodName, node) => {\n-        // Disallow life-cycle events in nested blocks\n-        if (methodName === 'on') {\n-          // Get the call arguments\n-          const parent = node.parent\n-          if (!parent || parent.type !== 'CallExpression') return\n-          if (parent.arguments.length == 0) return\n-          const eventNameArg = parent.arguments[0]\n-          if (eventNameArg.type !== 'Literal') return\n-          const eventName = eventNameArg.value\n-          if (typeof eventName !== 'string') return\n-          if (ctxLifeCycleEvents.includes(eventName)) {\n-            context.report({\n-              node: parent,\n-              messageId: 'noLifeCycleEventInNestedBlocks',\n-              data: {\n-                eventName,\n-              },\n-            })\n-          }\n-        }\n-      })\n-    }\n-\n-    /**\n-     * Check the set of all function names in ContextApi\n-     *\n-     * (which is called in the watchConf effect function scope)\n-     */\n-    const checkWatchConfCalls = (m: Map<TSESTree.Node, string>) => {\n-      const disallowedMethods = [...ctxEventFns]\n-      m.forEach((methodName, node) => {\n-        if (disallowedMethods.includes(methodName)) {\n-          context.report({\n-            node: node.parent || node,\n-            messageId: 'noEventInWatchConf',\n-            data: { functionName: `ctx.${methodName}` },\n-          })\n-        }\n-      })\n-    }\n-\n-    /**\n-     * Whether the ArtalkPlugin is imported\n-     *\n-     * (to enable the plugin checker)\n-     */\n-    let pluginCheckerEnabled = false\n+    let lastPluginFilePath = ''\n+    let lastPluginName = ''\n \n     return {\n-      ImportDeclaration(node) {\n-        // Check if contains ArtalkPlugin importing\n-        node.specifiers.forEach((specifier) => {\n-          if (specifier.type !== 'ImportSpecifier') return\n-          if (isPluginName(specifier.imported.name)) {\n-            pluginCheckerEnabled = true\n-          }\n-        })\n-      },\n+      ImportDeclaration(node) {},\n+\n+      TSTypeAnnotation(node) {\n+        const typeAnnotation = node.typeAnnotation\n+        if (typeAnnotation.type !== 'TSTypeReference') return\n+        if (typeAnnotation.typeName.type !== 'Identifier') return\n+        const typeName = typeAnnotation.typeName.name\n+        const identifier = node.parent\n \n-      VariableDeclaration(fnNode) {\n-        if (!pluginCheckerEnabled) return\n+        if (isPluginName(typeName)) {\n+          if (identifier.type !== 'Identifier') return\n+          const pluginName = identifier.name\n \n-        // Check if the variable declaration is ArtalkPlugin\n-        fnNode.declarations.forEach((decl) => {\n+          // Get the variable declaration of the ArtalkPlugin\n+          const varDecl = identifier.parent\n           if (\n-            isPluginName(getTypeName(decl)) &&\n-            decl.init &&\n-            decl.init?.type == 'ArrowFunctionExpression'\n+            varDecl.type === 'VariableDeclarator' &&\n+            varDecl.init &&\n+            varDecl.init?.type == 'ArrowFunctionExpression'\n           ) {\n-            // Is ArtalkPlugin arrow-function\n-            const pluginFn = decl.init\n-\n-            // Get the first parameter name as the ContextApi reference\n-            if (pluginFn.params.length === 0) return // No ctx reference\n-            const ctxArg = pluginFn.params[0]\n-            if (ctxArg.type !== 'Identifier') return\n-            const ctxArgName = ctxArg.name\n-\n-            // Visit the top-level scope of the ArtalkPlugin arrow-function\n-            const pluginFnScope = context.sourceCode.getScope(pluginFn.body)\n-            const topLevelCtxRefs = getCtxRefNamesInTopScope(ctxArgName, pluginFnScope)\n-            checkTopLevelCtxRefs(topLevelCtxRefs)\n-\n-            // Visit all nested scopes (including the top-level) of the ArtalkPlugin arrow-function\n-            const nestedCtxRefsIncludeTop = getCtxRefNamesInNestedScope(\n-              ctxArgName,\n-              pluginFnScope,\n-              true,\n-            )\n-            checkNestedCtxRefs(nestedCtxRefsIncludeTop)\n-\n-            // Visit all nested scopes (excluding the top-level) of the ArtalkPlugin arrow-function\n-            const nestedCtxRefsExcludeTop = getCtxRefNamesInNestedScope(\n-              ctxArgName,\n-              pluginFnScope,\n-              false,\n-            )\n-            checkNestedCtxRefsNoTop(nestedCtxRefsExcludeTop)\n-\n-            // Visit watchConf effect function scope\n-            const watchConfCalls = new Map<TSESTree.Node, string>()\n-            topLevelCtxRefs.forEach((v, k) => {\n-              if (v === 'watchConf') {\n-                // Get the watchConf call expression\n-                const watchConfCall = k.parent\n-                if (!watchConfCall || watchConfCall.type !== AST_NODE_TYPES.CallExpression) return\n-\n-                // Get the watchConf effect function\n-                if (watchConfCall.arguments.length < 2) return\n-                const watchConfEffectFn = watchConfCall.arguments[1]\n-                if (\n-                  watchConfEffectFn.type !== 'ArrowFunctionExpression' &&\n-                  watchConfEffectFn.type !== 'FunctionExpression'\n-                )\n-                  return\n-\n-                // Get the references to ContextApi in the watchConf effect function top scope\n-                const scope = context.sourceCode.getScope(watchConfEffectFn.body)\n-                getCtxRefNamesInTopScope(ctxArgName, scope).forEach((v, k) =>\n-                  watchConfCalls.set(k, v),\n-                )\n-              }\n-            })\n-            checkWatchConfCalls(watchConfCalls)\n+            // console.log('Found ArtalkPlugin:', pluginName)\n+            checkPluginFunction(checkerContext, varDecl.init)\n+\n+            // check for multiple ArtalkPlugins in the same file\n+            if (lastPluginFilePath === context.filename && lastPluginName !== pluginName) {\n+              context.report({\n+                node: identifier,\n+                messageId: 'onePluginPerFile',\n+              })\n+            }\n+            lastPluginFilePath = context.filename\n+            lastPluginName = pluginName\n           }\n-        })\n+        }\n       },\n \n-      Identifier(node) {},\n+      VariableDeclaration(fnNode) {},\n \n-      CallExpression(node) {},\n+      Identifier(node) {\n+        if (node.name === 'inject') {\n+          checkInjectCallOutsideArtalkPlugin(checkerContext, node)\n+        }\n+      },\n     }\n   },\n })\n+\n+type ArtalkPluginRuleContext = Parameters<(typeof artalkPlugin)['create']>[0]\n+\n+export type DepsData = Map<string, Set<string>> // DepName -> ProviderNames\n+export type DepsStore = Map<string, DepsData> // FilePath -> DepsData\n+\n+export interface ArtalkPluginCheckerContext {\n+  eslint: ArtalkPluginRuleContext\n+  depsStore: DepsStore\n+}"
    },
    {
      "sha": "9be78b7bda0e7833e23a805184c6d28ced769e78",
      "filename": "ui/eslint-plugin-artalk/src/scc.ts",
      "status": "added",
      "additions": 74,
      "deletions": 0,
      "changes": 74,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fscc.ts",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/ui%2Feslint-plugin-artalk%2Fsrc%2Fscc.ts",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/ui%2Feslint-plugin-artalk%2Fsrc%2Fscc.ts?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -0,0 +1,74 @@\n+type Graph = Map<string, Set<string>> // Graph with nodes and their dependencies\n+type SCC = Set<string>[] // Array of Strongly Connected Components\n+\n+/**\n+ * Tarjan's Algorithm to find Strongly Connected Components (SCCs) in a directed graph.\n+ *\n+ * The function uses a depth-first search (DFS) approach to discover SCCs in the input graph.\n+ * It keeps track of discovery times and low-link values for each node, which helps in detecting cycles.\n+ * Once SCCs are found, they are added as sets to the result array.\n+ *\n+ * @param graph - A directed graph represented as a Map where the keys are nodes and values are arrays of adjacent nodes.\n+ * @returns An array of Sets, where each Set contains the nodes of one Strongly Connected Component.\n+ * @link https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm#The_algorithm_in_pseudocode\n+ */\n+export function tarjan(graph: Graph): SCC {\n+  const indices = new Map<string, number>() // To store the discovery index of each node\n+  const lowlinks = new Map<string, number>() // To store the lowest point reachable from each node\n+  const onStack = new Set<string>() // To keep track of nodes currently on the stack\n+  const stack: string[] = [] // Stack to simulate recursion and track SCC nodes\n+  const scc: SCC = [] // Result array to store SCCs\n+  let idx = 0 // Global index counter\n+\n+  /**\n+   * Strongly connects a node by performing DFS, updating the indices and lowlinks.\n+   * Once an SCC is found (when a node's lowlink equals its index), it's popped off the stack.\n+   *\n+   * @param v - The current node being explored in the DFS\n+   */\n+  function strongConnect(v: string): void {\n+    // Set the discovery index and lowlink for the node\n+    indices.set(v, idx)\n+    lowlinks.set(v, idx)\n+    idx++\n+    stack.push(v)\n+    onStack.add(v)\n+\n+    // Explore the neighbors (dependencies) of the current node\n+    const deps = graph.get(v) || [] // Get the adjacent nodes (or an empty array if no edges)\n+    for (const dep of deps) {\n+      if (!indices.has(dep)) {\n+        // If the neighbor hasn't been visited, recursively explore it\n+        strongConnect(dep)\n+        lowlinks.set(v, Math.min(lowlinks.get(v)!, lowlinks.get(dep)!))\n+      } else if (onStack.has(dep)) {\n+        // If the neighbor is on the stack, update the lowlink of the current node\n+        lowlinks.set(v, Math.min(lowlinks.get(v)!, indices.get(dep)!))\n+      }\n+    }\n+\n+    // If the current node is a root node (its lowlink equals its index), it forms an SCC\n+    if (lowlinks.get(v) === indices.get(v)) {\n+      const vertices = new Set<string>()\n+      let w: string | undefined = undefined\n+      // Pop all nodes off the stack until we return to the current node\n+      while (v !== w) {\n+        w = stack.pop()!\n+        onStack.delete(w)\n+        vertices.add(w)\n+      }\n+      // Add the SCC to the result\n+      scc.push(vertices)\n+    }\n+  }\n+\n+  // Start DFS on all nodes that haven't been visited yet\n+  for (const v of graph.keys()) {\n+    if (!indices.has(v)) {\n+      strongConnect(v)\n+    }\n+  }\n+\n+  // Return the list of SCCs\n+  return scc\n+}"
    },
    {
      "sha": "044e513d9711ba0627cecd42afe40ecc7473c9f7",
      "filename": "vitest.workspace.ts",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/vitest.workspace.ts",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/f6c99e949bca319a7b53ff9f2df4f1efdada2cf5/vitest.workspace.ts",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/vitest.workspace.ts?ref=f6c99e949bca319a7b53ff9f2df4f1efdada2cf5",
      "patch": "@@ -1,11 +1,11 @@\n import { defineWorkspace } from 'vitest/config'\n \n export default defineWorkspace([\n-  \"./ui/artalk/vitest.config.ts\",\n-  // \"./docs/landing/vite.config.ts\",\n-  // \"./test/vue-test/vite.config.ts\",\n+  './ui/artalk/vitest.config.ts',\n   // \"./ui/plugin-katex/vite.config.ts\",\n   // \"./ui/plugin-auth/vite.config.ts\",\n   // \"./ui/plugin-lightbox/vite.config.ts\",\n   // \"./ui/artalk-sidebar/vite.config.ts\"\n+  // \"./docs/landing/vite.config.ts\",\n+  // \"./test/vue-test/vite.config.ts\",\n ])"
    }
  ]
}
