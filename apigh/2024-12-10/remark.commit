{
  "sha": "d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
  "node_id": "C_kwDOBtgov9oAKGQ1MTYyZDNmZTZiYTljNjU2ZGIwYjIwNjZkM2UzNzdjOWUxNDRkOTU",
  "commit": {
    "author": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2024-12-10T01:53:00Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2024-12-10T01:53:00Z"
    },
    "message": "Merge pull request #1758 from umputun/paskal/jwt_v5\n\nUpdate to go-pkgz/auth/v2 and golang-jwt/jwt/v5",
    "tree": {
      "sha": "d4860f241a23352a2aaf1215535da6fab94ee4de",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/d4860f241a23352a2aaf1215535da6fab94ee4de"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsFcBAABCAAQBQJnV578CRC1aQ7uu5UhlAAAxFgQAEQtGXVlj7rJ/OG7nyGoufp0\nhP5Mm/pc0O/Fg4wo0+nVKuUf63WZoZzXS8RkqEYhUGLFp8Jp3JZdxX/T1/B8mC52\nel4iBLCS+My/IWgHh6rNwQ5Ms2PBDAPkmeAW3W0wGnyjbSyU8YABDDtkjOttWBsm\ns8Reg4cDD32CZ53TaoNc3gb85f2N45MzQDbZK4UVO9NYw7CnXCwJVBOlVQylDi4e\n9LFvVWOB6x6RYF6xo1nM4MBTg49mT2IRfU78UUbX0Z1qntjU4xjJ4qjRHSxDxXVe\nWbEgF5Wyoq/dhwwzKrgcfiqhuHy0z8jfr5Jweyl4QSBf8XyBk8bcm5UGLOx6erxd\npk7obzxHcAvo91rt4WLziYRboNyMKtHY80+QlPKb2chuaHTQhyHBX7Ywnu2d2PUB\nq2uKIy5u0TjX95o4XzDWwG1FLnY0N5IBDDvncubbp0Q0IF+yc0t7kc5KZa/YnuQH\nHLp435Q5JN4X0w4WJOf01nBqq/hYMyBTnciyf8eu4Xh0qdB//683pYubxO62hNYn\nZCr80sip1A9liMtrA46hoYrGUPFL05WE7dVP35/9oQpTDz3kinU39XV13ZeKmQS/\nWz2kwyOB52rycmSzSmY/k/kSDrCHZhZoe6BrduMSv+mqmvSfXm2Evaioi4MnOrNS\ngNPXp7I/nIe0Etb2VwOo\n=0Ajl\n-----END PGP SIGNATURE-----\n",
      "payload": "tree d4860f241a23352a2aaf1215535da6fab94ee4de\nparent 6402ef9cae790b2361f270c6bcabe26261842064\nparent e61a46efffc57a0c3d278cc131acb68e6f063760\nauthor Umputun <umputun@gmail.com> 1733795580 -0600\ncommitter GitHub <noreply@github.com> 1733795580 -0600\n\nMerge pull request #1758 from umputun/paskal/jwt_v5\n\nUpdate to go-pkgz/auth/v2 and golang-jwt/jwt/v5",
      "verified_at": "2024-12-10T01:53:05Z"
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
  "html_url": "https://github.com/umputun/remark42/commit/d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/comments",
  "author": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6402ef9cae790b2361f270c6bcabe26261842064",
      "url": "https://api.github.com/repos/umputun/remark42/commits/6402ef9cae790b2361f270c6bcabe26261842064",
      "html_url": "https://github.com/umputun/remark42/commit/6402ef9cae790b2361f270c6bcabe26261842064"
    },
    {
      "sha": "e61a46efffc57a0c3d278cc131acb68e6f063760",
      "url": "https://api.github.com/repos/umputun/remark42/commits/e61a46efffc57a0c3d278cc131acb68e6f063760",
      "html_url": "https://github.com/umputun/remark42/commit/e61a46efffc57a0c3d278cc131acb68e6f063760"
    }
  ],
  "stats": {
    "total": 3956,
    "additions": 2127,
    "deletions": 1829
  },
  "files": [
    {
      "sha": "d5a91427ca4bae64d217616b6bc3b47db318287c",
      "filename": "backend/app/cmd/avatar.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Favatar.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Favatar.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Favatar.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -7,7 +7,7 @@ import (\n \tlog \"github.com/go-pkgz/lgr\"\n \tbolt \"go.etcd.io/bbolt\"\n \n-\t\"github.com/go-pkgz/auth/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n )\n \n // AvatarCommand set of flags and command for avatar migration"
    },
    {
      "sha": "a2bc7673a4f5c0566f09376a0ffe1903ce66ac6a",
      "filename": "backend/app/cmd/avatar_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Favatar_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Favatar_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Favatar_test.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -5,7 +5,7 @@ import (\n \t\"os\"\n \t\"testing\"\n \n-\t\"github.com/go-pkgz/auth/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n \t\"github.com/jessevdk/go-flags\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\""
    },
    {
      "sha": "07dd2c3b2809e9f94f01de3540836be6d3fa0179",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 23,
      "deletions": 17,
      "changes": 40,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Fserver.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Fserver.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fserver.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -19,15 +19,15 @@ import (\n \t\"github.com/go-pkgz/lcw/v2/eventbus\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tntf \"github.com/go-pkgz/notify\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \t\"github.com/kyokomi/emoji/v2\"\n \tbolt \"go.etcd.io/bbolt\"\n \n-\t\"github.com/go-pkgz/auth\"\n-\t\"github.com/go-pkgz/auth/avatar\"\n-\t\"github.com/go-pkgz/auth/provider\"\n-\t\"github.com/go-pkgz/auth/provider/sender\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/provider\"\n+\t\"github.com/go-pkgz/auth/v2/provider/sender\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n \tcache \"github.com/go-pkgz/lcw/v2\"\n \n \t\"github.com/umputun/remark42/backend/app/migrator\"\n@@ -1109,10 +1109,10 @@ func (s *ServerCommand) makeNotifyDestinations(authenticator *auth.Service) ([]n\n \t\t\tTokenGenFn: func(userID, email, site string) (string, error) {\n \t\t\t\tclaims := token.Claims{\n \t\t\t\t\tHandshake: &token.Handshake{ID: userID + \"::\" + email},\n-\t\t\t\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\t\t\t\tAudience:  site,\n-\t\t\t\t\t\tExpiresAt: time.Now().Add(100 * 365 * 24 * time.Hour).Unix(),\n-\t\t\t\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\t\t\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\t\t\t\tAudience:  jwt.ClaimStrings{site},\n+\t\t\t\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(100 * 365 * 24 * time.Hour)),\n+\t\t\t\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t\t\t\t\tIssuer:    \"remark42\",\n \t\t\t\t\t},\n \t\t\t\t}\n@@ -1215,10 +1215,16 @@ func (s *ServerCommand) getAuthenticator(ds *service.DataStore, avas avatar.Stor\n \t\t\tif c.User == nil {\n \t\t\t\treturn c\n \t\t\t}\n-\t\t\tc.User.SetAdmin(ds.IsAdmin(c.Audience, c.User.ID))\n-\t\t\tc.User.SetBoolAttr(\"blocked\", ds.IsBlocked(c.Audience, c.User.ID))\n+\t\t\t// Audience is a slice but we set it to a single element, and situation when there is no audience or there are more than one is unexpected\n+\t\t\tif len(c.Audience) != 1 {\n+\t\t\t\treturn c\n+\t\t\t}\n+\t\t\taudience := c.Audience[0]\n+\n+\t\t\tc.User.SetAdmin(ds.IsAdmin(audience, c.User.ID))\n+\t\t\tc.User.SetBoolAttr(\"blocked\", ds.IsBlocked(audience, c.User.ID))\n \t\t\tvar err error\n-\t\t\tc.User.Email, err = ds.GetUserEmail(c.Audience, c.User.ID)\n+\t\t\tc.User.Email, err = ds.GetUserEmail(audience, c.User.ID)\n \t\t\tif err != nil {\n \t\t\t\tlog.Printf(\"[WARN] can't read email for %s, %v\", c.User.ID, err)\n \t\t\t}\n@@ -1350,11 +1356,11 @@ func newAuthRefreshCache() *authRefreshCache {\n }\n \n // Get implements cache getter with key converted to string\n-func (c *authRefreshCache) Get(key interface{}) (interface{}, bool) {\n-\treturn c.LoadingCache.Peek(key.(string))\n+func (c *authRefreshCache) Get(key string) (token.Claims, bool) {\n+\treturn c.LoadingCache.Peek(key)\n }\n \n // Set implements cache setter with key converted to string\n-func (c *authRefreshCache) Set(key, value interface{}) {\n-\t_, _ = c.LoadingCache.Get(key.(string), func() (token.Claims, error) { return value.(token.Claims), nil })\n+func (c *authRefreshCache) Set(key string, value token.Claims) {\n+\t_, _ = c.LoadingCache.Get(key, func() (token.Claims, error) { return value, nil })\n }"
    },
    {
      "sha": "176ba5837e372d3e83e578817d8450b41fa52058",
      "filename": "backend/app/cmd/server_test.go",
      "status": "modified",
      "additions": 26,
      "deletions": 8,
      "changes": 34,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Fserver_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Fcmd%2Fserver_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fserver_test.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -15,8 +15,8 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/go-pkgz/auth/token\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \t\"github.com/jessevdk/go-flags\"\n \t\"go.uber.org/goleak\"\n \n@@ -609,11 +609,11 @@ func TestServerAuthHooks(t *testing.T) {\n \ttkService.TokenDuration = time.Second\n \n \tclaims := token.Claims{\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  \"remark\",\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  jwt.ClaimStrings{\"remark\"},\n \t\t\tIssuer:    \"remark\",\n-\t\t\tExpiresAt: time.Now().Add(time.Second).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Second)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t},\n \t\tUser: &token.User{\n \t\t\tID:   \"github_dev\",\n@@ -639,7 +639,7 @@ func TestServerAuthHooks(t *testing.T) {\n \n \t// try to add comment with no-aud claim\n \tbadClaimsNoAud := claims\n-\tbadClaimsNoAud.Audience = \"\"\n+\tbadClaimsNoAud.Audience = jwt.ClaimStrings{\"\"}\n \ttkNoAud, err := tkService.Token(badClaimsNoAud)\n \trequire.NoError(t, err)\n \tt.Logf(\"no-aud claims: %s\", tkNoAud)\n@@ -655,9 +655,27 @@ func TestServerAuthHooks(t *testing.T) {\n \trequire.NoError(t, resp.Body.Close())\n \tassert.Equal(t, http.StatusUnauthorized, resp.StatusCode, \"user without aud claim rejected, \\n\"+tkNoAud+\"\\n\"+string(body))\n \n+\t// try to add comment with multiple auds\n+\tbadClaimsMultipleAud := claims\n+\tbadClaimsMultipleAud.Audience = jwt.ClaimStrings{\"remark\", \"second_aud\"}\n+\ttkMultipleAuds, err := tkService.Token(badClaimsMultipleAud)\n+\trequire.NoError(t, err)\n+\tt.Logf(\"multiple aud claims: %s\", tkMultipleAuds)\n+\treq, err = http.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/api/v1/comment\", port),\n+\t\tstrings.NewReader(`{\"text\": \"test 123\", \"locator\":{\"url\": \"https://radio-t.com/p/2018/12/29/podcast-631/\",\n+\t\"site\": \"remark\"}}`))\n+\trequire.NoError(t, err)\n+\treq.Header.Set(\"X-JWT\", tkMultipleAuds)\n+\tresp, err = client.Do(req)\n+\trequire.NoError(t, err)\n+\tbody, err = io.ReadAll(resp.Body)\n+\trequire.NoError(t, err)\n+\trequire.NoError(t, resp.Body.Close())\n+\tassert.Equal(t, http.StatusUnauthorized, resp.StatusCode, \"user with multiple auds claim rejected, \\n\"+tkMultipleAuds+\"\\n\"+string(body))\n+\n \t// try to add comment without user set\n \tbadClaimsNoUser := claims\n-\tbadClaimsNoUser.Audience = \"remark\"\n+\tbadClaimsNoUser.Audience = jwt.ClaimStrings{\"remark\"}\n \tbadClaimsNoUser.User = nil\n \ttkNoUser, err := tkService.Token(badClaimsNoUser)\n \trequire.NoError(t, err)"
    },
    {
      "sha": "9b6809a54f87437a2fea712d75c8d3c33799264c",
      "filename": "backend/app/rest/api/admin.go",
      "status": "modified",
      "additions": 12,
      "deletions": 4,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fadmin.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -8,7 +8,7 @@ import (\n \n \t\"github.com/go-chi/chi/v5\"\n \t\"github.com/go-chi/render\"\n-\t\"github.com/go-pkgz/auth\"\n+\t\"github.com/go-pkgz/auth/v2\"\n \tcache \"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n@@ -107,13 +107,21 @@ func (a *admin) deleteMeRequestCtrl(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n-\tif err = a.dataService.DeleteUserDetail(claims.Audience, claims.User.ID, engine.AllUserDetails); err != nil {\n+\t// Audience is a slice but we set it to a single element, and situation when there is no audience or there are more than one is unexpected\n+\tif len(claims.Audience) != 1 {\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"bad request\"), \"can't process token, claims.Audience expected to be a single element but it's not\", rest.ErrActionRejected)\n+\t\treturn\n+\t}\n+\n+\taudience := claims.Audience[0]\n+\n+\tif err = a.dataService.DeleteUserDetail(audience, claims.User.ID, engine.AllUserDetails); err != nil {\n \t\tcode := parseError(err, rest.ErrInternal)\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't delete user details for user\", code)\n \t\treturn\n \t}\n \n-\tif err = a.dataService.DeleteUser(claims.Audience, claims.User.ID, store.HardDelete); err != nil {\n+\tif err = a.dataService.DeleteUser(audience, claims.User.ID, store.HardDelete); err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't delete user\", rest.ErrNoAccess)\n \t\treturn\n \t}\n@@ -126,7 +134,7 @@ func (a *admin) deleteMeRequestCtrl(w http.ResponseWriter, r *http.Request) {\n \t\t}\n \t}\n \n-\ta.cache.Flush(cache.Flusher(claims.Audience).Scopes(claims.Audience, claims.User.ID, lastCommentsScope))\n+\ta.cache.Flush(cache.Flusher(audience).Scopes(audience, claims.User.ID, lastCommentsScope))\n \trender.Status(r, http.StatusOK)\n \trender.JSON(w, r, R.JSON{\"user_id\": claims.User.ID, \"site_id\": claims.Audience})\n }"
    },
    {
      "sha": "6afac8ccce07a9422fe7831b4fd939ccb5883d97",
      "filename": "backend/app/rest/api/admin_test.go",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Fadmin_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Fadmin_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fadmin_test.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -13,10 +13,10 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n \tcache \"github.com/go-pkgz/lcw/v2\"\n \tR \"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n \n@@ -708,12 +708,12 @@ func TestAdmin_DeleteMeRequest(t *testing.T) {\n \n \tclaims := token.Claims{\n \t\tSessionOnly: true,\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  \"remark42\",\n-\t\t\tId:        \"1234567\",\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  jwt.ClaimStrings{\"remark42\"},\n+\t\t\tID:        \"1234567\",\n \t\t\tIssuer:    \"remark42\",\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n \t\t},\n \t\tUser: &token.User{\n \t\t\tID:      \"user1\",\n@@ -777,12 +777,12 @@ func TestAdmin_DeleteMeRequestFailed(t *testing.T) {\n \t// try with bad auth\n \tclaims := token.Claims{\n \t\tSessionOnly: true,\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  \"remark42\",\n-\t\t\tId:        \"provider1_1234567\",\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  jwt.ClaimStrings{\"remark42\"},\n+\t\t\tID:        \"provider1_1234567\",\n \t\t\tIssuer:    \"remark42\",\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n \t\t},\n \t\tUser: &token.User{\n \t\t\tID: \"provider1_user1\",\n@@ -835,7 +835,7 @@ func TestAdmin_DeleteMeRequestFailed(t *testing.T) {\n \n \t// try with wrong audience\n \tbadClaimsMultipleAudience := claims\n-\tbadClaimsMultipleAudience.StandardClaims.Audience = \"something else\"\n+\tbadClaimsMultipleAudience.RegisteredClaims.Audience = jwt.ClaimStrings{\"remark42\", \"something else\"}\n \ttkn, err = srv.Authenticator.TokenService().Token(badClaimsMultipleAudience)\n \tassert.NoError(t, err)\n \treq, err = http.NewRequest(http.MethodGet, fmt.Sprintf(\"%s/api/v1/admin/deleteme?token=%s\", ts.URL, tkn), http.NoBody)\n@@ -847,8 +847,8 @@ func TestAdmin_DeleteMeRequestFailed(t *testing.T) {\n \tb, err = io.ReadAll(resp.Body)\n \tassert.NoError(t, err)\n \tassert.NoError(t, resp.Body.Close())\n-\tassert.Contains(t, string(b), `site \\\"something else\\\" not found`)\n-\tbadClaimsMultipleAudience.StandardClaims.Audience = \"remark42\"\n+\tassert.Contains(t, string(b), \"can't process token, claims.Audience expected to be a single element but it's not\")\n+\tbadClaimsMultipleAudience.RegisteredClaims.Audience = jwt.ClaimStrings{\"remark42\"}\n }\n \n func TestAdmin_GetUserInfo(t *testing.T) {"
    },
    {
      "sha": "5922fc304581c0c1eab1bec5b51ff98b2018b816",
      "filename": "backend/app/rest/api/rest.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -21,7 +21,7 @@ import (\n \t\"github.com/go-chi/chi/v5/middleware\"\n \t\"github.com/go-chi/cors\"\n \t\"github.com/go-chi/render\"\n-\t\"github.com/go-pkgz/auth\"\n+\t\"github.com/go-pkgz/auth/v2\"\n \t\"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\""
    },
    {
      "sha": "cbe957929e48e3c35899d571756413b4b21c3d6a",
      "filename": "backend/app/rest/api/rest_private.go",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_private.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -16,12 +16,12 @@ import (\n \n \t\"github.com/go-chi/chi/v5\"\n \t\"github.com/go-chi/render\"\n-\t\"github.com/go-pkgz/auth\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n \tcache \"github.com/go-pkgz/lcw/v2\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \t\"github.com/hashicorp/go-multierror\"\n \n \t\"github.com/umputun/remark42/backend/app/notify\"\n@@ -362,10 +362,10 @@ func (s *private) sendEmailConfirmationCtrl(w http.ResponseWriter, r *http.Reque\n \n \tclaims := token.Claims{\n \t\tHandshake: &token.Handshake{ID: user.ID + \"::\" + subscribe.Address},\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  r.URL.Query().Get(\"site\"),\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  jwt.ClaimStrings{r.URL.Query().Get(\"site\")},\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t\tIssuer:    \"remark42\",\n \t\t},\n \t}\n@@ -704,11 +704,11 @@ func (s *private) deleteMeCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n \n \tclaims := token.Claims{\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  siteID,\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  jwt.ClaimStrings{siteID},\n \t\t\tIssuer:    \"remark42\",\n-\t\t\tExpiresAt: time.Now().AddDate(0, 3, 0).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().AddDate(0, 3, 0)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t},\n \t\tUser: &token.User{\n \t\t\tID:   user.ID,"
    },
    {
      "sha": "8bdb440d16954bb99be3b2e3e1a8c7a96896325b",
      "filename": "backend/app/rest/api/rest_private_test.go",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -17,10 +17,10 @@ import (\n \t\"time\"\n \n \t\"github.com/go-chi/render\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n \t\"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n \n@@ -861,10 +861,10 @@ func TestRest_EmailAndTelegram(t *testing.T) {\n \t// issue good token\n \tclaims := token.Claims{\n \t\tHandshake: &token.Handshake{ID: \"provider1_dev::good@example.com\"},\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  \"remark42\",\n-\t\t\tExpiresAt: time.Now().Add(10 * time.Minute).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  jwt.ClaimStrings{\"remark42\"},\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(10 * time.Minute)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t\tIssuer:    \"remark42\",\n \t\t},\n \t}"
    },
    {
      "sha": "f5085c1036294a15d252c030e229a4bfc239ad00",
      "filename": "backend/app/rest/api/rest_test.go",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_test.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -16,10 +16,10 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/go-pkgz/auth\"\n-\t\"github.com/go-pkgz/auth/avatar\"\n-\t\"github.com/go-pkgz/auth/provider\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/provider\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n \tcache \"github.com/go-pkgz/lcw/v2\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/stretchr/testify/assert\""
    },
    {
      "sha": "44963333abced7ddd228c61376edc2713e0976af",
      "filename": "backend/app/rest/user.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fuser.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fapp%2Frest%2Fuser.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fuser.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -4,7 +4,7 @@ import (\n \t\"fmt\"\n \t\"net/http\"\n \n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n )"
    },
    {
      "sha": "f13512e113b3ec4ea2670b8409dad37acfc063e4",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fgo.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fgo.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fgo.mod?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -13,15 +13,15 @@ require (\n \tgithub.com/go-chi/chi/v5 v5.1.0\n \tgithub.com/go-chi/cors v1.2.1\n \tgithub.com/go-chi/render v1.0.3\n-\tgithub.com/go-pkgz/auth v1.24.3-0.20241007090635-78537e6f812d\n+\tgithub.com/go-pkgz/auth/v2 v2.0.0-20241208183119-88b3a842be9f\n \tgithub.com/go-pkgz/jrpc v0.3.0\n \tgithub.com/go-pkgz/lcw/v2 v2.0.0\n \tgithub.com/go-pkgz/lgr v0.11.1\n \tgithub.com/go-pkgz/notify v1.2.0\n \tgithub.com/go-pkgz/repeater v1.2.0\n \tgithub.com/go-pkgz/rest v1.19.0\n \tgithub.com/go-pkgz/syncs v1.3.2\n-\tgithub.com/golang-jwt/jwt v3.2.2+incompatible\n+\tgithub.com/golang-jwt/jwt/v5 v5.2.1\n \tgithub.com/google/uuid v1.6.0\n \tgithub.com/gorilla/feeds v1.2.0\n \tgithub.com/hashicorp/go-multierror v1.1.1"
    },
    {
      "sha": "ea26e7b547bb2679a611263110425e4e7c206690",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fgo.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fgo.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fgo.sum?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -60,8 +60,8 @@ github.com/go-chi/render v1.0.3 h1:AsXqd2a1/INaIfUSKq3G5uA8weYx20FOsM7uSoCyyt4=\n github.com/go-chi/render v1.0.3/go.mod h1:/gr3hVkmYR0YlEy3LxCuVRFzEu9Ruok+gFqbIofjao0=\n github.com/go-oauth2/oauth2/v4 v4.5.2 h1:CuZhD3lhGuI6aNLyUbRHXsgG2RwGRBOuCBfd4WQKqBQ=\n github.com/go-oauth2/oauth2/v4 v4.5.2/go.mod h1:wk/2uLImWIa9VVQDgxz99H2GDbhmfi/9/Xr+GvkSUSQ=\n-github.com/go-pkgz/auth v1.24.3-0.20241007090635-78537e6f812d h1:6iwosbIwyRm7k0lprEv5mFWpGg1qQKLWJNHL088+Bcs=\n-github.com/go-pkgz/auth v1.24.3-0.20241007090635-78537e6f812d/go.mod h1:xmnzq6g8mhemW1nHnkuByXkBXsHrNf9/qkiVwJugWIs=\n+github.com/go-pkgz/auth/v2 v2.0.0-20241208183119-88b3a842be9f h1:CDG4Xwk8oq5jFzBtm81vAoB38PgXeUndiSQN/G2vnPA=\n+github.com/go-pkgz/auth/v2 v2.0.0-20241208183119-88b3a842be9f/go.mod h1:aepr8uqw5PKidS+h2sJDvTWbqzyveHDyKNEAznDb3L8=\n github.com/go-pkgz/email v0.5.0 h1:fdtMDGJ8NwyBACLR0LYHaCIK/OeUwZHMhH7Q0+oty9U=\n github.com/go-pkgz/email v0.5.0/go.mod h1:BdxglsQnymzhfdbnncEE72a6DrucZHy6I+42LK2jLEc=\n github.com/go-pkgz/expirable-cache v0.1.0/go.mod h1:GTrEl0X+q0mPNqN6dtcQXksACnzCBQ5k/k1SwXJsZKs=\n@@ -88,6 +88,8 @@ github.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3a\n github.com/golang-jwt/jwt v3.2.1+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=\n github.com/golang-jwt/jwt v3.2.2+incompatible h1:IfV12K8xAKAnZqdXVzCZ+TOjboZ2keLg81eXfW3O+oY=\n github.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=\n+github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=\n+github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=\n github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\n github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\n github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8="
    },
    {
      "sha": "2c09a37228a22cd5b50e58b2747c5b55f793a7b3",
      "filename": "backend/vendor/github.com/go-pkgz/auth/.gitignore",
      "status": "removed",
      "additions": 0,
      "deletions": 15,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2F.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2F.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2F.gitignore?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,15 +0,0 @@\n-# Binaries for programs and plugins\n-*.exe\n-*.exe~\n-*.dll\n-*.so\n-*.dylib\n-\n-# Test binary, build with `go test -c`\n-*.test\n-\n-# Output of the go coverage tool, specifically when used with LiteIDE\n-*.out\n-.vscode\n-*.cov\n-Dockerfile\n\\ No newline at end of file"
    },
    {
      "sha": "eab781a1a3ddcc470ef702bd4d94c3bd85f00afd",
      "filename": "backend/vendor/github.com/go-pkgz/auth/.golangci.yml",
      "status": "removed",
      "additions": 0,
      "deletions": 89,
      "changes": 89,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2F.golangci.yml?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,89 +0,0 @@\n-linters-settings:\n-  govet:\n-    check-shadowing: true\n-  golint:\n-    min-confidence: 0.6\n-  gocyclo:\n-    min-complexity: 15\n-  maligned:\n-    suggest-new: true\n-  dupl:\n-    threshold: 100\n-  goconst:\n-    min-len: 2\n-    min-occurrences: 2\n-  misspell:\n-    locale: US\n-  lll:\n-    line-length: 140\n-  gocritic:\n-    enabled-tags:\n-      - performance\n-      - style\n-      - experimental\n-    disabled-checks:\n-      - wrapperFunc\n-      - hugeParam\n-      - rangeValCopy\n-\n-linters:\n-  disable-all: true\n-  enable:\n-    - megacheck\n-    - revive\n-    - govet\n-    - unconvert\n-    - gas\n-    - misspell\n-    - unused\n-    - typecheck\n-    - ineffassign\n-    - stylecheck\n-    - gochecknoinits\n-    - exportloopref\n-    - nakedret\n-    - gosimple\n-    - prealloc\n-\n-  fast: false\n-\n-\n-run:\n-  #  modules-download-mode: vendor\n-  skip-dirs:\n-    - vendor\n-  concurrency: 4\n-\n-issues:\n-  exclude-rules:\n-    - text: \"should have a package comment, unless it's in another file for this package\"\n-      linters:\n-        - golint\n-    - text: \"exitAfterDefer:\"\n-      linters:\n-        - gocritic\n-    - text: \"whyNoLint: include an explanation for nolint directive\"\n-      linters:\n-        - gocritic\n-    - text: \"go.mongodb.org/mongo-driver/bson/primitive.E\"\n-      linters:\n-        - govet\n-    - text: \"weak cryptographic primitive\"\n-      linters:\n-        - gosec\n-    - text: \"at least one file in a package should have a package comment\"\n-      linters:\n-        - stylecheck\n-    - text: \"should have a package comment\"\n-      linters:\n-        - revive\n-    - text: 'Deferring unsafe method \"Close\" on type \"io.ReadCloser\"'\n-      linters:\n-        - gosec\n-    - linters:\n-        - unparam\n-        - unused\n-        - revive\n-      path: _test\\.go$\n-      text: \"unused-parameter\"\n-  exclude-use-default: false"
    },
    {
      "sha": "9e48ae4ca86a00cef4c53dc00283271097bb6392",
      "filename": "backend/vendor/github.com/go-pkgz/auth/README.md",
      "status": "removed",
      "additions": 0,
      "deletions": 638,
      "changes": 638,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2FREADME.md?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,638 +0,0 @@\n-# auth - authentication via oauth2, direct and email\n-[![Build Status](https://github.com/go-pkgz/auth/workflows/build/badge.svg)](https://github.com/go-pkgz/auth/actions) [![Coverage Status](https://coveralls.io/repos/github/go-pkgz/auth/badge.svg?branch=master)](https://coveralls.io/github/go-pkgz/auth?branch=master) [![godoc](https://godoc.org/github.com/go-pkgz/auth?status.svg)](https://pkg.go.dev/github.com/go-pkgz/auth?tab=doc)\n-\n-This library provides \"social login\" with Github, Google, Facebook, Microsoft, Twitter, Yandex, Battle.net, Apple, Patreon, Discord and Telegram as well as custom auth providers and email verification.\n-\n-- Multiple oauth2 providers can be used at the same time\n-- Special `dev` provider allows local testing and development\n-- JWT stored in a secure cookie with XSRF protection. Cookies can be session-only\n-- Minimal scopes with user name, id and picture (avatar) only\n-- Direct authentication with user's provided credential checker\n-- Verified authentication with user's provided sender (email, im, etc)\n-- Custom oauth2 server and ability to use any third party provider\n-- Integrated avatar proxy with an FS, boltdb and gridfs storage\n-- Support of user-defined storage for avatars\n-- Identicon for default avatars\n-- Black list with user-defined validator\n-- Multiple aud (audience) supported\n-- Secure key with customizable `SecretReader`\n-- Ability to store an extra information to token and retrieve on login\n-- Pre-auth and post-auth hooks to handle custom use cases.\n-- Middleware for easy integration into http routers\n-- Wrappers to extract user info from the request\n-- Role based access control\n-\n-## Install\n-\n-`go get -u github.com/go-pkgz/auth`\n-\n-## Usage\n-\n-Example with chi router:\n-\n-```go\n-\n-func main() {\n-\t// define options\n-\toptions := auth.Opts{\n-\t\tSecretReader: token.SecretFunc(func(id string) (string, error) { // secret key for JWT\n-\t\t\treturn \"secret\", nil\n-\t\t}),\n-\t\tTokenDuration:  time.Minute * 5, // token expires in 5 minutes\n-\t\tCookieDuration: time.Hour * 24,  // cookie expires in 1 day and will enforce re-login\n-\t\tIssuer:         \"my-test-app\",\n-\t\tURL:            \"http://127.0.0.1:8080\",\n-\t\tAvatarStore:    avatar.NewLocalFS(\"/tmp\"),\n-\t\tValidator: token.ValidatorFunc(func(_ string, claims token.Claims) bool {\n-\t\t\t// allow only dev_* names\n-\t\t\treturn claims.User != nil && strings.HasPrefix(claims.User.Name, \"dev_\")\n-\t\t}),\n-\t}\n-\n-\t// create auth service with providers\n-\tservice := auth.NewService(options)\n-\tservice.AddProvider(\"github\", \"<Client ID>\", \"<Client Secret>\")   // add github provider\n-\tservice.AddProvider(\"facebook\", \"<Client ID>\", \"<Client Secret>\") // add facebook provider\n-\n-\t// retrieve auth middleware\n-\tm := service.Middleware()\n-\n-\t// setup http server\n-\trouter := chi.NewRouter()\n-\trouter.Get(\"/open\", openRouteHandler)                      // open api\n-\trouter.With(m.Auth).Get(\"/private\", protectedRouteHandler) // protected api\n-\n-\t// setup auth routes\n-\tauthRoutes, avaRoutes := service.Handlers()\n-\trouter.Mount(\"/auth\", authRoutes)  // add auth handlers\n-\trouter.Mount(\"/avatar\", avaRoutes) // add avatar handler\n-\n-\tlog.Fatal(http.ListenAndServe(\":8080\", router))\n-}\n-```\n-\n-## Middleware\n-\n-`github.com/go-pkgz/auth/middleware` provides ready-to-use middleware.\n-\n-- `middleware.Auth` - requires authenticated user\n-- `middleware.Admin` - requires authenticated admin user\n-- `middleware.Trace` - doesn't require authenticated user, but adds user info to request\n-- `middleware.RBAC` - requires authenticated user with passed role(s)\n-\n-Also, there is a special middleware `middleware.UpdateUser` for population and modifying UserInfo in every request. See \"Customization\" for more details.\n-\n-## Details\n-\n-Generally, adding support of `auth` includes a few relatively simple steps:\n-\n-1. Setup `auth.Opts` structure with all parameters. Each of them [documented](https://github.com/go-pkgz/auth/blob/master/auth.go#L29) and most of parameters are optional and have sane defaults.\n-2. [Create](https://github.com/go-pkgz/auth/blob/master/auth.go#L56) the new `auth.Service` with provided options.\n-3. [Add all](https://github.com/go-pkgz/auth/blob/master/auth.go#L149) desirable authentication providers.\n-4. Retrieve [middleware](https://github.com/go-pkgz/auth/blob/master/auth.go#L144) and [http handlers](https://github.com/go-pkgz/auth/blob/master/auth.go#L105) from `auth.Service`\n-5. Wire auth and avatar handlers into http router as sub–routes.\n-\n-### API\n-\n-For the example above authentication handlers wired as `/auth` and provides:\n-\n-- `/auth/<provider>/login?site=<site_id>&from=<redirect_url>` - site_id used as `aud` claim for the token and can be processed by `SecretReader` to load/retrieve/define different secrets. redirect_url is the url to redirect after successful login.\n-- `/avatar/<avatar_id>` - returns the avatar (image). Links to those pictures added into user info automatically, for details see \"Avatar proxy\"\n-- `/auth/<provider>/logout` and `/auth/logout` - invalidate \"session\" by removing JWT cookie\n-- `/auth/list` - gives a json list of active providers\n-- `/auth/user` - returns `token.User` (json)\n-- `/auth/status` - returns status of logged in user (json)\n-\n-### User info\n-\n-Middleware populates `token.User` to request's context. It can be loaded with `token.GetUserInfo(r *http.Request) (user User, err error)` or `token.MustGetUserInfo(r *http.Request) User` functions.\n-\n-`token.User` object includes all fields retrieved from oauth2 provider:\n-- `Name` - user name\n-- `ID` - hash of user id\n-- `Picture` - full link to proxied avatar (see \"Avatar proxy\")\n-\n-It also has placeholders for fields application can populate with custom `token.ClaimsUpdater` (see \"Customization\")\n-\n-- `IP`  - hash of user's IP address\n-- `Email` - user's email\n-- `Attributes` - map of string:any-value. To simplify management of this map some setters and getters provided, for example `users.StrAttr`, `user.SetBoolAttr` and so on. See [user.go](https://github.com/go-pkgz/auth/blob/master/token/user.go) for more details.\n-\n-### Avatar proxy\n-\n-Direct links to avatars won't survive any real-life usage if they linked from a public page. For example, page [like this](https://remark42.com/demo/) may have hundreds of avatars and, most likely, will trigger throttling on provider's side. To eliminate such restriction `auth` library provides an automatic proxy\n-\n-- On each login the proxy will retrieve user's picture and save it to `AvatarStore`\n-- Local (proxied) link to avatar included in user's info (jwt token)\n-- API for avatar removal provided as a part of `AvatarStore`\n-- User can leverage one of the provided stores:\n-    - `avatar.LocalFS` - file system, each avatar in a separate file\n-    - `avatar.BoltDB`  - single [boltdb](https://go.etcd.io/bbolt) file (embedded KV store).\n-    - `avatar.GridFS` - external [GridFS](https://docs.mongodb.com/manual/core/gridfs/) (mongo db).\n-- In case of need custom implementations of other stores can be passed in and used by `auth` library. Each store has to implement `avatar.Store` [interface](https://github.com/go-pkgz/auth/blob/master/avatar/store.go#L25).\n-- All avatar-related setup done as a part of `auth.Opts` and needs:\n-    - `AvatarStore` - avatar store to use, i.e. `avatar.NewLocalFS(\"/tmp/avatars\")` or more generic `avatar.NewStore(uri)`\n-        - file system uri - `file:///tmp/location` or just `/tmp/location`\n-        - boltdb - `bolt://tmp/avatars.bdb`\n-        - mongo - `\"mongodb://127.0.0.1:27017/test?ava_db=db1&ava_coll=coll1`\n-    - `AvatarRoutePath` - route prefix for direct links to proxied avatar. For example `/api/v1/avatars` will make full links like this - `http://example.com/api/v1/avatars/1234567890123.image`. The url will be stored in user's token and retrieved by middleware (see \"User Info\")\n-    - `AvatarResizeLimit` - size (in pixels) used to resize the avatar. Pls note - resize happens once as a part of `Put` call, i.e. on login. 0 size (default) disables resizing.\n-\n-### Direct authentication\n-\n-In addition to oauth2 providers `auth.Service` allows to use direct user-defined authentication. This is done by adding direct provider with `auth.AddDirectProvider`.\n-\n-```go\n-\tservice.AddDirectProvider(\"local\", provider.CredCheckerFunc(func(user, password string) (ok bool, err error) {\n-\t\tok, err = checkUserSomehow(user, password)\n-\t\treturn ok, err\n-\t}))\n-```\n-\n-Such provider acts like any other, i.e. will be registered as `/auth/local/login`.\n-\n-The API for this provider supports both GET and POST requests:\n-\n-* POST request could be encoded as application/x-www-form-urlencoded or application/json:\n-  ```\n-  POST /auth/<name>/login?session=[1|0]\n-  body: application/x-www-form-urlencoded\n-  user=<user>&passwd=<password>&aud=<site_id>\n-  ```\n-  ```\n-  POST /auth/<name>/login?session=[1|0]\n-  body: application/json\n-  {\n-    \"user\": \"name\",\n-    \"passwd\": \"xyz\",\n-    \"aud\": \"bar\",\n-  }\n-  ```\n-* GET request with user credentials provided as query params, but be aware that [the https query string is not secure](https://stackoverflow.com/a/323286/633961):\n-  ```\n-  GET /auth/<name>/login?user=<user>&passwd=<password>&aud=<site_id>&session=[1|0]\n-  ```\n-\n-_note: password parameter doesn't have to be naked/real password and can be any kind of password hash prepared by caller._\n-\n-### Verified authentication\n-\n-Another non-oauth2 provider allowing user-confirmed authentication, for example by email or slack or telegram. This is\n-done by adding confirmed provider with `auth.AddVerifProvider`.\n-\n-```go\n-    msgTemplate := \"Confirmation email, token: {{.Token}}\"\n-\tservice.AddVerifProvider(\"email\", msgTemplate, sender)\n-```\n-\n-Message template may use the follow elements:\n-\n-- `{{.Address}}` - user address, for example email\n-- `{{.User}}` - user name\n-- `{{.Token}}` - confirmation token\n-- `{{.Site}}` - site ID\n-\n-Sender should be provided by end-user and implements a single function interface\n-\n-```go\n-type Sender interface {\n-\tSend(address string, text string) error\n-}\n-```\n-\n-For convenience a functional wrapper `SenderFunc` provided. Email sender provided in `provider/sender` package and can be\n-used as `Sender`.\n-\n-The API for this provider:\n-\n- - `GET /auth/<name>/login?user=<user>&address=<address>&aud=<site_id>&from=<url>` - send confirmation request to user\n- - `GET /auth/<name>/login?token=<conf.token>&sess=[1|0]` - authorize with confirmation token\n-\n-The provider acts like any other, i.e. will be registered as `/auth/email/login`.\n-\n-### Email\n-\n-For email notify provider, please use `github.com/go-pkgz/auth/provider/sender` package:\n-```go\n-\tsndr := sender.NewEmailClient(sender.EmailParams{\n-\t\tHost:               \"email.hostname\",\n-\t\tPort:               567,\n-\t\tSMTPUserName:       \"username\",\n-\t\tSMTPPassword:       \"pass\",\n-\t\tStartTLS:           true,\n-\t\tInsecureSkipVerify: false,\n-\t\tFrom:               \"notify@email.hostname\",\n-\t\tSubject:            \"subject\",\n-\t\tContentType:        \"text/html\",\n-\t\tCharset:            \"UTF-8\",\n-\t}, log.Default())\n-\tauthenticator.AddVerifProvider(\"email\", \"template goes here\", sndr)\n-```\n-\n-See [that documentation](https://github.com/go-pkgz/email#options) for full options list.\n-\n-### Telegram\n-\n-Telegram provider allows your users to log in with Telegram account. First, you will need to create your bot.\n-Contact [@BotFather](https://t.me/botfather) and follow his instructions to create your own bot (call it, for example, \"My site auth bot\")\n-\n-Next initialize TelegramHandler with following parameters:\n-* `ProviderName` - Any unique name to distinguish between providers\n-* `SuccessMsg` - Message sent to user on successfull authentication\n-* `ErrorMsg` - Message sent on errors (e.g. login request expired)\n-* `Telegram` - Telegram API implementation. Use provider.NewTelegramAPI with following arguments\n-\t1. The secret token bot father gave you\n-\t2. An http.Client for accessing Telegram API's\n-\n-```go\n-token := os.Getenv(\"TELEGRAM_TOKEN\")\n-\n-telegram := provider.TelegramHandler{\n-\tProviderName: \"telegram\",\n-\tErrorMsg:     \"❌ Invalid auth request. Please try clicking link again.\",\n-\tSuccessMsg:   \"✅ You have successfully authenticated!\",\n-\tTelegram:     provider.NewTelegramAPI(token, http.DefaultClient),\n-\n-\tL:            log.Default(),\n-\tTokenService: service.TokenService(),\n-\tAvatarSaver:  service.AvatarProxy(),\n-}\n-```\n-\n-After that run provider and register it's handlers:\n-```go\n-// Run Telegram provider in the background\n-go func() {\n-\terr := telegram.Run(context.Background())\n-\tif err != nil {\n-\t\tlog.Fatalf(\"[PANIC] failed to start telegram: %v\", err)\n-\t}\n-}()\n-\n-// Register Telegram provider\n-service.AddCustomHandler(&telegram)\n-```\n-\n-Now all your users have to do is click one of the following links and press **start**\n-`tg://resolve?domain=<botname>&start=<token>` or `https://t.me/<botname>/?start=<token>`\n-\n-Use the following routes to interact with provider:\n-1. `/auth/<providerName>/login` - Obtain auth token. Returns JSON object with `bot` (bot username) and `token` (token itself) fields.\n-2. `/auth/<providerName>/login?token=<token>` - Check if auth request has been confirmed (i.e. user pressed start). Sets session cookie and returns user info on success, errors with 404 otherwise.\n-\n-3. `/auth/<providerName>/logout` - Invalidate user session.\n-\n-### Custom oauth2\n-\n-This provider brings two extra functions:\n-\n-1. Adds ability to use any third-party oauth2 providers in addition to the list of directly supported. Included [example](https://github.com/go-pkgz/auth/blob/master/_example/main.go#L113) demonstrates how to do it for bitbucket.\n-In order to add a new oauth2 provider following input is required:\n-\t* `Name` - any name is allowed except the names from list of supported providers. It is possible to register more than one client for one given oauth2 provider (for example using different names `bitbucket_dev` and `bitbucket_prod`)\n-\t* `Client` - ID and secret of client\n-\t* `Endpoint` - auth URL and token URL. This information could be obtained from auth2 provider page\n-\t* `InfoURL` - oauth2 provider API method to read information of logged in user. This method could be found in documentation of oauth2 provider (e.g. for bitbucket https://developer.atlassian.com/bitbucket/api/2/reference/resource/user)\n-\t* `MapUserFn` - function to convert the response from `InfoURL` to `token.User` (s. example below)\n-\t* `Scopes` - minimal needed scope to read user information. Client should be authorized to these scopes\n-\t```go\n-\tc := auth.Client{\n-\t\tCid:     os.Getenv(\"AEXMPL_BITBUCKET_CID\"),\n-\t\tCsecret: os.Getenv(\"AEXMPL_BITBUCKET_CSEC\"),\n-\t}\n-\n-\tservice.AddCustomProvider(\"bitbucket\", c, provider.CustomHandlerOpt{\n-\t\tEndpoint: oauth2.Endpoint{\n-\t\t\tAuthURL:  \"https://bitbucket.org/site/oauth2/authorize\",\n-\t\t\tTokenURL: \"https://bitbucket.org/site/oauth2/access_token\",\n-\t\t},\n-\t\tInfoURL: \"https://api.bitbucket.org/2.0/user/\",\n-\t\tMapUserFn: func(data provider.UserData, _ []byte) token.User {\n-\t\t\tuserInfo := token.User{\n-\t\t\t\tID: \"bitbucket_\" + token.HashID(sha1.New(),\n-\t\t\t\t\tdata.Value(\"username\")),\n-\t\t\t\tName: data.Value(\"nickname\"),\n-\t\t\t}\n-\t\t\treturn userInfo\n-\t\t},\n-\t\tScopes: []string{\"account\"},\n-\t})\n-\t```\n-2.  Adds local oauth2 server user can fully customize. It uses [`gopkg.in/oauth2.v3`](https://github.com/go-oauth2/oauth2) library and example shows how [to initialize](https://github.com/go-pkgz/auth/blob/master/_example/main.go#L227) the server and [setup a provider](https://github.com/go-pkgz/auth/blob/master/_example/main.go#L100).\n-\t*  to start local oauth2 server following options are required:\n-\t\t* `URL` - url of oauth2 server with port\n-\t\t* `WithLoginPage` - flag to define whether login page should be shown\n-\t\t* `LoginPageHandler` - function to handle login request. If not specified default login page will be shown\n-\t\t```go\n-\t\tsopts := provider.CustomServerOpt{\n-\t\t\tURL:           \"http://127.0.0.1:9096\",\n-\t\t\tL:             options.Logger,\n-\t\t\tWithLoginPage: true,\n-\t\t}\n-\t\tprov := provider.NewCustomServer(srv, sopts)\n-\n-\t\t// Start server\n-\t\tgo prov.Run(context.Background())\n-\t\t```\n-\t* to register handler for local oauth2 following option are required:\n-\t\t* `Name` - any name except the names from list of supported providers\n-\t\t* `Client` - ID and secret of client\n-\t\t* `HandlerOpt` - handler options of custom oauth provider\n-\t\t```go\n-\t\tservice.AddCustomProvider(\"custom123\", auth.Client{Cid: \"cid\", Csecret: \"csecret\"}, prov.HandlerOpt)\n-\t\t```\n-\n-### Self-implemented auth handler\n-Additionally it is possible to implement own auth handler. It may be useful if auth provider does not conform to oauth standard. Self-implemented handler has to implement `provider.Provider` interface.\n-```go\n-// customHandler implements provider.Provider interface\n-c := customHandler{}\n-\n-// add customHandler to stack of auth handlers\n-service.AddCustomHandler(c)\n-```\n-\n-### Customization\n-\n-There are several ways to adjust functionality of the library:\n-\n-1. `SecretReader` - interface with a single method `Get(aud string) string` to return the secret used for JWT signing and verification\n-1. `ClaimsUpdater` - interface with `Update(claims Claims) Claims` method. This is the primary way to alter a token at login time and add any attributes, set ip, email, admin status, roles and so on.\n-1. `Validator` - interface with `Validate(token string, claims Claims) bool` method. This is post-token hook and will be called on **each request** wrapped with `Auth` middleware. This will be the place for special logic to reject some tokens or users.\n-1. `UserUpdater` - interface with `Update(claims token.User) token.User` method.  This method will be called on **each request** wrapped with `UpdateUser` middleware. This will be the place for special logic modify User Info in request context. [Example of usage.](https://github.com/go-pkgz/auth/blob/19c1b6d26608494955a4480f8f6165af85b1deab/_example/main.go#L189)\n-\n-All of the interfaces above have corresponding Func adapters - `SecretFunc`, `ClaimsUpdFunc`, `ValidatorFunc` and `UserUpdFunc`.\n-\n-### Implementing black list logic or some other filters\n-\n-Restricting some users or some tokens is two step process:\n-\n-- `ClaimsUpdater` sets an attribute, like `blocked` (or `allowed`)\n-- `Validator` checks the attribute and returns true/false\n-\n-_This technique used in the [example](https://github.com/go-pkgz/auth/blob/master/_example/main.go#L56) code_\n-\n-The process can be simplified by doing all checks directly in `Validator`, but depends on particular case such solution\n-can be too expensive because `Validator` runs on each request as a part of auth middleware. In contrast, `ClaimsUpdater` called on token creation/refresh only.\n-\n-### Multi-tenant services and support for different audiences\n-\n-For complex systems a single authenticator may serve multiple distinct subsystems or multiple set of independent users. For example some SaaS offerings may need to provide different authentications for different customers and prevent use of tokens/cookies made by another customer.\n-\n-Such functionality can be implemented in 3 different ways:\n-\n-- Different instances of `auth.Service` each one with different secret. Doing this way will ensure the highest level of isolation and cookies/tokens won't be even parsable across the instances. Practically such architecture can be too complicated and not always possible.\n-– Handling \"allowed audience\" as a part of `ClaimsUpdater` and `Validator` chain. I.e. `ClaimsUpdater` sets a claim indicating expected audience code/id and `Validator` making sure it matches. This way a single `auth.Service` could handle multiple groups of auth tokens and reject some based on the audience.\n-- Using the standard JWT `aud` claim. This method conceptually very similar to the previous one, but done by library internally and consumer don't need to define special  `ClaimsUpdater` and `Validator` logic.\n-\n-In order to allow `aud` support the list of allowed audiences should be passed in as `opts.Audiences` parameter. Non-empty value will trigger internal checks for token generation (will reject token creation for alien `aud`) as well as `Auth` middleware.\n-\n-### Dev provider\n-\n-Working with oauth2 providers can be a pain, especially during development phase. A special, development-only provider `dev` can make it less painful. This one can be registered directly, i.e. `service.AddProvider(\"dev\", \"\", \"\")` or `service.AddDevProvider(port)` and should be activated like this:\n-\n-```go\n-\t// runs dev oauth2 server on :8084 by default\n-\tgo func() {\n-\t\tdevAuthServer, err := service.DevAuth()\n-\t\tif err != nil {\n-\t\t\tlog.Fatal(err)\n-\t\t}\n-\t\tdevAuthServer.Run()\n-\t}()\n-```\n-\n-It will run fake aouth2 \"server\" on port :8084 and user could login with any user name. See [example](https://github.com/go-pkgz/auth/blob/master/_example/main.go) for more details.\n-\n-_Warning: this is not the real oauth2 server but just a small fake thing for development and testing only. Don't use `dev` provider with any production code._\n-\n-By default, Dev provider doesn't return `email` claim from `/user` endpoint, to match behaviour of other providers which only request minimal scopes.\n-However sometimes it is useful to have `email` included into user info. This can be done by configuring `devAuthServer.GetEmailFn` function:\n-\n-```go\n-    go func() {\n-\t\tdevAuthServer, err := service.DevAuth()\n-\t\tdevOauth2Srv.GetEmailFn = func(username string) string {\n-\t\t\treturn username + \"@example.com\"\n-\t\t}\n-\t\tif err != nil {\n-\t\t\tlog.Fatal(err)\n-\t\t}\n-\t\tdevAuthServer.Run()\n-\t}()\n-```\n-\n-### Other ways to authenticate\n-\n-In addition to the primary method (i.e. JWT cookie with XSRF header) there are two more ways to authenticate:\n-\n-1. Send JWT header as `X-JWT`. This shouldn't be used for web application, however can be helpful for service-to-service authentication.\n-2. Send JWT token as query parameter, i.e. `/something?token=<jwt>`\n-3. Basic access authentication, for more details see below [Basic authentication](#basic-authentication).\n-\n-### Basic authentication\n-\n-In some cases the `middleware.Authenticator` allow use  [Basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), which transmits credentials as user-id/password pairs, encoded using Base64 ([RFC7235](https://tools.ietf.org/html/rfc7617)).\n-When basic authentication used, client doesn't get auth token in response. It's auth type expect credentials in a header `Authorization` at every client request. It can be helpful, if client side not support cookie/token store (e.g. embedded device or custom apps).\n-This mode disabled by default and will be enabled with options.\n-\n-The `auth` package has two options of basic authentication:\n-- simple basic auth will be enabled if `Opts.AdminPasswd` defined. This will allow access with basic auth admin:<Opts.AdminPasswd> with user [admin](https://github.com/go-pkgz/auth/blob/master/middleware/auth.go#L24). Such method can be used for automation scripts.\n-- basic auth with custom checker [function](https://github.com/go-pkgz/auth/blob/master/middleware/auth.go#L47), which allow adding user data from store to context of request.  It will be enabled if `Opts.BasicAuthChecker` defined. When `BasicAuthChecker` defined then `Opts.AdminPasswd` option will be ignore.\n-```go\n-options := auth.Opts{\n-   //...\n-   AdminPasswd:    \"admin_secret_password\", // will ignore if BasicAuthChecker defined\n-   BasicAuthChecker: func(user, passwd string) (bool, token.User, error) {\n-      if user == \"basic_user\" && passwd == \"123456\" {\n-           return true, token.User{Name: user, Role: \"test_r\"}, nil\n-      }\n-      return false, token.User{}, errors.New(\"basic auth credentials check failed\")\n-   }\n-   //...\n-}\n-```\n-### Logging\n-\n-By default, this library doesn't print anything to stdout/stderr, however user can pass a logger implementing `logger.L` interface with a single method `Logf(format string, args ...interface{})`. Functional adapter for this interface included as `logger.Func`. There are two predefined implementations in the `logger` package - `NoOp` (prints nothing, default) and `Std` wrapping `log.Printf` from stdlib.\n-\n-## Register oauth2 providers\n-\n-Authentication handled by external providers. You should setup oauth2 for all (or some) of them to allow users to authenticate. It is not mandatory to have all of them, but at least one should be correctly configured.\n-\n-#### Google Auth Provider\n-\n-1.  Create a new project: https://console.developers.google.com/project\n-2.  Choose the new project from the top right project dropdown (only if another project is selected)\n-3.  In the project Dashboard center pane, choose **\"API Manager\"**\n-4.  In the left Nav pane, choose **\"Credentials\"**\n-5. In the center pane, choose the **\"OAuth consent screen\"** tab.\n-  * Select \"**External**\" and click \"Create\"\n-  * Fill in **\"App name\"** and select **User support email**\n-  * Upload a logo, if you want to\n-  * In the **App Domain** section:\n-    * **Application home page** - your site URL, e.g., `https://mysite.com`\n-    * **Application privacy policy link** - `/web/privacy.html` of your Remark42 installation, e.g. `https://remark42.mysite.com/web/privacy.html` (please check that it works)\n-    * **Terms of service** - leave empty\n-  * **Authorized domains** - your site domain, e.g., `mysite.com`\n-  * **Developer contact information** - add your email, and then click **Save and continue**\n-  * On the **Scopes** tab, just click **Save and continue**\n-  * On the **Test users**, add your email, then click **Save and continue**\n-  * Before going to the next step, set the app to \"Production\" and send it to verification\n-6. In the center pane, choose the **\"Credentials\"** tab\n-   * Open the **\"Create credentials\"** drop-down\n-   * Choose **\"OAuth client ID\"**\n-   * Choose **\"Web application\"**\n-   * Application **Name** is freeform; choose something appropriate, like \"Comments on mysite.com\"\n-   * **Authorized JavaScript Origins** should be your domain, e.g., `https://remark42.mysite.com`\n-   * **Authorized redirect URIs** is the location of OAuth2/callback constructed as domain + `/auth/google/callback`, e.g., `https://remark42.mysite.com/auth/google/callback`\n-   * Click **\"Create\"**\n-7.  Take note of the **Client ID** and **Client Secret**\n-\n-_instructions for google oauth2 setup borrowed from [oauth2_proxy](https://github.com/bitly/oauth2_proxy)_\n-\n-#### Microsoft Auth Provider\n-\n-1. Register a new application [using the Azure portal](https://docs.microsoft.com/en-us/graph/auth-register-app-v2).\n-2. Under **\"Authentication/Platform configurations/Web\"** enter the correct url constructed as domain + `/auth/microsoft/callback`. i.e. `https://example.mysite.com/auth/microsoft/callback`\n-3. In \"Overview\" take note of the **Application (client) ID**\n-4. Choose the new project from the top right project dropdown (only if another project is selected)\n-5.  Select \"Certificates & secrets\" and click on \"+ New Client Secret\".\n-\n-\n-#### GitHub Auth Provider\n-\n-1.  Create a new **\"OAuth App\"**: https://github.com/settings/developers\n-1.  Fill **\"Application Name\"** and **\"Homepage URL\"** for your site\n-1.  Under **\"Authorization callback URL\"** enter the correct url constructed as domain + `/auth/github/callback`. ie `https://example.mysite.com/auth/github/callback`\n-1.  Take note of the **Client ID** and **Client Secret**\n-\n-#### Facebook Auth Provider\n-\n-1.  From https://developers.facebook.com select **\"My Apps\"** / **\"Add a new App\"**\n-1.  Set **\"Display Name\"** and **\"Contact email\"**\n-1.  Choose **\"Facebook Login\"** and then **\"Web\"**\n-1.  Set \"Site URL\" to your domain, ex: `https://example.mysite.com`\n-1.  Under **\"Facebook login\"** / **\"Settings\"** fill \"Valid OAuth redirect URIs\" with your callback url constructed as domain + `/auth/facebook/callback`\n-1.  Select **\"App Review\"** and turn public flag on. This step may ask you to provide a link to your privacy policy.\n-\n-\n-#### Apple Auth Provider\n-\n-To configure this provider, a user requires an Apple developer account (without it setting up a sign in with Apple is impossible). [Sign in with Apple](https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api) lets users log in to your app using their two-factor authentication Apple ID.\n-\n-Follow to next steps for configuring on the Apple side:\n-\n-1. Log in [to the developer account](https://developer.apple.com/account).\n-1. If you don't have an App ID yet, [create one](https://developer.apple.com/account/resources/identifiers/add/bundleId). Later on, you'll need **TeamID**, which is an \"App ID Prefix\" value.\n-1. Enable the \"Sign in with Apple\" capability for your App ID in [the Certificates, Identifiers & Profiles](https://developer.apple.com/account/resources/identifiers/list) section.\n-1. Create [Service ID](https://developer.apple.com/account/resources/identifiers/list/serviceId) and bind with App ID from the previous step. Apple will display the description field value to end-users on sign-in. You'll need that service **Identifier as a ClientID** later on**.**\n-1. Configure \"Sign in with Apple\" for created Service ID. Add domain where you will use that auth on to \"Domains and subdomains\" and its main page URL (like `https://example.com/` to \"Return URLs\".\n-1. Register a [New Key](https://developer.apple.com/account/resources/authkeys/list) (private key) for the \"Sign in with Apple\" feature and download it. Write down the **Key ID**. This key will be used to create [JWT](https://developer.apple.com/documentation/sign_in_with_apple/generate_and_validate_tokens#3262048) Client Secret.\n-1. Add your domain name and sender email in the Certificates, Identifiers & Profiles >> [More](https://developer.apple.com/account/resources/services/configure) section as a new Email Source.\n-\n-After completing the previous steps, you can proceed with configuring the Apple auth provider. Here are the parameters for AppleConfig:\n-\n-- _ClientID_ (**required**) - Service ID (or App ID) which is used for Sign with Apple\n-- _TeamID_ (**required**) - Identifier a developer account (use as prefix for all App ID)\n-- _KeyID_ (**required**) - Identifier a generated key for Sign with Apple\n-- _ResponseMode_  - Response Mode, please see [documentation](https://developer.apple.com/documentation/sign_in_with_apple/request_an_authorization_to_the_sign_in_with_apple_server?changes=_1_2#4066168) for reference, default is `form_post`\n-\n-```go\n-    // apple config parameters\n-\tappleCfg := provider.AppleConfig{\n-\t\tTeamID:   os.Getenv(\"AEXMPL_APPLE_TID\"), // developer account identifier\n-\t\tClientID: os.Getenv(\"AEXMPL_APPLE_CID\"), // Service ID (or App ID)\n-\t\tKeyID:    os.Getenv(\"AEXMPL_APPLE_KEYID\"), // private key identifier\n-\t}\n-```\n-\n-Then add an Apple provider that accepts the following parameters:\n-* `appleConfig (provider.AppleConfig)`  created above\n-* `privateKeyLoader (PrivateKeyLoaderInterface)`\n-\n-`PrivateKeyLoaderInterface` [implements](https://github.com/go-pkgz/auth/blob/master/provider/apple.go#L98:L100) a loader for the private key (which you downloaded above) to create a `client_secret`. The user can use a pre-defined function `provider.LoadApplePrivateKeyFromFile(filePath string)` to load the private key from local file.\n-\n-`AddAppleProvide` tries to load private key at call and return an error if load failed. Always check error when calling this provider.\n-\n-```go\n-    if err := service.AddAppleProvider(appleCfg, provider.LoadApplePrivateKeyFromFile(\"PATH_TO_PRIVATE_KEY_FILE\")); err != nil {\n-\t\tlog.Fatalf(\"[ERROR] failed create to AppleProvider: %v\", err)\n-\t}\n-```\n-\n-**Limitation:**\n-\n-* Map a userName (if specific scope defined) is only sent in the upon initial user sign up.\n-  Subsequent logins to your app using Sign In with Apple with the same account do not share any user info and will only return a user identifier in IDToken claims.\n-  This behaves correctly until a user delete sign in for you service with Apple ID in own Apple account profile (security section).\n-  It is recommend that you securely cache the at first login containing the user info for bind it with a user UID at next login.\n-  Provider always get user `UID` (`sub` claim) in `IDToken`.\n-\n-* Apple doesn't have an API for fetch avatar and user info.\n-\n-See [example](https://github.com/go-pkgz/auth/blob/master/_example/main.go#L83:L93) before use.\n-\n-#### Yandex Auth Provider\n-\n-1.  Create a new **\"OAuth App\"**: https://oauth.yandex.com/client/new\n-1.  Fill **\"App name\"** for your site\n-1.  Under **Platforms** select **\"Web services\"** and enter **\"Callback URI #1\"** constructed as domain + `/auth/yandex/callback`. ie `https://example.mysite.com/auth/yandex/callback`\n-1.  Select **Permissions**. You need following permissions only from the **\"Yandex.Passport API\"** section:\n-    * Access to user avatar\n-    * Access to username, first name and surname, gender\n-1.  Fill out the rest of fields if needed\n-1.  Take note of the **ID** and **Password**\n-\n-For more details refer to [Yandex OAuth](https://tech.yandex.com/oauth/doc/dg/concepts/about-docpage/) and [Yandex.Passport](https://tech.yandex.com/passport/doc/dg/index-docpage/) API documentation.\n-\n-##### Battle.net Auth Provider\n-\n-1. Log into Battle.net as a developer: https://develop.battle.net/nav/login-redirect\n-1.  Click \"+ CREATE CLIENT\" https://develop.battle.net/access/clients/create\n-1. For \"Client name\", enter whatever you want\n-1. For \"Redirect URLs\", one of the lines must be \"http\\[s\\]://your_remark_installation:port//auth/battlenet/callback\", e.g. https://localhost:8443/auth/battlenet/callback or https://remark.mysite.com/auth/battlenet/callback\n-1. For \"Service URL\", enter the URL to your site or check \"I do not have a service URL for this client.\" checkbox if you don't have any\n-1. For \"Intended use\", describe the application you're developing\n-1. Click \"Save\".\n-1. You can see your client ID and client secret at https://develop.battle.net/access/clients by clicking the client you created\n-\n-For more details refer to [Complete Guide of Battle.net OAuth API and Login Button](https://hakanu.net/oauth/2017/01/26/complete-guide-of-battle-net-oauth-api-and-login-button/) or [the official Battle.net OAuth2 guide](https://develop.battle.net/documentation/guides/using-oauth)\n-\n-#### Patreon Auth Provider ####\n-1.\tCreate a new Patreon client https://www.patreon.com/portal/registration/register-clients\n-1.  Fill **\"App Name\"**, **\"Description\"**, **\"App Category\"** and **\"Author\"** for your site\n-1.  Under **\"Redirect URIs\"** enter the correct url constructed as domain + `/auth/patreon/callback`. ie `https://example.mysite.com/auth/patreon/callback`\n-1.  Take note of the **Client ID** and **Client Secret**\n-\n-#### Discord Auth Provider ####\n-1.  Log into Discord Developer Portal https://discord.com/developers/applications\n-2.  Click on **New Application** to create the application required for Oauth\n-3.  After filling **\"NAME\"**, navigate to **\"OAuth2\"** option on the left sidebar\n-4.  Under **\"Redirects\"** enter the correct url constructed as domain + `/auth/discord/callback`. ie `https://remark42.mysite.com/auth/discord/callback`\n-5.  Take note of the **CLIENT ID** and **CLIENT SECRET**\n-\n-#### Twitter Auth Provider\n-1.\tCreate a new twitter application https://developer.twitter.com/en/apps\n-1.\tFill **App name**  and **Description** and **URL** of your site\n-1.\tIn the field **Callback URLs** enter the correct url of your callback handler e.g. https://example.mysite.com/{route}/twitter/callback\n-1.\tUnder **Key and tokens** take note of the **Consumer API Key** and **Consumer API Secret key**. Those will be used as `cid` and `csecret`\n-\n-## XSRF Protections\n-By default, the XSRF protections will apply to all requests which reach the `middlewares.Auth`,\n-`middlewares.Admin` or `middlewares.RBAC` middlewares. This will require setting a request header \n-with a key of `<XSRFHeaderKey>` containing the value of the cookie named `<XSRFCookieName>`.\n-\n-To disable all XSRF protections, set `DisableXSRF` to `true`. This should probably only be used \n-during testing or debugging.\n-\n-When setting a custom request header is not possible, such as when building a web application which\n-is not a Single-Page-Application and HTML link tags are used to navigate pages, specific HTTP methods\n-may be excluded using the `XSRFIgnoreMethods` option. For example, to disable GET requests, set this\n-option to `XSRFIgnoreMethods: []string{\"GET\"}`. Adding methods other than GET to this list may result\n-in XSRF vulnerabilities.\n-\n-## Status\n-\n-The library extracted from [remark42](https://github.com/umputun/remark) project. The original code in production use on multiple sites and seems to work fine.\n-\n-`go-pkgz/auth` library still in development and until version 1 released some breaking changes possible."
    },
    {
      "sha": "c1b684bfdd131c354389d84f2b103eba2eaf9536",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/LICENSE",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2FLICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2FLICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2FLICENSE?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/LICENSE"
    },
    {
      "sha": "4245ac4c12a722af47c8814007fc24de4bc532ee",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/auth.go",
      "status": "renamed",
      "additions": 24,
      "deletions": 23,
      "changes": 47,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fauth.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fauth.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fauth.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -9,11 +9,11 @@ import (\n \n \t\"github.com/go-pkgz/rest\"\n \n-\t\"github.com/go-pkgz/auth/avatar\"\n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/middleware\"\n-\t\"github.com/go-pkgz/auth/provider\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/middleware\"\n+\t\"github.com/go-pkgz/auth/v2/provider\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // Client is a type of auth client\n@@ -99,24 +99,25 @@ func NewService(opts Opts) (res *Service) {\n \t}\n \n \tjwtService := token.NewService(token.Opts{\n-\t\tSecretReader:    opts.SecretReader,\n-\t\tClaimsUpd:       opts.ClaimsUpd,\n-\t\tSecureCookies:   opts.SecureCookies,\n-\t\tTokenDuration:   opts.TokenDuration,\n-\t\tCookieDuration:  opts.CookieDuration,\n-\t\tDisableXSRF:     opts.DisableXSRF,\n-\t\tDisableIAT:      opts.DisableIAT,\n-\t\tJWTCookieName:   opts.JWTCookieName,\n-\t\tJWTCookieDomain: opts.JWTCookieDomain,\n-\t\tJWTHeaderKey:    opts.JWTHeaderKey,\n-\t\tXSRFCookieName:  opts.XSRFCookieName,\n-\t\tXSRFHeaderKey:   opts.XSRFHeaderKey,\n-\t\tSendJWTHeader:   opts.SendJWTHeader,\n-\t\tJWTQuery:        opts.JWTQuery,\n-\t\tIssuer:          res.issuer,\n-\t\tAudienceReader:  opts.AudienceReader,\n-\t\tAudSecrets:      opts.AudSecrets,\n-\t\tSameSite:        opts.SameSiteCookie,\n+\t\tSecretReader:      opts.SecretReader,\n+\t\tClaimsUpd:         opts.ClaimsUpd,\n+\t\tSecureCookies:     opts.SecureCookies,\n+\t\tTokenDuration:     opts.TokenDuration,\n+\t\tCookieDuration:    opts.CookieDuration,\n+\t\tDisableXSRF:       opts.DisableXSRF,\n+\t\tDisableIAT:        opts.DisableIAT,\n+\t\tJWTCookieName:     opts.JWTCookieName,\n+\t\tJWTCookieDomain:   opts.JWTCookieDomain,\n+\t\tJWTHeaderKey:      opts.JWTHeaderKey,\n+\t\tXSRFCookieName:    opts.XSRFCookieName,\n+\t\tXSRFHeaderKey:     opts.XSRFHeaderKey,\n+\t\tXSRFIgnoreMethods: opts.XSRFIgnoreMethods,\n+\t\tSendJWTHeader:     opts.SendJWTHeader,\n+\t\tJWTQuery:          opts.JWTQuery,\n+\t\tIssuer:            res.issuer,\n+\t\tAudienceReader:    opts.AudienceReader,\n+\t\tAudSecrets:        opts.AudSecrets,\n+\t\tSameSite:          opts.SameSiteCookie,\n \t})\n \n \tif opts.SecretReader == nil {",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/auth.go"
    },
    {
      "sha": "a1d749a6210fdef5ca2ba797678818144cc33dbb",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/avatar/avatar.go",
      "status": "renamed",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Favatar.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Favatar.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Favatar.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -19,8 +19,8 @@ import (\n \t\"github.com/rrivera/identicon\"\n \t\"golang.org/x/image/draw\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // http.sniffLen is 512 bytes which is how much we need to read to detect content type",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/avatar/avatar.go"
    },
    {
      "sha": "001f214a9e3520dcb1ce540d21fd3996adc33f15",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/avatar/bolt.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fbolt.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fbolt.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fbolt.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/avatar/bolt.go"
    },
    {
      "sha": "fc6e2fb13ac74bf976d9a5eaa80e9151bb4e9715",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/avatar/gridfs.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fgridfs.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fgridfs.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fgridfs.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/avatar/gridfs.go"
    },
    {
      "sha": "ee4828c0c097034aa49925b2a59dcf08e6cb3c00",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/avatar/localfs.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Flocalfs.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Flocalfs.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Flocalfs.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/avatar/localfs.go"
    },
    {
      "sha": "560bcfc1d40b58c940b217886417bdaf52bb98d0",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/avatar/noop.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fnoop.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fnoop.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fnoop.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/avatar/noop.go"
    },
    {
      "sha": "cd2a38151fb2c5c6511d3af9b29382d117217cd7",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/avatar/store.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fstore.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fstore.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Favatar%2Fstore.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -19,7 +19,7 @@ import (\n \t\"go.mongodb.org/mongo-driver/mongo\"\n \t\"go.mongodb.org/mongo-driver/mongo/options\"\n \n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // imgSfx for avatars",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/avatar/store.go"
    },
    {
      "sha": "857243184e6203e9c47238a0e3798c015d3e8b1e",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/logger/interface.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Flogger%2Finterface.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Flogger%2Finterface.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Flogger%2Finterface.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/logger/interface.go"
    },
    {
      "sha": "6e8c5ed8e66222c77d8f783247716407dd0383f0",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/middleware/auth.go",
      "status": "renamed",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fmiddleware%2Fauth.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fmiddleware%2Fauth.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fmiddleware%2Fauth.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -10,9 +10,9 @@ import (\n \t\"net/http\"\n \t\"strings\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/provider\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/provider\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // Authenticator is top level auth object providing middlewares\n@@ -28,8 +28,8 @@ type Authenticator struct {\n \n // RefreshCache defines interface storing and retrieving refreshed tokens\n type RefreshCache interface {\n-\tGet(key interface{}) (value interface{}, ok bool)\n-\tSet(key, value interface{})\n+\tGet(key string) (value token.Claims, ok bool)\n+\tSet(key string, value token.Claims)\n }\n \n // TokenService defines interface accessing tokens\n@@ -173,11 +173,11 @@ func (a *Authenticator) refreshExpiredToken(w http.ResponseWriter, claims token.\n \tif a.RefreshCache != nil {\n \t\tif c, ok := a.RefreshCache.Get(tkn); ok {\n \t\t\t// already in cache\n-\t\t\treturn c.(token.Claims), nil\n+\t\t\treturn c, nil\n \t\t}\n \t}\n \n-\tclaims.ExpiresAt = 0                  // this will cause now+duration for refreshed token\n+\tclaims.ExpiresAt = nil                // this will cause now+duration for refreshed token\n \tc, err := a.JWTService.Set(w, claims) // Set changes token\n \tif err != nil {\n \t\treturn token.Claims{}, err",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/middleware/auth.go"
    },
    {
      "sha": "1103703bebd902c13a87610331b76c9064dee276",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/middleware/user_updater.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fmiddleware%2Fuser_updater.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fmiddleware%2Fuser_updater.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fmiddleware%2Fuser_updater.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -3,7 +3,7 @@ package middleware\n import (\n \t\"net/http\"\n \n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // UserUpdater defines interface adding extras or modifying UserInfo in request context",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/middleware/user_updater.go"
    },
    {
      "sha": "4a2fbcd0cf15a977573488ad9d85be1496db45b5",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/apple.go",
      "status": "renamed",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fapple.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fapple.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fapple.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -24,10 +24,10 @@ import (\n \t\"golang.org/x/oauth2\"\n \n \t\"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n const (\n@@ -41,7 +41,7 @@ const (\n \tappleRequestContentType = \"application/x-www-form-urlencoded\"\n \n \t// UserAgent required to every request to Apple REST API\n-\tdefaultUserAgent = \"github.com/go-pkgz/auth\"\n+\tdefaultUserAgent = \"github.com/go-pkgz/auth/v2\"\n \n \t// AcceptJSONHeader is the content to accept from response\n \tAcceptJSONHeader = \"application/json\"\n@@ -261,11 +261,11 @@ func (ah *AppleHandler) LoginHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\tFrom:  r.URL.Query().Get(\"from\"),\n \t\t},\n \t\tSessionOnly: r.URL.Query().Get(\"session\") != \"\" && r.URL.Query().Get(\"session\") != \"0\",\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tId:        cid,\n-\t\t\tAudience:  r.URL.Query().Get(\"site\"),\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tID:        cid,\n+\t\t\tAudience:  jwt.ClaimStrings{r.URL.Query().Get(\"site\")},\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t},\n \t}\n \n@@ -370,9 +370,9 @@ func (ah AppleHandler) AuthHandler(w http.ResponseWriter, r *http.Request) {\n \n \tclaims := token.Claims{\n \t\tUser: &u,\n-\t\tStandardClaims: jwt.StandardClaims{\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n \t\t\tIssuer:   ah.Issuer,\n-\t\t\tId:       cid,\n+\t\t\tID:       cid,\n \t\t\tAudience: oauthClaims.Audience,\n \t\t},\n \t\tSessionOnly: false,\n@@ -467,13 +467,13 @@ func (ah *AppleHandler) createClientSecret() (string, error) {\n \t}\n \t// Create a claims\n \tnow := time.Now()\n-\texp := now.Add(time.Minute * 30).Unix() // default value\n+\texp := now.Add(time.Minute * 30) // default value\n \n-\tclaims := &jwt.StandardClaims{\n+\tclaims := &jwt.RegisteredClaims{\n \t\tIssuer:    ah.conf.TeamID,\n-\t\tIssuedAt:  now.Unix(),\n-\t\tExpiresAt: exp,\n-\t\tAudience:  \"https://appleid.apple.com\",\n+\t\tIssuedAt:  jwt.NewNumericDate(now),\n+\t\tExpiresAt: jwt.NewNumericDate(exp),\n+\t\tAudience:  []string{\"https://appleid.apple.com\"},\n \t\tSubject:   ah.conf.ClientID,\n \t}\n ",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/apple.go"
    },
    {
      "sha": "364503dd558df01fefd429de5b1081f89197dae2",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/apple_pubkeys.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fapple_pubkeys.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fapple_pubkeys.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fapple_pubkeys.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -16,7 +16,7 @@ import (\n \t\"net/http\"\n \t\"time\"\n \n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n )\n \n // appleKeysURL is the endpoint URL for fetch Apple’s public key",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/apple_pubkeys.go"
    },
    {
      "sha": "d77a59412ad74fb7774b445ae71397766cf92d48",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/custom_server.go",
      "status": "renamed",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fcustom_server.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fcustom_server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fcustom_server.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -15,9 +15,9 @@ import (\n \tgoauth2 \"github.com/go-oauth2/oauth2/v4/server\"\n \t\"golang.org/x/oauth2\"\n \n-\t\"github.com/go-pkgz/auth/avatar\"\n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // CustomHandlerOpt are options to initialize a handler for oauth2 server",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/custom_server.go"
    },
    {
      "sha": "136877a2be358fffd82c19578cea405206342d3c",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/dev_provider.go",
      "status": "renamed",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fdev_provider.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fdev_provider.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fdev_provider.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -11,9 +11,9 @@ import (\n \n \t\"golang.org/x/oauth2\"\n \n-\t\"github.com/go-pkgz/auth/avatar\"\n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n const (",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/dev_provider.go"
    },
    {
      "sha": "7d940177070b470752bc5e4eea3955091ac673b3",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/direct.go",
      "status": "renamed",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fdirect.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fdirect.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fdirect.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -9,10 +9,10 @@ import (\n \t\"time\"\n \n \t\"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n const (\n@@ -120,10 +120,10 @@ func (p DirectHandler) LoginHandler(w http.ResponseWriter, r *http.Request) {\n \n \tclaims := token.Claims{\n \t\tUser: &u,\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tId:       cid,\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tID:       cid,\n \t\t\tIssuer:   p.Issuer,\n-\t\t\tAudience: creds.Audience,\n+\t\t\tAudience: []string{creds.Audience},\n \t\t},\n \t\tSessionOnly: sessOnly,\n \t}",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/direct.go"
    },
    {
      "sha": "6a51b0da67d73b264eabda88422b5b329b0118bd",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/oauth1.go",
      "status": "renamed",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Foauth1.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Foauth1.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Foauth1.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -10,10 +10,10 @@ import (\n \n \t\"github.com/dghubble/oauth1\"\n \t\"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // Oauth1Handler implements /login, /callback and /logout handlers for oauth1 flow\n@@ -55,11 +55,11 @@ func (h Oauth1Handler) LoginHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\tFrom:  r.URL.Query().Get(\"from\"),\n \t\t},\n \t\tSessionOnly: r.URL.Query().Get(\"session\") != \"\" && r.URL.Query().Get(\"session\") != \"0\",\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tId:        cid,\n-\t\t\tAudience:  r.URL.Query().Get(\"site\"),\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tID:        cid,\n+\t\t\tAudience:  []string{r.URL.Query().Get(\"site\")},\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t},\n \t}\n \n@@ -140,9 +140,9 @@ func (h Oauth1Handler) AuthHandler(w http.ResponseWriter, r *http.Request) {\n \t}\n \tclaims := token.Claims{\n \t\tUser: &u,\n-\t\tStandardClaims: jwt.StandardClaims{\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n \t\t\tIssuer:   h.Issuer,\n-\t\t\tId:       cid,\n+\t\t\tID:       cid,\n \t\t\tAudience: oauthClaims.Audience,\n \t\t},\n \t\tSessionOnly: oauthClaims.SessionOnly,",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/oauth1.go"
    },
    {
      "sha": "a985cd98a9df999ef169d36131adf449c114dee1",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/oauth2.go",
      "status": "renamed",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Foauth2.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Foauth2.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Foauth2.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -10,11 +10,11 @@ import (\n \t\"time\"\n \n \t\"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \t\"golang.org/x/oauth2\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // Oauth2Handler implements /login, /callback and /logout handlers from aouth2 flow\n@@ -111,11 +111,11 @@ func (p Oauth2Handler) LoginHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\tFrom:  r.URL.Query().Get(\"from\"),\n \t\t},\n \t\tSessionOnly: r.URL.Query().Get(\"session\") != \"\" && r.URL.Query().Get(\"session\") != \"0\",\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tId:        cid,\n-\t\t\tAudience:  aud,\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tID:        cid,\n+\t\t\tAudience:  []string{aud},\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t},\n \t\tNoAva: r.URL.Query().Get(\"noava\") == \"1\",\n \t}\n@@ -208,9 +208,9 @@ func (p Oauth2Handler) AuthHandler(w http.ResponseWriter, r *http.Request) {\n \t}\n \tclaims := token.Claims{\n \t\tUser: &u,\n-\t\tStandardClaims: jwt.StandardClaims{\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n \t\t\tIssuer:   p.Issuer,\n-\t\t\tId:       cid,\n+\t\t\tID:       cid,\n \t\t\tAudience: oauthClaims.Audience,\n \t\t},\n \t\tSessionOnly: oauthClaims.SessionOnly,",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/oauth2.go"
    },
    {
      "sha": "471fa312f94b699dd248e5a6cf061f90da7c3802",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/providers.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fproviders.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fproviders.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fproviders.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -8,7 +8,7 @@ import (\n \n \t\"github.com/dghubble/oauth1\"\n \t\"github.com/dghubble/oauth1/twitter\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n \t\"golang.org/x/oauth2\"\n \t\"golang.org/x/oauth2/facebook\"\n \t\"golang.org/x/oauth2/github\"",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/providers.go"
    },
    {
      "sha": "b70a71d41633db34b52544c87580616c4f7bba1a",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/sender/email.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fsender%2Femail.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fsender%2Femail.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fsender%2Femail.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -4,7 +4,7 @@ package sender\n import (\n \t\"time\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n \t\"github.com/go-pkgz/email\"\n )\n ",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/sender/email.go"
    },
    {
      "sha": "f085b5f2a0101afb287baef7b549bb1daaeee104",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/service.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fservice.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fservice.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fservice.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -7,7 +7,7 @@ import (\n \t\"net/http\"\n \t\"strings\"\n \n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n const (",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/service.go"
    },
    {
      "sha": "906fe59f9a8acc5fbfc04e9e05bdc489249ac492",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/telegram.go",
      "status": "renamed",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Ftelegram.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Ftelegram.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Ftelegram.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -17,10 +17,10 @@ import (\n \n \t\"github.com/go-pkgz/repeater\"\n \t\"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \n-\t\"github.com/go-pkgz/auth/logger\"\n-\tauthtoken \"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\tauthtoken \"github.com/go-pkgz/auth/v2/token\"\n )\n \n // TelegramHandler implements login via telegram\n@@ -302,12 +302,12 @@ func (th *TelegramHandler) LoginHandler(w http.ResponseWriter, r *http.Request)\n \n \tclaims := authtoken.Claims{\n \t\tUser: &u,\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  r.URL.Query().Get(\"site\"),\n-\t\t\tId:        queryToken,\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  []string{r.URL.Query().Get(\"site\")},\n+\t\t\tID:        queryToken,\n \t\t\tIssuer:    th.ProviderName,\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t},\n \t\tSessionOnly: false, // TODO review?\n \t}",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/telegram.go"
    },
    {
      "sha": "0fc9ca6e9ead3e0c35739f46d347288daf34ecab",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/provider/verify.go",
      "status": "renamed",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fverify.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fverify.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Fprovider%2Fverify.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -10,11 +10,11 @@ import (\n \t\"time\"\n \n \t\"github.com/go-pkgz/rest\"\n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n \n-\t\"github.com/go-pkgz/auth/avatar\"\n-\t\"github.com/go-pkgz/auth/logger\"\n-\t\"github.com/go-pkgz/auth/token\"\n+\t\"github.com/go-pkgz/auth/v2/avatar\"\n+\t\"github.com/go-pkgz/auth/v2/logger\"\n+\t\"github.com/go-pkgz/auth/v2/token\"\n )\n \n // VerifyHandler implements non-oauth2 provider authorizing users with some confirmation.\n@@ -111,8 +111,8 @@ func (e VerifyHandler) LoginHandler(w http.ResponseWriter, r *http.Request) {\n \n \tclaims := token.Claims{\n \t\tUser: &u,\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tId:       cid,\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tID:       cid,\n \t\t\tIssuer:   e.Issuer,\n \t\t\tAudience: confClaims.Audience,\n \t\t},\n@@ -146,10 +146,10 @@ func (e VerifyHandler) sendConfirmation(w http.ResponseWriter, r *http.Request)\n \t\t\tID:    user + \"::\" + address,\n \t\t},\n \t\tSessionOnly: r.URL.Query().Get(\"session\") != \"\" && r.URL.Query().Get(\"session\") != \"0\",\n-\t\tStandardClaims: jwt.StandardClaims{\n-\t\t\tAudience:  site,\n-\t\t\tExpiresAt: time.Now().Add(30 * time.Minute).Unix(),\n-\t\t\tNotBefore: time.Now().Add(-1 * time.Minute).Unix(),\n+\t\tRegisteredClaims: jwt.RegisteredClaims{\n+\t\t\tAudience:  []string{site},\n+\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(30 * time.Minute)),\n+\t\t\tNotBefore: jwt.NewNumericDate(time.Now().Add(-1 * time.Minute)),\n \t\t\tIssuer:    e.Issuer,\n \t\t},\n \t}",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/provider/verify.go"
    },
    {
      "sha": "bb2ea58266144008bcacd8b1dd56882e94fc5e70",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/token/jwt.go",
      "status": "renamed",
      "additions": 53,
      "deletions": 24,
      "changes": 77,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Ftoken%2Fjwt.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Ftoken%2Fjwt.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Ftoken%2Fjwt.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -3,13 +3,15 @@ package token\n \n import (\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"net/http\"\n \t\"slices\"\n \t\"strings\"\n+\t\"sync\"\n \t\"time\"\n \n-\t\"github.com/golang-jwt/jwt\"\n+\t\"github.com/golang-jwt/jwt/v5\"\n )\n \n // Service wraps jwt operations\n@@ -20,7 +22,7 @@ type Service struct {\n \n // Claims stores user info for token and state & from from login\n type Claims struct {\n-\tjwt.StandardClaims\n+\tjwt.RegisteredClaims\n \tUser        *User      `json:\"user,omitempty\"` // user info\n \tSessionOnly bool       `json:\"sess_only,omitempty\"`\n \tHandshake   *Handshake `json:\"handshake,omitempty\"` // used for oauth handshake\n@@ -80,6 +82,11 @@ type Opts struct {\n \n // NewService makes JWT service\n func NewService(opts Opts) *Service {\n+\tvar once sync.Once\n+\tonce.Do(func() {\n+\t\tjwt.MarshalSingleStringAsArray = false\n+\t})\n+\n \tres := Service{Opts: opts}\n \n \tsetDefault := func(fld *string, def string) {\n@@ -97,7 +104,7 @@ func NewService(opts Opts) *Service {\n \tsetDefault(&res.JWTCookieDomain, defaultJWTCookieDomain)\n \n \tif opts.XSRFIgnoreMethods == nil {\n-\t\topts.XSRFIgnoreMethods = defaultXSRFIgnoreMethods\n+\t\tres.XSRFIgnoreMethods = defaultXSRFIgnoreMethods\n \t}\n \n \tif opts.TokenDuration == 0 {\n@@ -131,7 +138,7 @@ func (j *Service) Token(claims Claims) (string, error) {\n \t\treturn \"\", fmt.Errorf(\"aud rejected: %w\", err)\n \t}\n \n-\tsecret, err := j.SecretReader.Get(claims.Audience) // get secret via consumer defined SecretReader\n+\tsecret, err := j.SecretReader.Get(claims.Audience[0]) // get secret via consumer defined SecretReader\n \tif err != nil {\n \t\treturn \"\", fmt.Errorf(\"can't get secret: %w\", err)\n \t}\n@@ -145,7 +152,7 @@ func (j *Service) Token(claims Claims) (string, error) {\n \n // Parse token string and verify. Not checking for expiration\n func (j *Service) Parse(tokenString string) (Claims, error) {\n-\tparser := jwt.Parser{SkipClaimsValidation: true} // allow parsing of expired tokens\n+\tparser := jwt.NewParser(jwt.WithoutClaimsValidation())\n \n \tif j.SecretReader == nil {\n \t\treturn Claims{}, fmt.Errorf(\"secret reader not defined\")\n@@ -189,7 +196,7 @@ func (j *Service) Parse(tokenString string) (Claims, error) {\n // aud pre-parse token and extracts aud from the claim\n // important! this step ignores token verification, should not be used for any validations\n func (j *Service) aud(tokenString string) (string, error) {\n-\tparser := jwt.Parser{}\n+\tparser := jwt.NewParser()\n \ttoken, _, err := parser.ParseUnverified(tokenString, &Claims{})\n \tif err != nil {\n \t\treturn \"\", fmt.Errorf(\"can't pre-parse token: %w\", err)\n@@ -198,42 +205,52 @@ func (j *Service) aud(tokenString string) (string, error) {\n \tif !ok {\n \t\treturn \"\", fmt.Errorf(\"invalid token\")\n \t}\n-\tif strings.TrimSpace(claims.Audience) == \"\" {\n+\n+\tif len(claims.Audience) == 0 {\n+\t\treturn \"\", fmt.Errorf(\"empty aud\")\n+\t}\n+\taud := claims.Audience[0]\n+\n+\tif strings.TrimSpace(aud) == \"\" {\n \t\treturn \"\", fmt.Errorf(\"empty aud\")\n \t}\n-\treturn claims.Audience, nil\n+\treturn aud, nil\n }\n \n func (j *Service) validate(claims *Claims) error {\n-\tcerr := claims.Valid()\n+\tvalidator := jwt.NewValidator()\n+\terr := validator.Validate(claims)\n \n-\tif cerr == nil {\n+\tif err == nil {\n \t\treturn nil\n \t}\n \n-\tif e, ok := cerr.(*jwt.ValidationError); ok {\n-\t\tif e.Errors == jwt.ValidationErrorExpired {\n-\t\t\treturn nil // allow expired tokens\n+\t// Ignore \"ErrTokenExpired\" if it is the only error.\n+\tif errors.Is(err, jwt.ErrTokenExpired) {\n+\t\tif uw, ok := err.(interface{ Unwrap() []error }); ok && len(uw.Unwrap()) == 1 {\n+\t\t\treturn nil\n \t\t}\n \t}\n \n-\treturn cerr\n+\treturn err\n }\n \n // Set creates token cookie with xsrf cookie and put it to ResponseWriter\n // accepts claims and sets expiration if none defined. permanent flag means long-living cookie,\n // false makes it session only.\n func (j *Service) Set(w http.ResponseWriter, claims Claims) (Claims, error) {\n-\tif claims.ExpiresAt == 0 {\n-\t\tclaims.ExpiresAt = time.Now().Add(j.TokenDuration).Unix()\n+\tnowUnix := time.Now().Unix()\n+\n+\tif claims.ExpiresAt == nil || claims.ExpiresAt.Time.Unix() == 0 {\n+\t\tclaims.ExpiresAt = jwt.NewNumericDate(time.Unix(nowUnix, 0).Add(j.TokenDuration))\n \t}\n \n \tif claims.Issuer == \"\" {\n \t\tclaims.Issuer = j.Issuer\n \t}\n \n \tif !j.DisableIAT {\n-\t\tclaims.IssuedAt = time.Now().Unix()\n+\t\tclaims.IssuedAt = jwt.NewNumericDate(time.Unix(nowUnix, 0))\n \t}\n \n \ttokenString, err := j.Token(claims)\n@@ -255,7 +272,7 @@ func (j *Service) Set(w http.ResponseWriter, claims Claims) (Claims, error) {\n \t\tMaxAge: cookieExpiration, Secure: j.SecureCookies, SameSite: j.SameSite}\n \thttp.SetCookie(w, &jwtCookie)\n \n-\txsrfCookie := http.Cookie{Name: j.XSRFCookieName, Value: claims.Id, HttpOnly: false, Path: \"/\", Domain: j.JWTCookieDomain,\n+\txsrfCookie := http.Cookie{Name: j.XSRFCookieName, Value: claims.ID, HttpOnly: false, Path: \"/\", Domain: j.JWTCookieDomain,\n \t\tMaxAge: cookieExpiration, Secure: j.SecureCookies, SameSite: j.SameSite}\n \thttp.SetCookie(w, &xsrfCookie)\n \n@@ -296,7 +313,10 @@ func (j *Service) Get(r *http.Request) (Claims, string, error) {\n \n \t// promote claim's aud to User.Audience\n \tif claims.User != nil {\n-\t\tclaims.User.Audience = claims.Audience\n+\t\tif len(claims.Audience) != 1 {\n+\t\t\treturn Claims{}, \"\", fmt.Errorf(\"aud is not of size 1\")\n+\t\t}\n+\t\tclaims.User.Audience = claims.Audience[0]\n \t}\n \n \tif !fromCookie && j.IsExpired(claims) {\n@@ -309,7 +329,7 @@ func (j *Service) Get(r *http.Request) (Claims, string, error) {\n \n \tif fromCookie && claims.User != nil {\n \t\txsrf := r.Header.Get(j.XSRFHeaderKey)\n-\t\tif claims.Id != xsrf {\n+\t\tif claims.ID != xsrf {\n \t\t\treturn Claims{}, \"\", fmt.Errorf(\"xsrf mismatch\")\n \t\t}\n \t}\n@@ -319,7 +339,9 @@ func (j *Service) Get(r *http.Request) (Claims, string, error) {\n \n // IsExpired returns true if claims expired\n func (j *Service) IsExpired(claims Claims) bool {\n-\treturn !claims.VerifyExpiresAt(time.Now().Unix(), true)\n+\tvalidator := jwt.NewValidator(jwt.WithExpirationRequired())\n+\terr := validator.Validate(claims)\n+\treturn errors.Is(err, jwt.ErrTokenExpired)\n }\n \n // Reset token's cookies\n@@ -337,25 +359,32 @@ func (j *Service) Reset(w http.ResponseWriter) {\n \n // checkAuds verifies if claims.Audience in the list of allowed by audReader\n func (j *Service) checkAuds(claims *Claims, audReader Audience) error {\n+\t// marshal the audience.\n \tif audReader == nil { // lack of any allowed means any\n \t\treturn nil\n \t}\n+\n+\tif len(claims.Audience) == 0 {\n+\t\treturn fmt.Errorf(\"no audience provided\")\n+\t}\n+\tclaimsAudience := claims.Audience[0]\n+\n \tauds, err := audReader.Get()\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to get auds: %w\", err)\n \t}\n \tfor _, a := range auds {\n-\t\tif strings.EqualFold(a, claims.Audience) {\n+\t\tif strings.EqualFold(a, claimsAudience) {\n \t\t\treturn nil\n \t\t}\n \t}\n-\treturn fmt.Errorf(\"aud %q not allowed\", claims.Audience)\n+\treturn fmt.Errorf(\"aud %q not allowed\", claimsAudience)\n }\n \n func (c Claims) String() string {\n \tb, err := json.Marshal(c)\n \tif err != nil {\n-\t\treturn fmt.Sprintf(\"%+v %+v\", c.StandardClaims, c.User)\n+\t\treturn fmt.Sprintf(\"%+v %+v\", c.RegisteredClaims, c.User)\n \t}\n \treturn string(b)\n }",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/token/jwt.go"
    },
    {
      "sha": "cc9875f79fbe14a9726a7b5ce960553a2184f7b8",
      "filename": "backend/vendor/github.com/go-pkgz/auth/v2/token/user.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Ftoken%2Fuser.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Ftoken%2Fuser.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fv2%2Ftoken%2Fuser.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/go-pkgz/auth/token/user.go"
    },
    {
      "sha": "c4efbd2a8c5db15a7eed3a49dde179cede90db21",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/MIGRATION_GUIDE.md",
      "status": "removed",
      "additions": 0,
      "deletions": 22,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2FMIGRATION_GUIDE.md",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2FMIGRATION_GUIDE.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2FMIGRATION_GUIDE.md?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,22 +0,0 @@\n-## Migration Guide (v3.2.1)\n-\n-Starting from [v3.2.1](https://github.com/golang-jwt/jwt/releases/tag/v3.2.1]), the import path has changed from `github.com/dgrijalva/jwt-go` to `github.com/golang-jwt/jwt`. Future releases will be using the `github.com/golang-jwt/jwt` import path and continue the existing versioning scheme of `v3.x.x+incompatible`. Backwards-compatible patches and fixes will be done on the `v3` release branch, where as new build-breaking features will be developed in a `v4` release, possibly including a SIV-style import path.\n-\n-### go.mod replacement\n-\n-In a first step, the easiest way is to use `go mod edit` to issue a replacement.\n-\n-```\n-go mod edit -replace github.com/dgrijalva/jwt-go=github.com/golang-jwt/jwt@v3.2.1+incompatible\n-go mod tidy\n-```\n-\n-This will still keep the old import path in your code but replace it with the new package and also introduce a new indirect dependency to `github.com/golang-jwt/jwt`. Try to compile your project; it should still work.\n-\n-### Cleanup\n-\n-If your code still consistently builds, you can replace all occurences of `github.com/dgrijalva/jwt-go` with `github.com/golang-jwt/jwt`, either manually or by using tools such as `sed`. Finally, the `replace` directive in the `go.mod` file can be removed.\n-\n-## Older releases (before v3.2.0)\n-\n-The original migration guide for older releases can be found at https://github.com/dgrijalva/jwt-go/blob/master/MIGRATION_GUIDE.md.\n\\ No newline at end of file"
    },
    {
      "sha": "9b653e46b013629b8b3fd793fdbfc9ec0bb8c13c",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/README.md",
      "status": "removed",
      "additions": 0,
      "deletions": 113,
      "changes": 113,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2FREADME.md?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,113 +0,0 @@\n-# jwt-go\n-\n-[![build](https://github.com/golang-jwt/jwt/actions/workflows/build.yml/badge.svg)](https://github.com/golang-jwt/jwt/actions/workflows/build.yml)\n-[![Go Reference](https://pkg.go.dev/badge/github.com/golang-jwt/jwt.svg)](https://pkg.go.dev/github.com/golang-jwt/jwt)\n-\n-A [go](http://www.golang.org) (or 'golang' for search engine friendliness) implementation of [JSON Web Tokens](https://datatracker.ietf.org/doc/html/rfc7519).\n-\n-**IMPORT PATH CHANGE:** Starting from [v3.2.1](https://github.com/golang-jwt/jwt/releases/tag/v3.2.1), the import path has changed from `github.com/dgrijalva/jwt-go` to `github.com/golang-jwt/jwt`. After the original author of the library suggested migrating the maintenance of `jwt-go`, a dedicated team of open source maintainers decided to clone the existing library into this repository. See [dgrijalva/jwt-go#462](https://github.com/dgrijalva/jwt-go/issues/462) for a detailed discussion on this topic.\n-\n-Future releases will be using the `github.com/golang-jwt/jwt` import path and continue the existing versioning scheme of `v3.x.x+incompatible`. Backwards-compatible patches and fixes will be done on the `v3` release branch, where as new build-breaking features will be developed in a `v4` release, possibly including a SIV-style import path.\n-\n-**SECURITY NOTICE:** Some older versions of Go have a security issue in the crypto/elliptic. Recommendation is to upgrade to at least 1.15 See issue [dgrijalva/jwt-go#216](https://github.com/dgrijalva/jwt-go/issues/216) for more detail.\n-\n-**SECURITY NOTICE:** It's important that you [validate the `alg` presented is what you expect](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/). This library attempts to make it easy to do the right thing by requiring key types match the expected alg, but you should take the extra step to verify it in your usage.  See the examples provided.\n-\n-### Supported Go versions\n-\n-Our support of Go versions is aligned with Go's [version release policy](https://golang.org/doc/devel/release#policy).\n-So we will support a major version of Go until there are two newer major releases.\n-We no longer support building jwt-go with unsupported Go versions, as these contain security vulnerabilities\n-which will not be fixed.\n-\n-## What the heck is a JWT?\n-\n-JWT.io has [a great introduction](https://jwt.io/introduction) to JSON Web Tokens.\n-\n-In short, it's a signed JSON object that does something useful (for example, authentication).  It's commonly used for `Bearer` tokens in Oauth 2.  A token is made of three parts, separated by `.`'s.  The first two parts are JSON objects, that have been [base64url](https://datatracker.ietf.org/doc/html/rfc4648) encoded.  The last part is the signature, encoded the same way.\n-\n-The first part is called the header.  It contains the necessary information for verifying the last part, the signature.  For example, which encryption method was used for signing and what key was used.\n-\n-The part in the middle is the interesting bit.  It's called the Claims and contains the actual stuff you care about.  Refer to [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519) for information about reserved keys and the proper way to add your own.\n-\n-## What's in the box?\n-\n-This library supports the parsing and verification as well as the generation and signing of JWTs.  Current supported signing algorithms are HMAC SHA, RSA, RSA-PSS, and ECDSA, though hooks are present for adding your own.\n-\n-## Examples\n-\n-See [the project documentation](https://pkg.go.dev/github.com/golang-jwt/jwt) for examples of usage:\n-\n-* [Simple example of parsing and validating a token](https://pkg.go.dev/github.com/golang-jwt/jwt#example-Parse-Hmac)\n-* [Simple example of building and signing a token](https://pkg.go.dev/github.com/golang-jwt/jwt#example-New-Hmac)\n-* [Directory of Examples](https://pkg.go.dev/github.com/golang-jwt/jwt#pkg-examples)\n-\n-## Extensions\n-\n-This library publishes all the necessary components for adding your own signing methods.  Simply implement the `SigningMethod` interface and register a factory method using `RegisterSigningMethod`.  \n-\n-Here's an example of an extension that integrates with multiple Google Cloud Platform signing tools (AppEngine, IAM API, Cloud KMS): https://github.com/someone1/gcp-jwt-go\n-\n-## Compliance\n-\n-This library was last reviewed to comply with [RTF 7519](https://datatracker.ietf.org/doc/html/rfc7519) dated May 2015 with a few notable differences:\n-\n-* In order to protect against accidental use of [Unsecured JWTs](https://datatracker.ietf.org/doc/html/rfc7519#section-6), tokens using `alg=none` will only be accepted if the constant `jwt.UnsafeAllowNoneSignatureType` is provided as the key.\n-\n-## Project Status & Versioning\n-\n-This library is considered production ready.  Feedback and feature requests are appreciated.  The API should be considered stable.  There should be very few backwards-incompatible changes outside of major version updates (and only with good reason).\n-\n-This project uses [Semantic Versioning 2.0.0](http://semver.org).  Accepted pull requests will land on `main`.  Periodically, versions will be tagged from `main`.  You can find all the releases on [the project releases page](https://github.com/golang-jwt/jwt/releases).\n-\n-While we try to make it obvious when we make breaking changes, there isn't a great mechanism for pushing announcements out to users.  You may want to use this alternative package include: `gopkg.in/golang-jwt/jwt.v3`.  It will do the right thing WRT semantic versioning.\n-\n-**BREAKING CHANGES:*** \n-* Version 3.0.0 includes _a lot_ of changes from the 2.x line, including a few that break the API.  We've tried to break as few things as possible, so there should just be a few type signature changes.  A full list of breaking changes is available in `VERSION_HISTORY.md`.  See `MIGRATION_GUIDE.md` for more information on updating your code.\n-\n-## Usage Tips\n-\n-### Signing vs Encryption\n-\n-A token is simply a JSON object that is signed by its author. this tells you exactly two things about the data:\n-\n-* The author of the token was in the possession of the signing secret\n-* The data has not been modified since it was signed\n-\n-It's important to know that JWT does not provide encryption, which means anyone who has access to the token can read its contents. If you need to protect (encrypt) the data, there is a companion spec, `JWE`, that provides this functionality. JWE is currently outside the scope of this library.\n-\n-### Choosing a Signing Method\n-\n-There are several signing methods available, and you should probably take the time to learn about the various options before choosing one.  The principal design decision is most likely going to be symmetric vs asymmetric.\n-\n-Symmetric signing methods, such as HSA, use only a single secret. This is probably the simplest signing method to use since any `[]byte` can be used as a valid secret. They are also slightly computationally faster to use, though this rarely is enough to matter. Symmetric signing methods work the best when both producers and consumers of tokens are trusted, or even the same system. Since the same secret is used to both sign and validate tokens, you can't easily distribute the key for validation.\n-\n-Asymmetric signing methods, such as RSA, use different keys for signing and verifying tokens. This makes it possible to produce tokens with a private key, and allow any consumer to access the public key for verification.\n-\n-### Signing Methods and Key Types\n-\n-Each signing method expects a different object type for its signing keys. See the package documentation for details. Here are the most common ones:\n-\n-* The [HMAC signing method](https://pkg.go.dev/github.com/golang-jwt/jwt#SigningMethodHMAC) (`HS256`,`HS384`,`HS512`) expect `[]byte` values for signing and validation\n-* The [RSA signing method](https://pkg.go.dev/github.com/golang-jwt/jwt#SigningMethodRSA) (`RS256`,`RS384`,`RS512`) expect `*rsa.PrivateKey` for signing and `*rsa.PublicKey` for validation\n-* The [ECDSA signing method](https://pkg.go.dev/github.com/golang-jwt/jwt#SigningMethodECDSA) (`ES256`,`ES384`,`ES512`) expect `*ecdsa.PrivateKey` for signing and `*ecdsa.PublicKey` for validation\n-\n-### JWT and OAuth\n-\n-It's worth mentioning that OAuth and JWT are not the same thing. A JWT token is simply a signed JSON object. It can be used anywhere such a thing is useful. There is some confusion, though, as JWT is the most common type of bearer token used in OAuth2 authentication.\n-\n-Without going too far down the rabbit hole, here's a description of the interaction of these technologies:\n-\n-* OAuth is a protocol for allowing an identity provider to be separate from the service a user is logging in to. For example, whenever you use Facebook to log into a different service (Yelp, Spotify, etc), you are using OAuth.\n-* OAuth defines several options for passing around authentication data. One popular method is called a \"bearer token\". A bearer token is simply a string that _should_ only be held by an authenticated user. Thus, simply presenting this token proves your identity. You can probably derive from here why a JWT might make a good bearer token.\n-* Because bearer tokens are used for authentication, it's important they're kept secret. This is why transactions that use bearer tokens typically happen over SSL.\n-\n-### Troubleshooting\n-\n-This library uses descriptive error messages whenever possible. If you are not getting the expected result, have a look at the errors. The most common place people get stuck is providing the correct type of key to the parser. See the above section on signing methods and key types.\n-\n-## More\n-\n-Documentation can be found [on pkg.go.dev](https://pkg.go.dev/github.com/golang-jwt/jwt).\n-\n-The command line utility included in this project (cmd/jwt) provides a straightforward example of token creation and parsing as well as a useful tool for debugging your own integration. You'll also find several implementation examples in the documentation."
    },
    {
      "sha": "f1dba3cb916f4c6a58014482cee68565cc9a242d",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/claims.go",
      "status": "removed",
      "additions": 0,
      "deletions": 146,
      "changes": 146,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fclaims.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fclaims.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fclaims.go?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,146 +0,0 @@\n-package jwt\n-\n-import (\n-\t\"crypto/subtle\"\n-\t\"fmt\"\n-\t\"time\"\n-)\n-\n-// For a type to be a Claims object, it must just have a Valid method that determines\n-// if the token is invalid for any supported reason\n-type Claims interface {\n-\tValid() error\n-}\n-\n-// Structured version of Claims Section, as referenced at\n-// https://tools.ietf.org/html/rfc7519#section-4.1\n-// See examples for how to use this with your own claim types\n-type StandardClaims struct {\n-\tAudience  string `json:\"aud,omitempty\"`\n-\tExpiresAt int64  `json:\"exp,omitempty\"`\n-\tId        string `json:\"jti,omitempty\"`\n-\tIssuedAt  int64  `json:\"iat,omitempty\"`\n-\tIssuer    string `json:\"iss,omitempty\"`\n-\tNotBefore int64  `json:\"nbf,omitempty\"`\n-\tSubject   string `json:\"sub,omitempty\"`\n-}\n-\n-// Validates time based claims \"exp, iat, nbf\".\n-// There is no accounting for clock skew.\n-// As well, if any of the above claims are not in the token, it will still\n-// be considered a valid claim.\n-func (c StandardClaims) Valid() error {\n-\tvErr := new(ValidationError)\n-\tnow := TimeFunc().Unix()\n-\n-\t// The claims below are optional, by default, so if they are set to the\n-\t// default value in Go, let's not fail the verification for them.\n-\tif !c.VerifyExpiresAt(now, false) {\n-\t\tdelta := time.Unix(now, 0).Sub(time.Unix(c.ExpiresAt, 0))\n-\t\tvErr.Inner = fmt.Errorf(\"token is expired by %v\", delta)\n-\t\tvErr.Errors |= ValidationErrorExpired\n-\t}\n-\n-\tif !c.VerifyIssuedAt(now, false) {\n-\t\tvErr.Inner = fmt.Errorf(\"Token used before issued\")\n-\t\tvErr.Errors |= ValidationErrorIssuedAt\n-\t}\n-\n-\tif !c.VerifyNotBefore(now, false) {\n-\t\tvErr.Inner = fmt.Errorf(\"token is not valid yet\")\n-\t\tvErr.Errors |= ValidationErrorNotValidYet\n-\t}\n-\n-\tif vErr.valid() {\n-\t\treturn nil\n-\t}\n-\n-\treturn vErr\n-}\n-\n-// Compares the aud claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (c *StandardClaims) VerifyAudience(cmp string, req bool) bool {\n-\treturn verifyAud([]string{c.Audience}, cmp, req)\n-}\n-\n-// Compares the exp claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (c *StandardClaims) VerifyExpiresAt(cmp int64, req bool) bool {\n-\treturn verifyExp(c.ExpiresAt, cmp, req)\n-}\n-\n-// Compares the iat claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (c *StandardClaims) VerifyIssuedAt(cmp int64, req bool) bool {\n-\treturn verifyIat(c.IssuedAt, cmp, req)\n-}\n-\n-// Compares the iss claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (c *StandardClaims) VerifyIssuer(cmp string, req bool) bool {\n-\treturn verifyIss(c.Issuer, cmp, req)\n-}\n-\n-// Compares the nbf claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (c *StandardClaims) VerifyNotBefore(cmp int64, req bool) bool {\n-\treturn verifyNbf(c.NotBefore, cmp, req)\n-}\n-\n-// ----- helpers\n-\n-func verifyAud(aud []string, cmp string, required bool) bool {\n-\tif len(aud) == 0 {\n-\t\treturn !required\n-\t}\n-\t// use a var here to keep constant time compare when looping over a number of claims\n-\tresult := false\n-\n-\tvar stringClaims string\n-\tfor _, a := range aud {\n-\t\tif subtle.ConstantTimeCompare([]byte(a), []byte(cmp)) != 0 {\n-\t\t\tresult = true\n-\t\t}\n-\t\tstringClaims = stringClaims + a\n-\t}\n-\n-\t// case where \"\" is sent in one or many aud claims\n-\tif len(stringClaims) == 0 {\n-\t\treturn !required\n-\t}\n-\n-\treturn result\n-}\n-\n-func verifyExp(exp int64, now int64, required bool) bool {\n-\tif exp == 0 {\n-\t\treturn !required\n-\t}\n-\treturn now <= exp\n-}\n-\n-func verifyIat(iat int64, now int64, required bool) bool {\n-\tif iat == 0 {\n-\t\treturn !required\n-\t}\n-\treturn now >= iat\n-}\n-\n-func verifyIss(iss string, cmp string, required bool) bool {\n-\tif iss == \"\" {\n-\t\treturn !required\n-\t}\n-\tif subtle.ConstantTimeCompare([]byte(iss), []byte(cmp)) != 0 {\n-\t\treturn true\n-\t} else {\n-\t\treturn false\n-\t}\n-}\n-\n-func verifyNbf(nbf int64, now int64, required bool) bool {\n-\tif nbf == 0 {\n-\t\treturn !required\n-\t}\n-\treturn now >= nbf\n-}"
    },
    {
      "sha": "1c93024aad2ea97b1bd2b944066d20145a69f1ce",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/errors.go",
      "status": "removed",
      "additions": 0,
      "deletions": 59,
      "changes": 59,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Ferrors.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Ferrors.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Ferrors.go?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,59 +0,0 @@\n-package jwt\n-\n-import (\n-\t\"errors\"\n-)\n-\n-// Error constants\n-var (\n-\tErrInvalidKey      = errors.New(\"key is invalid\")\n-\tErrInvalidKeyType  = errors.New(\"key is of invalid type\")\n-\tErrHashUnavailable = errors.New(\"the requested hash function is unavailable\")\n-)\n-\n-// The errors that might occur when parsing and validating a token\n-const (\n-\tValidationErrorMalformed        uint32 = 1 << iota // Token is malformed\n-\tValidationErrorUnverifiable                        // Token could not be verified because of signing problems\n-\tValidationErrorSignatureInvalid                    // Signature validation failed\n-\n-\t// Standard Claim validation errors\n-\tValidationErrorAudience      // AUD validation failed\n-\tValidationErrorExpired       // EXP validation failed\n-\tValidationErrorIssuedAt      // IAT validation failed\n-\tValidationErrorIssuer        // ISS validation failed\n-\tValidationErrorNotValidYet   // NBF validation failed\n-\tValidationErrorId            // JTI validation failed\n-\tValidationErrorClaimsInvalid // Generic claims validation error\n-)\n-\n-// Helper for constructing a ValidationError with a string error message\n-func NewValidationError(errorText string, errorFlags uint32) *ValidationError {\n-\treturn &ValidationError{\n-\t\ttext:   errorText,\n-\t\tErrors: errorFlags,\n-\t}\n-}\n-\n-// The error from Parse if token is not valid\n-type ValidationError struct {\n-\tInner  error  // stores the error returned by external dependencies, i.e.: KeyFunc\n-\tErrors uint32 // bitfield.  see ValidationError... constants\n-\ttext   string // errors that do not have a valid error just have text\n-}\n-\n-// Validation error is an error type\n-func (e ValidationError) Error() string {\n-\tif e.Inner != nil {\n-\t\treturn e.Inner.Error()\n-\t} else if e.text != \"\" {\n-\t\treturn e.text\n-\t} else {\n-\t\treturn \"token is invalid\"\n-\t}\n-}\n-\n-// No errors\n-func (e *ValidationError) valid() bool {\n-\treturn e.Errors == 0\n-}"
    },
    {
      "sha": "72c79f92e55ad4e87737d7c5e9e11f6bf5260db0",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/map_claims.go",
      "status": "removed",
      "additions": 0,
      "deletions": 120,
      "changes": 120,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fmap_claims.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fmap_claims.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fmap_claims.go?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,120 +0,0 @@\n-package jwt\n-\n-import (\n-\t\"encoding/json\"\n-\t\"errors\"\n-\t// \"fmt\"\n-)\n-\n-// Claims type that uses the map[string]interface{} for JSON decoding\n-// This is the default claims type if you don't supply one\n-type MapClaims map[string]interface{}\n-\n-// VerifyAudience Compares the aud claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (m MapClaims) VerifyAudience(cmp string, req bool) bool {\n-\tvar aud []string\n-\tswitch v := m[\"aud\"].(type) {\n-\tcase string:\n-\t\taud = append(aud, v)\n-\tcase []string:\n-\t\taud = v\n-\tcase []interface{}:\n-\t\tfor _, a := range v {\n-\t\t\tvs, ok := a.(string)\n-\t\t\tif !ok {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\taud = append(aud, vs)\n-\t\t}\n-\t}\n-\treturn verifyAud(aud, cmp, req)\n-}\n-\n-// Compares the exp claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (m MapClaims) VerifyExpiresAt(cmp int64, req bool) bool {\n-\texp, ok := m[\"exp\"]\n-\tif !ok {\n-\t\treturn !req\n-\t}\n-\tswitch expType := exp.(type) {\n-\tcase float64:\n-\t\treturn verifyExp(int64(expType), cmp, req)\n-\tcase json.Number:\n-\t\tv, _ := expType.Int64()\n-\t\treturn verifyExp(v, cmp, req)\n-\t}\n-\treturn false\n-}\n-\n-// Compares the iat claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (m MapClaims) VerifyIssuedAt(cmp int64, req bool) bool {\n-\tiat, ok := m[\"iat\"]\n-\tif !ok {\n-\t\treturn !req\n-\t}\n-\tswitch iatType := iat.(type) {\n-\tcase float64:\n-\t\treturn verifyIat(int64(iatType), cmp, req)\n-\tcase json.Number:\n-\t\tv, _ := iatType.Int64()\n-\t\treturn verifyIat(v, cmp, req)\n-\t}\n-\treturn false\n-}\n-\n-// Compares the iss claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (m MapClaims) VerifyIssuer(cmp string, req bool) bool {\n-\tiss, _ := m[\"iss\"].(string)\n-\treturn verifyIss(iss, cmp, req)\n-}\n-\n-// Compares the nbf claim against cmp.\n-// If required is false, this method will return true if the value matches or is unset\n-func (m MapClaims) VerifyNotBefore(cmp int64, req bool) bool {\n-\tnbf, ok := m[\"nbf\"]\n-\tif !ok {\n-\t\treturn !req\n-\t}\n-\tswitch nbfType := nbf.(type) {\n-\tcase float64:\n-\t\treturn verifyNbf(int64(nbfType), cmp, req)\n-\tcase json.Number:\n-\t\tv, _ := nbfType.Int64()\n-\t\treturn verifyNbf(v, cmp, req)\n-\t}\n-\treturn false\n-}\n-\n-// Validates time based claims \"exp, iat, nbf\".\n-// There is no accounting for clock skew.\n-// As well, if any of the above claims are not in the token, it will still\n-// be considered a valid claim.\n-func (m MapClaims) Valid() error {\n-\tvErr := new(ValidationError)\n-\tnow := TimeFunc().Unix()\n-\n-\tif !m.VerifyExpiresAt(now, false) {\n-\t\tvErr.Inner = errors.New(\"Token is expired\")\n-\t\tvErr.Errors |= ValidationErrorExpired\n-\t}\n-\n-\tif !m.VerifyIssuedAt(now, false) {\n-\t\tvErr.Inner = errors.New(\"Token used before issued\")\n-\t\tvErr.Errors |= ValidationErrorIssuedAt\n-\t}\n-\n-\tif !m.VerifyNotBefore(now, false) {\n-\t\tvErr.Inner = errors.New(\"Token is not valid yet\")\n-\t\tvErr.Errors |= ValidationErrorNotValidYet\n-\t}\n-\n-\tif vErr.valid() {\n-\t\treturn nil\n-\t}\n-\n-\treturn vErr\n-}"
    },
    {
      "sha": "d6901d9adb52bde1914ed614bc97f0a4a47057fb",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/parser.go",
      "status": "removed",
      "additions": 0,
      "deletions": 148,
      "changes": 148,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fparser.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fparser.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fparser.go?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,148 +0,0 @@\n-package jwt\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"strings\"\n-)\n-\n-type Parser struct {\n-\tValidMethods         []string // If populated, only these methods will be considered valid\n-\tUseJSONNumber        bool     // Use JSON Number format in JSON decoder\n-\tSkipClaimsValidation bool     // Skip claims validation during token parsing\n-}\n-\n-// Parse, validate, and return a token.\n-// keyFunc will receive the parsed token and should return the key for validating.\n-// If everything is kosher, err will be nil\n-func (p *Parser) Parse(tokenString string, keyFunc Keyfunc) (*Token, error) {\n-\treturn p.ParseWithClaims(tokenString, MapClaims{}, keyFunc)\n-}\n-\n-func (p *Parser) ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {\n-\ttoken, parts, err := p.ParseUnverified(tokenString, claims)\n-\tif err != nil {\n-\t\treturn token, err\n-\t}\n-\n-\t// Verify signing method is in the required set\n-\tif p.ValidMethods != nil {\n-\t\tvar signingMethodValid = false\n-\t\tvar alg = token.Method.Alg()\n-\t\tfor _, m := range p.ValidMethods {\n-\t\t\tif m == alg {\n-\t\t\t\tsigningMethodValid = true\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tif !signingMethodValid {\n-\t\t\t// signing method is not in the listed set\n-\t\t\treturn token, NewValidationError(fmt.Sprintf(\"signing method %v is invalid\", alg), ValidationErrorSignatureInvalid)\n-\t\t}\n-\t}\n-\n-\t// Lookup key\n-\tvar key interface{}\n-\tif keyFunc == nil {\n-\t\t// keyFunc was not provided.  short circuiting validation\n-\t\treturn token, NewValidationError(\"no Keyfunc was provided.\", ValidationErrorUnverifiable)\n-\t}\n-\tif key, err = keyFunc(token); err != nil {\n-\t\t// keyFunc returned an error\n-\t\tif ve, ok := err.(*ValidationError); ok {\n-\t\t\treturn token, ve\n-\t\t}\n-\t\treturn token, &ValidationError{Inner: err, Errors: ValidationErrorUnverifiable}\n-\t}\n-\n-\tvErr := &ValidationError{}\n-\n-\t// Validate Claims\n-\tif !p.SkipClaimsValidation {\n-\t\tif err := token.Claims.Valid(); err != nil {\n-\n-\t\t\t// If the Claims Valid returned an error, check if it is a validation error,\n-\t\t\t// If it was another error type, create a ValidationError with a generic ClaimsInvalid flag set\n-\t\t\tif e, ok := err.(*ValidationError); !ok {\n-\t\t\t\tvErr = &ValidationError{Inner: err, Errors: ValidationErrorClaimsInvalid}\n-\t\t\t} else {\n-\t\t\t\tvErr = e\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Perform validation\n-\ttoken.Signature = parts[2]\n-\tif err = token.Method.Verify(strings.Join(parts[0:2], \".\"), token.Signature, key); err != nil {\n-\t\tvErr.Inner = err\n-\t\tvErr.Errors |= ValidationErrorSignatureInvalid\n-\t}\n-\n-\tif vErr.valid() {\n-\t\ttoken.Valid = true\n-\t\treturn token, nil\n-\t}\n-\n-\treturn token, vErr\n-}\n-\n-// WARNING: Don't use this method unless you know what you're doing\n-//\n-// This method parses the token but doesn't validate the signature. It's only\n-// ever useful in cases where you know the signature is valid (because it has\n-// been checked previously in the stack) and you want to extract values from\n-// it.\n-func (p *Parser) ParseUnverified(tokenString string, claims Claims) (token *Token, parts []string, err error) {\n-\tparts = strings.Split(tokenString, \".\")\n-\tif len(parts) != 3 {\n-\t\treturn nil, parts, NewValidationError(\"token contains an invalid number of segments\", ValidationErrorMalformed)\n-\t}\n-\n-\ttoken = &Token{Raw: tokenString}\n-\n-\t// parse Header\n-\tvar headerBytes []byte\n-\tif headerBytes, err = DecodeSegment(parts[0]); err != nil {\n-\t\tif strings.HasPrefix(strings.ToLower(tokenString), \"bearer \") {\n-\t\t\treturn token, parts, NewValidationError(\"tokenstring should not contain 'bearer '\", ValidationErrorMalformed)\n-\t\t}\n-\t\treturn token, parts, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}\n-\t}\n-\tif err = json.Unmarshal(headerBytes, &token.Header); err != nil {\n-\t\treturn token, parts, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}\n-\t}\n-\n-\t// parse Claims\n-\tvar claimBytes []byte\n-\ttoken.Claims = claims\n-\n-\tif claimBytes, err = DecodeSegment(parts[1]); err != nil {\n-\t\treturn token, parts, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}\n-\t}\n-\tdec := json.NewDecoder(bytes.NewBuffer(claimBytes))\n-\tif p.UseJSONNumber {\n-\t\tdec.UseNumber()\n-\t}\n-\t// JSON Decode.  Special case for map type to avoid weird pointer behavior\n-\tif c, ok := token.Claims.(MapClaims); ok {\n-\t\terr = dec.Decode(&c)\n-\t} else {\n-\t\terr = dec.Decode(&claims)\n-\t}\n-\t// Handle decode error\n-\tif err != nil {\n-\t\treturn token, parts, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}\n-\t}\n-\n-\t// Lookup signature method\n-\tif method, ok := token.Header[\"alg\"].(string); ok {\n-\t\tif token.Method = GetSigningMethod(method); token.Method == nil {\n-\t\t\treturn token, parts, NewValidationError(\"signing method (alg) is unavailable.\", ValidationErrorUnverifiable)\n-\t\t}\n-\t} else {\n-\t\treturn token, parts, NewValidationError(\"signing method (alg) is unspecified.\", ValidationErrorUnverifiable)\n-\t}\n-\n-\treturn token, parts, nil\n-}"
    },
    {
      "sha": "ed1f212b21e1eaa5ca67d1e2b1969d984d92bfa7",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/signing_method.go",
      "status": "removed",
      "additions": 0,
      "deletions": 35,
      "changes": 35,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fsigning_method.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fsigning_method.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fsigning_method.go?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,35 +0,0 @@\n-package jwt\n-\n-import (\n-\t\"sync\"\n-)\n-\n-var signingMethods = map[string]func() SigningMethod{}\n-var signingMethodLock = new(sync.RWMutex)\n-\n-// Implement SigningMethod to add new methods for signing or verifying tokens.\n-type SigningMethod interface {\n-\tVerify(signingString, signature string, key interface{}) error // Returns nil if signature is valid\n-\tSign(signingString string, key interface{}) (string, error)    // Returns encoded signature or error\n-\tAlg() string                                                   // returns the alg identifier for this method (example: 'HS256')\n-}\n-\n-// Register the \"alg\" name and a factory function for signing method.\n-// This is typically done during init() in the method's implementation\n-func RegisterSigningMethod(alg string, f func() SigningMethod) {\n-\tsigningMethodLock.Lock()\n-\tdefer signingMethodLock.Unlock()\n-\n-\tsigningMethods[alg] = f\n-}\n-\n-// Get a signing method from an \"alg\" string\n-func GetSigningMethod(alg string) (method SigningMethod) {\n-\tsigningMethodLock.RLock()\n-\tdefer signingMethodLock.RUnlock()\n-\n-\tif methodF, ok := signingMethods[alg]; ok {\n-\t\tmethod = methodF()\n-\t}\n-\treturn\n-}"
    },
    {
      "sha": "6b30ced1200cb94b05aac81873122f972907498a",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/token.go",
      "status": "removed",
      "additions": 0,
      "deletions": 104,
      "changes": 104,
      "blob_url": "https://github.com/umputun/remark42/blob/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Ftoken.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6402ef9cae790b2361f270c6bcabe26261842064/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Ftoken.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Ftoken.go?ref=6402ef9cae790b2361f270c6bcabe26261842064",
      "patch": "@@ -1,104 +0,0 @@\n-package jwt\n-\n-import (\n-\t\"encoding/base64\"\n-\t\"encoding/json\"\n-\t\"strings\"\n-\t\"time\"\n-)\n-\n-// TimeFunc provides the current time when parsing token to validate \"exp\" claim (expiration time).\n-// You can override it to use another time value.  This is useful for testing or if your\n-// server uses a different time zone than your tokens.\n-var TimeFunc = time.Now\n-\n-// Parse methods use this callback function to supply\n-// the key for verification.  The function receives the parsed,\n-// but unverified Token.  This allows you to use properties in the\n-// Header of the token (such as `kid`) to identify which key to use.\n-type Keyfunc func(*Token) (interface{}, error)\n-\n-// A JWT Token.  Different fields will be used depending on whether you're\n-// creating or parsing/verifying a token.\n-type Token struct {\n-\tRaw       string                 // The raw token.  Populated when you Parse a token\n-\tMethod    SigningMethod          // The signing method used or to be used\n-\tHeader    map[string]interface{} // The first segment of the token\n-\tClaims    Claims                 // The second segment of the token\n-\tSignature string                 // The third segment of the token.  Populated when you Parse a token\n-\tValid     bool                   // Is the token valid?  Populated when you Parse/Verify a token\n-}\n-\n-// Create a new Token.  Takes a signing method\n-func New(method SigningMethod) *Token {\n-\treturn NewWithClaims(method, MapClaims{})\n-}\n-\n-func NewWithClaims(method SigningMethod, claims Claims) *Token {\n-\treturn &Token{\n-\t\tHeader: map[string]interface{}{\n-\t\t\t\"typ\": \"JWT\",\n-\t\t\t\"alg\": method.Alg(),\n-\t\t},\n-\t\tClaims: claims,\n-\t\tMethod: method,\n-\t}\n-}\n-\n-// Get the complete, signed token\n-func (t *Token) SignedString(key interface{}) (string, error) {\n-\tvar sig, sstr string\n-\tvar err error\n-\tif sstr, err = t.SigningString(); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tif sig, err = t.Method.Sign(sstr, key); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\treturn strings.Join([]string{sstr, sig}, \".\"), nil\n-}\n-\n-// Generate the signing string.  This is the\n-// most expensive part of the whole deal.  Unless you\n-// need this for something special, just go straight for\n-// the SignedString.\n-func (t *Token) SigningString() (string, error) {\n-\tvar err error\n-\tparts := make([]string, 2)\n-\tfor i := range parts {\n-\t\tvar jsonValue []byte\n-\t\tif i == 0 {\n-\t\t\tif jsonValue, err = json.Marshal(t.Header); err != nil {\n-\t\t\t\treturn \"\", err\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif jsonValue, err = json.Marshal(t.Claims); err != nil {\n-\t\t\t\treturn \"\", err\n-\t\t\t}\n-\t\t}\n-\n-\t\tparts[i] = EncodeSegment(jsonValue)\n-\t}\n-\treturn strings.Join(parts, \".\"), nil\n-}\n-\n-// Parse, validate, and return a token.\n-// keyFunc will receive the parsed token and should return the key for validating.\n-// If everything is kosher, err will be nil\n-func Parse(tokenString string, keyFunc Keyfunc) (*Token, error) {\n-\treturn new(Parser).Parse(tokenString, keyFunc)\n-}\n-\n-func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {\n-\treturn new(Parser).ParseWithClaims(tokenString, claims, keyFunc)\n-}\n-\n-// Encode JWT specific base64url encoding with padding stripped\n-func EncodeSegment(seg []byte) string {\n-\treturn base64.RawURLEncoding.EncodeToString(seg)\n-}\n-\n-// Decode JWT specific base64url encoding with padding stripped\n-func DecodeSegment(seg string) ([]byte, error) {\n-\treturn base64.RawURLEncoding.DecodeString(seg)\n-}"
    },
    {
      "sha": "09573e0169c2174c21620518c0c998eb27ce14d0",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/.gitignore",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2F.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2F.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2F.gitignore?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/.gitignore"
    },
    {
      "sha": "35dbc252041eae41edbf286d56d48371bc670d39",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/LICENSE",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FLICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FLICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FLICENSE?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/LICENSE"
    },
    {
      "sha": "ff9c57e1d84424d809f683404cb1ad5b6c43ae41",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/MIGRATION_GUIDE.md",
      "status": "added",
      "additions": 195,
      "deletions": 0,
      "changes": 195,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FMIGRATION_GUIDE.md",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FMIGRATION_GUIDE.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FMIGRATION_GUIDE.md?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,195 @@\n+# Migration Guide (v5.0.0)\n+\n+Version `v5` contains a major rework of core functionalities in the `jwt-go`\n+library. This includes support for several validation options as well as a\n+re-design of the `Claims` interface. Lastly, we reworked how errors work under\n+the hood, which should provide a better overall developer experience.\n+\n+Starting from [v5.0.0](https://github.com/golang-jwt/jwt/releases/tag/v5.0.0),\n+the import path will be:\n+\n+    \"github.com/golang-jwt/jwt/v5\"\n+\n+For most users, changing the import path *should* suffice. However, since we\n+intentionally changed and cleaned some of the public API, existing programs\n+might need to be updated. The following sections describe significant changes\n+and corresponding updates for existing programs.\n+\n+## Parsing and Validation Options\n+\n+Under the hood, a new `Validator` struct takes care of validating the claims. A\n+long awaited feature has been the option to fine-tune the validation of tokens.\n+This is now possible with several `ParserOption` functions that can be appended\n+to most `Parse` functions, such as `ParseWithClaims`. The most important options\n+and changes are:\n+  * Added `WithLeeway` to support specifying the leeway that is allowed when\n+    validating time-based claims, such as `exp` or `nbf`.\n+  * Changed default behavior to not check the `iat` claim. Usage of this claim\n+    is OPTIONAL according to the JWT RFC. The claim itself is also purely\n+    informational according to the RFC, so a strict validation failure is not\n+    recommended. If you want to check for sensible values in these claims,\n+    please use the `WithIssuedAt` parser option.\n+  * Added `WithAudience`, `WithSubject` and `WithIssuer` to support checking for\n+    expected `aud`, `sub` and `iss`.\n+  * Added `WithStrictDecoding` and `WithPaddingAllowed` options to allow\n+    previously global settings to enable base64 strict encoding and the parsing\n+    of base64 strings with padding. The latter is strictly speaking against the\n+    standard, but unfortunately some of the major identity providers issue some\n+    of these incorrect tokens. Both options are disabled by default.\n+\n+## Changes to the `Claims` interface\n+\n+### Complete Restructuring\n+\n+Previously, the claims interface was satisfied with an implementation of a\n+`Valid() error` function. This had several issues:\n+  * The different claim types (struct claims, map claims, etc.) then contained\n+    similar (but not 100 % identical) code of how this validation was done. This\n+    lead to a lot of (almost) duplicate code and was hard to maintain\n+  * It was not really semantically close to what a \"claim\" (or a set of claims)\n+    really is; which is a list of defined key/value pairs with a certain\n+    semantic meaning.\n+\n+Since all the validation functionality is now extracted into the validator, all\n+`VerifyXXX` and `Valid` functions have been removed from the `Claims` interface.\n+Instead, the interface now represents a list of getters to retrieve values with\n+a specific meaning. This allows us to completely decouple the validation logic\n+with the underlying storage representation of the claim, which could be a\n+struct, a map or even something stored in a database.\n+\n+```go\n+type Claims interface {\n+\tGetExpirationTime() (*NumericDate, error)\n+\tGetIssuedAt() (*NumericDate, error)\n+\tGetNotBefore() (*NumericDate, error)\n+\tGetIssuer() (string, error)\n+\tGetSubject() (string, error)\n+\tGetAudience() (ClaimStrings, error)\n+}\n+```\n+\n+Users that previously directly called the `Valid` function on their claims,\n+e.g., to perform validation independently of parsing/verifying a token, can now\n+use the `jwt.NewValidator` function to create a `Validator` independently of the\n+`Parser`.\n+\n+```go\n+var v = jwt.NewValidator(jwt.WithLeeway(5*time.Second))\n+v.Validate(myClaims)\n+```\n+\n+### Supported Claim Types and Removal of `StandardClaims`\n+\n+The two standard claim types supported by this library, `MapClaims` and\n+`RegisteredClaims` both implement the necessary functions of this interface. The\n+old `StandardClaims` struct, which has already been deprecated in `v4` is now\n+removed.\n+\n+Users using custom claims, in most cases, will not experience any changes in the\n+behavior as long as they embedded `RegisteredClaims`. If they created a new\n+claim type from scratch, they now need to implemented the proper getter\n+functions.\n+\n+### Migrating Application Specific Logic of the old `Valid`\n+\n+Previously, users could override the `Valid` method in a custom claim, for\n+example to extend the validation with application-specific claims. However, this\n+was always very dangerous, since once could easily disable the standard\n+validation and signature checking.\n+\n+In order to avoid that, while still supporting the use-case, a new\n+`ClaimsValidator` interface has been introduced. This interface consists of the\n+`Validate() error` function. If the validator sees, that a `Claims` struct\n+implements this interface, the errors returned to the `Validate` function will\n+be *appended* to the regular standard validation. It is not possible to disable\n+the standard validation anymore (even only by accident).\n+\n+Usage examples can be found in [example_test.go](./example_test.go), to build\n+claims structs like the following.\n+\n+```go\n+// MyCustomClaims includes all registered claims, plus Foo.\n+type MyCustomClaims struct {\n+\tFoo string `json:\"foo\"`\n+\tjwt.RegisteredClaims\n+}\n+\n+// Validate can be used to execute additional application-specific claims\n+// validation.\n+func (m MyCustomClaims) Validate() error {\n+\tif m.Foo != \"bar\" {\n+\t\treturn errors.New(\"must be foobar\")\n+\t}\n+\n+\treturn nil\n+}\n+```\n+\n+## Changes to the `Token` and `Parser` struct\n+\n+The previously global functions `DecodeSegment` and `EncodeSegment` were moved\n+to the `Parser` and `Token` struct respectively. This will allow us in the\n+future to configure the behavior of these two based on options supplied on the\n+parser or the token (creation). This also removes two previously global\n+variables and moves them to parser options `WithStrictDecoding` and\n+`WithPaddingAllowed`.\n+\n+In order to do that, we had to adjust the way signing methods work. Previously\n+they were given a base64 encoded signature in `Verify` and were expected to\n+return a base64 encoded version of the signature in `Sign`, both as a `string`.\n+However, this made it necessary to have `DecodeSegment` and `EncodeSegment`\n+global and was a less than perfect design because we were repeating\n+encoding/decoding steps for all signing methods. Now, `Sign` and `Verify`\n+operate on a decoded signature as a `[]byte`, which feels more natural for a\n+cryptographic operation anyway. Lastly, `Parse` and `SignedString` take care of\n+the final encoding/decoding part.\n+\n+In addition to that, we also changed the `Signature` field on `Token` from a\n+`string` to `[]byte` and this is also now populated with the decoded form. This\n+is also more consistent, because the other parts of the JWT, mainly `Header` and\n+`Claims` were already stored in decoded form in `Token`. Only the signature was\n+stored in base64 encoded form, which was redundant with the information in the\n+`Raw` field, which contains the complete token as base64.\n+\n+```go\n+type Token struct {\n+\tRaw       string                 // Raw contains the raw token\n+\tMethod    SigningMethod          // Method is the signing method used or to be used\n+\tHeader    map[string]interface{} // Header is the first segment of the token in decoded form\n+\tClaims    Claims                 // Claims is the second segment of the token in decoded form\n+\tSignature []byte                 // Signature is the third segment of the token in decoded form\n+\tValid     bool                   // Valid specifies if the token is valid\n+}\n+```\n+\n+Most (if not all) of these changes should not impact the normal usage of this\n+library. Only users directly accessing the `Signature` field as well as\n+developers of custom signing methods should be affected.\n+\n+# Migration Guide (v4.0.0)\n+\n+Starting from [v4.0.0](https://github.com/golang-jwt/jwt/releases/tag/v4.0.0),\n+the import path will be:\n+\n+    \"github.com/golang-jwt/jwt/v4\"\n+\n+The `/v4` version will be backwards compatible with existing `v3.x.y` tags in\n+this repo, as well as `github.com/dgrijalva/jwt-go`. For most users this should\n+be a drop-in replacement, if you're having troubles migrating, please open an\n+issue.\n+\n+You can replace all occurrences of `github.com/dgrijalva/jwt-go` or\n+`github.com/golang-jwt/jwt` with `github.com/golang-jwt/jwt/v4`, either manually\n+or by using tools such as `sed` or `gofmt`.\n+\n+And then you'd typically run:\n+\n+```\n+go get github.com/golang-jwt/jwt/v4\n+go mod tidy\n+```\n+\n+# Older releases (before v3.2.0)\n+\n+The original migration guide for older releases can be found at\n+https://github.com/dgrijalva/jwt-go/blob/master/MIGRATION_GUIDE.md."
    },
    {
      "sha": "964598a3173e543e6fd7a7d6fb9eb95783444263",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/README.md",
      "status": "added",
      "additions": 167,
      "deletions": 0,
      "changes": 167,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FREADME.md?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,167 @@\n+# jwt-go\n+\n+[![build](https://github.com/golang-jwt/jwt/actions/workflows/build.yml/badge.svg)](https://github.com/golang-jwt/jwt/actions/workflows/build.yml)\n+[![Go\n+Reference](https://pkg.go.dev/badge/github.com/golang-jwt/jwt/v5.svg)](https://pkg.go.dev/github.com/golang-jwt/jwt/v5)\n+[![Coverage Status](https://coveralls.io/repos/github/golang-jwt/jwt/badge.svg?branch=main)](https://coveralls.io/github/golang-jwt/jwt?branch=main)\n+\n+A [go](http://www.golang.org) (or 'golang' for search engine friendliness)\n+implementation of [JSON Web\n+Tokens](https://datatracker.ietf.org/doc/html/rfc7519).\n+\n+Starting with [v4.0.0](https://github.com/golang-jwt/jwt/releases/tag/v4.0.0)\n+this project adds Go module support, but maintains backwards compatibility with\n+older `v3.x.y` tags and upstream `github.com/dgrijalva/jwt-go`. See the\n+[`MIGRATION_GUIDE.md`](./MIGRATION_GUIDE.md) for more information. Version\n+v5.0.0 introduces major improvements to the validation of tokens, but is not\n+entirely backwards compatible. \n+\n+> After the original author of the library suggested migrating the maintenance\n+> of `jwt-go`, a dedicated team of open source maintainers decided to clone the\n+> existing library into this repository. See\n+> [dgrijalva/jwt-go#462](https://github.com/dgrijalva/jwt-go/issues/462) for a\n+> detailed discussion on this topic.\n+\n+\n+**SECURITY NOTICE:** Some older versions of Go have a security issue in the\n+crypto/elliptic. Recommendation is to upgrade to at least 1.15 See issue\n+[dgrijalva/jwt-go#216](https://github.com/dgrijalva/jwt-go/issues/216) for more\n+detail.\n+\n+**SECURITY NOTICE:** It's important that you [validate the `alg` presented is\n+what you\n+expect](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/).\n+This library attempts to make it easy to do the right thing by requiring key\n+types match the expected alg, but you should take the extra step to verify it in\n+your usage.  See the examples provided.\n+\n+### Supported Go versions\n+\n+Our support of Go versions is aligned with Go's [version release\n+policy](https://golang.org/doc/devel/release#policy). So we will support a major\n+version of Go until there are two newer major releases. We no longer support\n+building jwt-go with unsupported Go versions, as these contain security\n+vulnerabilities which will not be fixed.\n+\n+## What the heck is a JWT?\n+\n+JWT.io has [a great introduction](https://jwt.io/introduction) to JSON Web\n+Tokens.\n+\n+In short, it's a signed JSON object that does something useful (for example,\n+authentication).  It's commonly used for `Bearer` tokens in Oauth 2.  A token is\n+made of three parts, separated by `.`'s.  The first two parts are JSON objects,\n+that have been [base64url](https://datatracker.ietf.org/doc/html/rfc4648)\n+encoded.  The last part is the signature, encoded the same way.\n+\n+The first part is called the header.  It contains the necessary information for\n+verifying the last part, the signature.  For example, which encryption method\n+was used for signing and what key was used.\n+\n+The part in the middle is the interesting bit.  It's called the Claims and\n+contains the actual stuff you care about.  Refer to [RFC\n+7519](https://datatracker.ietf.org/doc/html/rfc7519) for information about\n+reserved keys and the proper way to add your own.\n+\n+## What's in the box?\n+\n+This library supports the parsing and verification as well as the generation and\n+signing of JWTs.  Current supported signing algorithms are HMAC SHA, RSA,\n+RSA-PSS, and ECDSA, though hooks are present for adding your own.\n+\n+## Installation Guidelines\n+\n+1. To install the jwt package, you first need to have\n+   [Go](https://go.dev/doc/install) installed, then you can use the command\n+   below to add `jwt-go` as a dependency in your Go program.\n+\n+```sh\n+go get -u github.com/golang-jwt/jwt/v5\n+```\n+\n+2. Import it in your code:\n+\n+```go\n+import \"github.com/golang-jwt/jwt/v5\"\n+```\n+\n+## Usage\n+\n+A detailed usage guide, including how to sign and verify tokens can be found on\n+our [documentation website](https://golang-jwt.github.io/jwt/usage/create/).\n+\n+## Examples\n+\n+See [the project documentation](https://pkg.go.dev/github.com/golang-jwt/jwt/v5)\n+for examples of usage:\n+\n+* [Simple example of parsing and validating a\n+  token](https://pkg.go.dev/github.com/golang-jwt/jwt/v5#example-Parse-Hmac)\n+* [Simple example of building and signing a\n+  token](https://pkg.go.dev/github.com/golang-jwt/jwt/v5#example-New-Hmac)\n+* [Directory of\n+  Examples](https://pkg.go.dev/github.com/golang-jwt/jwt/v5#pkg-examples)\n+\n+## Compliance\n+\n+This library was last reviewed to comply with [RFC\n+7519](https://datatracker.ietf.org/doc/html/rfc7519) dated May 2015 with a few\n+notable differences:\n+\n+* In order to protect against accidental use of [Unsecured\n+  JWTs](https://datatracker.ietf.org/doc/html/rfc7519#section-6), tokens using\n+  `alg=none` will only be accepted if the constant\n+  `jwt.UnsafeAllowNoneSignatureType` is provided as the key.\n+\n+## Project Status & Versioning\n+\n+This library is considered production ready.  Feedback and feature requests are\n+appreciated.  The API should be considered stable.  There should be very few\n+backwards-incompatible changes outside of major version updates (and only with\n+good reason).\n+\n+This project uses [Semantic Versioning 2.0.0](http://semver.org).  Accepted pull\n+requests will land on `main`.  Periodically, versions will be tagged from\n+`main`.  You can find all the releases on [the project releases\n+page](https://github.com/golang-jwt/jwt/releases).\n+\n+**BREAKING CHANGES:*** A full list of breaking changes is available in\n+`VERSION_HISTORY.md`.  See `MIGRATION_GUIDE.md` for more information on updating\n+your code.\n+\n+## Extensions\n+\n+This library publishes all the necessary components for adding your own signing\n+methods or key functions.  Simply implement the `SigningMethod` interface and\n+register a factory method using `RegisterSigningMethod` or provide a\n+`jwt.Keyfunc`.\n+\n+A common use case would be integrating with different 3rd party signature\n+providers, like key management services from various cloud providers or Hardware\n+Security Modules (HSMs) or to implement additional standards.\n+\n+| Extension | Purpose                                                                                                  | Repo                                       |\n+| --------- | -------------------------------------------------------------------------------------------------------- | ------------------------------------------ |\n+| GCP       | Integrates with multiple Google Cloud Platform signing tools (AppEngine, IAM API, Cloud KMS)             | https://github.com/someone1/gcp-jwt-go     |\n+| AWS       | Integrates with AWS Key Management Service, KMS                                                          | https://github.com/matelang/jwt-go-aws-kms |\n+| JWKS      | Provides support for JWKS ([RFC 7517](https://datatracker.ietf.org/doc/html/rfc7517)) as a `jwt.Keyfunc` | https://github.com/MicahParks/keyfunc      |\n+\n+*Disclaimer*: Unless otherwise specified, these integrations are maintained by\n+third parties and should not be considered as a primary offer by any of the\n+mentioned cloud providers\n+\n+## More\n+\n+Go package documentation can be found [on\n+pkg.go.dev](https://pkg.go.dev/github.com/golang-jwt/jwt/v5). Additional\n+documentation can be found on [our project\n+page](https://golang-jwt.github.io/jwt/).\n+\n+The command line utility included in this project (cmd/jwt) provides a\n+straightforward example of token creation and parsing as well as a useful tool\n+for debugging your own integration. You'll also find several implementation\n+examples in the documentation.\n+\n+[golang-jwt](https://github.com/orgs/golang-jwt) incorporates a modified version\n+of the JWT logo, which is distributed under the terms of the [MIT\n+License](https://github.com/jsonwebtoken/jsonwebtoken.github.io/blob/master/LICENSE.txt)."
    },
    {
      "sha": "b08402c3427f4488375bf9c4aba0924820585fee",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/SECURITY.md",
      "status": "added",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FSECURITY.md",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FSECURITY.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FSECURITY.md?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,19 @@\n+# Security Policy\n+\n+## Supported Versions\n+\n+As of February 2022 (and until this document is updated), the latest version `v4` is supported.\n+\n+## Reporting a Vulnerability\n+\n+If you think you found a vulnerability, and even if you are not sure, please report it to jwt-go-security@googlegroups.com or one of the other [golang-jwt maintainers](https://github.com/orgs/golang-jwt/people). Please try be explicit, describe steps to reproduce the security issue with code example(s).\n+\n+You will receive a response within a timely manner. If the issue is confirmed, we will do our best to release a patch as soon as possible given the complexity of the problem.\n+\n+## Public Discussions\n+\n+Please avoid publicly discussing a potential security vulnerability.\n+\n+Let's take this offline and find a solution first, this limits the potential impact as much as possible.\n+\n+We appreciate your help!"
    },
    {
      "sha": "b5039e49c102e164dd2acb5a9c4ae074a224f1fc",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/VERSION_HISTORY.md",
      "status": "renamed",
      "additions": 12,
      "deletions": 6,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FVERSION_HISTORY.md",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FVERSION_HISTORY.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2FVERSION_HISTORY.md?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -1,13 +1,19 @@\n-## `jwt-go` Version History\n+# `jwt-go` Version History\n \n-#### 3.2.2\n+The following version history is kept for historic purposes. To retrieve the current changes of each version, please refer to the change-log of the specific release versions on https://github.com/golang-jwt/jwt/releases.\n+\n+## 4.0.0\n+\n+* Introduces support for Go modules. The `v4` version will be backwards compatible with `v3.x.y`.\n+\n+## 3.2.2\n \n * Starting from this release, we are adopting the policy to support the most 2 recent versions of Go currently available. By the time of this release, this is Go 1.15 and 1.16 ([#28](https://github.com/golang-jwt/jwt/pull/28)).\n * Fixed a potential issue that could occur when the verification of `exp`, `iat` or `nbf` was not required and contained invalid contents, i.e. non-numeric/date. Thanks for @thaJeztah for making us aware of that and @giorgos-f3 for originally reporting it to the formtech fork ([#40](https://github.com/golang-jwt/jwt/pull/40)).\n * Added support for EdDSA / ED25519 ([#36](https://github.com/golang-jwt/jwt/pull/36)).\n * Optimized allocations ([#33](https://github.com/golang-jwt/jwt/pull/33)).\n \n-#### 3.2.1\n+## 3.2.1\n \n * **Import Path Change**: See MIGRATION_GUIDE.md for tips on updating your code\n \t* Changed the import path from `github.com/dgrijalva/jwt-go` to `github.com/golang-jwt/jwt`\n@@ -113,17 +119,17 @@ It is likely the only integration change required here will be to change `func(t\n * Refactored the RSA implementation to be easier to read\n * Exposed helper methods `ParseRSAPrivateKeyFromPEM` and `ParseRSAPublicKeyFromPEM`\n \n-#### 1.0.2\n+## 1.0.2\n \n * Fixed bug in parsing public keys from certificates\n * Added more tests around the parsing of keys for RS256\n * Code refactoring in RS256 implementation.  No functional changes\n \n-#### 1.0.1\n+## 1.0.1\n \n * Fixed panic if RS256 signing method was passed an invalid key\n \n-#### 1.0.0\n+## 1.0.0\n \n * First versioned release\n * API stabilized",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/VERSION_HISTORY.md"
    },
    {
      "sha": "d50ff3dad829706e9e9445ed4a002730f57d8a6c",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/claims.go",
      "status": "added",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fclaims.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fclaims.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fclaims.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,16 @@\n+package jwt\n+\n+// Claims represent any form of a JWT Claims Set according to\n+// https://datatracker.ietf.org/doc/html/rfc7519#section-4. In order to have a\n+// common basis for validation, it is required that an implementation is able to\n+// supply at least the claim names provided in\n+// https://datatracker.ietf.org/doc/html/rfc7519#section-4.1 namely `exp`,\n+// `iat`, `nbf`, `iss`, `sub` and `aud`.\n+type Claims interface {\n+\tGetExpirationTime() (*NumericDate, error)\n+\tGetIssuedAt() (*NumericDate, error)\n+\tGetNotBefore() (*NumericDate, error)\n+\tGetIssuer() (string, error)\n+\tGetSubject() (string, error)\n+\tGetAudience() (ClaimStrings, error)\n+}"
    },
    {
      "sha": "a86dc1a3b348cd1a3cf0730da9936f36098268a2",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/doc.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fdoc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fdoc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fdoc.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/doc.go"
    },
    {
      "sha": "c929e4a02fcbc753c8c53e0eef0d8d176368cb21",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/ecdsa.go",
      "status": "renamed",
      "additions": 11,
      "deletions": 19,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fecdsa.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fecdsa.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fecdsa.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -13,7 +13,7 @@ var (\n \tErrECDSAVerification = errors.New(\"crypto/ecdsa: verification error\")\n )\n \n-// Implements the ECDSA family of signing methods signing methods\n+// SigningMethodECDSA implements the ECDSA family of signing methods.\n // Expects *ecdsa.PrivateKey for signing and *ecdsa.PublicKey for verification\n type SigningMethodECDSA struct {\n \tName      string\n@@ -53,24 +53,16 @@ func (m *SigningMethodECDSA) Alg() string {\n \treturn m.Name\n }\n \n-// Implements the Verify method from SigningMethod\n+// Verify implements token verification for the SigningMethod.\n // For this verify method, key must be an ecdsa.PublicKey struct\n-func (m *SigningMethodECDSA) Verify(signingString, signature string, key interface{}) error {\n-\tvar err error\n-\n-\t// Decode the signature\n-\tvar sig []byte\n-\tif sig, err = DecodeSegment(signature); err != nil {\n-\t\treturn err\n-\t}\n-\n+func (m *SigningMethodECDSA) Verify(signingString string, sig []byte, key interface{}) error {\n \t// Get the key\n \tvar ecdsaKey *ecdsa.PublicKey\n \tswitch k := key.(type) {\n \tcase *ecdsa.PublicKey:\n \t\tecdsaKey = k\n \tdefault:\n-\t\treturn ErrInvalidKeyType\n+\t\treturn newError(\"ECDSA verify expects *ecdsa.PublicKey\", ErrInvalidKeyType)\n \t}\n \n \tif len(sig) != 2*m.KeySize {\n@@ -95,21 +87,21 @@ func (m *SigningMethodECDSA) Verify(signingString, signature string, key interfa\n \treturn ErrECDSAVerification\n }\n \n-// Implements the Sign method from SigningMethod\n+// Sign implements token signing for the SigningMethod.\n // For this signing method, key must be an ecdsa.PrivateKey struct\n-func (m *SigningMethodECDSA) Sign(signingString string, key interface{}) (string, error) {\n+func (m *SigningMethodECDSA) Sign(signingString string, key interface{}) ([]byte, error) {\n \t// Get the key\n \tvar ecdsaKey *ecdsa.PrivateKey\n \tswitch k := key.(type) {\n \tcase *ecdsa.PrivateKey:\n \t\tecdsaKey = k\n \tdefault:\n-\t\treturn \"\", ErrInvalidKeyType\n+\t\treturn nil, newError(\"ECDSA sign expects *ecdsa.PrivateKey\", ErrInvalidKeyType)\n \t}\n \n \t// Create the hasher\n \tif !m.Hash.Available() {\n-\t\treturn \"\", ErrHashUnavailable\n+\t\treturn nil, ErrHashUnavailable\n \t}\n \n \thasher := m.Hash.New()\n@@ -120,7 +112,7 @@ func (m *SigningMethodECDSA) Sign(signingString string, key interface{}) (string\n \t\tcurveBits := ecdsaKey.Curve.Params().BitSize\n \n \t\tif m.CurveBits != curveBits {\n-\t\t\treturn \"\", ErrInvalidKey\n+\t\t\treturn nil, ErrInvalidKey\n \t\t}\n \n \t\tkeyBytes := curveBits / 8\n@@ -135,8 +127,8 @@ func (m *SigningMethodECDSA) Sign(signingString string, key interface{}) (string\n \t\tr.FillBytes(out[0:keyBytes]) // r is assigned to the first half of output.\n \t\ts.FillBytes(out[keyBytes:])  // s is assigned to the second half of output.\n \n-\t\treturn EncodeSegment(out), nil\n+\t\treturn out, nil\n \t} else {\n-\t\treturn \"\", err\n+\t\treturn nil, err\n \t}\n }",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/ecdsa.go"
    },
    {
      "sha": "5700636d35b6c82b414e4670f16be52ddbec9066",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/ecdsa_utils.go",
      "status": "renamed",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fecdsa_utils.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fecdsa_utils.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fecdsa_utils.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -8,11 +8,11 @@ import (\n )\n \n var (\n-\tErrNotECPublicKey  = errors.New(\"Key is not a valid ECDSA public key\")\n-\tErrNotECPrivateKey = errors.New(\"Key is not a valid ECDSA private key\")\n+\tErrNotECPublicKey  = errors.New(\"key is not a valid ECDSA public key\")\n+\tErrNotECPrivateKey = errors.New(\"key is not a valid ECDSA private key\")\n )\n \n-// Parse PEM encoded Elliptic Curve Private Key Structure\n+// ParseECPrivateKeyFromPEM parses a PEM encoded Elliptic Curve Private Key Structure\n func ParseECPrivateKeyFromPEM(key []byte) (*ecdsa.PrivateKey, error) {\n \tvar err error\n \n@@ -39,7 +39,7 @@ func ParseECPrivateKeyFromPEM(key []byte) (*ecdsa.PrivateKey, error) {\n \treturn pkey, nil\n }\n \n-// Parse PEM encoded PKCS1 or PKCS8 public key\n+// ParseECPublicKeyFromPEM parses a PEM encoded PKCS1 or PKCS8 public key\n func ParseECPublicKeyFromPEM(key []byte) (*ecdsa.PublicKey, error) {\n \tvar err error\n ",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/ecdsa_utils.go"
    },
    {
      "sha": "c2138119e5120f6121184bd97d370a3e480f1431",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/ed25519.go",
      "status": "renamed",
      "additions": 23,
      "deletions": 25,
      "changes": 48,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fed25519.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fed25519.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fed25519.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -1,16 +1,17 @@\n package jwt\n \n import (\n-\t\"errors\"\n-\n+\t\"crypto\"\n \t\"crypto/ed25519\"\n+\t\"crypto/rand\"\n+\t\"errors\"\n )\n \n var (\n \tErrEd25519Verification = errors.New(\"ed25519: verification error\")\n )\n \n-// Implements the EdDSA family\n+// SigningMethodEd25519 implements the EdDSA family.\n // Expects ed25519.PrivateKey for signing and ed25519.PublicKey for verification\n type SigningMethodEd25519 struct{}\n \n@@ -30,27 +31,20 @@ func (m *SigningMethodEd25519) Alg() string {\n \treturn \"EdDSA\"\n }\n \n-// Implements the Verify method from SigningMethod\n+// Verify implements token verification for the SigningMethod.\n // For this verify method, key must be an ed25519.PublicKey\n-func (m *SigningMethodEd25519) Verify(signingString, signature string, key interface{}) error {\n-\tvar err error\n+func (m *SigningMethodEd25519) Verify(signingString string, sig []byte, key interface{}) error {\n \tvar ed25519Key ed25519.PublicKey\n \tvar ok bool\n \n \tif ed25519Key, ok = key.(ed25519.PublicKey); !ok {\n-\t\treturn ErrInvalidKeyType\n+\t\treturn newError(\"Ed25519 verify expects ed25519.PublicKey\", ErrInvalidKeyType)\n \t}\n \n \tif len(ed25519Key) != ed25519.PublicKeySize {\n \t\treturn ErrInvalidKey\n \t}\n \n-\t// Decode the signature\n-\tvar sig []byte\n-\tif sig, err = DecodeSegment(signature); err != nil {\n-\t\treturn err\n-\t}\n-\n \t// Verify the signature\n \tif !ed25519.Verify(ed25519Key, []byte(signingString), sig) {\n \t\treturn ErrEd25519Verification\n@@ -59,23 +53,27 @@ func (m *SigningMethodEd25519) Verify(signingString, signature string, key inter\n \treturn nil\n }\n \n-// Implements the Sign method from SigningMethod\n+// Sign implements token signing for the SigningMethod.\n // For this signing method, key must be an ed25519.PrivateKey\n-func (m *SigningMethodEd25519) Sign(signingString string, key interface{}) (string, error) {\n-\tvar ed25519Key ed25519.PrivateKey\n+func (m *SigningMethodEd25519) Sign(signingString string, key interface{}) ([]byte, error) {\n+\tvar ed25519Key crypto.Signer\n \tvar ok bool\n \n-\tif ed25519Key, ok = key.(ed25519.PrivateKey); !ok {\n-\t\treturn \"\", ErrInvalidKeyType\n+\tif ed25519Key, ok = key.(crypto.Signer); !ok {\n+\t\treturn nil, newError(\"Ed25519 sign expects crypto.Signer\", ErrInvalidKeyType)\n+\t}\n+\n+\tif _, ok := ed25519Key.Public().(ed25519.PublicKey); !ok {\n+\t\treturn nil, ErrInvalidKey\n \t}\n \n-\t// ed25519.Sign panics if private key not equal to ed25519.PrivateKeySize\n-\t// this allows to avoid recover usage\n-\tif len(ed25519Key) != ed25519.PrivateKeySize {\n-\t\treturn \"\", ErrInvalidKey\n+\t// Sign the string and return the result. ed25519 performs a two-pass hash\n+\t// as part of its algorithm. Therefore, we need to pass a non-prehashed\n+\t// message into the Sign function, as indicated by crypto.Hash(0)\n+\tsig, err := ed25519Key.Sign(rand.Reader, []byte(signingString), crypto.Hash(0))\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n-\t// Sign the string and return the encoded result\n-\tsig := ed25519.Sign(ed25519Key, []byte(signingString))\n-\treturn EncodeSegment(sig), nil\n+\treturn sig, nil\n }",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/ed25519.go"
    },
    {
      "sha": "cdb5e68e8767ab72b1debe77a8e1d91e17286fd3",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/ed25519_utils.go",
      "status": "renamed",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fed25519_utils.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fed25519_utils.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fed25519_utils.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -9,11 +9,11 @@ import (\n )\n \n var (\n-\tErrNotEdPrivateKey = errors.New(\"Key is not a valid Ed25519 private key\")\n-\tErrNotEdPublicKey  = errors.New(\"Key is not a valid Ed25519 public key\")\n+\tErrNotEdPrivateKey = errors.New(\"key is not a valid Ed25519 private key\")\n+\tErrNotEdPublicKey  = errors.New(\"key is not a valid Ed25519 public key\")\n )\n \n-// Parse PEM-encoded Edwards curve private key\n+// ParseEdPrivateKeyFromPEM parses a PEM-encoded Edwards curve private key\n func ParseEdPrivateKeyFromPEM(key []byte) (crypto.PrivateKey, error) {\n \tvar err error\n \n@@ -38,7 +38,7 @@ func ParseEdPrivateKeyFromPEM(key []byte) (crypto.PrivateKey, error) {\n \treturn pkey, nil\n }\n \n-// Parse PEM-encoded Edwards curve public key\n+// ParseEdPublicKeyFromPEM parses a PEM-encoded Edwards curve public key\n func ParseEdPublicKeyFromPEM(key []byte) (crypto.PublicKey, error) {\n \tvar err error\n ",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/ed25519_utils.go"
    },
    {
      "sha": "23bb616ddde3a5417e162f47c0f796bf4e3c84f3",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/errors.go",
      "status": "added",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,49 @@\n+package jwt\n+\n+import (\n+\t\"errors\"\n+\t\"strings\"\n+)\n+\n+var (\n+\tErrInvalidKey                = errors.New(\"key is invalid\")\n+\tErrInvalidKeyType            = errors.New(\"key is of invalid type\")\n+\tErrHashUnavailable           = errors.New(\"the requested hash function is unavailable\")\n+\tErrTokenMalformed            = errors.New(\"token is malformed\")\n+\tErrTokenUnverifiable         = errors.New(\"token is unverifiable\")\n+\tErrTokenSignatureInvalid     = errors.New(\"token signature is invalid\")\n+\tErrTokenRequiredClaimMissing = errors.New(\"token is missing required claim\")\n+\tErrTokenInvalidAudience      = errors.New(\"token has invalid audience\")\n+\tErrTokenExpired              = errors.New(\"token is expired\")\n+\tErrTokenUsedBeforeIssued     = errors.New(\"token used before issued\")\n+\tErrTokenInvalidIssuer        = errors.New(\"token has invalid issuer\")\n+\tErrTokenInvalidSubject       = errors.New(\"token has invalid subject\")\n+\tErrTokenNotValidYet          = errors.New(\"token is not valid yet\")\n+\tErrTokenInvalidId            = errors.New(\"token has invalid id\")\n+\tErrTokenInvalidClaims        = errors.New(\"token has invalid claims\")\n+\tErrInvalidType               = errors.New(\"invalid type for claim\")\n+)\n+\n+// joinedError is an error type that works similar to what [errors.Join]\n+// produces, with the exception that it has a nice error string; mainly its\n+// error messages are concatenated using a comma, rather than a newline.\n+type joinedError struct {\n+\terrs []error\n+}\n+\n+func (je joinedError) Error() string {\n+\tmsg := []string{}\n+\tfor _, err := range je.errs {\n+\t\tmsg = append(msg, err.Error())\n+\t}\n+\n+\treturn strings.Join(msg, \", \")\n+}\n+\n+// joinErrors joins together multiple errors. Useful for scenarios where\n+// multiple errors next to each other occur, e.g., in claims validation.\n+func joinErrors(errs ...error) error {\n+\treturn &joinedError{\n+\t\terrs: errs,\n+\t}\n+}"
    },
    {
      "sha": "a893d355e1abeea5b03487333a5c81e748506a43",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/errors_go1_20.go",
      "status": "added",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors_go1_20.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors_go1_20.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors_go1_20.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,47 @@\n+//go:build go1.20\n+// +build go1.20\n+\n+package jwt\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+// Unwrap implements the multiple error unwrapping for this error type, which is\n+// possible in Go 1.20.\n+func (je joinedError) Unwrap() []error {\n+\treturn je.errs\n+}\n+\n+// newError creates a new error message with a detailed error message. The\n+// message will be prefixed with the contents of the supplied error type.\n+// Additionally, more errors, that provide more context can be supplied which\n+// will be appended to the message. This makes use of Go 1.20's possibility to\n+// include more than one %w formatting directive in [fmt.Errorf].\n+//\n+// For example,\n+//\n+//\tnewError(\"no keyfunc was provided\", ErrTokenUnverifiable)\n+//\n+// will produce the error string\n+//\n+//\t\"token is unverifiable: no keyfunc was provided\"\n+func newError(message string, err error, more ...error) error {\n+\tvar format string\n+\tvar args []any\n+\tif message != \"\" {\n+\t\tformat = \"%w: %s\"\n+\t\targs = []any{err, message}\n+\t} else {\n+\t\tformat = \"%w\"\n+\t\targs = []any{err}\n+\t}\n+\n+\tfor _, e := range more {\n+\t\tformat += \": %w\"\n+\t\targs = append(args, e)\n+\t}\n+\n+\terr = fmt.Errorf(format, args...)\n+\treturn err\n+}"
    },
    {
      "sha": "2ad542f00ca3e4cca742d78adde61634035bb93a",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/errors_go_other.go",
      "status": "added",
      "additions": 78,
      "deletions": 0,
      "changes": 78,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors_go_other.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors_go_other.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ferrors_go_other.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,78 @@\n+//go:build !go1.20\n+// +build !go1.20\n+\n+package jwt\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+// Is implements checking for multiple errors using [errors.Is], since multiple\n+// error unwrapping is not possible in versions less than Go 1.20.\n+func (je joinedError) Is(err error) bool {\n+\tfor _, e := range je.errs {\n+\t\tif errors.Is(e, err) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// wrappedErrors is a workaround for wrapping multiple errors in environments\n+// where Go 1.20 is not available. It basically uses the already implemented\n+// functionality of joinedError to handle multiple errors with supplies a\n+// custom error message that is identical to the one we produce in Go 1.20 using\n+// multiple %w directives.\n+type wrappedErrors struct {\n+\tmsg string\n+\tjoinedError\n+}\n+\n+// Error returns the stored error string\n+func (we wrappedErrors) Error() string {\n+\treturn we.msg\n+}\n+\n+// newError creates a new error message with a detailed error message. The\n+// message will be prefixed with the contents of the supplied error type.\n+// Additionally, more errors, that provide more context can be supplied which\n+// will be appended to the message. Since we cannot use of Go 1.20's possibility\n+// to include more than one %w formatting directive in [fmt.Errorf], we have to\n+// emulate that.\n+//\n+// For example,\n+//\n+//\tnewError(\"no keyfunc was provided\", ErrTokenUnverifiable)\n+//\n+// will produce the error string\n+//\n+//\t\"token is unverifiable: no keyfunc was provided\"\n+func newError(message string, err error, more ...error) error {\n+\t// We cannot wrap multiple errors here with %w, so we have to be a little\n+\t// bit creative. Basically, we are using %s instead of %w to produce the\n+\t// same error message and then throw the result into a custom error struct.\n+\tvar format string\n+\tvar args []any\n+\tif message != \"\" {\n+\t\tformat = \"%s: %s\"\n+\t\targs = []any{err, message}\n+\t} else {\n+\t\tformat = \"%s\"\n+\t\targs = []any{err}\n+\t}\n+\terrs := []error{err}\n+\n+\tfor _, e := range more {\n+\t\tformat += \": %s\"\n+\t\targs = append(args, e)\n+\t\terrs = append(errs, e)\n+\t}\n+\n+\terr = &wrappedErrors{\n+\t\tmsg:         fmt.Sprintf(format, args...),\n+\t\tjoinedError: joinedError{errs: errs},\n+\t}\n+\treturn err\n+}"
    },
    {
      "sha": "aca600ce1b00fcd103c02a75ed4b1e73c9de193b",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/hmac.go",
      "status": "renamed",
      "additions": 25,
      "deletions": 16,
      "changes": 41,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fhmac.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fhmac.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fhmac.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -6,7 +6,7 @@ import (\n \t\"errors\"\n )\n \n-// Implements the HMAC-SHA family of signing methods signing methods\n+// SigningMethodHMAC implements the HMAC-SHA family of signing methods.\n // Expects key type of []byte for both signing and validation\n type SigningMethodHMAC struct {\n \tName string\n@@ -45,18 +45,21 @@ func (m *SigningMethodHMAC) Alg() string {\n \treturn m.Name\n }\n \n-// Verify the signature of HSXXX tokens.  Returns nil if the signature is valid.\n-func (m *SigningMethodHMAC) Verify(signingString, signature string, key interface{}) error {\n+// Verify implements token verification for the SigningMethod. Returns nil if\n+// the signature is valid. Key must be []byte.\n+//\n+// Note it is not advised to provide a []byte which was converted from a 'human\n+// readable' string using a subset of ASCII characters. To maximize entropy, you\n+// should ideally be providing a []byte key which was produced from a\n+// cryptographically random source, e.g. crypto/rand. Additional information\n+// about this, and why we intentionally are not supporting string as a key can\n+// be found on our usage guide\n+// https://golang-jwt.github.io/jwt/usage/signing_methods/#signing-methods-and-key-types.\n+func (m *SigningMethodHMAC) Verify(signingString string, sig []byte, key interface{}) error {\n \t// Verify the key is the right type\n \tkeyBytes, ok := key.([]byte)\n \tif !ok {\n-\t\treturn ErrInvalidKeyType\n-\t}\n-\n-\t// Decode signature, for comparison\n-\tsig, err := DecodeSegment(signature)\n-\tif err != nil {\n-\t\treturn err\n+\t\treturn newError(\"HMAC verify expects []byte\", ErrInvalidKeyType)\n \t}\n \n \t// Can we use the specified hashing method?\n@@ -77,19 +80,25 @@ func (m *SigningMethodHMAC) Verify(signingString, signature string, key interfac\n \treturn nil\n }\n \n-// Implements the Sign method from SigningMethod for this signing method.\n-// Key must be []byte\n-func (m *SigningMethodHMAC) Sign(signingString string, key interface{}) (string, error) {\n+// Sign implements token signing for the SigningMethod. Key must be []byte.\n+//\n+// Note it is not advised to provide a []byte which was converted from a 'human\n+// readable' string using a subset of ASCII characters. To maximize entropy, you\n+// should ideally be providing a []byte key which was produced from a\n+// cryptographically random source, e.g. crypto/rand. Additional information\n+// about this, and why we intentionally are not supporting string as a key can\n+// be found on our usage guide https://golang-jwt.github.io/jwt/usage/signing_methods/.\n+func (m *SigningMethodHMAC) Sign(signingString string, key interface{}) ([]byte, error) {\n \tif keyBytes, ok := key.([]byte); ok {\n \t\tif !m.Hash.Available() {\n-\t\t\treturn \"\", ErrHashUnavailable\n+\t\t\treturn nil, ErrHashUnavailable\n \t\t}\n \n \t\thasher := hmac.New(m.Hash.New, keyBytes)\n \t\thasher.Write([]byte(signingString))\n \n-\t\treturn EncodeSegment(hasher.Sum(nil)), nil\n+\t\treturn hasher.Sum(nil), nil\n \t}\n \n-\treturn \"\", ErrInvalidKeyType\n+\treturn nil, newError(\"HMAC sign expects []byte\", ErrInvalidKeyType)\n }",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/hmac.go"
    },
    {
      "sha": "b2b51a1f80657b9e26ae2199b558a4c8249922d2",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/map_claims.go",
      "status": "added",
      "additions": 109,
      "deletions": 0,
      "changes": 109,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fmap_claims.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fmap_claims.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fmap_claims.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,109 @@\n+package jwt\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+)\n+\n+// MapClaims is a claims type that uses the map[string]interface{} for JSON\n+// decoding. This is the default claims type if you don't supply one\n+type MapClaims map[string]interface{}\n+\n+// GetExpirationTime implements the Claims interface.\n+func (m MapClaims) GetExpirationTime() (*NumericDate, error) {\n+\treturn m.parseNumericDate(\"exp\")\n+}\n+\n+// GetNotBefore implements the Claims interface.\n+func (m MapClaims) GetNotBefore() (*NumericDate, error) {\n+\treturn m.parseNumericDate(\"nbf\")\n+}\n+\n+// GetIssuedAt implements the Claims interface.\n+func (m MapClaims) GetIssuedAt() (*NumericDate, error) {\n+\treturn m.parseNumericDate(\"iat\")\n+}\n+\n+// GetAudience implements the Claims interface.\n+func (m MapClaims) GetAudience() (ClaimStrings, error) {\n+\treturn m.parseClaimsString(\"aud\")\n+}\n+\n+// GetIssuer implements the Claims interface.\n+func (m MapClaims) GetIssuer() (string, error) {\n+\treturn m.parseString(\"iss\")\n+}\n+\n+// GetSubject implements the Claims interface.\n+func (m MapClaims) GetSubject() (string, error) {\n+\treturn m.parseString(\"sub\")\n+}\n+\n+// parseNumericDate tries to parse a key in the map claims type as a number\n+// date. This will succeed, if the underlying type is either a [float64] or a\n+// [json.Number]. Otherwise, nil will be returned.\n+func (m MapClaims) parseNumericDate(key string) (*NumericDate, error) {\n+\tv, ok := m[key]\n+\tif !ok {\n+\t\treturn nil, nil\n+\t}\n+\n+\tswitch exp := v.(type) {\n+\tcase float64:\n+\t\tif exp == 0 {\n+\t\t\treturn nil, nil\n+\t\t}\n+\n+\t\treturn newNumericDateFromSeconds(exp), nil\n+\tcase json.Number:\n+\t\tv, _ := exp.Float64()\n+\n+\t\treturn newNumericDateFromSeconds(v), nil\n+\t}\n+\n+\treturn nil, newError(fmt.Sprintf(\"%s is invalid\", key), ErrInvalidType)\n+}\n+\n+// parseClaimsString tries to parse a key in the map claims type as a\n+// [ClaimsStrings] type, which can either be a string or an array of string.\n+func (m MapClaims) parseClaimsString(key string) (ClaimStrings, error) {\n+\tvar cs []string\n+\tswitch v := m[key].(type) {\n+\tcase string:\n+\t\tcs = append(cs, v)\n+\tcase []string:\n+\t\tcs = v\n+\tcase []interface{}:\n+\t\tfor _, a := range v {\n+\t\t\tvs, ok := a.(string)\n+\t\t\tif !ok {\n+\t\t\t\treturn nil, newError(fmt.Sprintf(\"%s is invalid\", key), ErrInvalidType)\n+\t\t\t}\n+\t\t\tcs = append(cs, vs)\n+\t\t}\n+\t}\n+\n+\treturn cs, nil\n+}\n+\n+// parseString tries to parse a key in the map claims type as a [string] type.\n+// If the key does not exist, an empty string is returned. If the key has the\n+// wrong type, an error is returned.\n+func (m MapClaims) parseString(key string) (string, error) {\n+\tvar (\n+\t\tok  bool\n+\t\traw interface{}\n+\t\tiss string\n+\t)\n+\traw, ok = m[key]\n+\tif !ok {\n+\t\treturn \"\", nil\n+\t}\n+\n+\tiss, ok = raw.(string)\n+\tif !ok {\n+\t\treturn \"\", newError(fmt.Sprintf(\"%s is invalid\", key), ErrInvalidType)\n+\t}\n+\n+\treturn iss, nil\n+}"
    },
    {
      "sha": "685c2ea306552ef26e06b03ede20907ed2198a20",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/none.go",
      "status": "renamed",
      "additions": 9,
      "deletions": 11,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fnone.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fnone.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fnone.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -1,6 +1,6 @@\n package jwt\n \n-// Implements the none signing method.  This is required by the spec\n+// SigningMethodNone implements the none signing method.  This is required by the spec\n // but you probably should never use it.\n var SigningMethodNone *signingMethodNone\n \n@@ -13,7 +13,7 @@ type unsafeNoneMagicConstant string\n \n func init() {\n \tSigningMethodNone = &signingMethodNone{}\n-\tNoneSignatureTypeDisallowedError = NewValidationError(\"'none' signature type is not allowed\", ValidationErrorSignatureInvalid)\n+\tNoneSignatureTypeDisallowedError = newError(\"'none' signature type is not allowed\", ErrTokenUnverifiable)\n \n \tRegisterSigningMethod(SigningMethodNone.Alg(), func() SigningMethod {\n \t\treturn SigningMethodNone\n@@ -25,28 +25,26 @@ func (m *signingMethodNone) Alg() string {\n }\n \n // Only allow 'none' alg type if UnsafeAllowNoneSignatureType is specified as the key\n-func (m *signingMethodNone) Verify(signingString, signature string, key interface{}) (err error) {\n+func (m *signingMethodNone) Verify(signingString string, sig []byte, key interface{}) (err error) {\n \t// Key must be UnsafeAllowNoneSignatureType to prevent accidentally\n \t// accepting 'none' signing method\n \tif _, ok := key.(unsafeNoneMagicConstant); !ok {\n \t\treturn NoneSignatureTypeDisallowedError\n \t}\n \t// If signing method is none, signature must be an empty string\n-\tif signature != \"\" {\n-\t\treturn NewValidationError(\n-\t\t\t\"'none' signing method with non-empty signature\",\n-\t\t\tValidationErrorSignatureInvalid,\n-\t\t)\n+\tif len(sig) != 0 {\n+\t\treturn newError(\"'none' signing method with non-empty signature\", ErrTokenUnverifiable)\n \t}\n \n \t// Accept 'none' signing method.\n \treturn nil\n }\n \n // Only allow 'none' signing if UnsafeAllowNoneSignatureType is specified as the key\n-func (m *signingMethodNone) Sign(signingString string, key interface{}) (string, error) {\n+func (m *signingMethodNone) Sign(signingString string, key interface{}) ([]byte, error) {\n \tif _, ok := key.(unsafeNoneMagicConstant); ok {\n-\t\treturn \"\", nil\n+\t\treturn []byte{}, nil\n \t}\n-\treturn \"\", NoneSignatureTypeDisallowedError\n+\n+\treturn nil, NoneSignatureTypeDisallowedError\n }",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/none.go"
    },
    {
      "sha": "ecf99af78f97811bcd1a54b1d630d48d57dc5753",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/parser.go",
      "status": "added",
      "additions": 238,
      "deletions": 0,
      "changes": 238,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fparser.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fparser.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fparser.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,238 @@\n+package jwt\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"strings\"\n+)\n+\n+type Parser struct {\n+\t// If populated, only these methods will be considered valid.\n+\tvalidMethods []string\n+\n+\t// Use JSON Number format in JSON decoder.\n+\tuseJSONNumber bool\n+\n+\t// Skip claims validation during token parsing.\n+\tskipClaimsValidation bool\n+\n+\tvalidator *Validator\n+\n+\tdecodeStrict bool\n+\n+\tdecodePaddingAllowed bool\n+}\n+\n+// NewParser creates a new Parser with the specified options\n+func NewParser(options ...ParserOption) *Parser {\n+\tp := &Parser{\n+\t\tvalidator: &Validator{},\n+\t}\n+\n+\t// Loop through our parsing options and apply them\n+\tfor _, option := range options {\n+\t\toption(p)\n+\t}\n+\n+\treturn p\n+}\n+\n+// Parse parses, validates, verifies the signature and returns the parsed token.\n+// keyFunc will receive the parsed token and should return the key for validating.\n+func (p *Parser) Parse(tokenString string, keyFunc Keyfunc) (*Token, error) {\n+\treturn p.ParseWithClaims(tokenString, MapClaims{}, keyFunc)\n+}\n+\n+// ParseWithClaims parses, validates, and verifies like Parse, but supplies a default object implementing the Claims\n+// interface. This provides default values which can be overridden and allows a caller to use their own type, rather\n+// than the default MapClaims implementation of Claims.\n+//\n+// Note: If you provide a custom claim implementation that embeds one of the standard claims (such as RegisteredClaims),\n+// make sure that a) you either embed a non-pointer version of the claims or b) if you are using a pointer, allocate the\n+// proper memory for it before passing in the overall claims, otherwise you might run into a panic.\n+func (p *Parser) ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {\n+\ttoken, parts, err := p.ParseUnverified(tokenString, claims)\n+\tif err != nil {\n+\t\treturn token, err\n+\t}\n+\n+\t// Verify signing method is in the required set\n+\tif p.validMethods != nil {\n+\t\tvar signingMethodValid = false\n+\t\tvar alg = token.Method.Alg()\n+\t\tfor _, m := range p.validMethods {\n+\t\t\tif m == alg {\n+\t\t\t\tsigningMethodValid = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !signingMethodValid {\n+\t\t\t// signing method is not in the listed set\n+\t\t\treturn token, newError(fmt.Sprintf(\"signing method %v is invalid\", alg), ErrTokenSignatureInvalid)\n+\t\t}\n+\t}\n+\n+\t// Decode signature\n+\ttoken.Signature, err = p.DecodeSegment(parts[2])\n+\tif err != nil {\n+\t\treturn token, newError(\"could not base64 decode signature\", ErrTokenMalformed, err)\n+\t}\n+\ttext := strings.Join(parts[0:2], \".\")\n+\n+\t// Lookup key(s)\n+\tif keyFunc == nil {\n+\t\t// keyFunc was not provided.  short circuiting validation\n+\t\treturn token, newError(\"no keyfunc was provided\", ErrTokenUnverifiable)\n+\t}\n+\n+\tgot, err := keyFunc(token)\n+\tif err != nil {\n+\t\treturn token, newError(\"error while executing keyfunc\", ErrTokenUnverifiable, err)\n+\t}\n+\n+\tswitch have := got.(type) {\n+\tcase VerificationKeySet:\n+\t\tif len(have.Keys) == 0 {\n+\t\t\treturn token, newError(\"keyfunc returned empty verification key set\", ErrTokenUnverifiable)\n+\t\t}\n+\t\t// Iterate through keys and verify signature, skipping the rest when a match is found.\n+\t\t// Return the last error if no match is found.\n+\t\tfor _, key := range have.Keys {\n+\t\t\tif err = token.Method.Verify(text, token.Signature, key); err == nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\tdefault:\n+\t\terr = token.Method.Verify(text, token.Signature, have)\n+\t}\n+\tif err != nil {\n+\t\treturn token, newError(\"\", ErrTokenSignatureInvalid, err)\n+\t}\n+\n+\t// Validate Claims\n+\tif !p.skipClaimsValidation {\n+\t\t// Make sure we have at least a default validator\n+\t\tif p.validator == nil {\n+\t\t\tp.validator = NewValidator()\n+\t\t}\n+\n+\t\tif err := p.validator.Validate(claims); err != nil {\n+\t\t\treturn token, newError(\"\", ErrTokenInvalidClaims, err)\n+\t\t}\n+\t}\n+\n+\t// No errors so far, token is valid.\n+\ttoken.Valid = true\n+\n+\treturn token, nil\n+}\n+\n+// ParseUnverified parses the token but doesn't validate the signature.\n+//\n+// WARNING: Don't use this method unless you know what you're doing.\n+//\n+// It's only ever useful in cases where you know the signature is valid (since it has already\n+// been or will be checked elsewhere in the stack) and you want to extract values from it.\n+func (p *Parser) ParseUnverified(tokenString string, claims Claims) (token *Token, parts []string, err error) {\n+\tparts = strings.Split(tokenString, \".\")\n+\tif len(parts) != 3 {\n+\t\treturn nil, parts, newError(\"token contains an invalid number of segments\", ErrTokenMalformed)\n+\t}\n+\n+\ttoken = &Token{Raw: tokenString}\n+\n+\t// parse Header\n+\tvar headerBytes []byte\n+\tif headerBytes, err = p.DecodeSegment(parts[0]); err != nil {\n+\t\treturn token, parts, newError(\"could not base64 decode header\", ErrTokenMalformed, err)\n+\t}\n+\tif err = json.Unmarshal(headerBytes, &token.Header); err != nil {\n+\t\treturn token, parts, newError(\"could not JSON decode header\", ErrTokenMalformed, err)\n+\t}\n+\n+\t// parse Claims\n+\ttoken.Claims = claims\n+\n+\tclaimBytes, err := p.DecodeSegment(parts[1])\n+\tif err != nil {\n+\t\treturn token, parts, newError(\"could not base64 decode claim\", ErrTokenMalformed, err)\n+\t}\n+\n+\t// If `useJSONNumber` is enabled then we must use *json.Decoder to decode\n+\t// the claims. However, this comes with a performance penalty so only use\n+\t// it if we must and, otherwise, simple use json.Unmarshal.\n+\tif !p.useJSONNumber {\n+\t\t// JSON Unmarshal. Special case for map type to avoid weird pointer behavior.\n+\t\tif c, ok := token.Claims.(MapClaims); ok {\n+\t\t\terr = json.Unmarshal(claimBytes, &c)\n+\t\t} else {\n+\t\t\terr = json.Unmarshal(claimBytes, &claims)\n+\t\t}\n+\t} else {\n+\t\tdec := json.NewDecoder(bytes.NewBuffer(claimBytes))\n+\t\tdec.UseNumber()\n+\t\t// JSON Decode. Special case for map type to avoid weird pointer behavior.\n+\t\tif c, ok := token.Claims.(MapClaims); ok {\n+\t\t\terr = dec.Decode(&c)\n+\t\t} else {\n+\t\t\terr = dec.Decode(&claims)\n+\t\t}\n+\t}\n+\tif err != nil {\n+\t\treturn token, parts, newError(\"could not JSON decode claim\", ErrTokenMalformed, err)\n+\t}\n+\n+\t// Lookup signature method\n+\tif method, ok := token.Header[\"alg\"].(string); ok {\n+\t\tif token.Method = GetSigningMethod(method); token.Method == nil {\n+\t\t\treturn token, parts, newError(\"signing method (alg) is unavailable\", ErrTokenUnverifiable)\n+\t\t}\n+\t} else {\n+\t\treturn token, parts, newError(\"signing method (alg) is unspecified\", ErrTokenUnverifiable)\n+\t}\n+\n+\treturn token, parts, nil\n+}\n+\n+// DecodeSegment decodes a JWT specific base64url encoding. This function will\n+// take into account whether the [Parser] is configured with additional options,\n+// such as [WithStrictDecoding] or [WithPaddingAllowed].\n+func (p *Parser) DecodeSegment(seg string) ([]byte, error) {\n+\tencoding := base64.RawURLEncoding\n+\n+\tif p.decodePaddingAllowed {\n+\t\tif l := len(seg) % 4; l > 0 {\n+\t\t\tseg += strings.Repeat(\"=\", 4-l)\n+\t\t}\n+\t\tencoding = base64.URLEncoding\n+\t}\n+\n+\tif p.decodeStrict {\n+\t\tencoding = encoding.Strict()\n+\t}\n+\treturn encoding.DecodeString(seg)\n+}\n+\n+// Parse parses, validates, verifies the signature and returns the parsed token.\n+// keyFunc will receive the parsed token and should return the cryptographic key\n+// for verifying the signature. The caller is strongly encouraged to set the\n+// WithValidMethods option to validate the 'alg' claim in the token matches the\n+// expected algorithm. For more details about the importance of validating the\n+// 'alg' claim, see\n+// https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/\n+func Parse(tokenString string, keyFunc Keyfunc, options ...ParserOption) (*Token, error) {\n+\treturn NewParser(options...).Parse(tokenString, keyFunc)\n+}\n+\n+// ParseWithClaims is a shortcut for NewParser().ParseWithClaims().\n+//\n+// Note: If you provide a custom claim implementation that embeds one of the\n+// standard claims (such as RegisteredClaims), make sure that a) you either\n+// embed a non-pointer version of the claims or b) if you are using a pointer,\n+// allocate the proper memory for it before passing in the overall claims,\n+// otherwise you might run into a panic.\n+func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc, options ...ParserOption) (*Token, error) {\n+\treturn NewParser(options...).ParseWithClaims(tokenString, claims, keyFunc)\n+}"
    },
    {
      "sha": "88a780fbd4a2ee61e5622d8b912ffd7eb4a39731",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/parser_option.go",
      "status": "added",
      "additions": 128,
      "deletions": 0,
      "changes": 128,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fparser_option.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fparser_option.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fparser_option.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,128 @@\n+package jwt\n+\n+import \"time\"\n+\n+// ParserOption is used to implement functional-style options that modify the\n+// behavior of the parser. To add new options, just create a function (ideally\n+// beginning with With or Without) that returns an anonymous function that takes\n+// a *Parser type as input and manipulates its configuration accordingly.\n+type ParserOption func(*Parser)\n+\n+// WithValidMethods is an option to supply algorithm methods that the parser\n+// will check. Only those methods will be considered valid. It is heavily\n+// encouraged to use this option in order to prevent attacks such as\n+// https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/.\n+func WithValidMethods(methods []string) ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validMethods = methods\n+\t}\n+}\n+\n+// WithJSONNumber is an option to configure the underlying JSON parser with\n+// UseNumber.\n+func WithJSONNumber() ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.useJSONNumber = true\n+\t}\n+}\n+\n+// WithoutClaimsValidation is an option to disable claims validation. This\n+// option should only be used if you exactly know what you are doing.\n+func WithoutClaimsValidation() ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.skipClaimsValidation = true\n+\t}\n+}\n+\n+// WithLeeway returns the ParserOption for specifying the leeway window.\n+func WithLeeway(leeway time.Duration) ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validator.leeway = leeway\n+\t}\n+}\n+\n+// WithTimeFunc returns the ParserOption for specifying the time func. The\n+// primary use-case for this is testing. If you are looking for a way to account\n+// for clock-skew, WithLeeway should be used instead.\n+func WithTimeFunc(f func() time.Time) ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validator.timeFunc = f\n+\t}\n+}\n+\n+// WithIssuedAt returns the ParserOption to enable verification\n+// of issued-at.\n+func WithIssuedAt() ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validator.verifyIat = true\n+\t}\n+}\n+\n+// WithExpirationRequired returns the ParserOption to make exp claim required.\n+// By default exp claim is optional.\n+func WithExpirationRequired() ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validator.requireExp = true\n+\t}\n+}\n+\n+// WithAudience configures the validator to require the specified audience in\n+// the `aud` claim. Validation will fail if the audience is not listed in the\n+// token or the `aud` claim is missing.\n+//\n+// NOTE: While the `aud` claim is OPTIONAL in a JWT, the handling of it is\n+// application-specific. Since this validation API is helping developers in\n+// writing secure application, we decided to REQUIRE the existence of the claim,\n+// if an audience is expected.\n+func WithAudience(aud string) ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validator.expectedAud = aud\n+\t}\n+}\n+\n+// WithIssuer configures the validator to require the specified issuer in the\n+// `iss` claim. Validation will fail if a different issuer is specified in the\n+// token or the `iss` claim is missing.\n+//\n+// NOTE: While the `iss` claim is OPTIONAL in a JWT, the handling of it is\n+// application-specific. Since this validation API is helping developers in\n+// writing secure application, we decided to REQUIRE the existence of the claim,\n+// if an issuer is expected.\n+func WithIssuer(iss string) ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validator.expectedIss = iss\n+\t}\n+}\n+\n+// WithSubject configures the validator to require the specified subject in the\n+// `sub` claim. Validation will fail if a different subject is specified in the\n+// token or the `sub` claim is missing.\n+//\n+// NOTE: While the `sub` claim is OPTIONAL in a JWT, the handling of it is\n+// application-specific. Since this validation API is helping developers in\n+// writing secure application, we decided to REQUIRE the existence of the claim,\n+// if a subject is expected.\n+func WithSubject(sub string) ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.validator.expectedSub = sub\n+\t}\n+}\n+\n+// WithPaddingAllowed will enable the codec used for decoding JWTs to allow\n+// padding. Note that the JWS RFC7515 states that the tokens will utilize a\n+// Base64url encoding with no padding. Unfortunately, some implementations of\n+// JWT are producing non-standard tokens, and thus require support for decoding.\n+func WithPaddingAllowed() ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.decodePaddingAllowed = true\n+\t}\n+}\n+\n+// WithStrictDecoding will switch the codec used for decoding JWTs into strict\n+// mode. In this mode, the decoder requires that trailing padding bits are zero,\n+// as described in RFC 4648 section 3.5.\n+func WithStrictDecoding() ParserOption {\n+\treturn func(p *Parser) {\n+\t\tp.decodeStrict = true\n+\t}\n+}"
    },
    {
      "sha": "77951a531d91f7b085aad58b90d7a3804020fdf0",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/registered_claims.go",
      "status": "added",
      "additions": 63,
      "deletions": 0,
      "changes": 63,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fregistered_claims.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fregistered_claims.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fregistered_claims.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,63 @@\n+package jwt\n+\n+// RegisteredClaims are a structured version of the JWT Claims Set,\n+// restricted to Registered Claim Names, as referenced at\n+// https://datatracker.ietf.org/doc/html/rfc7519#section-4.1\n+//\n+// This type can be used on its own, but then additional private and\n+// public claims embedded in the JWT will not be parsed. The typical use-case\n+// therefore is to embedded this in a user-defined claim type.\n+//\n+// See examples for how to use this with your own claim types.\n+type RegisteredClaims struct {\n+\t// the `iss` (Issuer) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1\n+\tIssuer string `json:\"iss,omitempty\"`\n+\n+\t// the `sub` (Subject) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2\n+\tSubject string `json:\"sub,omitempty\"`\n+\n+\t// the `aud` (Audience) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3\n+\tAudience ClaimStrings `json:\"aud,omitempty\"`\n+\n+\t// the `exp` (Expiration Time) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4\n+\tExpiresAt *NumericDate `json:\"exp,omitempty\"`\n+\n+\t// the `nbf` (Not Before) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5\n+\tNotBefore *NumericDate `json:\"nbf,omitempty\"`\n+\n+\t// the `iat` (Issued At) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6\n+\tIssuedAt *NumericDate `json:\"iat,omitempty\"`\n+\n+\t// the `jti` (JWT ID) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7\n+\tID string `json:\"jti,omitempty\"`\n+}\n+\n+// GetExpirationTime implements the Claims interface.\n+func (c RegisteredClaims) GetExpirationTime() (*NumericDate, error) {\n+\treturn c.ExpiresAt, nil\n+}\n+\n+// GetNotBefore implements the Claims interface.\n+func (c RegisteredClaims) GetNotBefore() (*NumericDate, error) {\n+\treturn c.NotBefore, nil\n+}\n+\n+// GetIssuedAt implements the Claims interface.\n+func (c RegisteredClaims) GetIssuedAt() (*NumericDate, error) {\n+\treturn c.IssuedAt, nil\n+}\n+\n+// GetAudience implements the Claims interface.\n+func (c RegisteredClaims) GetAudience() (ClaimStrings, error) {\n+\treturn c.Audience, nil\n+}\n+\n+// GetIssuer implements the Claims interface.\n+func (c RegisteredClaims) GetIssuer() (string, error) {\n+\treturn c.Issuer, nil\n+}\n+\n+// GetSubject implements the Claims interface.\n+func (c RegisteredClaims) GetSubject() (string, error) {\n+\treturn c.Subject, nil\n+}"
    },
    {
      "sha": "83cbee6ae2babe093dd438ce18db324a8985445a",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/rsa.go",
      "status": "renamed",
      "additions": 10,
      "deletions": 18,
      "changes": 28,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -6,7 +6,7 @@ import (\n \t\"crypto/rsa\"\n )\n \n-// Implements the RSA family of signing methods signing methods\n+// SigningMethodRSA implements the RSA family of signing methods.\n // Expects *rsa.PrivateKey for signing and *rsa.PublicKey for validation\n type SigningMethodRSA struct {\n \tName string\n@@ -44,22 +44,14 @@ func (m *SigningMethodRSA) Alg() string {\n \treturn m.Name\n }\n \n-// Implements the Verify method from SigningMethod\n+// Verify implements token verification for the SigningMethod\n // For this signing method, must be an *rsa.PublicKey structure.\n-func (m *SigningMethodRSA) Verify(signingString, signature string, key interface{}) error {\n-\tvar err error\n-\n-\t// Decode the signature\n-\tvar sig []byte\n-\tif sig, err = DecodeSegment(signature); err != nil {\n-\t\treturn err\n-\t}\n-\n+func (m *SigningMethodRSA) Verify(signingString string, sig []byte, key interface{}) error {\n \tvar rsaKey *rsa.PublicKey\n \tvar ok bool\n \n \tif rsaKey, ok = key.(*rsa.PublicKey); !ok {\n-\t\treturn ErrInvalidKeyType\n+\t\treturn newError(\"RSA verify expects *rsa.PublicKey\", ErrInvalidKeyType)\n \t}\n \n \t// Create hasher\n@@ -73,29 +65,29 @@ func (m *SigningMethodRSA) Verify(signingString, signature string, key interface\n \treturn rsa.VerifyPKCS1v15(rsaKey, m.Hash, hasher.Sum(nil), sig)\n }\n \n-// Implements the Sign method from SigningMethod\n+// Sign implements token signing for the SigningMethod\n // For this signing method, must be an *rsa.PrivateKey structure.\n-func (m *SigningMethodRSA) Sign(signingString string, key interface{}) (string, error) {\n+func (m *SigningMethodRSA) Sign(signingString string, key interface{}) ([]byte, error) {\n \tvar rsaKey *rsa.PrivateKey\n \tvar ok bool\n \n \t// Validate type of key\n \tif rsaKey, ok = key.(*rsa.PrivateKey); !ok {\n-\t\treturn \"\", ErrInvalidKey\n+\t\treturn nil, newError(\"RSA sign expects *rsa.PrivateKey\", ErrInvalidKeyType)\n \t}\n \n \t// Create the hasher\n \tif !m.Hash.Available() {\n-\t\treturn \"\", ErrHashUnavailable\n+\t\treturn nil, ErrHashUnavailable\n \t}\n \n \thasher := m.Hash.New()\n \thasher.Write([]byte(signingString))\n \n \t// Sign the string and return the encoded bytes\n \tif sigBytes, err := rsa.SignPKCS1v15(rand.Reader, rsaKey, m.Hash, hasher.Sum(nil)); err == nil {\n-\t\treturn EncodeSegment(sigBytes), nil\n+\t\treturn sigBytes, nil\n \t} else {\n-\t\treturn \"\", err\n+\t\treturn nil, err\n \t}\n }",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/rsa.go"
    },
    {
      "sha": "28c386ec43aa97b95a42292716c5dac5f81f1877",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/rsa_pss.go",
      "status": "renamed",
      "additions": 11,
      "deletions": 18,
      "changes": 29,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa_pss.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa_pss.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa_pss.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -1,3 +1,4 @@\n+//go:build go1.4\n // +build go1.4\n \n package jwt\n@@ -8,7 +9,7 @@ import (\n \t\"crypto/rsa\"\n )\n \n-// Implements the RSAPSS family of signing methods signing methods\n+// SigningMethodRSAPSS implements the RSAPSS family of signing methods signing methods\n type SigningMethodRSAPSS struct {\n \t*SigningMethodRSA\n \tOptions *rsa.PSSOptions\n@@ -79,23 +80,15 @@ func init() {\n \t})\n }\n \n-// Implements the Verify method from SigningMethod\n+// Verify implements token verification for the SigningMethod.\n // For this verify method, key must be an rsa.PublicKey struct\n-func (m *SigningMethodRSAPSS) Verify(signingString, signature string, key interface{}) error {\n-\tvar err error\n-\n-\t// Decode the signature\n-\tvar sig []byte\n-\tif sig, err = DecodeSegment(signature); err != nil {\n-\t\treturn err\n-\t}\n-\n+func (m *SigningMethodRSAPSS) Verify(signingString string, sig []byte, key interface{}) error {\n \tvar rsaKey *rsa.PublicKey\n \tswitch k := key.(type) {\n \tcase *rsa.PublicKey:\n \t\trsaKey = k\n \tdefault:\n-\t\treturn ErrInvalidKey\n+\t\treturn newError(\"RSA-PSS verify expects *rsa.PublicKey\", ErrInvalidKeyType)\n \t}\n \n \t// Create hasher\n@@ -113,30 +106,30 @@ func (m *SigningMethodRSAPSS) Verify(signingString, signature string, key interf\n \treturn rsa.VerifyPSS(rsaKey, m.Hash, hasher.Sum(nil), sig, opts)\n }\n \n-// Implements the Sign method from SigningMethod\n+// Sign implements token signing for the SigningMethod.\n // For this signing method, key must be an rsa.PrivateKey struct\n-func (m *SigningMethodRSAPSS) Sign(signingString string, key interface{}) (string, error) {\n+func (m *SigningMethodRSAPSS) Sign(signingString string, key interface{}) ([]byte, error) {\n \tvar rsaKey *rsa.PrivateKey\n \n \tswitch k := key.(type) {\n \tcase *rsa.PrivateKey:\n \t\trsaKey = k\n \tdefault:\n-\t\treturn \"\", ErrInvalidKeyType\n+\t\treturn nil, newError(\"RSA-PSS sign expects *rsa.PrivateKey\", ErrInvalidKeyType)\n \t}\n \n \t// Create the hasher\n \tif !m.Hash.Available() {\n-\t\treturn \"\", ErrHashUnavailable\n+\t\treturn nil, ErrHashUnavailable\n \t}\n \n \thasher := m.Hash.New()\n \thasher.Write([]byte(signingString))\n \n \t// Sign the string and return the encoded bytes\n \tif sigBytes, err := rsa.SignPSS(rand.Reader, rsaKey, m.Hash, hasher.Sum(nil), m.Options); err == nil {\n-\t\treturn EncodeSegment(sigBytes), nil\n+\t\treturn sigBytes, nil\n \t} else {\n-\t\treturn \"\", err\n+\t\treturn nil, err\n \t}\n }",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/rsa_pss.go"
    },
    {
      "sha": "b3aeebbe110b156af4ec1f3377dff3bff7453c81",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/rsa_utils.go",
      "status": "renamed",
      "additions": 13,
      "deletions": 7,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa_utils.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa_utils.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Frsa_utils.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -8,12 +8,12 @@ import (\n )\n \n var (\n-\tErrKeyMustBePEMEncoded = errors.New(\"Invalid Key: Key must be a PEM encoded PKCS1 or PKCS8 key\")\n-\tErrNotRSAPrivateKey    = errors.New(\"Key is not a valid RSA private key\")\n-\tErrNotRSAPublicKey     = errors.New(\"Key is not a valid RSA public key\")\n+\tErrKeyMustBePEMEncoded = errors.New(\"invalid key: Key must be a PEM encoded PKCS1 or PKCS8 key\")\n+\tErrNotRSAPrivateKey    = errors.New(\"key is not a valid RSA private key\")\n+\tErrNotRSAPublicKey     = errors.New(\"key is not a valid RSA public key\")\n )\n \n-// Parse PEM encoded PKCS1 or PKCS8 private key\n+// ParseRSAPrivateKeyFromPEM parses a PEM encoded PKCS1 or PKCS8 private key\n func ParseRSAPrivateKeyFromPEM(key []byte) (*rsa.PrivateKey, error) {\n \tvar err error\n \n@@ -39,7 +39,11 @@ func ParseRSAPrivateKeyFromPEM(key []byte) (*rsa.PrivateKey, error) {\n \treturn pkey, nil\n }\n \n-// Parse PEM encoded PKCS1 or PKCS8 private key protected with password\n+// ParseRSAPrivateKeyFromPEMWithPassword parses a PEM encoded PKCS1 or PKCS8 private key protected with password\n+//\n+// Deprecated: This function is deprecated and should not be used anymore. It uses the deprecated x509.DecryptPEMBlock\n+// function, which was deprecated since RFC 1423 is regarded insecure by design. Unfortunately, there is no alternative\n+// in the Go standard library for now. See https://github.com/golang/go/issues/8860.\n func ParseRSAPrivateKeyFromPEMWithPassword(key []byte, password string) (*rsa.PrivateKey, error) {\n \tvar err error\n \n@@ -71,7 +75,7 @@ func ParseRSAPrivateKeyFromPEMWithPassword(key []byte, password string) (*rsa.Pr\n \treturn pkey, nil\n }\n \n-// Parse PEM encoded PKCS1 or PKCS8 public key\n+// ParseRSAPublicKeyFromPEM parses a certificate or a PEM encoded PKCS1 or PKIX public key\n func ParseRSAPublicKeyFromPEM(key []byte) (*rsa.PublicKey, error) {\n \tvar err error\n \n@@ -87,7 +91,9 @@ func ParseRSAPublicKeyFromPEM(key []byte) (*rsa.PublicKey, error) {\n \t\tif cert, err := x509.ParseCertificate(block.Bytes); err == nil {\n \t\t\tparsedKey = cert.PublicKey\n \t\t} else {\n-\t\t\treturn nil, err\n+\t\t\tif parsedKey, err = x509.ParsePKCS1PublicKey(block.Bytes); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n \t\t}\n \t}\n ",
      "previous_filename": "backend/vendor/github.com/golang-jwt/jwt/rsa_utils.go"
    },
    {
      "sha": "0d73631c1bf365cf55bd66312f4e7d42b0137fb7",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/signing_method.go",
      "status": "added",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fsigning_method.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fsigning_method.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fsigning_method.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,49 @@\n+package jwt\n+\n+import (\n+\t\"sync\"\n+)\n+\n+var signingMethods = map[string]func() SigningMethod{}\n+var signingMethodLock = new(sync.RWMutex)\n+\n+// SigningMethod can be used add new methods for signing or verifying tokens. It\n+// takes a decoded signature as an input in the Verify function and produces a\n+// signature in Sign. The signature is then usually base64 encoded as part of a\n+// JWT.\n+type SigningMethod interface {\n+\tVerify(signingString string, sig []byte, key interface{}) error // Returns nil if signature is valid\n+\tSign(signingString string, key interface{}) ([]byte, error)     // Returns signature or error\n+\tAlg() string                                                    // returns the alg identifier for this method (example: 'HS256')\n+}\n+\n+// RegisterSigningMethod registers the \"alg\" name and a factory function for signing method.\n+// This is typically done during init() in the method's implementation\n+func RegisterSigningMethod(alg string, f func() SigningMethod) {\n+\tsigningMethodLock.Lock()\n+\tdefer signingMethodLock.Unlock()\n+\n+\tsigningMethods[alg] = f\n+}\n+\n+// GetSigningMethod retrieves a signing method from an \"alg\" string\n+func GetSigningMethod(alg string) (method SigningMethod) {\n+\tsigningMethodLock.RLock()\n+\tdefer signingMethodLock.RUnlock()\n+\n+\tif methodF, ok := signingMethods[alg]; ok {\n+\t\tmethod = methodF()\n+\t}\n+\treturn\n+}\n+\n+// GetAlgorithms returns a list of registered \"alg\" names\n+func GetAlgorithms() (algs []string) {\n+\tsigningMethodLock.RLock()\n+\tdefer signingMethodLock.RUnlock()\n+\n+\tfor alg := range signingMethods {\n+\t\talgs = append(algs, alg)\n+\t}\n+\treturn\n+}"
    },
    {
      "sha": "53745d51d7c74a5e2af4b23fd1a9f2e775a9c999",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/staticcheck.conf",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fstaticcheck.conf",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fstaticcheck.conf",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fstaticcheck.conf?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1 @@\n+checks = [\"all\", \"-ST1000\", \"-ST1003\", \"-ST1016\", \"-ST1023\"]"
    },
    {
      "sha": "352873a2d9c26ee017b7d0efd63b2b26df7aeec3",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/token.go",
      "status": "added",
      "additions": 100,
      "deletions": 0,
      "changes": 100,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftoken.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftoken.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftoken.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,100 @@\n+package jwt\n+\n+import (\n+\t\"crypto\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+)\n+\n+// Keyfunc will be used by the Parse methods as a callback function to supply\n+// the key for verification.  The function receives the parsed, but unverified\n+// Token.  This allows you to use properties in the Header of the token (such as\n+// `kid`) to identify which key to use.\n+//\n+// The returned interface{} may be a single key or a VerificationKeySet containing\n+// multiple keys.\n+type Keyfunc func(*Token) (interface{}, error)\n+\n+// VerificationKey represents a public or secret key for verifying a token's signature.\n+type VerificationKey interface {\n+\tcrypto.PublicKey | []uint8\n+}\n+\n+// VerificationKeySet is a set of public or secret keys. It is used by the parser to verify a token.\n+type VerificationKeySet struct {\n+\tKeys []VerificationKey\n+}\n+\n+// Token represents a JWT Token.  Different fields will be used depending on\n+// whether you're creating or parsing/verifying a token.\n+type Token struct {\n+\tRaw       string                 // Raw contains the raw token.  Populated when you [Parse] a token\n+\tMethod    SigningMethod          // Method is the signing method used or to be used\n+\tHeader    map[string]interface{} // Header is the first segment of the token in decoded form\n+\tClaims    Claims                 // Claims is the second segment of the token in decoded form\n+\tSignature []byte                 // Signature is the third segment of the token in decoded form.  Populated when you Parse a token\n+\tValid     bool                   // Valid specifies if the token is valid.  Populated when you Parse/Verify a token\n+}\n+\n+// New creates a new [Token] with the specified signing method and an empty map\n+// of claims. Additional options can be specified, but are currently unused.\n+func New(method SigningMethod, opts ...TokenOption) *Token {\n+\treturn NewWithClaims(method, MapClaims{}, opts...)\n+}\n+\n+// NewWithClaims creates a new [Token] with the specified signing method and\n+// claims. Additional options can be specified, but are currently unused.\n+func NewWithClaims(method SigningMethod, claims Claims, opts ...TokenOption) *Token {\n+\treturn &Token{\n+\t\tHeader: map[string]interface{}{\n+\t\t\t\"typ\": \"JWT\",\n+\t\t\t\"alg\": method.Alg(),\n+\t\t},\n+\t\tClaims: claims,\n+\t\tMethod: method,\n+\t}\n+}\n+\n+// SignedString creates and returns a complete, signed JWT. The token is signed\n+// using the SigningMethod specified in the token. Please refer to\n+// https://golang-jwt.github.io/jwt/usage/signing_methods/#signing-methods-and-key-types\n+// for an overview of the different signing methods and their respective key\n+// types.\n+func (t *Token) SignedString(key interface{}) (string, error) {\n+\tsstr, err := t.SigningString()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tsig, err := t.Method.Sign(sstr, key)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\treturn sstr + \".\" + t.EncodeSegment(sig), nil\n+}\n+\n+// SigningString generates the signing string.  This is the most expensive part\n+// of the whole deal.  Unless you need this for something special, just go\n+// straight for the SignedString.\n+func (t *Token) SigningString() (string, error) {\n+\th, err := json.Marshal(t.Header)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tc, err := json.Marshal(t.Claims)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\treturn t.EncodeSegment(h) + \".\" + t.EncodeSegment(c), nil\n+}\n+\n+// EncodeSegment encodes a JWT specific base64url encoding with padding\n+// stripped. In the future, this function might take into account a\n+// [TokenOption]. Therefore, this function exists as a method of [Token], rather\n+// than a global function.\n+func (*Token) EncodeSegment(seg []byte) string {\n+\treturn base64.RawURLEncoding.EncodeToString(seg)\n+}"
    },
    {
      "sha": "b4ae3badf8e488ce2db2f4597a72e57383c20b26",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/token_option.go",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftoken_option.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftoken_option.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftoken_option.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,5 @@\n+package jwt\n+\n+// TokenOption is a reserved type, which provides some forward compatibility,\n+// if we ever want to introduce token creation-related options.\n+type TokenOption func(*Token)"
    },
    {
      "sha": "b2655a9e6d26db6d144063c098957b0bc36a090e",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/types.go",
      "status": "added",
      "additions": 149,
      "deletions": 0,
      "changes": 149,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftypes.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftypes.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Ftypes.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,149 @@\n+package jwt\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"strconv\"\n+\t\"time\"\n+)\n+\n+// TimePrecision sets the precision of times and dates within this library. This\n+// has an influence on the precision of times when comparing expiry or other\n+// related time fields. Furthermore, it is also the precision of times when\n+// serializing.\n+//\n+// For backwards compatibility the default precision is set to seconds, so that\n+// no fractional timestamps are generated.\n+var TimePrecision = time.Second\n+\n+// MarshalSingleStringAsArray modifies the behavior of the ClaimStrings type,\n+// especially its MarshalJSON function.\n+//\n+// If it is set to true (the default), it will always serialize the type as an\n+// array of strings, even if it just contains one element, defaulting to the\n+// behavior of the underlying []string. If it is set to false, it will serialize\n+// to a single string, if it contains one element. Otherwise, it will serialize\n+// to an array of strings.\n+var MarshalSingleStringAsArray = true\n+\n+// NumericDate represents a JSON numeric date value, as referenced at\n+// https://datatracker.ietf.org/doc/html/rfc7519#section-2.\n+type NumericDate struct {\n+\ttime.Time\n+}\n+\n+// NewNumericDate constructs a new *NumericDate from a standard library time.Time struct.\n+// It will truncate the timestamp according to the precision specified in TimePrecision.\n+func NewNumericDate(t time.Time) *NumericDate {\n+\treturn &NumericDate{t.Truncate(TimePrecision)}\n+}\n+\n+// newNumericDateFromSeconds creates a new *NumericDate out of a float64 representing a\n+// UNIX epoch with the float fraction representing non-integer seconds.\n+func newNumericDateFromSeconds(f float64) *NumericDate {\n+\tround, frac := math.Modf(f)\n+\treturn NewNumericDate(time.Unix(int64(round), int64(frac*1e9)))\n+}\n+\n+// MarshalJSON is an implementation of the json.RawMessage interface and serializes the UNIX epoch\n+// represented in NumericDate to a byte array, using the precision specified in TimePrecision.\n+func (date NumericDate) MarshalJSON() (b []byte, err error) {\n+\tvar prec int\n+\tif TimePrecision < time.Second {\n+\t\tprec = int(math.Log10(float64(time.Second) / float64(TimePrecision)))\n+\t}\n+\ttruncatedDate := date.Truncate(TimePrecision)\n+\n+\t// For very large timestamps, UnixNano would overflow an int64, but this\n+\t// function requires nanosecond level precision, so we have to use the\n+\t// following technique to get round the issue:\n+\t//\n+\t// 1. Take the normal unix timestamp to form the whole number part of the\n+\t//    output,\n+\t// 2. Take the result of the Nanosecond function, which returns the offset\n+\t//    within the second of the particular unix time instance, to form the\n+\t//    decimal part of the output\n+\t// 3. Concatenate them to produce the final result\n+\tseconds := strconv.FormatInt(truncatedDate.Unix(), 10)\n+\tnanosecondsOffset := strconv.FormatFloat(float64(truncatedDate.Nanosecond())/float64(time.Second), 'f', prec, 64)\n+\n+\toutput := append([]byte(seconds), []byte(nanosecondsOffset)[1:]...)\n+\n+\treturn output, nil\n+}\n+\n+// UnmarshalJSON is an implementation of the json.RawMessage interface and\n+// deserializes a [NumericDate] from a JSON representation, i.e. a\n+// [json.Number]. This number represents an UNIX epoch with either integer or\n+// non-integer seconds.\n+func (date *NumericDate) UnmarshalJSON(b []byte) (err error) {\n+\tvar (\n+\t\tnumber json.Number\n+\t\tf      float64\n+\t)\n+\n+\tif err = json.Unmarshal(b, &number); err != nil {\n+\t\treturn fmt.Errorf(\"could not parse NumericData: %w\", err)\n+\t}\n+\n+\tif f, err = number.Float64(); err != nil {\n+\t\treturn fmt.Errorf(\"could not convert json number value to float: %w\", err)\n+\t}\n+\n+\tn := newNumericDateFromSeconds(f)\n+\t*date = *n\n+\n+\treturn nil\n+}\n+\n+// ClaimStrings is basically just a slice of strings, but it can be either\n+// serialized from a string array or just a string. This type is necessary,\n+// since the \"aud\" claim can either be a single string or an array.\n+type ClaimStrings []string\n+\n+func (s *ClaimStrings) UnmarshalJSON(data []byte) (err error) {\n+\tvar value interface{}\n+\n+\tif err = json.Unmarshal(data, &value); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar aud []string\n+\n+\tswitch v := value.(type) {\n+\tcase string:\n+\t\taud = append(aud, v)\n+\tcase []string:\n+\t\taud = ClaimStrings(v)\n+\tcase []interface{}:\n+\t\tfor _, vv := range v {\n+\t\t\tvs, ok := vv.(string)\n+\t\t\tif !ok {\n+\t\t\t\treturn ErrInvalidType\n+\t\t\t}\n+\t\t\taud = append(aud, vs)\n+\t\t}\n+\tcase nil:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn ErrInvalidType\n+\t}\n+\n+\t*s = aud\n+\n+\treturn\n+}\n+\n+func (s ClaimStrings) MarshalJSON() (b []byte, err error) {\n+\t// This handles a special case in the JWT RFC. If the string array, e.g.\n+\t// used by the \"aud\" field, only contains one element, it MAY be serialized\n+\t// as a single string. This may or may not be desired based on the ecosystem\n+\t// of other JWT library used, so we make it configurable by the variable\n+\t// MarshalSingleStringAsArray.\n+\tif len(s) == 1 && !MarshalSingleStringAsArray {\n+\t\treturn json.Marshal(s[0])\n+\t}\n+\n+\treturn json.Marshal([]string(s))\n+}"
    },
    {
      "sha": "008ecd8712ec5edc778c760314bf77ab1609b964",
      "filename": "backend/vendor/github.com/golang-jwt/jwt/v5/validator.go",
      "status": "added",
      "additions": 316,
      "deletions": 0,
      "changes": 316,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fvalidator.go",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fvalidator.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgolang-jwt%2Fjwt%2Fv5%2Fvalidator.go?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -0,0 +1,316 @@\n+package jwt\n+\n+import (\n+\t\"crypto/subtle\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+// ClaimsValidator is an interface that can be implemented by custom claims who\n+// wish to execute any additional claims validation based on\n+// application-specific logic. The Validate function is then executed in\n+// addition to the regular claims validation and any error returned is appended\n+// to the final validation result.\n+//\n+//\ttype MyCustomClaims struct {\n+//\t    Foo string `json:\"foo\"`\n+//\t    jwt.RegisteredClaims\n+//\t}\n+//\n+//\tfunc (m MyCustomClaims) Validate() error {\n+//\t    if m.Foo != \"bar\" {\n+//\t        return errors.New(\"must be foobar\")\n+//\t    }\n+//\t    return nil\n+//\t}\n+type ClaimsValidator interface {\n+\tClaims\n+\tValidate() error\n+}\n+\n+// Validator is the core of the new Validation API. It is automatically used by\n+// a [Parser] during parsing and can be modified with various parser options.\n+//\n+// The [NewValidator] function should be used to create an instance of this\n+// struct.\n+type Validator struct {\n+\t// leeway is an optional leeway that can be provided to account for clock skew.\n+\tleeway time.Duration\n+\n+\t// timeFunc is used to supply the current time that is needed for\n+\t// validation. If unspecified, this defaults to time.Now.\n+\ttimeFunc func() time.Time\n+\n+\t// requireExp specifies whether the exp claim is required\n+\trequireExp bool\n+\n+\t// verifyIat specifies whether the iat (Issued At) claim will be verified.\n+\t// According to https://www.rfc-editor.org/rfc/rfc7519#section-4.1.6 this\n+\t// only specifies the age of the token, but no validation check is\n+\t// necessary. However, if wanted, it can be checked if the iat is\n+\t// unrealistic, i.e., in the future.\n+\tverifyIat bool\n+\n+\t// expectedAud contains the audience this token expects. Supplying an empty\n+\t// string will disable aud checking.\n+\texpectedAud string\n+\n+\t// expectedIss contains the issuer this token expects. Supplying an empty\n+\t// string will disable iss checking.\n+\texpectedIss string\n+\n+\t// expectedSub contains the subject this token expects. Supplying an empty\n+\t// string will disable sub checking.\n+\texpectedSub string\n+}\n+\n+// NewValidator can be used to create a stand-alone validator with the supplied\n+// options. This validator can then be used to validate already parsed claims.\n+//\n+// Note: Under normal circumstances, explicitly creating a validator is not\n+// needed and can potentially be dangerous; instead functions of the [Parser]\n+// class should be used.\n+//\n+// The [Validator] is only checking the *validity* of the claims, such as its\n+// expiration time, but it does NOT perform *signature verification* of the\n+// token.\n+func NewValidator(opts ...ParserOption) *Validator {\n+\tp := NewParser(opts...)\n+\treturn p.validator\n+}\n+\n+// Validate validates the given claims. It will also perform any custom\n+// validation if claims implements the [ClaimsValidator] interface.\n+//\n+// Note: It will NOT perform any *signature verification* on the token that\n+// contains the claims and expects that the [Claim] was already successfully\n+// verified.\n+func (v *Validator) Validate(claims Claims) error {\n+\tvar (\n+\t\tnow  time.Time\n+\t\terrs []error = make([]error, 0, 6)\n+\t\terr  error\n+\t)\n+\n+\t// Check, if we have a time func\n+\tif v.timeFunc != nil {\n+\t\tnow = v.timeFunc()\n+\t} else {\n+\t\tnow = time.Now()\n+\t}\n+\n+\t// We always need to check the expiration time, but usage of the claim\n+\t// itself is OPTIONAL by default. requireExp overrides this behavior\n+\t// and makes the exp claim mandatory.\n+\tif err = v.verifyExpiresAt(claims, now, v.requireExp); err != nil {\n+\t\terrs = append(errs, err)\n+\t}\n+\n+\t// We always need to check not-before, but usage of the claim itself is\n+\t// OPTIONAL.\n+\tif err = v.verifyNotBefore(claims, now, false); err != nil {\n+\t\terrs = append(errs, err)\n+\t}\n+\n+\t// Check issued-at if the option is enabled\n+\tif v.verifyIat {\n+\t\tif err = v.verifyIssuedAt(claims, now, false); err != nil {\n+\t\t\terrs = append(errs, err)\n+\t\t}\n+\t}\n+\n+\t// If we have an expected audience, we also require the audience claim\n+\tif v.expectedAud != \"\" {\n+\t\tif err = v.verifyAudience(claims, v.expectedAud, true); err != nil {\n+\t\t\terrs = append(errs, err)\n+\t\t}\n+\t}\n+\n+\t// If we have an expected issuer, we also require the issuer claim\n+\tif v.expectedIss != \"\" {\n+\t\tif err = v.verifyIssuer(claims, v.expectedIss, true); err != nil {\n+\t\t\terrs = append(errs, err)\n+\t\t}\n+\t}\n+\n+\t// If we have an expected subject, we also require the subject claim\n+\tif v.expectedSub != \"\" {\n+\t\tif err = v.verifySubject(claims, v.expectedSub, true); err != nil {\n+\t\t\terrs = append(errs, err)\n+\t\t}\n+\t}\n+\n+\t// Finally, we want to give the claim itself some possibility to do some\n+\t// additional custom validation based on a custom Validate function.\n+\tcvt, ok := claims.(ClaimsValidator)\n+\tif ok {\n+\t\tif err := cvt.Validate(); err != nil {\n+\t\t\terrs = append(errs, err)\n+\t\t}\n+\t}\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\treturn joinErrors(errs...)\n+}\n+\n+// verifyExpiresAt compares the exp claim in claims against cmp. This function\n+// will succeed if cmp < exp. Additional leeway is taken into account.\n+//\n+// If exp is not set, it will succeed if the claim is not required,\n+// otherwise ErrTokenRequiredClaimMissing will be returned.\n+//\n+// Additionally, if any error occurs while retrieving the claim, e.g., when its\n+// the wrong type, an ErrTokenUnverifiable error will be returned.\n+func (v *Validator) verifyExpiresAt(claims Claims, cmp time.Time, required bool) error {\n+\texp, err := claims.GetExpirationTime()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif exp == nil {\n+\t\treturn errorIfRequired(required, \"exp\")\n+\t}\n+\n+\treturn errorIfFalse(cmp.Before((exp.Time).Add(+v.leeway)), ErrTokenExpired)\n+}\n+\n+// verifyIssuedAt compares the iat claim in claims against cmp. This function\n+// will succeed if cmp >= iat. Additional leeway is taken into account.\n+//\n+// If iat is not set, it will succeed if the claim is not required,\n+// otherwise ErrTokenRequiredClaimMissing will be returned.\n+//\n+// Additionally, if any error occurs while retrieving the claim, e.g., when its\n+// the wrong type, an ErrTokenUnverifiable error will be returned.\n+func (v *Validator) verifyIssuedAt(claims Claims, cmp time.Time, required bool) error {\n+\tiat, err := claims.GetIssuedAt()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif iat == nil {\n+\t\treturn errorIfRequired(required, \"iat\")\n+\t}\n+\n+\treturn errorIfFalse(!cmp.Before(iat.Add(-v.leeway)), ErrTokenUsedBeforeIssued)\n+}\n+\n+// verifyNotBefore compares the nbf claim in claims against cmp. This function\n+// will return true if cmp >= nbf. Additional leeway is taken into account.\n+//\n+// If nbf is not set, it will succeed if the claim is not required,\n+// otherwise ErrTokenRequiredClaimMissing will be returned.\n+//\n+// Additionally, if any error occurs while retrieving the claim, e.g., when its\n+// the wrong type, an ErrTokenUnverifiable error will be returned.\n+func (v *Validator) verifyNotBefore(claims Claims, cmp time.Time, required bool) error {\n+\tnbf, err := claims.GetNotBefore()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif nbf == nil {\n+\t\treturn errorIfRequired(required, \"nbf\")\n+\t}\n+\n+\treturn errorIfFalse(!cmp.Before(nbf.Add(-v.leeway)), ErrTokenNotValidYet)\n+}\n+\n+// verifyAudience compares the aud claim against cmp.\n+//\n+// If aud is not set or an empty list, it will succeed if the claim is not required,\n+// otherwise ErrTokenRequiredClaimMissing will be returned.\n+//\n+// Additionally, if any error occurs while retrieving the claim, e.g., when its\n+// the wrong type, an ErrTokenUnverifiable error will be returned.\n+func (v *Validator) verifyAudience(claims Claims, cmp string, required bool) error {\n+\taud, err := claims.GetAudience()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif len(aud) == 0 {\n+\t\treturn errorIfRequired(required, \"aud\")\n+\t}\n+\n+\t// use a var here to keep constant time compare when looping over a number of claims\n+\tresult := false\n+\n+\tvar stringClaims string\n+\tfor _, a := range aud {\n+\t\tif subtle.ConstantTimeCompare([]byte(a), []byte(cmp)) != 0 {\n+\t\t\tresult = true\n+\t\t}\n+\t\tstringClaims = stringClaims + a\n+\t}\n+\n+\t// case where \"\" is sent in one or many aud claims\n+\tif stringClaims == \"\" {\n+\t\treturn errorIfRequired(required, \"aud\")\n+\t}\n+\n+\treturn errorIfFalse(result, ErrTokenInvalidAudience)\n+}\n+\n+// verifyIssuer compares the iss claim in claims against cmp.\n+//\n+// If iss is not set, it will succeed if the claim is not required,\n+// otherwise ErrTokenRequiredClaimMissing will be returned.\n+//\n+// Additionally, if any error occurs while retrieving the claim, e.g., when its\n+// the wrong type, an ErrTokenUnverifiable error will be returned.\n+func (v *Validator) verifyIssuer(claims Claims, cmp string, required bool) error {\n+\tiss, err := claims.GetIssuer()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif iss == \"\" {\n+\t\treturn errorIfRequired(required, \"iss\")\n+\t}\n+\n+\treturn errorIfFalse(iss == cmp, ErrTokenInvalidIssuer)\n+}\n+\n+// verifySubject compares the sub claim against cmp.\n+//\n+// If sub is not set, it will succeed if the claim is not required,\n+// otherwise ErrTokenRequiredClaimMissing will be returned.\n+//\n+// Additionally, if any error occurs while retrieving the claim, e.g., when its\n+// the wrong type, an ErrTokenUnverifiable error will be returned.\n+func (v *Validator) verifySubject(claims Claims, cmp string, required bool) error {\n+\tsub, err := claims.GetSubject()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif sub == \"\" {\n+\t\treturn errorIfRequired(required, \"sub\")\n+\t}\n+\n+\treturn errorIfFalse(sub == cmp, ErrTokenInvalidSubject)\n+}\n+\n+// errorIfFalse returns the error specified in err, if the value is true.\n+// Otherwise, nil is returned.\n+func errorIfFalse(value bool, err error) error {\n+\tif value {\n+\t\treturn nil\n+\t} else {\n+\t\treturn err\n+\t}\n+}\n+\n+// errorIfRequired returns an ErrTokenRequiredClaimMissing error if required is\n+// true. Otherwise, nil is returned.\n+func errorIfRequired(required bool, claim string) error {\n+\tif required {\n+\t\treturn newError(fmt.Sprintf(\"%s claim is required\", claim), ErrTokenRequiredClaimMissing)\n+\t} else {\n+\t\treturn nil\n+\t}\n+}"
    },
    {
      "sha": "93f581edacd876a8119ccd4222478037c810a555",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fmodules.txt",
      "raw_url": "https://github.com/umputun/remark42/raw/d5162d3fe6ba9c656db0b2066d3e377c9e144d95/backend%2Fvendor%2Fmodules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fmodules.txt?ref=d5162d3fe6ba9c656db0b2066d3e377c9e144d95",
      "patch": "@@ -65,15 +65,15 @@ github.com/go-chi/render\n github.com/go-oauth2/oauth2/v4\n github.com/go-oauth2/oauth2/v4/errors\n github.com/go-oauth2/oauth2/v4/server\n-# github.com/go-pkgz/auth v1.24.3-0.20241007090635-78537e6f812d\n+# github.com/go-pkgz/auth/v2 v2.0.0-20241208183119-88b3a842be9f\n ## explicit; go 1.21\n-github.com/go-pkgz/auth\n-github.com/go-pkgz/auth/avatar\n-github.com/go-pkgz/auth/logger\n-github.com/go-pkgz/auth/middleware\n-github.com/go-pkgz/auth/provider\n-github.com/go-pkgz/auth/provider/sender\n-github.com/go-pkgz/auth/token\n+github.com/go-pkgz/auth/v2\n+github.com/go-pkgz/auth/v2/avatar\n+github.com/go-pkgz/auth/v2/logger\n+github.com/go-pkgz/auth/v2/middleware\n+github.com/go-pkgz/auth/v2/provider\n+github.com/go-pkgz/auth/v2/provider/sender\n+github.com/go-pkgz/auth/v2/token\n # github.com/go-pkgz/email v0.5.0\n ## explicit; go 1.19\n github.com/go-pkgz/email\n@@ -105,9 +105,9 @@ github.com/go-pkgz/rest/realip\n # github.com/go-pkgz/syncs v1.3.2\n ## explicit; go 1.20\n github.com/go-pkgz/syncs\n-# github.com/golang-jwt/jwt v3.2.2+incompatible\n-## explicit\n-github.com/golang-jwt/jwt\n+# github.com/golang-jwt/jwt/v5 v5.2.1\n+## explicit; go 1.18\n+github.com/golang-jwt/jwt/v5\n # github.com/golang/snappy v0.0.4\n ## explicit\n github.com/golang/snappy"
    }
  ]
}
