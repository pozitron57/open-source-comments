{
  "sha": "b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
  "node_id": "C_kwDOAKEu-toAKGI4YTkxZTg3YWI5NzM0ZDNlNzdkZmI0YTc1YjRjYTMzMTdkMDg4OTA",
  "commit": {
    "author": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2025-02-03T08:58:10Z"
    },
    "committer": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2025-02-03T08:58:10Z"
    },
    "message": "Merge v0.2025.001 into 'release'.",
    "tree": {
      "sha": "f6e73b39a510e6682996913ddb193e4fd0b42152",
      "url": "https://api.github.com/repos/debiki/talkyard/git/trees/f6e73b39a510e6682996913ddb193e4fd0b42152"
    },
    "url": "https://api.github.com/repos/debiki/talkyard/git/commits/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/debiki/talkyard/commits/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
  "html_url": "https://github.com/debiki/talkyard/commit/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
  "comments_url": "https://api.github.com/repos/debiki/talkyard/commits/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/comments",
  "author": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "committer": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca",
      "url": "https://api.github.com/repos/debiki/talkyard/commits/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca",
      "html_url": "https://github.com/debiki/talkyard/commit/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca"
    },
    {
      "sha": "6d4bd78f81d31a58d43ea98d75d2c49af956a6a4",
      "url": "https://api.github.com/repos/debiki/talkyard/commits/6d4bd78f81d31a58d43ea98d75d2c49af956a6a4",
      "html_url": "https://github.com/debiki/talkyard/commit/6d4bd78f81d31a58d43ea98d75d2c49af956a6a4"
    }
  ],
  "stats": {
    "total": 6323,
    "additions": 4803,
    "deletions": 1520
  },
  "files": [
    {
      "sha": "d6f73f398e9a5967a6c9571da84ee306018b17f7",
      "filename": "LICENSE-BUSLv11.txt",
      "status": "removed",
      "additions": 0,
      "deletions": 47,
      "changes": 47,
      "blob_url": "https://github.com/debiki/talkyard/blob/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca/LICENSE-BUSLv11.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca/LICENSE-BUSLv11.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/LICENSE-BUSLv11.txt?ref=1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca",
      "patch": "@@ -1,47 +0,0 @@\n-License text copyright © 2017 MariaDB Corporation Ab, All Rights Reserved. \"Business Source License\" is a trademark of MariaDB Corporation Ab.\n-\n-Terms\n-\n-Change Date: 2029-01-01\n-Change License: GNU General Public License v2.0 or later\n-Additional Use Grant: You can use the Licensed Work, that is, Talkyard, in production for up to 4 months (123 days) after the day when your organization first installed Talkyard. (Installed — not when you upgraded to some later version.)\n-\n-The Licensor hereby grants you the right to copy, modify, create derivative works, redistribute, and make non-production use of the Licensed Work. The Licensor may make an Additional Use Grant, above, permitting limited production use.\n-\n-Effective on the Change Date, or the fourth anniversary of the first publicly available distribution of a specific version of the Licensed Work under this License, whichever comes first, the Licensor hereby grants you rights under the terms of the Change License, and the rights granted in the paragraph above terminate.\n-\n-If your use of the Licensed Work does not comply with the requirements currently in effect as described in this License, you must purchase a commercial license from the Licensor, its affiliated entities, or authorized resellers, or you must refrain from using the Licensed Work.\n-\n-All copies of the original and modified Licensed Work, and derivative works of the Licensed Work, are subject to this License. This License applies separately for each version of the Licensed Work and the Change Date may vary for each version of the Licensed Work released by Licensor.\n-\n-You must conspicuously display this License on each original or modified copy of the Licensed Work. If you receive the Licensed Work in original or modified form from a third party, the terms and conditions set forth in this License apply to your use of that work.\n-\n-Any use of the Licensed Work in violation of this License will automatically terminate your rights under this License for the current and all other versions of the Licensed Work.\n-\n-This License does not grant you any right in any trademark or logo of Licensor or its affiliates (provided that you may use a trademark or logo of Licensor as expressly required by this License).\n-\n-TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON AN \"AS IS\" BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND TITLE.\n-\n-MariaDB hereby grants you permission to use this License's text to license your works, and to refer to it using the trademark \"Business Source License\", as long as you comply with the Covenants of Licensor below.\n-\n-Covenants of Licensor\n-\n-In consideration of the right to use this License's text and the \"Business Source License\" name and trademark, Licensor covenants to MariaDB, and to all other recipients of the licensed work to be provided by Licensor:\n-\n-    1. To specify as the Change License the GPL Version 2.0 or any later version, or a license that is compatible with GPL Version 2.0 or a later version, where \"compatible\" means that software provided under the Change License can be included in a program with software provided under GPL Version 2.0 or a later version. Licensor may specify additional Change Licenses without limitation.\n-    2. To either: (a) specify an additional grant of rights to use that does not impose any additional restriction on the right granted in this License, as the Additional Use Grant; or (b) insert the text \"None\".\n-    3. To specify a Change Date.\n-    4. Not to modify this License in any other way.\n-\n-Notice\n-\n-- The Business Source License (this document, or the \"License\") is not an Open Source license. However, the Licensed Work will eventually be made available under an Open Source License, as stated in this License.\n-\n-- License text available here: https://spdx.org/licenses/BUSL-1.1.html\n-  and here: https://mariadb.com/bsl11/.\n-\n-- Here's a license FAQ: https://mariadb.com/bsl-faq-mariadb/.\n-\n-- After the above-mentioned change date, you can *not* redistribute Talkyard under GPLv2\n-  — because Talkyard includes Apache2 software and Apache2 is incompatible with GPLv2.\n-  You can, however, after the change date, redistribute Talkyard under GPLv3 or later."
    },
    {
      "sha": "532ea2acb2d6806d98273d0ba9526e389ec7b303",
      "filename": "README.md",
      "status": "modified",
      "additions": 14,
      "deletions": 6,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/README.md",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/README.md",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/README.md?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -306,13 +306,21 @@ That repo, squashed, is in this repo.\n License\n -----------------------------\n \n-Copyright (c) 2010-2024 Kaj Magnus Lindberg and contributors.\n+Copyright (c) 2010-2025 Kaj Magnus Lindberg and contributors.\n \n-Talkyard is multi licensed under 1) AGPLv3 or later, see LICENSE.txt, and\n-2) Business Source License v1.1, with change license GPLv2 or later, and\n-change date 2029-01-01 (we bump the change date yearly,\n-so it's between 4 and 5 years into the future) — see LICENSE-BUSLv1.1.txt.\n-And 3) possibly other licenses.\n+Talkyard is licensed under AGPLv3 or later, see LICENSE.txt.\n+\n+<!-- Later, add this, but first ask someone if the wording is ok:\n+Starting on 2032-01-01, this specific version of Talkyard (see ./version.txt)\n+is also licensed under GPLv2 or later. That is, AGPLv3+ until year 2032, thereafter\n+dual licensed under AGPLv3+ and GPLv2+.\n+\n+Note:\n+  - We try to bump the above GPLv2 date each year, so it's 6–7 years in the future.\n+  - After the above GPLv2+ date, you can *not* redistribute Talkyard under GPLv2\n+    — Talkyard includes Apache2 software and Apache2 is incompatible with GPLv2.\n+    You can, however, after the GPLv2+ date, redistribute Talkyard under GPLv3+.\n+-->\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of"
    },
    {
      "sha": "29b934740bd843a3a06c5a7a3d090dbec22b539f",
      "filename": "appsv/model/src/main/scala/com/debiki/core/Page.scala",
      "status": "modified",
      "additions": 160,
      "deletions": 1,
      "changes": 161,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPage.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPage.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPage.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1188,9 +1188,137 @@ object PinPageWhere {\n \n \n \n-// MOVE these two (PageQuery, PostQuery) to their own file,  queries.scala?\n+// --------------------------------------------------------------------------------------\n+// MOVE QUICK the rest of this page to its own file,  queries.scala?\n // And add more, e.g. user queries.\n \n+\n+sealed abstract class WhichPostsOnPage(val onlyPublic: Bo, val onlyPrivate: Bo) {\n+  assert(!onlyPublic || !onlyPrivate)\n+\n+  /** Hidden and deleted posts are \"inactive\", all others are \"active\" — for example,\n+    * a post in a collapsed thread is not visible, but it's acvite, for\n+    * lack of a better word.\n+    */\n+  def activeOnly: Bo\n+\n+  /** If activeOnly, then, set mustBeApproved to Some(false) to nevertheless load not-yet-\n+    * -approved posts. Useful for loading one's bookmarks which don't need to be approved.\n+    * (And private comments? [priv_comts])\n+    *\n+    * Default (if None) is same as activeOnly. [load_only_approved]\n+    */\n+  def mustBeApproved: Opt[Bo]\n+}\n+\n+\n+object WhichPostsOnPage {\n+\n+  def thoseMaybeRelatedTo(postNr: PostNr): WhichPostsOnPage = {\n+    if (postNr >= PageParts.MinPublicNr) {\n+      // Public comments cannot reply to private things.\n+      OnlyPublic()\n+    }\n+    else {\n+      // Bookmarks and private comments are always related to some public post\n+      // (not always directly, but as descendants of).\n+      AllByAnyone()\n+    }\n+  }\n+\n+  /** Posts you can see, if you have access to the page, are called \"public\". E.g.\n+    * the title, orig post & comments — but not bookmarks or private comments.\n+    */\n+  case class OnlyPublic(\n+    activeOnly: Bo = false,\n+    mustBeApproved: Opt[Bo] = None,\n+  ) extends WhichPostsOnPage(onlyPublic = true, onlyPrivate = false)\n+\n+  /** Bookmarks and private comments (e.g. between moderators).  [priv_comts]\n+    * Currently only bookmarks — private comments not yet implemented.\n+    */\n+  case class OnlyPrivate(\n+    byUserId: PatId,\n+    // groupIds: Set[PatId], // later. byUserId's groups.\n+    activeOnly: Bo = false,\n+    mustBeApproved: Opt[Bo] = None,\n+  ) extends WhichPostsOnPage(onlyPublic = false, onlyPrivate = true)\n+\n+\n+  /** For loading more chat messages, when scrolling up/down in a chat. Then, we first\n+    * load only top level comments — and if ever [threaded_chat]s get implemented, then,\n+    * as a subsequent step, we'd load a few nested replies (if any) to those\n+    * top level comments (and one might need to click to see all, depending on how many).\n+    *\n+    * The comment with post nr = `offset` gets loaded, and `limit - 1` more\n+    * comments in the `direction` direction.\n+    *\n+    * @param offset Later:  Should? Must? be divible by 25? or 10?, so simpler to cache.\n+    *   Why 25?:\n+    *   My wide 30'' screen fits these many comments:\n+    *   HackerNews zoomed out to 75%: I see sometimes 21 sometimes 24 pretty short\n+    *   comments at a time.  Slack fits around 16, 100% zoom.  GitHub Issues maybe 13?\n+    *   Talkyard: 30'' height: 1458 px (browser window decoration takes some space),\n+    *   short message height: 47px + 15 margin = 62px  and  1458 / 62 = 23.5,  but\n+    *   if zommed out 90%:  1600 / 62  =  25.4 messages.\n+    *   Maybe chunks of 25 then?\n+    *   And if loading cached json (from page_html_cache_t) to show chat messages,\n+    *   the most recent chunk is enough.  While if jumping to a bookmarked message,\n+    *   then, one or two chunks would be enough to fill the page with messages above\n+    *   & below the bookmarked one, also on 30'' monitors.\n+    *\n+    *   O.t.o.h. if optimizing for mobile phones, then, maybe smaller chunk size, say\n+    *   just 10, might make sense — but caching *at all* would be what makes the major\n+    *   difference? not if the chunk size is 10 or 25?  Still, there's already\n+    *   page_html_cache_t.param_width_layout_c  which tells us if it's probably a\n+    *   mobile phone, or a >= laptop.  So we *could* use different sizes\n+    *   depending on if mobile or >= laptop, say,  10 for mobile, else 25.\n+    *   Or use 10 always, and fetch 2–3 chunks to render on laptops, would be ok too.\n+    *\n+    * @param direction:\n+    */\n+  case class TopLevelRange(\n+    offset: PostNr,\n+    direction: RangeDir,\n+    activeOnly: Bo,\n+    mustBeApproved: Opt[Bo] = None,\n+    ) extends WhichPostsOnPage(onlyPublic = true, onlyPrivate = false) {\n+\n+    def limit: i32 = 25  // see param `offset` comment above. For now  [chat_pagination_size]\n+  }\n+\n+\n+  /** By any user.\n+    */\n+  case class AllByAnyone(\n+    activeOnly: Bo = false,\n+    mustBeApproved: Opt[Bo] = None,\n+  ) extends WhichPostsOnPage(\n+      onlyPublic = false, onlyPrivate = false)\n+}\n+\n+\n+sealed abstract class RangeDir(val IntVal: i32)\n+\n+object RangeDir {\n+  /** Older as in less recent posts on a page. */\n+  case object Older extends RangeDir(-1)\n+\n+  /** The more recent posts on a page. */\n+  case object Newer extends RangeDir(+1)\n+\n+  /** Loads limit/2 older comments and limit/2 newer comments, maybe a bit more. */\n+  case object Around extends RangeDir(0)\n+\n+  def fromInt(value: i32): Opt[RangeDir] = Some(value match {\n+    case Older.IntVal => Older\n+    case Newer.IntVal => Newer\n+    case Around.IntVal => Around\n+    case _ => return None\n+  })\n+}\n+\n+\n case class PageQuery(  // also see PeopleQuery\n   orderOffset: PageOrderOffset,\n   pageFilter: PageFilter,\n@@ -1217,6 +1345,13 @@ sealed trait PostQuery {\n \n \n object PostQuery {\n+\n+  /** But what about private comments? \"All\" sounds as if they'd be included.\n+    * And bookmarks are currently implemented as posts — what about them?\n+    * Currenly bookmarks & private comments are excluded: [all_0_incl_bookmarks] [priv_comts]\n+    *\n+    * RENAME QUICK to just Posts? (Without \"all\")\n+    */\n   case class AllPosts(\n     reqrInf: ReqrInf,\n     inclAnonPosts: Bo,\n@@ -1232,6 +1367,8 @@ object PostQuery {\n \n   }\n \n+  /** This also excludes bookmarks & private comments: [all_0_incl_bookmarks]\n+    */\n   case class PostsRelatedToPat[T <: PatNodeRelType](\n     reqrInf: ReqrInf,\n     relatedPatId: PatId,\n@@ -1251,9 +1388,14 @@ object PostQuery {\n   }\n \n   // Later, replace w PostsRelatedToPat and relType AuthorOf.\n+  /** Also excludes bookmarks & private comments: [all_0_incl_bookmarks]\n+    */\n   case class PostsByAuthor(\n     reqrInf: ReqrInf,\n     authorId: PatId,\n+    // Currently not in use. But \"needed\" for consistency? Because one can specify\n+    // type Bookmark, but then a PatsBookmarks query is used.\n+    onlyPostType: Opt[PostType],  // [onlyPostType_not_used]\n     inclAnonPosts: Bo,\n     inclTitles: Bo,\n     inclUnapproved: Bo,\n@@ -1268,6 +1410,8 @@ object PostQuery {\n   }\n \n \n+  /** Excludes bookmarks & private comments: [all_0_incl_bookmarks]\n+    */\n   case class PostsWithTag(\n     reqrInf: ReqrInf,\n     tagTypeId: TagTypeId,\n@@ -1282,6 +1426,21 @@ object PostQuery {\n     def inclAnonPosts = true\n     def inclTitles = false\n   }\n+\n+\n+  case class PatsBookmarks(\n+    reqrInf: ReqrInf,\n+    bookmarkerId: PatId,\n+    // tagTypeId: Opt[TagTypeId] — maybe later\n+    limit: i32,\n+    orderBy: OrderBy,\n+    ) extends PostQuery {\n+\n+    def inclAnonPosts = true\n+    def inclTitles = false\n+    def inclUnapproved = true\n+    def inclUnlistedPagePosts = true\n+  }\n }\n \n "
    },
    {
      "sha": "70c94ea7c455226eb40e39472ebc8095c97f9b9a",
      "filename": "appsv/model/src/main/scala/com/debiki/core/PageParts.scala",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPageParts.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPageParts.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPageParts.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -44,7 +44,11 @@ case class InterestingPosters(\n \n object PageParts {\n \n+  // Private comments (e.g. between mods) and people's bookmarks aren't visible to others.\n+  // Their post nrs are <= -1001, so there's a quick way to find all not-private page parts.\n   val MaxPrivateNr: i32 = -1001\n+  val MinPublicNr : i32 = 0  // for now. But the title nr will change from 0 to -1?\n+  // (Values -1 ... -1000 are reserved, sort of.)\n \n   // Letting the page body / original post be number 1 is compatible with Discourse.\n   // COULD change to TitleNr = -1. That'd *reduce bug risk* because right now,\n@@ -299,7 +303,6 @@ abstract class PageParts {\n   }\n \n   def allPosts: Vec[Post]\n-  def activePosts: Vec[Post] = allPosts.filter(_.isVisible)\n \n   def postByNr(postNr: PostNr): Option[Post] = postsByNr.get(postNr)\n   def postByNr(postNr: Option[PostNr]): Option[Post] = postNr.flatMap(postsByNr.get)\n@@ -392,10 +395,12 @@ abstract class PageParts {\n   }\n \n \n+  // (Maybe exclude bookmarks?  Currently [bookmarks_filtered_out] elsewhere)\n   def childrenSortedOf(postNr: PostNr): immutable.Seq[Post] =\n     childrenSortedByParentNr.get(postNr).map(_.childsSorted) getOrElse Nil\n \n \n+  // (Exclude bookmarks?  Currently [bookmarks_filtered_out] elsewhere)\n   def descendantsOf(postNr: PostNr): immutable.Seq[Post] = {\n     val childs = childrenSortedOf(postNr)\n     val pending = ArrayBuffer[Post](childs: _*)"
    },
    {
      "sha": "591119860bee91ffa8091630711d4743145a3d30",
      "filename": "appsv/model/src/main/scala/com/debiki/core/Post.scala",
      "status": "modified",
      "additions": 19,
      "deletions": 12,
      "changes": 31,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPost.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPost.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPost.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -136,6 +136,7 @@ sealed abstract class PostType(\n   protected val IntValue: Int,\n   val isChat: Bo = false,\n   val isComment: Bo = false,\n+  val isPrivate: Bo = false,\n ) {\n   def toInt: Int = IntValue\n   def isWiki = false\n@@ -145,11 +146,17 @@ sealed abstract class PostType(\n }\n \n \n-// REFACTOR. See harmless bug below. Should change to a bit field, or split into separate fields.\n+// REFACTOR. See harmless bug below. Should change *some* types to a bit field,\n+// or split into separate fields.\n // The title should be it's own type. Maybe title and OP will be -1 and 1?\n // And comments 2, meta posts 3?\n+// But types Bookmark, Flag, Comment, Meta Comment still make sense?\n+// (Can't be both a bookmark and a flag, for example.)\n+//\n+// Currently types 1-12 are used in discussions  [depr_post_type],\n+// and can be tagged and bookmarked. SHOULD change to 1-31? Why not be able to\n+// tag & bookmark CompletedForm and MetaMessage?\n //\n-@deprecated  // [depr_post_type]\n object PostType {\n \n   // Maybe could be the same as PageType, + a higher bit set, if is a chat message, and another,\n@@ -223,6 +230,7 @@ object PostType {\n   //    date. For FormSubmission pages only.\n   // ? But isn't this CompletedForm above ?\n \n+  // But should be a *page* & page type, not a post?\n   /** Later:\n     *\n     * Flags of posts and pats, will in the future be posts themselves [flags_as_posts] —\n@@ -242,15 +250,13 @@ object PostType {\n     * version control? Should  posts_t  include a val_json_c  or  val_i32_c  (and maybe a  title_c),\n     * in addition to  current_source_c?  And editing any, creates a new post revision?\n     */\n-  case object Flag_later extends PostType(-1)   // probably not 51\n+  case object Flag_later extends PostType(-1)\n \n-  /** Later: Bookmarks.\n+  /** Bookmarks. Post nrs should be < 0, so can easily avoid loading other people's bookmarks.\n     *\n-    * A tree of bookmarks would be nicely stored as posts? Posts form a tree already,\n-    * have edit history, sub threads can be moved to other places in the tree.\n-    * And can be shared with each other, by changing visibility.\n+    * Is private: Others cannot see your bookmarks.\n     */\n-  case object Bookmark_later extends PostType(-1)\n+  case object Bookmark extends PostType(51, isPrivate = true)\n \n \n   def fromInt(value: Int): Option[PostType] = Some(value match {\n@@ -263,7 +269,7 @@ object PostType {\n     case CompletedForm.IntValue => CompletedForm\n     case MetaMessage.IntValue => MetaMessage\n     case Flag_later.IntValue => Flag_later\n-    case Bookmark_later.IntValue => Bookmark_later\n+    case Bookmark.IntValue => Bookmark\n     case _ => return None\n   })\n }\n@@ -478,8 +484,8 @@ case class Post(   // [exp] ok use\n   require(id >= 1, \"DwE4WEKQ8\")\n \n   if (isPrivate) {\n-    require(nr == PageParts.TitleNr || nr <= PageParts.MaxPrivateNr, s\"Private post nr is: ${nr\n-          } but should be < ${PageParts.MaxPrivateNr} [TyEPRIVPONR]\")\n+    require(nr <= PageParts.MaxPrivateNr, s\"Private post nr is: ${nr\n+          } but should be <= ${PageParts.MaxPrivateNr} [TyEPRIVPONR]\")\n   }\n   else {\n     require(nr == PageParts.TitleNr || nr >= PageParts.BodyNr, s\"Post nr: $nr [TyE4AKB28]\")\n@@ -579,7 +585,7 @@ case class Post(   // [exp] ok use\n   def isOrigPostReply: Boolean = isReply && parentNr.contains(PageParts.BodyNr) && !isBottomComment\n   def isMultireply: Boolean = isReply && multireplyPostNrs.nonEmpty\n   def isFlat: Boolean = tyype == PostType.Flat\n-  def isPrivate: Bo = false // privatePatsId.isDefined  [priv_comts]\n+  def isPrivate: Bo = tyype.isPrivate // || privatePatsId.isDefined  [priv_comts]\n   def isMetaMessage: Boolean = tyype == PostType.MetaMessage\n   def isBottomComment: Boolean = tyype == PostType.BottomComment   // RENAME to isProgressReply\n   def shallAppendLast: Boolean = isMetaMessage || isBottomComment\n@@ -604,6 +610,7 @@ case class Post(   // [exp] ok use\n \n   def createdAtUnixSeconds: UnixSecs = createdAt.getTime / 1000\n   def createdAtMillis: UnixMillis = createdAt.getTime\n+  def createdAtMnt: UnixMinutes = (createdAt.getTime / MillisPerMinute).toInt\n   def createdWhen: When = When.fromMillis(createdAt.getTime)\n \n   def newChildCollapsedStatus = new CollapsedStatus("
    },
    {
      "sha": "e797988fe6978f11cd2bf3ac6128e125bbfee66a",
      "filename": "appsv/model/src/main/scala/com/debiki/core/Prelude.scala",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPrelude.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPrelude.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FPrelude.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -675,6 +675,17 @@ object Prelude {   CLEAN_UP; RENAME // to BugDie and re-export the interesting\n     result\n   }\n \n+  /** Returns a random number between -RandomIdNrRangeLen and  PageParts.MaxPrivateNr.\n+    */\n+  def nextRandomPrivPostNr(): i32 = {\n+    assert(PageParts.MaxPrivateNr == -1001)\n+    val positiveNr = _random.nextInt(RandomIdNrRangeLen + PageParts.MaxPrivateNr)\n+    val nr = -positiveNr + PageParts.MaxPrivateNr\n+    require(nr <= PageParts.MaxPrivateNr)\n+    require(nr >= -RandomIdNrRangeLen)\n+    nr\n+  }\n+\n \n   /** Generates a by default 130 bits entropy string, almost 26 chars long since\n     * each char in a 32 chars alphabet has 5 bits (but we use 36 chars here)."
    },
    {
      "sha": "ccb8692e995c25430b5bcedf7849d43fc69576d7",
      "filename": "appsv/model/src/main/scala/com/debiki/core/SiteTransaction.scala",
      "status": "modified",
      "additions": 16,
      "deletions": 4,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FSiteTransaction.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FSiteTransaction.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2FSiteTransaction.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -111,16 +111,17 @@ trait SiteTransaction {   RENAME // to SiteTx — already started with a type Si\n   /** Useful for chats — then, we want to show the chat description, which is\n     * in the orig post. And the most recent chat messsages, to show.  */\n   def loadOrigPostAndLatestPosts(pageId: PageId, limit: Int): Seq[Post]\n-  def loadPostsOnPage(pageId: PageId, activeOnly: Bo = false): Vec[Post]\n+  def loadPostsOnPage(pageId: PageId, which: WhichPostsOnPage): Vec[Post]\n   def loadPostsByNrs(pagePostNrs: Iterable[PagePostNr]): immutable.Seq[Post]\n   /** The result is shorter, if some posts weren't found. */\n   def loadPostsByIdKeepOrder(postIds: Iterable[PostId]): ImmSeq[Post]\n   def loadPostsByUniqueId(postIds: Iterable[PostId]): immutable.Map[PostId, Post]     ; RENAME; QUICK // to loadPostsByIds\n   def loadPostsByExtIdAsMap(extImpIds: Iterable[ExtId]): immutable.Map[ExtId, Post]\n \n   def loadAllPostsForExport(): immutable.Seq[Post]\n-  def loadAllUnapprovedPosts(pageId: PageId, limit: Int): immutable.Seq[Post]\n-  def loadUnapprovedPosts(pageId: PageId, by: UserId, limit: Int): immutable.Seq[Post]\n+  // This loads one's bookmarks too (they are posts, unapproved).\n+  def loadUnapprovedPosts(pageId: PageId, ownBy: PatId, allPublic: Bo = false,\n+                          limit: i32): immutable.Seq[Post]\n   def loadCompletedForms(pageId: PageId, limit: Int): immutable.Seq[Post]\n \n \n@@ -166,6 +167,17 @@ trait SiteTransaction {   RENAME // to SiteTx — already started with a type Si\n   def loadDraftsByLocator(userId: UserId, draftLocator: DraftLocator): immutable.Seq[Draft]\n   def listDraftsRecentlyEditedFirst(userId: UserId, limit: Int): immutable.Seq[Draft]\n \n+  /** Returns (bookmarks, bookmarked-posts),  most recent first (no particular page).\n+    *\n+    * Bookmarks[X] might not be a bookmark for bookmarked-posts[X], and there would be\n+    * more bookmarks than bookmarked posts if some bookmarked posts have been deleted.\n+    *\n+    * @param offsetAt Currently ignored [to_paginate].\n+    * @param offsetId Ignored too.\n+    */\n+  def loadBookmarksAndBookmarkedPosts(byPatId: PatId,\n+          limit: i32, offsetAt: When, offsetId: PostId): (imm.Seq[Post], imm.Seq[Post])\n+\n   def nextPostId(): PostId\n   def insertPost(newPost: Post): Unit\n   def updatePost(newPost: Post): Unit\n@@ -202,7 +214,7 @@ trait SiteTransaction {   RENAME // to SiteTx — already started with a type Si\n \n   // Returns recently active pages first.\n   def loadPagePostNrsByPostIds(postIds: Iterable[PostId]): Map[PostId, PagePostNr]\n-  def loadPageIdsWithVisiblePostsBy(patIds: Set[PatId], limit: i32): Set[PageId]\n+  def loadPageIdsWithPublicActivePostsBy(patIds: Set[PatId], limit: i32): Set[PageId]\n   def loadPageIdsUserIsMemberOf(userAndGroupIds: Seq[MemId], onlyPageRoles: Set[PageType]): ImmSeq[PageId]\n   def loadReadProgress(userId: UserId, pageId: PageId): Option[PageReadingProgress]\n   def loadReadProgressAndIfHasSummaryEmailed(userId: UserId, pageId: PageId)"
    },
    {
      "sha": "6f0d169302965149eb81fefda03babfc20e13656",
      "filename": "appsv/model/src/main/scala/com/debiki/core/links.scala",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Flinks.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Flinks.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Flinks.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -70,12 +70,32 @@ case class LinkPreview(\n }\n \n \n+/** A link from one post to another, to show from where a page is linked from (backlinks).\n+  * If the link is to outside the forum, then it's external.\n+  *\n+  * @param fromPostId\n+  * @param linkUrl\n+  * @param addedAt\n+  * @param addedById\n+  * @param isExternal\n+  * @param isFromToPrivatePosts ? So we can exclude all private comment links  [priv_comts]\n+  *    when loading stuff to render the public cacheable version of a page. ?\n+  *     If it's from *or* to a private post, the link is private. But not if it's only\n+  *     from or to an access restricted page or category.\n+  * @param toStaffSpace\n+  * @param toPageId\n+  * @param toPostId\n+  * @param toPpId\n+  * @param toTagId\n+  * @param toCategoryId\n+  */\n case class Link(\n   fromPostId: PostId,\n   linkUrl: String,\n   addedAt: When,\n   addedById: UserId,\n   isExternal: Boolean,\n+  // isFromToPrivatePosts: Bo, — later? See descr above\n   toStaffSpace: Boolean = false,\n   toPageId: Option[PageId] = None,\n   toPostId: Option[PostId] = None,"
    },
    {
      "sha": "710fe63e46791df5add86ab7c02d1f23e0f441ed",
      "filename": "appsv/model/src/main/scala/com/debiki/core/package.scala",
      "status": "modified",
      "additions": 30,
      "deletions": 8,
      "changes": 38,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpackage.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpackage.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Fpackage.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -560,7 +560,8 @@ package object core {\n   }\n \n \n-  val LowestTempImpId: Int = 2*1000*1000*1000\n+  val LowestTempImpId: Int     = 2*1000*1000*1000\n+  val RandomIdNrRangeLen: Int  =      9*1000*1000\n   val FirstTempImpId: Int = LowestTempImpId + 1\n   def isPageTempId(pageId: PageId): Boolean =\n     pageId.length == 10 && pageId.startsWith(\"2000\") // good enough for now\n@@ -1349,6 +1350,7 @@ package object core {\n     */\n   case class PageRenderParams(\n     comtOrder: PostSortOrder,\n+    comtOffset: Opt[PostNr],\n     //comtNesting: NestingDepth, — later, for now, `def comtNesting` below instead\n     widthLayout: WidthLayout,\n     isEmbedded: Bo,\n@@ -1417,7 +1419,7 @@ package object core {\n           pageVersion = -1,\n           appVersion = \"wrong\",\n           renderParams = PageRenderParams(\n-                PostSortOrder.OldestFirst, WidthLayout.Tiny,\n+                PostSortOrder.OldestFirst, comtOffset = None, WidthLayout.Tiny,\n                 isEmbedded = false, \"https://example.com\", None, None, None, None),\n           storeJsonHash = \"wrong\")\n \n@@ -1483,10 +1485,30 @@ package object core {\n   sealed trait ComtOrderAtDepth\n \n   RENAME // to ComtOrder?\n-  sealed abstract class PostSortOrder(val IntVal: Int, val isByTime__remove: Bo) {\n+\n+\n+  /** How to sort posts, when rendering a page.  A bitfield, or rather, a nibble field.\n+    */\n+  sealed abstract class PostSortOrder(val IntVal: i32) {\n+\n     def toInt: Int = IntVal\n+\n     // Overridden by subclasses.\n     def atDepth(_depth: i32): ComtOrderAtDepth = this.asInstanceOf[ComtOrderAtDepth]\n+\n+    /** If top level comments (replies to the orig post, or chat messages if a chat)\n+      * are to be sorted by the order in which they appeared on the page\n+      * (which might be different from the order in which they were created,\n+      * if they're moved from an old page, to a newer page).\n+      */\n+    def topLevelIsByNr: Bo = topLevelIsByNrAsc || topLevelIsByNrDesc\n+\n+    /** For chats — then, most recent messages are at the bottom.\n+      * (Threaded chats (not impl) might sort sub threads differently though.)\n+      */\n+    def topLevelIsByNrAsc: Bo = atDepth(1) == PostSortOrder.OldestFirst\n+\n+    def topLevelIsByNrDesc: Bo = atDepth(1) == PostSortOrder.NewestFirst\n   }\n \n   /// Sync with Typescript [PostSortOrder].\n@@ -1516,20 +1538,20 @@ package object core {\n     // Like FriendsAndBestFirst but sort by Trending not by Best.\n     // private val FriendsAndTrendingFirst\n \n-    case object BestFirst extends PostSortOrder(BestFirstNibble, false) with ComtOrderAtDepth\n-    case object NewestFirst extends PostSortOrder(NewestFirstNibble, true) with ComtOrderAtDepth\n-    case object OldestFirst extends PostSortOrder(OldestFirstNibble, true) with ComtOrderAtDepth\n+    case object BestFirst extends PostSortOrder(BestFirstNibble) with ComtOrderAtDepth\n+    case object NewestFirst extends PostSortOrder(NewestFirstNibble) with ComtOrderAtDepth\n+    case object OldestFirst extends PostSortOrder(OldestFirstNibble) with ComtOrderAtDepth\n \n     case object NewestThenBest extends PostSortOrder(\n-      NewestFirstNibble + (BestFirstNibble << 4), true) {\n+      NewestFirstNibble + (BestFirstNibble << 4)) {\n       assert(IntVal == 18)  // 2 + 1 * 16\n       override def atDepth(depth: i32): ComtOrderAtDepth =\n         if (depth <= 1) NewestFirst\n         else BestFirst\n     }\n \n     case object NewestThenOldest extends PostSortOrder(\n-      NewestFirstNibble + (OldestFirstNibble << 4), true) {\n+      NewestFirstNibble + (OldestFirstNibble << 4)) {\n       assert(IntVal == 50)  // 2 + 3 * 16\n       override def atDepth(depth: i32): ComtOrderAtDepth =\n         if (depth <= 1) NewestFirst"
    },
    {
      "sha": "c89fbe3a32d4d166019e0bff304a2463f520b06f",
      "filename": "appsv/model/src/main/scala/com/debiki/core/types.scala",
      "status": "modified",
      "additions": 29,
      "deletions": 3,
      "changes": 32,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Ftypes.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Ftypes.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fmodel%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fcore%2Ftypes.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -26,11 +26,19 @@ import com.debiki.core.Prelude._\n   * For example, for a tag, its type tells you the name of the tag, e.g. \"Priority\",\n   * and if the tag can have any values and of what type, e.g. TypeValueType.Int32,\n   * and then you can tag your posts with Priority: 123.\n+  *\n+  * @param scopedToPatId If a person or group want to create and use its own tag types,\n+  *     then the tag primary key starts with this pat id, so there'll be no\n+  *     conflicts with other tags. — Later, moderators might want to make\n+  *     the tag type an official tag type (after talking with the ones who created it).\n+  *     So, [bottom_up_tags] that can be promoted to official tags?\n+  *     Not implemented, except for this field and a bunch of db constraints.\n   */\n case class TagType(\n   id: TagTypeId,\n   refId: Opt[RefId],\n-  canTagWhat: i32,\n+  scopedToPatId: Opt[PatId] = None,\n+  canTagWhat: i32,  // CHANGE to ThingKind.Tag|Badge ?\n   urlSlug: Opt[St],\n   dispName: St,\n   createdById: PatId,\n@@ -73,11 +81,29 @@ object TypeValueType {\n   // Sync w db constr: value_type_d_c_lt3000_for_now.\n   // Sync w db constr: value_type_d_c_gtem3_nz\n   // Sync w Typescript enum TypeValueType.\n-  // case object BoolTrue extends TypeValueType(-2)\n-  // case object BoolFalse extends TypeValueType(-1)\n+\n+  // Booleans: No need to store both a type and a value — can instead use\n+  // \"types\" true & false, and skip the value.\n+  // case object BoolTrue extends TypeValueType(-1)\n+  // case object BoolFalse extends TypeValueType(-2)\n+  // (case object None/Null/Undefined? — Can just leave the value empty instead?)\n+\n   case object Int32 extends TypeValueType(1)\n   case object Flt64 extends TypeValueType(5)\n   case object StrKwd extends TypeValueType(17)\n+  // Tags with longer text. Indexed as type: text in ElasticSearch, not type: keyword.\n+  // case object StrTxt extends TypeValueType(18)\n+\n+  //* What was I thinking here? */\n+  //case object Task extends TypeValueType(?)\n+\n+  //* A tag that links to a post. F.ex. a Depends-On relationship?  */\n+  //case object PostLink extends TypeValueType(?)\n+\n+  //* A tag that links to a person or group.\n+  //* Can be used for custom Reviewer (who's to review a blog post before it gets\n+  //* published, f.ex.)?\n+  //case object PatLink  extends TypeValueType(?)\n \n   def fromInt(value: i32): Opt[TypeValueType] = Some(value match {\n     case Int32.IntVal => Int32"
    },
    {
      "sha": "a78c351c1351773bcd867a9b51be3ad737392b11",
      "filename": "appsv/rdb/src/main/resources/db/migration/db-wip.sql",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fdb-wip.sql",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fdb-wip.sql",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fdb-wip.sql?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -5,6 +5,22 @@\n --   https://medium.com/developer-rants/bitwise-magic-in-postgresql-1a05284e4017\n \n \n+-- Sleeping bug fix? Bookmarks don't use  private_status_c?   [bookm_0_priv_status]\n+-- NEED TO SET  private_status_c  to NULL too, if type 51!\n+update  posts3\n+  set private_status_c = null where type = 51 and private_status_c is not null;\n+alter table  posts3\n+    add constraint posts_c_bookmarks_0_priv_status check (\n+        (type != 51) or (private_status_c is null),\n+\n+    -- There's already:\n+    add constraint posts_c_bookmark_neg_nr check (\n+        type != 51 or post_nr <= -1001), -- PageParts.MaxPrivateNr\n+\n+    add constraint posts_c_privatecomt_neg_nr check (\n+        (private_status_c is null) or post_nr <= -1001); -- PageParts.MaxPrivateNr\n+\n+\n --=============================================================================\n --  Misc new domains?\n --=============================================================================\n@@ -452,6 +468,8 @@ create unique index types_u_anypat_basetype_subtype_urlslug on types_t (\n \n -- upd triggers too!\n alter table post_actions3 rename to pat_node_rels_t; -- not: pat_rels_t;\n+-- Also see: [tags_vs_pat_node_rels] — because pat_node_rels_t is\n+-- pretty similar to tags_t.\n \n alter table post_actions3 drop column action_id; -- ?. Already noted below in \"delete: ...\".\n alter table post_actions3 rename to created_at to added_at_c;\n@@ -597,6 +615,8 @@ $_$;\n --   about_tag_id_c,\n -- )\n \n+-- Maybe a menu_t?  See wip_v427__sidebar_menu.sql  (or v427__sidebar_menu.sql)\n+\n \n \n -- Split settings3 and pages3 into:"
    },
    {
      "sha": "23e922c706321442548dccd0bf6bdba926f02251",
      "filename": "appsv/rdb/src/main/resources/db/migration/old/skip_v426__bookmarks.sql",
      "status": "added",
      "additions": 150,
      "deletions": 0,
      "changes": 150,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fold%2Fskip_v426__bookmarks.sql",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fold%2Fskip_v426__bookmarks.sql",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fold%2Fskip_v426__bookmarks.sql?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,150 @@\n+\n+-- alter table  page_html_cache_t\n+--    add column  from_post_nr  i32_gez_d,\n+--    add column  to_post_nr    i32_gez_d,\n+--    add constraint  pagecache_c_from_to_null  check (\n+--          (from_post_nr is null) = (to_post_nr is null));\n+\n+\n+--- Skip everytihg below? Won't use tags or pages for storing bookmarks, f.ex.\n+-- Except for [sub_pages] and [about_user_notes] below maybe?\n+\n+alter table  posts3 rename column type to post_type_c;  -- grep friendly\n+\n+alter table  pages3\n+    -- [sub_pages]\n+    add  column parent_page_id_st_c  page_id_st_d,  -- hmm?\n+    add  column parent_post_id_c     post_id_d,     -- maybe only this?\n+\n+    -- fk ix: pages_parentpageid_r_pages\n+    add constraint  (site_id, parent_page_id_st_c)\n+        references  pages3 (site_id, page_id)  deferrable,\n+\n+    -- fk ix: pages_parentpostid_r_posts\n+    add constraint  (site_id, parent_post_id_c)\n+        references  posts3 (site_id, unique_post_id)  deferrable,\n+\n+    -- A bookmark has a parent post (the one it's bookmarking).\n+    add constraint  pages_c_bookmark_parentpost check (\n+          (page_role = 29) = (parent_post_id is not null));\n+\n+\n+create index  pages_parentpageid_r_pages  on  pages3 (site_id, parent_page_id_st_c);\n+create index  pages_parentpostid_r_posts  on  posts3 (site_id, parent_post_id_c);\n+\n+-- One cannot bookmark the same post many times? At least for now, to catch bugs.\n+-- Tihs also let's us look up all relevant bookmarks, on a page.\n+create unique index  pages_u_authorid_parentpostid_if_bookmark  on  pages3 (\n+    site_id, author_id, parent_post_id_c) where page_role = 29 and deleted_at is null;\n+\n+-- For listing one's recent bookmarks.\n+create index  pages_i_authorid_createdat_if_bookmark  on  pages3 (\n+    site_id, author_id, created_at desc) where page_role = 29 and deleted_at is null;\n+\n+-- For listing one's deleted bookmarks.\n+create index  pages_i_authorid_createdat_if_bookmark_deleted on  pages3 (\n+    site_id, author_id, created_at desc) where page_role = 29 and deleted_at is not null;\n+\n+\n+\n+-- Nix.\n+-- alter table  tagtypes_t\n+--     alter  column id_c type i32_nz_d,\n+--     drop constraint  tagtypes_c_id_gt1000,\n+--     add constraint types_c_id_gt_m100 check (id_c between -99 and -1 or id_c > 1000);\n+-- \n+-- insert into  tagtypes_t (\n+--     site_id_c,\n+--     id_c,\n+--     can_tag_what_c,\n+--     is_personal,\n+--     disp_name_c,\n+--     created_by_id_c,\n+--     wants_value_c,\n+--     value_type_c)\n+-- select  id, -1, 56, true, 'Bookmark', 1, 3, 18\n+-- from  sites3;\n+\n+\n+-- No!   (Except for the bugfix.)\n+-- Bookmarks need  visible_only_to_pat_id_c,  since they're private (per person).\n+--\n+alter table tags_t\n+    -- Ooops, this is an i32_d, should be an f64. Ok to change, not in use yet.\n+    alter column val_f64_b_c type f64_d using (val_f64_b_c::f64_d),\n+\n+    -- E.g. [about_user_notes]: Tag a user with a \"Notes\" badge, visible only to staff,\n+    -- and share some notes about that user. (The post id would be the orig-post\n+    -- (or title post?) of the page with notes about the user.)\n+    add column  val_post_id_c             post_id_d,\n+\n+    -- When is this useful? A tag that points to a user? Feels it's needed, for symmetry.\n+    -- Maybe to *suggest* assigning a task (the tagged post) to someone? If a\n+    -- community creates such a tag type.\n+    add column  val_pat_id_c              pat_id_d,\n+\n+    -- Could be helpul e.g. if marking pages which maybe should be moved to another\n+    -- category? To get an overview, and later on, move them?\n+    add column  val_cat_id_c              cat_id_d,\n+\n+    -- If a tag type is visilbe only to, saye, mods & admins, it's good to\n+    -- have a way to directly find all publicly visible tags on a page, plus those\n+    -- the current requester can see.\n+    add column  visible_only_to_pat_id_c  pat_id_d,\n+\n+    -- fk ix: tags_i_valpostid\n+    add constraint tags_valpostid_r_posts foreign key (site_id_c, val_post_id_c)\n+        references posts3 (site_id, unique_post_id) deferrable,\n+\n+    -- fk ix: tags_i_valpatid\n+    add constraint tags_valpatid_r_pats foreign key (site_id_c, val_pat_id_c)\n+        references users3 (site_id, user_id) deferrable,\n+\n+    -- fk ix: tags_i_valcatid\n+    add constraint tags_valcatid_r_cats foreign key (site_id_c, val_cat_id_c)\n+        references categories3 (site_id, id) deferrable,\n+\n+    -- fk ix: tags_i_visibleonlytopatid\n+    add constraint tags_visibleonlytopatid_r_pats foreign key (\n+                                            site_id_c, visible_only_to_pat_id_c)\n+        references users3 (site_id, user_id) deferrable;\n+\n+\n+-- Foreign key indexes:\n+\n+create index tags_i_valpostid on tags_t (site_id_c, val_post_id_c)\n+    where val_post_id_c is not null;\n+\n+create index tags_i_valpatid on tags_t (site_id_c, val_pat_id_c)\n+    where val_pat_id_c is not null;\n+\n+create index tags_i_valcatid on tags_t (site_id_c, val_cat_id_c)\n+    where val_cat_id_c is not null;\n+\n+create index tags_i_visibleonlytopatid on tags_t (site_id_c, visible_only_to_pat_id_c)\n+    where visible_only_to_pat_id_c is not null;\n+\n+\n+-- Rendering pages fast:\n+\n+-- We look up the null rows, to find tags everyone may see, when rendering a page.\n+-- And look up rows with the current requester's id, to we can show han all hans bookmarks\n+-- on that page.\n+\n+create index tags_i_onpostid_visibleonlytopatid on tags_t (\n+      site_id_c, on_post_id_c, visible_only_to_pat_id_c)\n+    where on_post_id_c is not null;\n+\n+create index tags_i_onpatid_visibleonlytopatid on tags_t (\n+      site_id_c, on_pat_id_c, visible_only_to_pat_id_c)\n+    where on_pat_id_c is not null;\n+\n+\n+\n+\n+------------------------------------------------------------------------\n+comment on column  tags_t.visible_only_to_pat_id_c  is $_$\n+Bookmarks are visible only to oneself, so we need to remember who may\n+see them. And there'll be private tags & badges, e.g. staff-only user\n+notes (see below), so this makes sense for tags & badges too.\n+$_$;  -- '"
    },
    {
      "sha": "f3bcce628d6a33d4d1e478344b9b0eb1dfb6ca73",
      "filename": "appsv/rdb/src/main/resources/db/migration/r__comments.sql",
      "status": "modified",
      "additions": 84,
      "deletions": 23,
      "changes": 107,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fr__comments.sql",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fr__comments.sql",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fr__comments.sql?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -179,6 +179,29 @@ $_$;\n --@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n \n \n+--======================================================================\n+--  drafts3\n+--======================================================================\n+\n+------------------------------------------------------------------------\n+comment on table  drafts3  is $_$\n+Should remove, and store drafts in posts_t/nodes_t instead. [drafts3_2_nodes_t]\n+With negative nrs, to indicate that they're private (others can't see\n+one's drafts). Then, once published, the nr changes to the next public nr\n+on the relevant page (i.e. 1, 2, 3, ...).\n+But what about the `title` column — there's no title column in posts_t.\n+Maybe wait until pages are stored in nodes_t, and then create both a\n+title & a body post that together become the new page draft.\n+$_$; -- '\n+\n+------------------------------------------------------------------------\n+comment on column  drafts3.order_c  is $_$\n+For sorting drafts in one's todo list (with tasks, bookmarks, drafts).\n+Once drafts3 has been merged into posts_t, maybe merge posts_t.pinned_position\n+into order_c? Then use it both for sorting personal posts\n+(drafts, bookmarks) and for public post pin order (if any — rarely used).\n+$_$; -- '\n+\n \n --======================================================================\n --  pats_t\n@@ -212,6 +235,8 @@ comment on table  post_actions3 is $_$\n To be renamed to  pat_post_rels_t or pat_node_rels_t. Currently stores votes,\n AssignedTo, and flags.  Later, flags will be kept in posts_t instead,\n linked to the flagged things via the upcoming table post_rels_t.\n+Maybe assigned-to could be a post too? So can add a note about what the assignee \n+is assigned to do — maybe assigned-to-review for example. [tasks_2_nodes_t]\n $_$;\n \n ------------------------------------------------------------------------\n@@ -230,6 +255,12 @@ comment on index  patnoderels_i_pageid_fromtrueid  is $_$\n For finding one's Like votes etc done anonymously on the current page.\n $_$;\n \n+------------------------------------------------------------------------\n+comment on column  post_actions3.order_c  is $_$\n+For the assignee, so han can reorder the task as han wants, in hans\n+personal todo list (with tasks, bookmarks, drafts).\n+$_$;\n+\n \n --======================================================================\n --  perms_on_pages_t\n@@ -315,12 +346,33 @@ And to find the true author, one looks up that anon/pseudonym in pats_t,\n and looks at the true_id_c column.\n $_$; -- '\n \n+------------------------------------------------------------------------\n+comment on column  posts3.order_c  is $_$\n+For sorting bookmarks in one's todo list (together with tasks, bookmarks, drafts).\n+Maybe merge posts_t.pinned_position into order_c, don't need both?\n+Can't have public posts directly in one's todo list — instead, they'd be\n+there via bookmarks or assigned-to relationships. So, don't need both order_c\n+and pinned_position?\n+> 0 means place first, ascending?\n+< 0 means place last (asc or desc? from end?), for less important bookmarks?\n+null (or 0) means in the middle (after the > 0 but before the < 0), newest first?\n+$_$;\n \n+------------------------------------------------------------------------\n+comment on column  posts3.pinned_position  is $_$\n+Rename to  order_c. Use for sorting one's private posts: bookmarks and drafts.\n+$_$; -- '\n \n ------------------------------------------------------------------------\n comment on column  posts3.private_status_c  is $_$\n+NO, skip this. Instead, use private pages  [priv_comts_pages] \n+for storing private comments? And all comments on such a page, are private,\n+private_status_c is overkill.\n+\n If non-null, the post is private, and all descendants (the whole\n-comments tree or page if it's the orig post) are private too.\n+comments tree or page if it's the orig post) are private too. Its\n+post nr (and those of all its descendants) must be negative, <=\n+PageParts.MaxPrivateNr.\n \n In  perms_on_pages3.{may_post_comment, may_see}  we see who may\n reply to (or only see) the private tree.\n@@ -331,28 +383,37 @@ tree, and if someone added, can see already existing private comments\n These things can only be changed in the more-private direction,\n once the private tree has been created.  Maybe values could be:\n \n-0 or null: Not private.\n-1: Can add more private members, and make it public. The default.\n-   All other values below, won't be implemented the nearest ... years?:\n-2: Can add more people to the private tree, that is, make it less private, sort of.\n-   And they get to see the alreday existing comments.\n-3: Can add more people to a private tree, but they don't get to see any\n-   already existing comments; they can see only comments posted after they\n-   (the new people) got added. Will use  perms_on_posts3.can_see_priv_aft_c\n-   to remember when?\n-4: If adding more people to a private page, instead, a new private page\n-   gets created, with the original people plus the ones now added.\n-   (And you can keep adding people, until a comment has been posted on this\n-   new page — thereafter, adding more, cerates yet another page.)\n-   Then new people won't see that there was an earlier discussion,\n-   with fewer participants.\n-5: Cannot add more private pats (except for by adding to a group who can see).\n-6: Cannot add more private pats, not even by adding sbd to a group.\n-   (How's that going to get implemented? And does it ever make sense)\n-\n-Comments in private comment trees have nr:s < 0\n-(actually, <= -1001, PageParts.MaxPrivateNr), so there's a quick way for Ty\n-to skip them when loading comments to show by default on a page, *and*\n+Edit: Isn't it better to store the below \"was previously public\" in a separate\n+field, e.g.  was_public_until_c  — then we'd know for about how long too.\n+Or don't store at all in posts3, only in the audit log. [_skip_was_pub]  /Edit\n+\n+Null: Not private. Edit: Or it can be a bookmark? [bookm_0_priv_status]\n+4:  Like 5, but was previously public for a while?  EDIT: _skip_was_pub? See above.\n+5:  Can add more private members, and make it public. The default.\n+    All other values below, won't be implemented the nearest ... years?:\n+8:  Like 9, but previously_public.\n+9:  Can add more people to the private tree, that is, make it less private, sort of.\n+    And they get to see the alreday existing comments.\n+12:  Like 12, but previously_public.\n+13: Can add more people to a private tree, but they don't get to see any\n+    already existing comments; they can see only comments posted after they\n+    (the new people) got added. Will use  perms_on_posts3.can_see_priv_aft_c\n+    to remember when?\n+16:  Like 17, but previously_public.\n+17: If adding more people to a private page, instead, a new private page\n+    gets created, with the original people plus the ones now added.\n+    (And you can keep adding people, until a comment has been posted on this\n+    new page — thereafter, adding more, cerates yet another page.)\n+    Then new people won't see that there was an earlier discussion,\n+    with fewer participants.\n+20:  Like 9, but previously_public.\n+21: Cannot add more private pats (except for by adding to a group who can see).\n+24:  Like 9, but previously_public.\n+25: Cannot add more private pats, not even by adding sbd to a group.\n+    (How's that going to get implemented? And does it ever make sense)\n+\n+Since private comments have nr:s <= -1001 (PageParts.MaxPrivateNr), they can be\n+effectively skipped when loading comments to show by default on a page, *and*\n so there won't be any gaps in the not-private comment nr sequence (> 0).\n Comments on private *pages* though, can have nrs > 0? Because anyone who can\n see the private page, can see those comments, so we want to load all of them."
    },
    {
      "sha": "9492aac53119e7db5223796bb9d4a24085a2e26b",
      "filename": "appsv/rdb/src/main/resources/db/migration/y2999/wip_v427__sidebar_menu.sql",
      "status": "added",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fy2999%2Fwip_v427__sidebar_menu.sql",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fy2999%2Fwip_v427__sidebar_menu.sql",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fresources%2Fdb%2Fmigration%2Fy2999%2Fwip_v427__sidebar_menu.sql?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,51 @@\n+\n+\n+\n+create table menus_t (\n+  site_id_c         site_id_d,\n+  menu_id_c         menu_id_d,\n+  -- If one wants to include some things from what-would-have-been\n+  -- one's default menu. If null, then, looks up by looking at one's groups\n+  -- and their menus.\n+  default_menu_id     menu_id_d\n+  -- Currently only sidebar menu.\n+  menu_type_c       menu_type_d,\n+  -- People in this group, will use this menu, by default. (If two groups one\n+  -- is a member of have different menus, then what? Won't be a problem, for now:\n+  -- there'd probably just be an Everyone group's menu, and one's own changes\n+  -- if any.)\n+  for_pat_id_c      pat_id_d,\n+  -- People in this group, can edit the menu items.\n+  -- If null, the menu is for_pat_id_c's personal menu (someone's custom sidebar).\n+  -- (A new table, perms_on_menus_t, would be overkill, right?)\n+  managed_by_id_c   pat_id_d,\n+);\n+\n+\n+-- icon class? Or a number into an images table?\n+create domain  icon_d  text_oneline_60_d;\n+\n+\n+create table menu_items_t (\n+  site_id_c           site_id_d,\n+  menu_id_c           menu_id_d,\n+  item_id_c           i32_lt2e9_gt1000_d,\n+  parent_id_c         i32_lt2e9_gt1000_d\n+  position_c          i32_nz_d,\n+  disp_name_c         tag_name_60_d,\n+  abbr_name_c         tag_name_15_d,\n+  descr_c             text_nonempty_ste1000_trimmed_d,\n+  icon_c              icon_d,\n+\n+  -- A link to all cats, all tags, groups, or something.\n+  -- Or, inserts the contents from the default_menu_id — so one can\n+  -- add a few menu items, without \"losing\" what-would-have-been the default menu\n+  -- items at that place in the menu.\n+  special_c           i16_gz_d,\n+  link_cat_id_c       cat_id_d,    -- link to a category\n+  link_type_id_c      type_d,      -- link to a tag type, bookmark type, user badge type\n+  link_page_id_c      page_id_d,   -- link to a page\n+  link_pat_id_c       pat_id_d,    -- link to some group\n+  link_url_path_c     http_url_d,  -- to a page in the forum\n+  link_url_c          http_url_d,  -- to a page elsewhere, e.g. in one's website\n+);"
    },
    {
      "sha": "877bbe6f15bbf7c15518f16122d3536ef18e0541",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/CategoriesSiteDaoMixin.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FCategoriesSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FCategoriesSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FCategoriesSiteDaoMixin.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -587,7 +587,7 @@ trait CategoriesSiteDaoMixin extends SiteTransaction {\n \n \n /*\n-Old code that recursively finds all ancestor pages of a page. Was in use\n+Old code that recursively finds all ancestor pages of a page  [sub_pages]. Was in use\n before I created the categories table. Perhaps it'll be useful again in the future\n if there'll be really many categories sometimes, so one doesn't want to load all of them?\n def batchLoadAncestorIdsParentFirst(pageIds: List[PageId])(connection: js.Connection)"
    },
    {
      "sha": "394b47cdd8f6ae0cbbb66b3d85fd203e68e7ceb8",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/LinksSiteTxMixin.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FLinksSiteTxMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FLinksSiteTxMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FLinksSiteTxMixin.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -106,6 +106,7 @@ trait LinksSiteTxMixin extends SiteTransaction {\n \n \n   override def upsertLink(link: Link): Boolean = {   QUOTA\n+    // We don't create links from bookmarks or private comments, see: [0_ln_from_priv].\n     val upsertStatement = s\"\"\"\n           insert into links_t (\n               site_id_c,"
    },
    {
      "sha": "79c840163df34dfda5ead4974b81e8382cc3da33",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/PageUsersSiteDaoMixin.scala",
      "status": "modified",
      "additions": 12,
      "deletions": 2,
      "changes": 14,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPageUsersSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPageUsersSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPageUsersSiteDaoMixin.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -157,13 +157,23 @@ trait PageUsersSiteDaoMixin extends SiteTransaction {\n   }\n \n \n-  override def loadPageIdsWithVisiblePostsBy(patIds: Set[PatId], limit: i32): Set[PageId] = {\n+  /** Returns pages that need to be rerendered if a person changes hans username\n+    * — that is, pages with public (not private comments or bookmarks) and active\n+    * (not hidden/deleted/unapproved) posts by that person.\n+    *\n+    * Would correspond to: public & active = `WhichPostsOnPage.OnlyPublic(activeOnly = true)`\n+    * if using WhichPostsOnPage as param, some day, instead.\n+    */\n+  override def loadPageIdsWithPublicActivePostsBy(patIds: Set[PatId], limit: i32): Set[PageId] = {\n     if (patIds.isEmpty) return Set.empty\n+    // Dupl code, keep this. [page_ids_with_authors]\n     val query = s\"\"\"\n           select distinct page_id\n           from posts3\n           where site_id = ?\n-            and created_by_id in (${ makeInListFor(patIds) })   -- + pat_node_rels_t [AuthorOf] !\n+            and created_by_id in (${ makeInListFor(patIds) })   -- + pat_node_rels_t [AuthorOf]\n+            -- Exclude bookmarks and private comments.\n+            and post_nr >= ${PageParts.MinPublicNr}\n             and approved_at is not null\n             and deleted_status = 0\n             and hidden_at is null"
    },
    {
      "sha": "aa443c5ca0291f4508bbbf01cabf4646f69a2ed3",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/PagesSiteDaoMixin.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPagesSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPagesSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPagesSiteDaoMixin.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -60,9 +60,11 @@ trait PagesSiteDaoMixin extends SiteTransaction {\n         set version = version + 1, updated_at = now_utc()\n         where site_id = ?\n           and page_id in (\n+            -- Dupl code [page_ids_with_authors]\n             select distinct page_id from posts3\n             where site_id = ?\n               and created_by_id = ?   -- + pat_node_rels_t [AuthorOf] !\n+              and post_nr >= ${PageParts.MinPublicNr}\n               and approved_at is not null\n               and deleted_status = 0\n               and hidden_at is null)"
    },
    {
      "sha": "4c634a24b92b630ee23b8bb9047e8290143e13f8",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/PostsSiteDaoMixin.scala",
      "status": "modified",
      "additions": 232,
      "deletions": 41,
      "changes": 273,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPostsSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPostsSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FPostsSiteDaoMixin.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -20,6 +20,7 @@ package com.debiki.dao.rdb\n import collection.immutable\n import collection.mutable.ArrayBuffer\n import com.debiki.core._\n+import com.debiki.core.isProd\n import com.debiki.core.PageParts.TitleNr\n import com.debiki.core.Prelude._\n import java.{sql => js}\n@@ -38,11 +39,11 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n \n \n   override def loadPost(pageId: PageId, postNr: PostNr): Option[Post] =\n-    loadPostsOnPageImpl(pageId, postNr = Some(postNr)).headOption\n+    loadPostsOnPageImpl(pageId, postNr = Some(postNr), None).headOption\n \n \n-  override def loadPostsOnPage(pageId: PageId, activeOnly: Bo = false): Vec[Post] =\n-    loadPostsOnPageImpl(pageId, postNr = None, activeOnly = activeOnly)\n+  override def loadPostsOnPage(pageId: PageId, which: WhichPostsOnPage): Vec[Post] =\n+    loadPostsOnPageImpl(pageId, postNr = None, Some(which))\n \n   private def select__posts_po__someJoin__patPostRels_pa(someJoin: St): St = s\"\"\"\n         select po.*,\n@@ -80,26 +81,88 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n \n   private val and__po_approved_at__is_not_null = \"and po.approved_at is not null\"\n \n-  private def loadPostsOnPageImpl(pageId: PageId, postNr: Opt[PostNr], activeOnly: Bo = false)\n-          : Vec[Post] = {\n+\n+  private def loadPostsOnPageImpl(pageId: PageId, postNr: Opt[PostNr],\n+          which: Opt[WhichPostsOnPage]): Vec[Post] = {\n     // Similar to:  loadPostsByNrs(_: Iterable[PagePostNr])\n+\n+    dieIf(postNr.isDefined && which.isDefined, \"TyE7SGJ3Q\", \"Both post nr & which\")\n+\n     val values = ArrayBuffer[AnyRef](siteId.asAnyRef, pageId)\n+\n     val andPostNrEq = postNr map { id =>\n       values.append(id.asAnyRef)\n       \"and po.post_nr = ?\"\n     } getOrElse \"\"\n \n-    val andActiveOnly = if (!activeOnly) \"\" else\n-            s\"\"\"$and__po_approved_at__is_not_null\n-                and  po.hidden_at  is null\n+    val andPostNrGtOrLt = which match {\n+      case None =>\n+        // Then we're loading specific posts by nr, don't need another filter.\n+        \"\"\n+      case Some(which2) => which2 match {\n+        case _: WhichPostsOnPage.OnlyPublic =>\n+          s\"and  po.post_nr >= ${PageParts.MinPublicNr}\"\n+        case priv: WhichPostsOnPage.OnlyPrivate =>\n+          // Later: Need a way to specify & load private-posts-visible-to somebody. [priv_comts]\n+          // Maybe we'll need to [load_all_private_comments] on pageId.\n+          // But for now, this works for bookmarks.\n+          // If:  activeOnly = true, mustBeApproved = Some(false),\n+          // then is ame as:  loadUnapprovedPosts(allPublic = false, ...)?\n+          // except that the latter loads hidden posts, this one doesn't, but\n+          // doesn't matter since bookmarks & priv comments can't be hidden?\n+          values.append(priv.byUserId.asAnyRef)\n+          s\"and  po.post_nr <= ${PageParts.MaxPrivateNr}  and po.created_by_id = ?\"\n+        case range: WhichPostsOnPage.TopLevelRange =>\n+          // Posts with lower nrs were added first — they're \"older'.\n+          val (start, end) = range.direction match {\n+            case RangeDir.Older => (range.offset - range.limit + 1, range.offset)\n+            case RangeDir.Newer => (range.offset, range.offset + range.limit - 1)\n+            case RangeDir.Around =>\n+              // If TopLevelRange.limit is 25:  25 / 2 = 12, so we'll load the post nr\n+              // at `range.offset` + 12 older and 12 newer, that's 25 in total.\n+              val halfLim = range.limit / 2\n+              (range.offset - halfLim, range.offset + halfLim)\n+          }\n+          // Load from incl start.  But the title and orig post should already have been\n+          // loaded. Negative nr are private posts (e.g. bookmarks, private comments) and\n+          // have random nrs, so, off-topic here.\n+          values.append(Math.max(start, PageParts.FirstReplyNr).asAnyRef)\n+          // Shouldn't try to load private posts, or title or body.\n+          dieIf(end < PageParts.FirstReplyNr, \"TyE602SKL9\", s\"Bad scroll offset: end = ${\n+                end} < FirstReplyNr, range: $range\")\n+          // Load up to incl end:\n+          values.append(end.asAnyRef)\n+          s\"and  po.post_nr  between ? and ?\"\n+        case _: WhichPostsOnPage.AllByAnyone =>\n+           \"\" // all\n+      }\n+    }\n+\n+    val mustBeApproved = which map { which2 =>\n+            which2.mustBeApproved getOrElse which2.activeOnly  // [load_only_approved]\n+          } getOrElse {\n+            // If loading a specific post nr, it's wanted, approved or not approved.\n+            false\n+          }\n+\n+    COULD_OPTIMIZE // Don't load others' unapproved comments. Filtered out later, but better\n+    // do here directly? [careful_cache_range]\n+    val andApproved =\n+          if (mustBeApproved) and__po_approved_at__is_not_null\n+          else \"\"\n+\n+    val andNotHiddenDeleted = if (!which.exists(_.activeOnly)) \"\" else\n+            s\"\"\"and  po.hidden_at  is null\n                 and  po.deleted_status = ${DeletedStatus.NotDeleted.toInt} \"\"\"\n \n     val query = s\"\"\" -- loadPostsOnPageImpl\n           $select__posts_po__leftJoin__patPostRels_pa\n           where po.site_id = ? and\n                 po.page_id = ?\n                 $andPostNrEq\n-                $andActiveOnly\n+                $andPostNrGtOrLt\n+                $andApproved\n+                $andNotHiddenDeleted\n           $groupBy_orderBy__siteId_postId \"\"\"\n \n     runQueryFindMany(query, values.toList, rs => {\n@@ -108,6 +171,7 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n   }\n \n \n+  // [to_paginate]\n   override def loadOrigPostAndLatestPosts(pageId: PageId, limit: Int): Seq[Post] = {\n     require(limit > 0, \"EsE7GK4W0\")\n     // Use post_nr, not created_at, because 1) if a post is moved from another page to page pageId,\n@@ -127,7 +191,8 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n             $select__posts_po__leftJoin__patPostRels_pa\n             where po.site_id = ? and\n                   po.page_id = ? and\n-                  po.post_nr not in (${PageParts.TitleNr}, ${PageParts.BodyNr})\n+                  -- Skip title & body (loaded above) and private posts e.g. bookmarks.\n+                  po.post_nr >= ${PageParts.FirstReplyNr}\n             $groupBy__siteId_postId\n             order by post_nr desc limit $limit\n             ) required_subquery_alias  \"\"\"\n@@ -244,36 +309,70 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n   }\n \n \n-  def loadAllUnapprovedPosts(pageId: PageId, limit: Int): immutable.Seq[Post] = {\n-    loadUnapprovedPostsImpl(pageId, None, limit)\n-  }\n-\n-\n-  def loadUnapprovedPosts(pageId: PageId, by: UserId, limit: Int): immutable.Seq[Post] = {\n-    loadUnapprovedPostsImpl(pageId, Some(by), limit)\n-  }\n-\n-\n-  private def loadUnapprovedPostsImpl(pageId: PageId, by: Option[UserId], limit: Int)\n-        : immutable.Seq[Post] = {\n-    var query = s\"\"\" -- loadUnapprovedPostsImpl\n-      $select__posts_po__leftJoin__patPostRels_pa\n-      where po.site_id = ?\n-        and po.page_id = ?\n-        and po.approved_at is null\n-        and (po.type is null or po.type <> ${PostType.CompletedForm.toInt})\n-      \"\"\"\n+  def loadUnapprovedPosts(pageId: PageId, ownBy: PatId, allPublic: Bo = false,\n+          limit: i32): immutable.Seq[Post] = {\n+\n+    // Later: Do we ever want to use this for loading private comments? [priv_comts]\n+    // Maybe theoretically if  loadPostsOnPageImpl()  [load_all_private_comments]  won't\n+    // load all private comments because there's too many (a billion!), then we could use\n+    // this fn to load the current user's *own* private comments, which would be\n+    // more important to han.\n+\n+    // If we're also loading *all* public unapproved posts, no need\n+    // to also load our *own* public unapproved posts. Only our own private.\n+    val andIsPrivate =\n+          if (allPublic) s\"and po.post_nr <= ${PageParts.MaxPrivateNr}\"\n+          else \"\"\n+\n+    // If admins want to see deleted posts, or one wants to see one's own deleted\n+    // posts, the last `po.deleted_status` test needs to be dynamically changed to\n+    // `or deleted_status <> ...` and some reordering and parenthesis.  [opt_show_deld_posts]\n+    // Then, rename this fn to: loadUnapprovedAndDeletedPosts ?\n+    val andNotFormOrDeleted = s\"\"\"\n+              and (po.type is null or po.type not in (\n+                    -- Form submissions don't currently need to be approved\n+                    -- (aren't part of any discussion).\n+                    ${PostType.CompletedForm.toInt}))\n+              -- Load unapproved hidden posts, right. [_load_hidden]\n+              -- But not deleted:\n+              and po.deleted_status = ${DeletedStatus.NotDeleted.toInt}  \"\"\"\n \n-    var values = ArrayBuffer[AnyRef](siteId.asAnyRef, pageId.asAnyRef)\n+    val values = ArrayBuffer[AnyRef](\n+          siteId.asAnyRef, pageId.asAnyRef, ownBy.asAnyRef)\n \n-    if (by.isDefined) {\n-      query += \" and po.created_by_id = ?  -- pat_node_rels_t [AuthorOf]\"\n-      values += by.get.asAnyRef\n+    // One's own unapproved comments, but also one's bookmarks (they're posts too, unapproved).\n+    val ownUnapprovedQuery = s\"\"\"\n+          $select__posts_po__leftJoin__patPostRels_pa\n+          where po.site_id = ?\n+              and po.page_id = ?\n+              and po.approved_at is null\n+              -- Only our own.\n+              and po.created_by_id = ?  -- pat_node_rels_t [AuthorOf]\n+              -- Only private, if loading all public in the union query below.\n+              $andIsPrivate\n+              $andNotFormOrDeleted\n+          $groupBy__siteId_postId \"\"\"\n+\n+    // For moderators, so they can see & review posts pending approval.\n+    val unionPublicUnapprovedQuery = if (!allPublic) \"\" else {\n+      values.append(siteId.asAnyRef, pageId.asAnyRef)\n+      s\"\"\"\n+          union\n+          $select__posts_po__leftJoin__patPostRels_pa\n+          where po.site_id = ?\n+              and po.page_id = ?\n+              and po.approved_at is null\n+              -- Only public (exclude bookmarks and private comments).\n+              and po.post_nr >= ${PageParts.MinPublicNr}\n+              $andNotFormOrDeleted\n+          $groupBy__siteId_postId \"\"\"\n     }\n \n-    query += s\"\"\"\n-          $groupBy__siteId_postId\n-          order by po.created_at desc limit $limit \"\"\"\n+    val query = s\"\"\" -- loadUnapprovedPosts\n+          $ownUnapprovedQuery\n+          $unionPublicUnapprovedQuery\n+          -- Order the total result, after union. (Incl id, for predictable e2e tests.)\n+          order by created_at desc, unique_post_id desc limit $limit \"\"\"\n \n     runQueryFindMany(query, values.toList, rs => {\n       readPost(rs, pageId = Some(pageId))\n@@ -297,6 +396,49 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n   }\n \n \n+  def loadBookmarksAndBookmarkedPosts(byPatId: PatId,\n+            limit: i32, offsetAt: When, offsetId: PostId)\n+            : (ImmSeq[Post], ImmSeq[Post]) = {\n+\n+    val values = List(siteId.asAnyRef, byPatId.asAnyRef)\n+    val query = s\"\"\" -- loadBookmarksAndBookmarkedPosts\n+          with bms as (\n+            $select__posts_po__leftJoin__patPostRels_pa\n+            where  po.site_id =  ?\n+              and  po.created_by_id = ?\n+              and  po.type = ${PostType.Bookmark.toInt}\n+              and  po.deleted_at is null\n+            $groupBy__siteId_postId\n+            order by po.created_at desc\n+            limit $limit\n+          )\n+          -- Bookmarks\n+          select * from bms\n+          union\n+          -- Bookmarked posts\n+          $select__posts_po__leftJoin__patPostRels_pa\n+          inner join  bms\n+             on   bms.site_id       =  po.site_id\n+             and  bms.page_id       =  po.page_id\n+             and  bms.parent_nr     =  po.post_nr\n+             -- Skip deleted, but do _load_hidden posts.\n+             and  po.deleted_status = ${DeletedStatus.NotDeleted.toInt}\n+             and  (po.type is null  or  po.type between 1 and 12)  -- [depr_post_type]\n+          $groupBy__siteId_postId\n+          -- This is for the complete result set (after union).\n+          order by created_at desc\n+          \"\"\"\n+    val bookmarks = MutArrBuf[Post]()\n+    val bookmarkedPosts = MutArrBuf[Post]()\n+    runQueryAndForEachRow(query, values, rs => {\n+      val p = readPost(rs)\n+      if (p.tyype == PostType.Bookmark) bookmarks.append(p)\n+      else bookmarkedPosts.append(p)\n+    })\n+    (bookmarks.to[Vec], bookmarkedPosts.to[Vec])\n+  }\n+\n+\n   /*\n   def loadPosts(authorId: UserId, includeTitles: Boolean, includeChatMessages: Boolean,\n         limit: Int, orderBy: OrderBy, onPageId: Option[PageId], onlyUnapproved: Boolean)\n@@ -306,6 +448,7 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n \n     val andSkipTitles = includeTitles ? \"\" | s\"and post_nr <> $TitleNr\"\n     val andSkipChat = includeChatMessages ?\n+          ? Skip bookmarks too ?\n       \"\" | s\"and (po.type is null or po.type <> ${PostType.ChatMessage.toInt})\"\n     val andOnlyUnapproved = onlyUnapproved ? \"po.curr_rev_nr > approved_rev_nr\" | \"\"\n \n@@ -333,13 +476,23 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n \n     val values = ArrayBuffer[AnyRef](siteId.asAnyRef)\n \n-    val andAuthorEq = postQuery match {\n+    val (andAuthorEq, andTypeEq) = postQuery match {\n       case q: PostQuery.PostsByAuthor =>\n         // Including the author's anon posts, hasn't been implemented.\n         unimplIf(postQuery.inclAnonPosts, \"TyEANONUNIMP04\") ; ANON_UNIMPL\n         values.append(q.authorId.asAnyRef)\n-        \"and po.created_by_id = ?\"\n-      case _ => \"\"\n+\n+        val andTypeEq = q.onlyPostType map { t =>\n+          // This not in use  [onlyPostType_not_used]. I thought this'd be for loading\n+          // bookmarks, but they're loaded via  loadBookmarksAndBookmarkedPosts()  instead.\n+          assert(false)\n+          values.append(t.toInt.asAnyRef)\n+          \"and po.post_type = ?\"\n+        } getOrElse \"\"\n+\n+        (\"and po.created_by_id = ?\", andTypeEq)\n+      case _ =>\n+        (\"\", \"\")\n     }\n \n     val andNotTitle = postQuery.inclTitles ? \"\" | s\"and po.post_nr <> $TitleNr\"\n@@ -355,10 +508,10 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n         CLEAN_UP; REMOVE // Or? Not in use.\n         // Including tasks assigned to one's anonyms, hasn't been implemented.\n         unimplIf(postQuery.inclAnonPosts, \"TyEANONUNIMP05\") ; ANON_UNIMPL\n-\n         // Currently using  tx.loadPatPostRels()  instead, see [load_posts_by_rels],\n         // and this match-case branch is dead code.\n         unimpl(\"Would .not_load_all_post_rels [TyE602MRTL5]\")\n+        /*\n         values.append(q.relatedPatId.asAnyRef)\n         values.append(q.relType.toInt.asAnyRef)\n         (\"and pa.from_pat_id_c = ?\"\n@@ -369,6 +522,7 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n             // (Need sth like max() or min() because we array_agg rows from pa =\n             // pat_node_rels_t.)\n             \"order by max(pa.created_at) desc, po.unique_post_id desc\")) // [.same_time]\n+            */\n       case _ => (\"\", \"\", None)\n     }\n \n@@ -417,10 +571,16 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n             select__posts_po__leftJoin__patPostRels_pa\n           }\n \n+    val andOnlyPublic =  // [all_0_incl_bookmarks]\n+          if (false) \"\"\n+          else s\"and po.post_nr >= ${PageParts.MinPublicNr}\"\n+\n     val sqlQuery = s\"\"\" -- loadPostsByQuery\n           $select__posts_po__theJoin__patPostRels_pa\n           where po.site_id = ?\n               $andAuthorEq  -- pat_node_rels_t [AuthorOf]  needs new sub query?\n+              $andOnlyPublic\n+              $andTypeEq\n               $andNotTitle\n               $andSomeVersionApproved\n               $andPageNotUnlisted_unimpl\n@@ -473,6 +633,7 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n              and  t.on_post_id_c =  po.unique_post_id\n              and  t.tagtype_id_c =  ?\n           where  po.site_id =  ?\n+            and  po.post_nr >= ${PageParts.MinPublicNr} -- [all_0_incl_bookmarks]\n             and  (po.type is null  or  po.type between 1 and 12)  -- [depr_post_type]\n             and  po.deleted_status = ${DeletedStatus.NotDeleted.toInt}\n             and  po.hidden_at is null\n@@ -560,6 +721,12 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n         where p.site_id = ?\n           and p.page_id in (${makeInListFor(pageIds)})\n           and p.post_nr >= ${exclOrigPost ? PageParts.FirstReplyNr | PageParts.BodyNr}\n+          -- We want public posts only. The line above is enough, but let's include\n+          -- this check too, for clarity:\n+          and p.post_nr >= ${PageParts.MinPublicNr}\n+          -- Bookmarks have nrs < 0, but let's include here anyway.\n+          and (p.type is null or p.type not in (\n+                ${PostType.Bookmark.toInt}, ${PostType.CompletedForm.toInt}))\n           and length(p.approved_html_sanitized) > 20\n           and p.collapsed_status = 0\n           and p.closed_status = 0\n@@ -589,11 +756,18 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n         where po.site_id = ?\n           and po.page_id in (${makeInListFor(pageIds)})\n           and po.post_nr <> ${PageParts.TitleNr}\n+          -- This excludes bookmarks and private comments.\n+          and po.post_nr >= ${PageParts.MinPublicNr}\n           and po.approved_at is not null\n           and (po.type is null or po.type not in (\n             ${PostType.BottomComment.toInt},  -- [2GYKFS4]\n             ${PostType.MetaMessage.toInt},\n-            ${PostType.ChatMessage.toInt}))\n+            ${PostType.ChatMessage.toInt},\n+            -- Don't need to list these (bookmarks & forms), but why not:\n+            -- (Hmm? But do need to list forms? They have nrs > 0?)\n+            ${PostType.Bookmark.toInt},\n+            ${PostType.CompletedForm.toInt}\n+            ))\n           and po.closed_status = 0\n           and po.hidden_at is null\n           and po.deleted_status = 0\n@@ -661,6 +835,9 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n \n \n   override def insertPost(post: Post) {\n+    dieIf(isProd && post.tyype == PostType.Bookmark,\n+          \"TyEBOOKM0ENA11\", \"Bookmarks not yet enabled\")\n+\n     val statement = \"\"\" -- insertPost\n       insert into posts3(\n         site_id,\n@@ -800,6 +977,9 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n \n \n   def updatePost(post: Post) {\n+    dieIf(isProd && post.tyype == PostType.Bookmark,\n+          \"TyEBOOKM0ENA12\", \"Bookmarks not yet enabled\")\n+\n     val statement = \"\"\" -- updatePost\n       update posts3 set\n         page_id = ?,\n@@ -1172,6 +1352,8 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n             and  po.unique_post_id = pa.to_post_id_c\n             and  po.closed_status = 0\n             and  po.deleted_status = 0\n+            -- Later: Sometimes include [priv_comts]? (nr <= MaxPrivateNr)\n+            and  po.post_nr >= ${PageParts.MinPublicNr} -- [all_0_incl_bookmarks]\n           inner join  pages3 pg\n              on  pg.site_id = po.site_id\n             and  pg.page_id = po.page_id\n@@ -1192,6 +1374,9 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n                  $andPageIdEq\n                  $andCreatedBy\n                  $andRelTypeIn\n+                  -- This (post_actions3.post_nr) gets out of date if post moved to other page?\n+                  -- But the sign (> 0 or < 0) will at least stay the same. [priv_comts]\n+                  and  pa.post_nr >= ${PageParts.MinPublicNr} -- [all_0_incl_bookmarks]\n           $orderByAndLimit  \"\"\"\n \n     val result = runQueryFindMany(query, values.toList, rs => {\n@@ -1339,6 +1524,12 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n       })\n     }\n \n+    // Upvoting a bookmark would be a bug.\n+    // Could search for all  insertPostAction()  usage too, throwForbidden  if wrong\n+    // post type?  [weird_post_actions]\n+    dieIf(postNr < PageParts.MinPublicNr, \"TyEPRIVPOACT\", o\"\"\"s$siteId: Trying to do sth\n+          with a private post, nr $postNr id $postId, action type: $actionType\"\"\")\n+\n     val statement = s\"\"\"\n       insert into post_actions3(site_id, to_post_id_c, page_id, post_nr, rel_type_c,\n           from_pat_id_c, from_true_id_c,"
    },
    {
      "sha": "f1ae4296dde92c5f865586e78445320df1741a3e",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/RdbUtil.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FRdbUtil.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FRdbUtil.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FRdbUtil.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1035,6 +1035,7 @@ object RdbUtil {\n     PageRenderParams(\n           PostSortOrder.fromInt(getInt32(rs, \"param_comt_order_c\")).getOrDie(\"TyE703MRKJL5\"),\n           // comtNesting =  param_comt_nesting_c  — later\n+          comtOffset = None,\n           widthLayout = WidthLayout.fromInt(rs.getInt(\"param_width_layout_c\")),\n           isEmbedded = rs.getBoolean(\"param_is_embedded_c\"),\n           origin = rs.getString(\"param_origin_or_empty_c\"),"
    },
    {
      "sha": "c6e83e8708c806c81c28b33db654fa6461c8a25f",
      "filename": "appsv/rdb/src/main/scala/com/debiki/dao/rdb/UserSiteDaoMixin.scala",
      "status": "modified",
      "additions": 19,
      "deletions": 3,
      "changes": 22,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FUserSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FUserSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Frdb%2Fsrc%2Fmain%2Fscala%2Fcom%2Fdebiki%2Fdao%2Frdb%2FUserSiteDaoMixin.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -218,7 +218,8 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n       where u.site_id = ?\n         and user_id >= ${Participant.LowestNormalMemberId}\n         and deleted_at is null\n-        and ($conditions)\"\"\"\n+        and ($conditions)\n+      order by user_id \"\"\"\n \n     runQueryFindMany(query, values.toList, rs => {\n       getParticipant(rs).toMemberOrThrowCode(\"TyE5ABK20A2\")\n@@ -495,6 +496,7 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n         where site_id = ?\n           and participant_id = ?\n           and is_member\n+        order by group_id\n         \"\"\"\n     runQueryFindMany(query, List(siteId.asAnyRef, pptId.asAnyRef), rs => {\n       rs.getInt(\"group_id\")\n@@ -751,13 +753,19 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n   }\n \n \n+  /** For finding out which people to notify about new comments.\n+    */\n   def loadPageRepliers(pageId: PageId, usersOnly: Bo): Seq[User] = {\n     unimplIf(!usersOnly, \"Must be usersOnly [TyE7AMT05MRKT]\")\n     val sql = s\"\"\"\n           select distinct $UserSelectListItemsNoGuests\n           from posts3 p inner join users3 u  -- + pat_node_rels_t [AuthorOf]\n             on p.site_id = u.site_id\n             and p.created_by_id = u.user_id\n+            -- Include authors of private comments  [priv_comts], so we can notify them.\n+            -- But not bookmarks.\n+            and (p.type  is null  or  p.type  not in (\n+                  ${PostType.Bookmark.toInt}, ${PostType.CompletedForm.toInt}))\n             and not u.is_group\n             and u.user_id >= $LowestTalkToMemberId\n           where p.site_id = ? and p.page_id = ?\n@@ -806,6 +814,7 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n         on u.guest_email_addr = e.EMAIL and u.SITE_ID = e.SITE_ID\n       where\n         u.SITE_ID = ? and u.user_id <= ${Participant.MaxGuestId}\n+      order by u.user_id\n       \"\"\"\n     runQueryFindMany(query, List(siteId.asAnyRef), rs => {\n       val p = getParticipant(rs)\n@@ -835,6 +844,7 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n       where site_id = ?\n         and user_id >= ${Participant.LowestMemberId}\n         and trust_level is not null -- means is user, not group\n+      order by user_id\n       \"\"\"\n     runQueryFindMany(query, List(siteId.asAnyRef), rs => {\n       getUserInclDetails(rs)\n@@ -850,6 +860,7 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n       where site_id = ?\n         and is_group\n         and deleted_at is null\n+      order by user_id\n       \"\"\"\n     runQueryFindMany(query, List(siteId.asAnyRef), getGroup)\n   }\n@@ -1228,7 +1239,6 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n   // NameAndUsername,  but that's too little — need privacy prefs and trust level too\n   // (but now we load too much, instead).\n   def listUsernamesOnPage(pageId: PageId): ImmSeq[UserBr] = {\n-    // Later, once bookmarks impl: [dont_list_bookmarkers] and don't list [priv_comts] authors.\n     /* Was, but not enough:\n       select distinct\n           u.user_id,\n@@ -1243,12 +1253,18 @@ trait UserSiteDaoMixin extends SiteTransaction {  // RENAME; QUICK // to UserSit\n       from posts3 p inner join users3 u    -- + pat_node_rels_t [AuthorOf]\n          on p.SITE_ID = u.SITE_ID\n         and p.CREATED_BY_ID = u.USER_ID\n+        -- Exclude [priv_comts] and [dont_list_bookmarkers].  (Later, could include\n+        -- authors of private comments the requester may see. [incl_priv_authors])\n+        and p.post_nr >= ${PageParts.MinPublicNr}\n+        and p.type not in (${PostType.CompletedForm.toInt})\n+        and p.deleted_status = ${DeletedStatus.NotDeleted}\n+        and p.hidden_at is null  -- or maybe allow, if is staff?\n         and u.USERNAME is not null\n       where p.SITE_ID = ? and p.PAGE_ID = ?\"\"\"\n     val values = List(siteId.asAnyRef, pageId)\n     runQueryFindMany(sql, values, getUser)\n \n-    /* Was: rs => {\n+    /* Was, when returning a `NameAndUsername` instead of a `UserBr`:   rs => {\n       val userId = rs.getInt(\"user_id\")\n       val fullName = Option(rs.getString(\"full_name\")) getOrElse \"\"\n       val username = rs.getString(\"USERNAME\")"
    },
    {
      "sha": "d9f582b09bb61dd58c18043552bfc666b5dfa49d",
      "filename": "appsv/server/controllers/EditController.scala",
      "status": "modified",
      "additions": 19,
      "deletions": 9,
      "changes": 28,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FEditController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FEditController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FEditController.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -18,11 +18,12 @@\n package controllers\n \n import com.debiki.core._\n+import com.debiki.core.isProd\n import com.debiki.core.Prelude._\n import debiki._\n import debiki.dao.SiteDao\n import debiki.EdHttp._\n-import debiki.JsonUtils.asJsObject\n+import debiki.JsonUtils._\n import talkyard.server.linkpreviews.{LinkPreviewRenderer, PreviewResult, LinkPreviewProblem}\n import talkyard.server.http._\n import talkyard.server.{TyContext, TyController}\n@@ -196,11 +197,11 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n         request: JsonPostRequest =>\n     import request.{dao, theRequester => requester}\n     val body = asJsObject(request.body, \"request body\")\n-    val pageId = (body \\ \"pageId\").as[PageId]\n-    val postNr = (body \\ \"postNr\").as[PostNr] ; SHOULD // change to id, in case moved to other page [idnotnr]\n-    val anyPostId: Option[PostId] = (body \\ \"postId\").asOpt[PostId]\n-    val newText = (body \\ \"text\").as[String]\n-    val deleteDraftNr = (body \\ \"deleteDraftNr\").asOpt[DraftNr]\n+    val pageId: PageId = parseSt(body, \"pageId\")\n+    val postNr: PostNr = parseInt32(body, \"postNr\") ; SHOULD // change to id, in case moved to other page [idnotnr]\n+    val anyPostId: Opt[PostId] = parseOptInt32(body, \"postId\")\n+    val newText: St = parseSt(body, \"text\")\n+    val deleteDraftNr: Opt[DraftNr] = parseOptInt32(body, \"deleteDraftNr\")\n \n     TESTS_MISSING // Do as anon  TyTANONEDIT\n     val asAlias: Opt[WhichAliasPat] =\n@@ -226,6 +227,12 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n         (pageMeta, post)\n     }\n \n+    throwForbiddenIf(isProd && post.tyype == PostType.Bookmark,\n+          \"TyEBOOKM0ENA1\", \"Bookmarks not yet enabled in prod mode\")\n+\n+    throwBadReqIf(asAlias.isDefined && post.isPrivate, // [both_anon_priv]\n+          \"TyEANONPRIVED1\", \"Cannot edit bookmarks or private comments anonymously\")\n+\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n     CHECK_AUTHN_STRENGTH\n@@ -362,6 +369,9 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val newTypeInt = (request.body \\ \"newType\").as[Int]\n     val newType = PostType.fromInt(newTypeInt) getOrElse throwBadArgument(\"DwE4EWL3\", \"newType\")\n \n+    throwForbiddenIf(isProd && newType == PostType.Bookmark,\n+          \"TyEBOOKM0ENA3\", \"Bookmarks not yet enabled in prod mode\")\n+\n     request.dao.changePostType(pageId = pageId, postNr = postNr, newType, request.reqrIds)\n     Ok\n   }\n@@ -380,9 +390,9 @@ class EditController @Inject()(cc: ControllerComponents, edContext: TyContext)\n         MinAuthnStrength.EmbeddingStorageSid12, maxBytes = 5000, canUseAlias = true) { req =>\n     import req.dao\n     val body = asJsObject(req.body, \"Delete post request body\")\n-    val pageId = (body \\ \"pageId\").as[PageId]\n-    val postNr = (body \\ \"postNr\").as[PostNr]\n-    val repliesToo = (body \\ \"repliesToo\").asOpt[Boolean] getOrElse false\n+    val pageId: PageId = parseSt(body, \"pageId\")\n+    val postNr: PostNr = parseInt32(body, \"postNr\")\n+    val repliesToo = parseOptBo(body, \"repliesToo\") getOrElse false\n \n     val action =\n       if (repliesToo) PostStatusAction.DeleteTree"
    },
    {
      "sha": "f712ecc5eb1c0c5e16b57594198f44acd5924d75",
      "filename": "appsv/server/controllers/EmbeddedTopicsController.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FEmbeddedTopicsController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FEmbeddedTopicsController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FEmbeddedTopicsController.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -102,6 +102,7 @@ class EmbeddedTopicsController @Inject()(cc: ControllerComponents, edContext: Ty\n         val pageRenderParams = PageRenderParams(\n               // (Later, pass a discProps.renderProps — all relevant disc props in one line?)\n               comtOrder = discProps.comtOrder,\n+              comtOffset = None,\n               widthLayout = if (request.isMobile) WidthLayout.Tiny else WidthLayout.Medium,\n               isEmbedded = true,\n               origin = request.origin,"
    },
    {
      "sha": "0f8cff3bb76b962ecdccd5f6afbe27affa869b05",
      "filename": "appsv/server/controllers/ReplyController.scala",
      "status": "modified",
      "additions": 12,
      "deletions": 3,
      "changes": 15,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FReplyController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FReplyController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FReplyController.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -18,6 +18,7 @@\n package controllers\n \n import com.debiki.core._\n+import com.debiki.core.isProd\n import com.debiki.core.Prelude._\n import debiki._\n import debiki.EdHttp._\n@@ -43,6 +44,7 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   import context.security.{throwNoUnless, throwIndistinguishableNotFound}\n \n \n+  RENAME // to createPost?  Also handles bookmarks.\n   def handleReply: Action[JsValue] = PostJsonAction(RateLimits.PostReply,\n         MinAuthnStrength.EmbeddingStorageSid12, maxBytes = MaxPostSize, canUseAlias = true) {\n         request: JsonPostRequest =>\n@@ -59,11 +61,16 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n       \"DwE6KG4\", \"Bad post type\")\n     val deleteDraftNr = (body \\ \"deleteDraftNr\").asOpt[DraftNr]\n \n+    throwForbiddenIf(isProd && postType == PostType.Bookmark,\n+          \"TyEBOOKM0ENA1\", \"Bookmarks not yet enabled\")\n+\n     val asAlias: Opt[WhichAliasPat] =\n           debiki.dao.SiteDao.checkAliasOrThrowForbidden(body, requester, request.anyAliasPat)(dao)\n \n     throwBadRequestIf(text.isEmpty, \"EdE85FK03\", \"Empty post\")\n     throwForbiddenIf(requester.isGroup, \"EdE4GKRSR1\", \"Groups may not reply\")\n+    throwBadReqIf(asAlias.isDefined && postType.isPrivate, // [both_anon_priv]\n+            \"TyEANONPRIVPO\", \"Cannot post bookmarks or private comments anonymously\")\n \n     DISCUSSION_QUALITY; COULD // require that the user has spent a reasonable time reading\n     // the topic, in comparison to # posts in the topic, before allowing hen to post a reply.\n@@ -73,14 +80,14 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n           anyEmbeddingUrl = anyEmbeddingUrl, lazyCreatePageInCatId = lazyCreatePageInCatId,\n           request)\n \n-    REMOVE // these 3 vals, once we're using dao.insertReplyIfAuZ() instead of\n+    REMOVE // these 4 vals, once we're using dao.insertReplyIfAuZ() instead of\n     // doing authz here in this fn.\n     val pageMeta = dao.getPageMeta(pageId) getOrElse throwIndistinguishableNotFound(\"EdE5FKW20\")\n     val pageAuthor =\n           if (pageMeta.authorId == requester.id) requester\n           else dao.getTheParticipant(pageMeta.authorId)\n-    val replyToPosts = dao.loadPostsAllOrError(pageId, replyToPostNrs) getOrIfBad { missingPostNr =>\n-      throwNotFound(s\"Post nr $missingPostNr not found\", \"EdEW3HPY08\")\n+    val replyToPosts = dao.loadPostsAllOrError(pageId, replyToPostNrs) getOrIfBad { missingNr =>\n+      throwIndistinguishableNotFound(\"TyEPOST0FND1\", isAboutPostNr = Some(missingNr.loneElement))\n     }\n     val categoriesRootLast = dao.getAncestorCategoriesRootLast(pageMeta.categoryId)\n \n@@ -99,6 +106,8 @@ class ReplyController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     // val authzContext = dao.getPageAuthzContext(requester, pageMeta)\n     // throwNoUnless(Authz.mayPostReply(authzContext, postType, \"EdEZBXK3M2\")\n \n+    COULD_OPTIMIZE // Don't commonmark-format bookmarks — they're just plain text\n+    // anyway. [dont_format_bookmarks]\n     // For now, don't follow links in replies. COULD rel=follow if all authors + editors = trusted.\n     // (Here, and at other calls to forBodyOrComment(), is a better place to remember\n     // whom to mention — so the author will know for sure; compare with: [filter_mentions].)"
    },
    {
      "sha": "1be68f4ebb46356efb8205329d95bcb9c928201b",
      "filename": "appsv/server/controllers/UserController.scala",
      "status": "modified",
      "additions": 23,
      "deletions": 9,
      "changes": 32,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FUserController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FUserController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FUserController.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -33,8 +33,7 @@ import scala.util.Try\n import scala.collection.{mutable => mut}\n import debiki.RateLimits.TrackReadingActivity\n import talkyard.server.{TyContext, TyController}\n-import talkyard.server.authz\n-import talkyard.server.authz.{Authz, PatAndPrivPrefs}\n+import talkyard.server.authz.{Authz, PatAndPrivPrefs, AuthzCtxOnAllWithReqer}\n import talkyard.server.security.WhatApiSecret\n import javax.inject.Inject\n import org.scalactic.{Bad, Good}\n@@ -1177,7 +1176,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n       throwForbidden(\"TyE5RKPW025\", s\"Bad post nr, smaller than BodyNr: $badNr\")\n     }\n \n-    CHECK_AUTHN_STRENGTH // + may see?\n+    CHECK_AUTHN_STRENGTH\n+    // If page & post nrs read included, we check if _may_see_page, below.\n \n     logger.trace(\n       s\"s$siteId, page $anyPageId: Post nrs read: $postNrsRead, seconds reading: $secondsReading\")\n@@ -1224,13 +1224,26 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n       }\n     }\n \n-    request.dao.pubSub.userIsActive(request.siteId, requester, request.theBrowserIdData)\n+    COULD_OPTIMIZE // Don't need both this and [user_watches_pages_pubsub]?\n+    dao.pubSub.userIsActive(request.siteId, requester, request.theBrowserIdData)\n \n     if (anyPageReadingProgress.isDefined) {\n       // This visit happened on an article / discussion page.\n-      dieIf(anyPageId.isEmpty, \"TyE7KAKR25\")\n+      val pageId = anyPageId.getOrDie(\"TyE7KAKR25\")\n+\n+      // [upd_watchbar_has_read]\n+      val authzCtx: AuthzCtxOnAllWithReqer = request.authzCtxOnAllWithReqer.get\n+      var watchbar: BareWatchbar = dao.getOrCreateWatchbar(authzCtx)\n+      COULD_OPTIMIZE // Page loaded again below in trackReadingProgressClearNotfsPerhapsPromote().\n+      val page = dao.getPageMeta(pageId) getOrElse {\n+        throwIndistinguishableNotFound(\"TyE702SKJ\", s\"Page $pageId not found\")\n+      }\n+\n+      // This'll check if _may_see_page, throws Not Found if not. [WATCHSEC]\n+      dao.watchbarAddRecentMarkSeen(watchbar, page, authzCtx)\n+\n       dao.trackReadingProgressClearNotfsPerhapsPromote(\n-        requester, anyPageId.get, pagePostNrIdsRead.map(_.postId).toSet, anyPageReadingProgress.get)\n+          requester, pageId, pagePostNrIdsRead.map(_.postId).toSet, anyPageReadingProgress.get)\n     }\n     else {\n       // This visit happened on an admin page or user profile page.\n@@ -1255,6 +1268,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n   def loadNotifications(userId: UserId, upToWhenMs: Long): Action[Unit] =\n         GetActionRateLimited(RateLimits.ExpensiveGetRequest) { request =>\n+    // [to_paginate]\n     loadNotificationsImpl(userId, upToWhen = None, request)\n   }\n \n@@ -1483,9 +1497,7 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n           RateLimits.ReadsFromDb, MinAuthnStrength.EmbeddingStorageSid12) { request =>\n     import request.{dao, requester, requesterOrUnknown}\n \n-    SECURITY // Later: skip authors of hidden / deleted / private comments.  [priv_comts]\n-    // & bookmarks, once implemented. [dont_list_bookmarkers]\n-    // Or if some time in the future there will be \"hidden\" accounts  [private_pats]\n+    // If some time in the future there will be \"hidden\" accounts  [private_pats]\n     // — someone who don't want strangers and new members to see hens profile —\n     // then, would need to exclude those accounts here.\n \n@@ -1514,6 +1526,8 @@ class UserController @Inject()(cc: ControllerComponents, edContext: TyContext)\n               prefix, caseSensitive = false, limit = _ListUsersLimit, requesterOrUnknown)\n       }\n       else {\n+        // This skips authors of hidden / deleted / private comments,  [priv_comts]\n+        // and bookmarks. [dont_list_bookmarkers]\n         val users: ImmSeq[UserBr] = dao.listUsernamesOnPage(pageId = pageId)\n \n         // Reqr may see page, so can see all users there anyway."
    },
    {
      "sha": "5647fdd417a4ee8da96bde0313601e8314e38013",
      "filename": "appsv/server/controllers/ViewPageController.scala",
      "status": "modified",
      "additions": 121,
      "deletions": 18,
      "changes": 139,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FViewPageController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fcontrollers%2FViewPageController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fcontrollers%2FViewPageController.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -33,8 +33,9 @@ import ViewPageController._\n import debiki.dao.NoUsersOnlineStuff\n import talkyard.server.authn.LoginReason\n import talkyard.server.authn.MinAuthnStrength\n-import talkyard.server.authz.MaySeeOrWhyNot\n+import talkyard.server.authz.{Authz, MaySeeOrWhyNot}\n import talkyard.server.JsX.JsObjOrNull\n+import scala.collection.{mutable => mut}\n \n \n \n@@ -55,23 +56,34 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: TyContex\n \n \n   CHECK_AUTHN_STRENGTH\n-  def loadPost(pageId: PageId, postNr: PostNr): Action[Unit] = GetActionAllowAnyone { request =>\n+  private def _checkAuthn(request: GetRequest): U = {\n     // Similar to getPageAsJsonImpl and getPageAsHtmlImpl, keep in sync. [7PKW0YZ2]\n \n     val dao = request.dao\n-    val siteSettings = dao.getWholeSiteSettings()\n-    val authenticationRequired = siteSettings.userMustBeAuthenticated ||\n-      siteSettings.userMustBeApproved\n+    val settings = dao.getWholeSiteSettings()\n+    val authenticationRequired = settings.userMustBeAuthenticated || settings.userMustBeApproved\n \n+    // Need not return detailed error messages. Those are shown on the initial page load,\n+    // by getPageAsHtmlImpl.\n     if (authenticationRequired) {\n       if (!request.theUser.isAuthenticated)\n         throwForbidden(\"EdE7KFW02\", \"Not authenticated\")\n \n-      if (siteSettings.userMustBeApproved && !request.theUser.isApprovedOrStaff)\n+      if (settings.userMustBeApproved && !request.theUser.isApprovedOrStaff)\n         throwForbidden(\"EdE4F8WV0\", \"Account not approved\")\n     }\n+  }\n+\n+\n+  def loadPost(pageId: PageId, postNr: PostNr): Action[Unit] =\n+          GetActionAllowAnyoneRateLimited(RateLimits.ReadsFromDb) { request =>\n+    import request.dao\n+    // Authentication\n+    _checkAuthn(request)\n \n     // & sid leveL?\n+\n+    // Authorization\n     val (maySeeResult, debugCode) = dao.maySeePostUseCache(pageId, postNr, request.user)\n     maySeeResult match {\n       case MaySeeOrWhyNot.YesMaySee =>\n@@ -95,6 +107,104 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: TyContex\n   }\n \n \n+  def loadManyPosts(pageId: PageId, comtOrder: i32, offset: i32, rangeDir: i32): Action[U] =\n+          GetActionAllowAnyoneRateLimited(RateLimits.ReadsFromDb) { req =>\n+    import req.{dao, anyReqr}\n+    val reqrIsStaff = anyReqr.exists(_.isStaff)\n+\n+    throwBadReqIf(offset < PageParts.FirstReplyNr,\n+          \"TyEPOSTSOFS\", s\"Bad offset: $offset, it's < ${PageParts.FirstReplyNr}\")\n+\n+    // Bit dupl code. [posts_2_json]\n+\n+    _checkAuthn(req)\n+\n+    // ----- AuthZ 1/2: The page\n+\n+    val pageMeta = dao.getPageMeta(pageId) getOrElse {\n+      throwIndistinguishableNotFound(\"ManyPos_0Meta\")\n+    }\n+    val maySeeResult = dao.maySeePageUseCache(pageMeta, anyReqr)\n+    if (!maySeeResult.maySee)\n+      throwIndistinguishableNotFound(maySeeResult.debugCode)\n+\n+    SHOULD_OPTIMIZE // Cache, but what? Posts json chunks: 2–9, 10–19, 20–29, ... or each\n+    // post individually?  But don't cache too much! [careful_cache_range]\n+\n+    // ----- Load posts\n+\n+    // `order` needed later.\n+    val order = PostSortOrder.fromInt(comtOrder).getOrThrowBadArg(\"TyECOMTORD\", \"comtOrder\")\n+    val direction = RangeDir.fromInt(rangeDir).getOrThrowBadArg(\"TyECOMTRANGE\", \"rangeDir\")\n+    val which = WhichPostsOnPage.TopLevelRange(offset = offset, direction,\n+          // Don't load deleted or hidden commnets.\n+          activeOnly = true,\n+          // Isn't cached anyway, so might as well load one's own unapproved comments, if\n+          // one want to edit them.\n+          mustBeApproved = Some(false))\n+\n+    val postsInclCantSee: Vec[Post] = dao.readTx(_.loadPostsOnPage(pageId, which))\n+\n+    // ----- AuthZ 2/2: Each post  [careful_cache_range]\n+\n+    val postsMaySee = postsInclCantSee.filter { p =>\n+      val (maySee, dbgCode) = Authz.maySeePostIfMaySeePage(anyReqr, p)\n+      maySee.may\n+    }\n+\n+    // ----- Get related things\n+\n+    val patIds = mut.Set[PatId]()\n+    postsMaySee.foreach(_.addVisiblePatIdsTo(patIds))\n+\n+    // Bit dupl code. [pats_by_id_json]\n+    val patsById: Map[PatId, Pat] = dao.getParticipantsAsMap(patIds)\n+\n+    val tagsAndBadges: TagsAndBadges =\n+          dao.readTx(_.loadPostTagsAndAuthorBadges(postsMaySee.map(_.id)))\n+    val tagTypes = dao.getTagTypes(tagsAndBadges.tagTypeIds)\n+\n+    import talkyard.server.JsX._\n+\n+    val patsJsArr = JsArray(patsById.values.toSeq map { pat =>\n+      JsPat(pat, tagsAndBadges,\n+            // Set to None, if ever caching this. [careful_cache_range]\n+            toShowForPatId = anyReqr.map(_.id))\n+    })\n+\n+    // ----- To json\n+\n+    val postsJson = postsMaySee map { post =>\n+      var postJson = dao.jsonMaker.postToJsonOutsidePage(post, pageMeta.pageType,\n+            showHidden = false,\n+            // We've filtered out posts the reqr can't see, in authz step 2/2 above.\n+            includeUnapproved = true, // [careful_cache_range]\n+            tagsAndBadges,\n+            // The client already knows which page this is for.\n+            inclPageId = false)\n+\n+      if (reqrIsStaff && (post.numPendingFlags > 0 || post.numHandledFlags > 0)) {\n+        postJson += \"numPendingFlags\" -> JsNumber(post.numPendingFlags)\n+        postJson += \"numHandledFlags\" -> JsNumber(post.numHandledFlags)\n+      }\n+      postJson\n+    }\n+\n+    val res = Json.obj(  // Typescript: MorePostsStorePatch\n+        \"storePatch\" -> Json.obj(\n+          // This tells the client app to ignore the page version — it's better to show\n+          // the posts we return, even if the page has changed (e.g. gotten renamed).\n+          // (Normally, old changes (old page versions) are ignored — so a patch that\n+          // arrives too late somehow, won't reintroduce an old change.)\n+          \"ignorePageVersion\" -> JsTrue,\n+          \"postsByPageId\" -> Json.obj(pageId -> JsArray(postsJson)),\n+          \"patsBrief\" -> patsJsArr,\n+          \"tagTypes\" -> JsTagTypeArray(tagTypes, inclRefId = reqrIsStaff)))\n+\n+    OkSafeJson(res)\n+  }\n+\n+\n   /** Load a page like so: GET server/page/path and you'll get normal HTML.\n     * Load it instead like so: GET server/page/path?json — and you'll get JSON for usage\n     * in \"instant\" navigation in the single-page-app (SPA).\n@@ -105,6 +215,10 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: TyContex\n     * steps that updates the browser's URL to the page path.\n     * Good for analytics and understanding what the users do at the site?\n     * The SPA stuff is just an optimization.\n+    *\n+    * CLEAN_UP, COULD: RateLimits checked in  renderWholePageHtmlMaybeUseMemCache\n+    * — but wouldn't it be clearer to check  RateLimits.ViewPage  here, and only\n+    * RateLimits.ViewPageNoCache  there?\n     */\n   CHECK_AUTHN_STRENGTH\n   def viewPage(path: String): Action[Unit] = AsyncGetActionAllowAnyone { request =>\n@@ -154,19 +268,8 @@ class ViewPageController @Inject()(cc: ControllerComponents, edContext: TyContex\n \n     val dao = request.dao\n     val user = request.user\n-    val siteSettings = dao.getWholeSiteSettings()\n-    val authenticationRequired = siteSettings.userMustBeAuthenticated ||\n-      siteSettings.userMustBeApproved\n \n-    // Need not return detailed error messages. Those are shown on the initial page load,\n-    // by getPageAsHtmlImpl.\n-    if (authenticationRequired) {\n-      if (!user.exists(_.isAuthenticated))\n-        return Future.successful(makeProblemJsonResult(UNAUTHORIZED))\n-\n-      if (siteSettings.userMustBeApproved && !user.exists(_.isApprovedOrStaff))\n-        return Future.successful(makeProblemJsonResult(UNAUTHORIZED))\n-    }\n+    _checkAuthn(request)\n \n     val correctPagePath = dao.checkPagePath(specifiedPagePath) getOrElse {\n       throwIndistinguishableNotFound(\"LoadJson-NotFound\")"
    },
    {
      "sha": "09f2377f65ea7f5c32891f8a0781af52210a3b55",
      "filename": "appsv/server/debiki/Globals.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2FGlobals.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2FGlobals.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2FGlobals.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -272,7 +272,7 @@ class Globals(  // RENAME to TyApp? or AppContext? TyAppContext? variable name =\n     }\n   }\n \n-  // Could rename to \"rendererVersion\".\n+  // Could rename to \"rendererVersion\".  [renderer_version]\n   val applicationVersion = \"0.00.79\"  // later, read from some build config file\n \n   def applicationSecret: String = _appSecret"
    },
    {
      "sha": "1eb0ff1050b729298e74fdaaf5be78181547ec96",
      "filename": "appsv/server/debiki/ReactJson.scala",
      "status": "modified",
      "additions": 104,
      "deletions": 41,
      "changes": 145,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2FReactJson.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2FReactJson.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2FReactJson.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -42,7 +42,8 @@ case class PostExcerpt(text: String, firstImageUrls: imm.Seq[String])\n \n \n private case class RendererWithSettings(\n-  renderer: PostRenderer, settings: PostRendererSettings, site: SiteIdHostnames) {\n+  renderer: PostRenderer, settings: PostRendererSettings, site: SiteIdHostnames,\n+  inclPageId: Bo = false) {\n \n   def renderAndSanitize(post: Post, ifCached: IfCached): String = {\n     renderer.renderAndSanitize(post, settings, ifCached, site)\n@@ -109,7 +110,22 @@ case class PageToJsonResult(\n   version: CachedPageVersion,\n   pageTitleUnsafe: Option[String],\n   customHeadTags: FindHeadTagsResult,\n+\n+  //------\n   unapprovedPostAuthorIds: Set[UserId],\n+  // Later:  [remember_if_bookmarks_or_priv_comts]\n+  // hasBookmarksPatIds: Set[UserId], — or, could be part of unapprovedPostAuthorIds\n+  //      and maybe rename  patIdsWithUnapprovedPostsInclBoookmarks  hmm\n+  //      Maybe better to switch to \"node\" vs \"post\" terminology, then just:  [its_a_node]\n+  //       [patIdsWithOwnNodes],\n+  //          and an \"own node\" includes:  bookmarks,  drafts,  unapproved posts.\n+  // thereArePrivateComments: Bo,\n+  // BUT there's no need to cache this in the *database*. Aren't rendered server side\n+  // since not visible to everyone, only to a few specific peolpe, e.g. the bookmarker\n+  // or private thread members.\n+  // Maybe remember in  PageStuff?  It's in the mem cache already.\n+  //------\n+\n   anonsByRealId: Map[PatId, Seq[Anonym]])\n \n case class FindHeadTagsResult(\n@@ -226,6 +242,8 @@ class JsonMaker(dao: SiteDao) {\n   private def pageToJsonImpl(page: Page, renderParams: PageRenderParams,\n         dao: SiteDao, transaction: SiteTx): PageToJsonResult = {\n \n+    // Also see: [posts_2_json]\n+\n     // The json constructed here will be cached & sent to \"everyone\", so in this function\n     // we always specify !isStaff and the requester must be a stranger (user = None):\n     val pubAuthzCtx = dao.getForumPublicAuthzContext()\n@@ -236,8 +254,23 @@ class JsonMaker(dao: SiteDao) {\n     val pageParts = page.parts\n     val posts =\n       if (page.pageType.isChat) {\n-        // Load the latest chat messages only. We'll load earlier posts from the browser, on demand.\n-        transaction.loadOrigPostAndLatestPosts(page.id, limit = 100)\n+        renderParams.comtOffset match {\n+          case None =>\n+            // Load the latest chat messages only. We'll load earlier posts from the browser,\n+            // on demand.\n+            transaction.loadOrigPostAndLatestPosts(page.id, limit = 40)\n+          case Some(ofs) =>\n+            die(\"TyEDEADMAYBE04\", \"Is this dead code?\")\n+            // Orig pots & title should have been loaded already? But then would\n+            // one really need *page*PoJsonImpl? Shouldn't we return only json\n+            // for the post range, not any html?   [careful_cache_range]\n+            transaction.loadPostsOnPage(page.id, WhichPostsOnPage.TopLevelRange(\n+                  offset = ofs,\n+                  // Either include range dir in the render params, or decide on\n+                  // fixed offsets and limits? E.g. first 25, 26-50, 51-75, ...\n+                  direction = RangeDir.Older,\n+                  activeOnly = true))\n+        }\n       }\n       else if (page.pageType == PageType.Form) {\n         // Don't load any comments on form pages. [5GDK02]\n@@ -574,6 +607,12 @@ class JsonMaker(dao: SiteDao) {\n       storeJsonHash = hashSha1Base64UrlSafe(reactStoreJsonString))\n \n     COULD_OPTIMIZE // cache unapproved posts too?\n+    //\n+    // And which users have bookmarks,  [remember_if_bookmarks_or_priv_comts]\n+    // and if there are any rivate comments.\n+    // But then `page` needs to include private posts too, and we need to be careful\n+    // to not include any of them when rendering the public & cached version of the page.\n+    //\n     val unapprovedPosts = posts.filter(!_.isSomeVersionApproved)\n     val unapprovedPostAuthorIds = unapprovedPosts.map(_.createdById).toSet\n \n@@ -704,8 +743,9 @@ class JsonMaker(dao: SiteDao) {\n         tagsAndBadges: Opt[TagsAndBadges] = None, includeUnapproved: Bo = false,\n         showHidden: Bo = false, maySquash: Bo): (JsObject, PageVersion) = {\n     dao.readTx { tx =>\n-      // COULD optimize: don't load the whole page, load only postNr and the author and last editor.\n-      val page = dao.newPageDao(pageId, tx, useMemCache = true)\n+      COULD_OPTIMIZE // Load only postNr, author and last editor — not the whole page.\n+      val page = dao.newPageDao(pageId, tx, WhichPostsOnPage.thoseMaybeRelatedTo(postNr),\n+                        useMemCache = true)\n       val post = page.parts.thePostByNr(postNr)\n       val theTagsAndBadges = tagsAndBadges.getOrElse(\n             tx.loadPostTagsAndAuthorBadges(Seq(post.id)))\n@@ -845,10 +885,11 @@ class JsonMaker(dao: SiteDao) {\n \n \n   def postToJsonOutsidePage(post: Post, pageRole: PageType, showHidden: Bo,\n-          includeUnapproved: Bo, tagsAndBadges: TagsAndBadges): JsObject = {\n+          includeUnapproved: Bo, tagsAndBadges: TagsAndBadges,\n+          inclPageId: Bo): JsObject = {\n     val postRenderSettings = dao.makePostRenderSettings(pageRole)\n     val renderer = RendererWithSettings(\n-          dao.context.postRenderer, postRenderSettings, dao.theSite())\n+          dao.context.postRenderer, postRenderSettings, dao.theSite(), inclPageId = inclPageId)\n \n     postToJsonNoDbAccess(post, showHidden = showHidden,\n           includeUnapproved = includeUnapproved, tagsAndBadges,\n@@ -901,21 +942,7 @@ class JsonMaker(dao: SiteDao) {\n     if (pageRequest.pageExists) {\n       // (See comment above about ought-to-rename this whole function / stuff.)\n       RACE // if the user opens a page, and someone adds her to a chat at the same time.\n-      watchbar.tryAddRecentTopicMarkSeen(pageRequest.thePageMeta) match {\n-        case None => // watchbar wasn't modified\n-        case Some(modifiedWatchbar) =>\n-\n-          // Double check we may see the page(s) we're adding to the watchbar. [WATCHSEC]\n-          SEC_TESTS_MISSING // TyT602KRGJG\n-          val pageCtx = dao.maySeePageUseCacheAndAuthzCtx(pageRequest.thePageMeta, authzCtx)\n-                              .ifNot { debugCode =>\n-            dao.context.security.throwIndistinguishableNotFound(debugCode)\n-          }\n-\n-          watchbar = modifiedWatchbar\n-          dao.saveWatchbar(requester.id, watchbar)\n-          dao.pubSub.userWatchesPages(pageRequest.siteId, requester.id, watchbar.watchedPageIds) ;RACE\n-      }\n+      watchbar = dao.watchbarAddRecentMarkSeen(watchbar, pageRequest.thePageMeta, authzCtx)\n     }\n     val watchbarWithTitles = dao.fillInWatchbarTitlesEtc(watchbar)\n     val restrTopicsCatsLinks = listRestrictedCategoriesAndTopics(pageRequest)\n@@ -973,6 +1000,9 @@ class JsonMaker(dao: SiteDao) {\n     val restrictedTopics: Seq[JsValue] = restrTopicsCatsLinks.topicsJson\n     val restrictedTopicsUsers: Seq[JsObject] = restrTopicsCatsLinks.topicParticipantsJson\n \n+    COULD_OPTIMIZE // If [its_a_node], then, can remember in the  PageToJsonResult\n+    // which users have any drafts?  [remember_if_bookmarks_or_priv_comts]\n+    // Then, wouldn't need this sql query.\n     val draftsOnThisPage: imm.Seq[Draft] =\n       anyPageId.map(tx.loadDraftsByUserOnPage(requester.id, _)).getOrElse(Nil)\n \n@@ -1002,14 +1032,21 @@ class JsonMaker(dao: SiteDao) {\n     val (pageNotfPrefs: Seq[PageNotfPref],\n          ownVotesJson,\n          ownAnonVoters: ImmSeq[Anonym],\n-         unapprovedPostsJson,\n+         unapprovedPostsJson, // includes any bookmarks\n          unapprovedAuthorsJson) =\n       anyPageId map { pageId =>\n         COULD_OPTIMIZE // load cat prefs together with page notf prefs here?\n         val pageNotfPrefs = tx.loadNotfPrefsForMemberAboutPage(pageId, ownIdAndGroupIds)\n         SECURITY // minor: filter out prefs for cats one may not access...  [7RKBGW02]\n         SECURITY // Ensure done when generating notfs.\n \n+        // Later, load [priv_comts] here, & filter may-see? (looking at user & group ids)\n+        // But, COULD_OPTIMIZE, only if there actually *are* private comments — we can\n+        // remember in:  [remember_if_bookmarks_or_priv_comts]\n+        // loadPostsOnPage(pageId, WhichPostsOnPage.OnlyPrivate(... ? ...,\n+        //        activeOnly = true, mustBeApproved = Some(false))\n+        // } getOrElse Nil\n+\n         // The requester's own votes, and any anonyms han's used when voting.\n         val (ownVotesJson, voterIds) = mkVotesJson(requester.id, pageId, tx)\n         val ownVoters = tx.loadParticipants(voterIds)\n@@ -1082,7 +1119,7 @@ class JsonMaker(dao: SiteDao) {\n             \"votesByPostNr\" -> ownVotesJson,\n             \"internalBacklinks\" -> restrTopicsCatsLinks.internalBacklinksJson,\n             // later: \"flags\" -> JsArray(...) [7KW20WY1]\n-            \"unapprovedPosts\" -> unapprovedPostsJson,\n+            \"unapprovedPosts\" -> unapprovedPostsJson, // includes bookmarks\n             \"unapprovedPostAuthors\" -> unapprovedAuthorsJson,  // should remove [5WKW219] + search for elsewhere\n             \"knownAnons\" -> JsArray(ownAnons map JsKnownAnonym),\n             // later: JsArray(real-anon-authors.map(a => JsUser(a))), if is staff.\n@@ -1312,23 +1349,23 @@ class JsonMaker(dao: SiteDao) {\n   private def unapprovedPostsAndAuthorsJson(reqer: Pat, pageId: PageId,\n         unapprovedPostAuthorIds: Set[UserId], tx: SiteTx): UnapprovedPostsAndAuthors = {\n \n-    var posts: Seq[Post] =\n-      if (unapprovedPostAuthorIds.isEmpty) {\n-        // This is usually the case, and lets us avoid a db query.\n-        Nil\n-      }\n-      else if (reqer.isStaff) {\n-        // Mods & admins can see and apporve unapproved posts.\n-        tx.loadAllUnapprovedPosts(pageId, limit = 999)\n-      }\n-      else if (unapprovedPostAuthorIds.contains(reqer.id)) {\n-        // The requester henself can see and edit hens own unapproved posts.\n-        tx.loadUnapprovedPosts(pageId, by = reqer.id, limit = 999)\n+    // This loads bookmarks too (they're unapproved, and private: nrs < PageParts.MaxPrivateNr).\n+    var posts: Seq[Post] = {\n+      COULD_OPTIMIZE // [remember_if_bookmarks_or_priv_comts]\n+      // We currently don't know if there're [priv_comts] or bookmarks on this page,\n+      // so, if the user is logged in, we need to run a database query.\n+      // Later:\n+      // if (no unapproved posts & no bookmarks & no private comments  this user can see)\n+      //     Nil\n+      // else\n+      if (reqer.isAuthenticated) {\n+        tx.loadUnapprovedPosts(pageId, ownBy = reqer.id, allPublic = reqer.isStaff, limit = 999)\n       }\n       else {\n         // Others cannot see unapproved posts. Except for category mods? [cat_mods]\n         Nil\n       }\n+    }\n \n     COULD // load form replies also if user is page author?\n     if (reqer.isAdmin) {\n@@ -1520,7 +1557,13 @@ class JsonMaker(dao: SiteDao) {\n       postsByPageId.toSeq.map(pageIdPosts => {\n         val pageId = pageIdPosts._1\n         val posts = pageIdPosts._2\n-        val page = dao.newPageDao(pageId, tx, useMemCache = false)  // later: cache\n+        val page = dao.newPageDao(  // WOULD_OPTIMIZE: reuse from earlier in the same tx?\n+              pageId, tx, useMemCache = false,\n+              whichPosts =\n+                  // If it's private, we need also public posts, since private posts\n+                  // comment about or bookmark public posts.\n+                  if (posts.exists(_.isPrivate)) WhichPostsOnPage.AllByAnyone()\n+                  else WhichPostsOnPage.OnlyPublic() )\n         val postsJson = posts map { p =>\n           // We're in a tx, and postToJsonImpl renders CommonMark, slightly bad. [nashorn_in_tx]\n           postToJsonImpl(p, page, tagsAndBadges,\n@@ -2215,12 +2258,21 @@ object JsonMaker {\n       \"pinnedPosition\" -> JsNumberOrNull(post.pinnedPosition),\n       \"branchSideways\" -> JsNumberOrNull(post.branchSideways.map(_.toInt)),\n       \"likeScore\" -> JsNumber(decimal(post.likeScore)),\n-      \"childNrsSorted\" -> JsArray(howRender.childrenSorted.map(reply => JsNumber(reply.nr))),\n+      \"childNrsSorted\" -> JsArray( // [derive_client_side_instead]?  [bookmarks_filtered_out]\n+            howRender.childrenSorted.flatMap(reply =>\n+                if (reply.tyype == PostType.Bookmark) None else Some(JsNumber(reply.nr)))),\n       \"sanitizedHtml\" -> JsStringOrNull(anySanitizedHtml),\n       \"pubTags\" -> JsArray(postTags map JsTag),\n       )\n \n-    if (post.isBodyHidden) fields :+= \"isBodyHidden\" -> JsTrue\n+    if (howRender.childrenSorted.exists(_.tyype == PostType.Bookmark))\n+      fields :+= \"bookmarkNrs\" ->  // [derive_client_side_instead]?  [bookmarks_filtered_out]\n+            JsArray(howRender.childrenSorted.flatMap(reply =>\n+                  if (reply.tyype != PostType.Bookmark) None\n+                  else Some(JsNumber(reply.nr))))\n+\n+    if (post.isBodyHidden)\n+      fields :+= \"isBodyHidden\" -> JsTrue\n \n     if (!isApproved) {\n       // Then need to know which revision nr we'll approve, if clicking\n@@ -2230,8 +2282,14 @@ object JsonMaker {\n       fields :+= \"approvedRevNr\" -> JsNumberOrNull(post.approvedRevisionNr)\n     }\n \n+    if (renderer.inclPageId)\n+      fields :+= \"pageId\" -> JsString(post.pageId)\n+\n     // For now. So can edit the title without extra loading the title post's source. [5S02MR4]\n-    if (post.isTitle) fields :+= \"unsafeSource\" -> JsStringOrNull(unsafeSource)\n+    // Bookmarks use the current source  [dont_format_bookmarks],  need not be approved\n+    // (others can't see them).\n+    if (post.isTitle || post.tyype == PostType.Bookmark)\n+      fields :+= \"unsafeSource\" -> JsStringOrNull(unsafeSource)\n \n     // Later: Don't incl any private members. [private_pats]\n     if (post.authorIds.nonEmpty)\n@@ -2268,13 +2326,18 @@ object JsonMaker {\n \n \n   /** Creates a dummy root post, needed when rendering React elements. */\n-  def embeddedCommentsDummyRootPost(parentlessReplyNrsSorted: imm.Seq[JsNumber]): JsObject =\n+  def embeddedCommentsDummyRootPost(parentlessReplyNrsSorted: imm.Seq[JsNumber]): JsObject = {\n+    val badNrs = parentlessReplyNrsSorted.filter(_.value < PageParts.MinPublicNr)\n+    dieIf(badNrs.nonEmpty,  // [bookmarks_filtered_out]\n+          \"TyEPRIVCOMTNR\", s\"Non-public nr among dummy root reply nrs: $badNrs\")\n+\n     Json.obj(\n       \"nr\" -> JsNumber(PageParts.BodyNr),\n       \"isApproved\" -> JsTrue,\n       // COULD link to embedding article, change text to: \"Discussion of the text at https://....\"\n       \"sanitizedHtml\" -> JsString(\"(Embedded comments dummy root post [EdM2PWKV06]\"),\n       \"childNrsSorted\" -> parentlessReplyNrsSorted)\n+  }\n \n \n   case class ToTextResult(text: String, isSingleParagraph: Boolean)"
    },
    {
      "sha": "8a34dcbb0c62493bba2c82b88cb5cc0dbf2d3d42",
      "filename": "appsv/server/debiki/dao/FeedsDao.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FFeedsDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FFeedsDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FFeedsDao.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -74,7 +74,7 @@ trait FeedsDao {\n \n   private def loadAtomFeedXml(reqrInf: ReqrInf, onlyEmbComments: Boolean)\n         : xml.Node = {\n-    val LoadPostsResult(postsOneMaySee, pageStuffById) =\n+    val LoadPostsResult(postsOneMaySee, pageStuffById, _) =\n           loadPostsMaySeeByQuery(PostQuery.AllPosts(\n                 reqrInf, orderBy = OrderBy.MostRecentFirst, limit = 25,\n                 inclAnonPosts = true, // true authors not shown [list_anon_posts]"
    },
    {
      "sha": "2a81dfebc25bd9be30affea1ef1d3e40ef833dd6",
      "filename": "appsv/server/debiki/dao/PageDao.scala",
      "status": "modified",
      "additions": 6,
      "deletions": 29,
      "changes": 35,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FPageDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FPageDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FPageDao.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -31,7 +31,8 @@ import debiki.AllSettings\n   */\n // REFACTOR  combine PageDao and PagePartsDao into the same class, \"PageDao\". [ONEPAGEDAO]\n case class PageDao(override val id: PageId, settings: AllSettings,\n-      transaction: SiteTransaction, anyDao: Opt[SiteDao])\n+      transaction: SiteTransaction, anyDao: Opt[SiteDao],\n+      whichPosts: WhichPostsOnPage = WhichPostsOnPage.OnlyPublic(activeOnly = false))\n   extends Page {\n \n   assert(id ne null)\n@@ -40,7 +41,7 @@ case class PageDao(override val id: PageId, settings: AllSettings,\n \n   var _path: Option[PagePathWithId] = null\n \n-  val parts = PagePartsDao(id, settings, transaction, anyDao)\n+  val parts = PagePartsDao(id, settings, transaction, anyDao, whichPosts)\n \n   override def siteId: SiteId = transaction.siteId\n \n@@ -99,6 +100,8 @@ case class PagePartsDao(\n   transaction: SiteTx,\n   // COULD_OPTIMIZE Use any dao instead of the tx always if possible?\n   anyDao: Opt[SiteDao] = None,\n+  // Public (not bookmarks or priv comts) is the default.\n+  whichPosts: WhichPostsOnPage = WhichPostsOnPage.OnlyPublic(activeOnly = false),\n   ) extends PageParts {\n \n   assert(pageId ne null)\n@@ -174,29 +177,10 @@ case class PagePartsDao(\n   }\n \n   private var _allPosts: Vec[Post] = _\n-  private var _activePosts: Vec[Post] = _\n \n   def loadAllPosts(): Unit = {\n     if (_allPosts eq null) {\n-      WOULD_OPTIMIZE // If _activePosts ne null, load only *in*active?\n-      // We're in the same tx, so should usually be fine — however, what if a\n-      // previously inactive post has been made active, in this tx?\n-      // Then, if calling this.activePosts and then this.allPosts, allPosts\n-      // would be incomplete — I think that is _surprising_behavior?\n-      // Maybe load inactive posts, only if the tx is read-only?\n-      // For now, always:\n-      _allPosts = transaction.loadPostsOnPage(pageId)\n-    }\n-  }\n-\n-  def loadActivePostsOnly(): U = {\n-    if (_activePosts eq null) {\n-      // If _allPosts have been loaded already, and a new post created afterwards,\n-      // then, that new post wouldn't be included here. I think that's\n-      // pretty *un*_surprising_behavior? so maybe can be ok?\n-      _activePosts =\n-            if (_allPosts ne null) _allPosts.filter(_.isVisible)\n-            else transaction.loadPostsOnPage(pageId, activeOnly = true)\n+      _allPosts = transaction.loadPostsOnPage(pageId, whichPosts)\n     }\n   }\n \n@@ -207,13 +191,6 @@ case class PagePartsDao(\n     _allPosts\n   }\n \n-  override def activePosts: Vec[Post] = {\n-    if (_activePosts eq null) {\n-      loadActivePostsOnly()\n-    }\n-    _activePosts\n-  }\n-\n \n   def updatePostInMem_unimpl(posts: Iterable[Post]): PagePartsDao = this // impl later?\n "
    },
    {
      "sha": "43ff469137595448e10c8dcea7aa45fca3ded39c",
      "filename": "appsv/server/debiki/dao/PostsDao.scala",
      "status": "modified",
      "additions": 283,
      "deletions": 46,
      "changes": 329,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FPostsDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FPostsDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FPostsDao.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -18,9 +18,10 @@\n package debiki.dao\n \n import com.debiki.core._\n+import com.debiki.core.isProd\n import com.debiki.core.EditedSettings.MaxNumFirstPosts\n import com.debiki.core.Prelude._\n-import com.debiki.core.PageParts.FirstReplyNr\n+import com.debiki.core.PageParts.{FirstReplyNr, MinPublicNr}\n import controllers.EditController\n import debiki._\n import debiki.EdHttp._\n@@ -47,7 +48,9 @@ case class ApprovePostResult(\n \n case class LoadPostsResult(\n   posts: immutable.Seq[Post],\n-  pageStuffById: Map[PageId, PageStuff])\n+  pageStuffById: Map[PageId, PageStuff],\n+  bookmarks: immutable.Seq[Post],\n+  )\n \n \n \n@@ -153,10 +156,18 @@ trait PostsDao {\n \n     val storePatchJson = jsonMaker.makeStorePatchForPost(newPost, showHidden = true)\n \n-    // (If reply not approved, this'll send mod task notfs to staff [306DRTL3])\n-    pubSub.publish(StorePatchMessage(siteId, pageId, storePatchJson, notifications),\n-          // This can be an anonym's id — fine. (Right?)\n-          byId = author.id)\n+    // WebSocket-notify others about the new post, if it's public (meaning, if those\n+    // who can see the page, can see the post).\n+    //\n+    // But don't send bookmarks or private comments to others. There's a double check\n+    // in PubSubActor that nothing private gets sent: [dont_leak_private_posts].\n+    //\n+    if (!newPost.isPrivate) {\n+      // (If reply not approved, this'll send mod task notfs to staff [306DRTL3])\n+      pubSub.publish(StorePatchMessage(siteId, pageId, storePatchJson, notifications),\n+            // This can be an anonym's id — fine. (Right?)\n+            byId = author.id)\n+    }\n \n     InsertPostResult(storePatchJson, newPost, anyReviewTask)\n   }\n@@ -173,12 +184,79 @@ trait PostsDao {\n         refId: Opt[RefId] = None)\n         : (Post, Participant, Notifications, Option[ReviewTask]) = {\n \n+    // ----- Sanity checks\n+\n     require(textAndHtml.safeHtml.trim.nonEmpty, \"TyE25JP5L2\")\n \n+    dieIf(isProd && postType == PostType.Bookmark,\n+          \"TyEBOOKM0ENA1\", \"Bookmarks not yet enabled in prod mode\")\n+\n+    if (asAlias.isDefined) {  // [both_anon_priv]\n+      throwForbiddenIf(postType == PostType.Bookmark,\n+            \"TyEANONBOOKM\", \"Anonyms cannot bookmark things\")\n+\n+      throwForbiddenIf(postType.isPrivate,\n+            \"TyEANONPRIVPO2\", \"Anonyms cannot post private comments\")\n+\n+      // maybe must be System?\n+      throwForbiddenIf(postType == PostType.MetaMessage,\n+            \"TyEANONMETA\", \"Anonyms cannot post meta messages\")\n+    }\n+\n+    throwBadReqIf(postType == PostType.Bookmark && byWho.isGuestOrAnon,\n+          \"TyEANONBOKM\", \"Guests and anonyms cannot bookmark things\")\n+\n+    throwBadReqIf(postType.isPrivate && byWho.isGuestOrAnon,\n+          \"TyEANONPRIVCOMT\", \"Guests and anonyms cannot comment privately\")\n+\n+    val noReplyToIsPrivate   = replyToPostNrs.forall(_ >= PageParts.MinPublicNr)\n+    val someReplyToIsPrivate = replyToPostNrs.exists(_ <= PageParts.MaxPrivateNr)\n+    val allReplyToArePrivate = (replyToPostNrs.forall(_ <= PageParts.MaxPrivateNr)\n+                                  && !replyToPostNrs.isEmpty)  // but can't be empty? oh well\n+\n+    // Later, maybe there'll be some `makePrivate: Bo` param instead/in-addition-to checking\n+    // `postType.isPrivate`,  since [priv_comts] will have the same type as public comments?\n+    // But their nrs are <= MaxPrivateNr; then need to generate such a nr.\n+    throwForbiddenIf(someReplyToIsPrivate && !postType.isPrivate,\n+          \"TyEREPUB2PRIV\", \"Cannot post a not-private post to private posts\")\n+\n+    // (However, replying privately to a public comment is ok — that's the whole point\n+    // with private comments, sort of.)\n+\n+    // ----- Load stuff\n+\n+    WOULD_OPTIMIZE // We'll load all priv or pub posts, but maybe it'd be enough to\n+    // load only those pat is replying to, and their ancestors? (to know whom to notify)\n+    val loadWhichPosts =\n+          if (allReplyToArePrivate) {\n+            // Then we don't need to know about any of the public posts — which nrs exist,\n+            // which is the next public nr, doesn't matter.\n+            // Later, [priv_comts]: We need public posts too, so we can generate\n+            // notifications to [people who posted public comments earlier and can see\n+            // the private comments, but didn't post any private comments themselves yet].\n+            // (Note that `page` below contains only `loadWhichPosts` but is used\n+            // for generating notifications [_gen_notfs].)\n+            unimpl(\"Replying to private posts [TyEUNTEST0367]\")\n+            WhichPostsOnPage.OnlyPrivate(byUserId = byWho.id)\n+          }\n+          else if (noReplyToIsPrivate) {\n+            // Then we don't need to look at private posts — cannot be any private ancestors.\n+            WhichPostsOnPage.OnlyPublic()\n+          }\n+          else {\n+            unimpl(\"Multireply to mixed priv pub [TyE6F8FMS26]\")\n+            // WhichPostsOnPage.AllByAnyone\n+          }\n+\n     val realAuthorAndLevels = loadUserAndLevels(byWho, tx)\n-    val page = newPageDao(pageId, tx)\n-    val replyToPosts = page.parts.getPostsAllOrError(replyToPostNrs) getOrIfBad  { missingPostNr =>\n-      throwNotFound(s\"Post nr $missingPostNr not found\", \"EdE4JK2RJ\")\n+    val page = newPageDao(pageId, tx, whichPosts = loadWhichPosts)\n+    val replyToPosts = page.parts.getPostsAllOrError(replyToPostNrs) getOrIfBad { missingNr =>\n+      throwIndistinguishableNotFound(\"TyEPOST0FND2\", isAboutPostNr = Some(missingNr.loneElement))\n+    }\n+\n+    if (replyToPosts.exists(_.tyype == PostType.Bookmark)) {\n+      throwBadReqIf(postType == PostType.Bookmark, \"TyEBOKMBOKM\", \"Cannot bookmark bookmarks\")\n+      throwBadReq(\"TyERE2BOKM\", \"Cannot reply to bookmarks\")\n     }\n \n     // Might be a [pseudonyms_later] though, if ever implemented.\n@@ -192,21 +270,42 @@ trait PostsDao {\n \n     val pageAuthor = tx.loadTheParticipant(page.meta.authorId)\n \n+    // ----- Authz check\n+\n+    // If we're adding a bookmark, or posting private comments, then it's enough if we\n+    // can see the page or comment, since others won't know about our bookmarks or private\n+    // comments thread anyway.  mayPostReply() knows about that (looks at the post type).\n     dieOrThrowNoUnless(Authz.mayPostReply(\n       realAuthorAndLevels, asAlias /* _not_same_tx, ok */, realAuthorAndGroupIds,\n       postType, page.meta, pageAuthor = pageAuthor,\n       replyToPosts, tx.loadAnyPrivateGroupTalkMembers(page.meta),\n       tx.loadCategoryPathRootLast(page.meta.categoryId, inclSelfFirst = true),\n       tx.loadPermsOnPages()), \"EdEMAY0RE\")\n \n-    if (page.pageType.isChat)\n+    // ----- Generate id, nr\n+\n+    if (page.pageType.isChat && postType != PostType.Bookmark)\n       throwForbidden(\"EsE50WG4\", s\"Page '${page.id}' is a chat page; cannot post normal replies\")\n \n     val settings = loadWholeSiteSettings(tx)\n \n     // Some dupl code [3GTKYA02]\n     val uniqueId = tx.nextPostId()\n-    val postNr = page.parts.highestReplyNr.map(_ + 1).map(max(FirstReplyNr, _)) getOrElse FirstReplyNr\n+    val postNr =\n+          if (postType.isPrivate) {  // later: or if is [priv_comts]\n+            // Generate a random post nr <= MaxPrivateNr. (Sequential order would enable\n+            // others to figure out if others have bookmarked something or if there're\n+            // private comment threads.)  [gen_priv_post_nr]\n+            nextRandomPrivPostNr()\n+          }\n+          else {\n+            // Bump the post nr to previous reply nr + 1, so the orig post & comments have\n+            // nrs 1, 2, 3, ...\n+            page.parts.highestReplyNr.map(_ + 1).map(max(FirstReplyNr, _)) getOrElse FirstReplyNr\n+          }\n+\n+    // ----- More sanity checks\n+\n     val commonAncestorNr = page.parts.findCommonAncestorNr(replyToPostNrs.toSeq)\n     val anyParent: Opt[Post] =\n       if (commonAncestorNr == PageParts.NoNr) {\n@@ -237,7 +336,14 @@ trait PostsDao {\n     // no descendants. So it cannot create a cycle. (However, if *importing* posts,\n     // then in a corrupt import file the posts on a page might form cycles. [ck_po_ckl])\n \n+    // ----- Review? Approve?\n+\n     val (reviewReasons: Seq[ReviewReason], shallApprove: Bo) =\n+          if (postType == PostType.Bookmark) {   // later: or if is [priv_comts] ?\n+            // Bookmarks can't be seen by others, need not be approved.\n+            (Nil, false)\n+          }\n+          else {\n             // Don't use an anonym's true user or trust level here — that would\n             // make it simpler to guess who the anonym is.\n             // F.ex. if there aren't many members, and only one member, M1, has had their\n@@ -248,7 +354,8 @@ trait PostsDao {\n             // who actually wrote such a comment to decide if to review it or not. Still,\n             // in the future, for some communities that might be fine, if moderators are\n             // very trusted (they're the ones who can see when a comment got approved).)\n-            throwOrFindNewPostReviewReasons(page.meta, personaAndLevels, tx)\n+             throwOrFindNewPostReviewReasons(page.meta, personaAndLevels, tx)\n+          }\n \n     // Similar to: [find_approver_id].\n     val approverId =\n@@ -258,6 +365,9 @@ trait PostsDao {\n             // author is a mod, it'd be simpler to guess who the author is. [mod_deanon_risk]\n             None\n           }\n+          else if (postType.isPrivate || postNr < PageParts.MinPublicNr) {\n+            die(\"TyEAPRPRIVPO\", \"Approving private post?\")\n+          }\n           else {\n             if (realAuthor.isStaff && asAlias.isEmpty) {\n               // Mods approve their own commments, upon posting them.  Unless it's an anon\n@@ -272,6 +382,8 @@ trait PostsDao {\n             }\n           }\n \n+    // ----- Create post\n+\n     val newPost = Post.create(\n       uniqueId = uniqueId,\n       extImpId = refId,\n@@ -296,16 +408,31 @@ trait PostsDao {\n             page.meta.frequentPosterIds\n \n     val oldMeta = page.meta\n-    val newMeta = oldMeta.copy(\n-      bumpedAt = shallBumpPage ? Option(now.toJavaDate) | oldMeta.bumpedAt,\n-      lastApprovedReplyAt = shallApprove ? Option(now.toJavaDate) | oldMeta.lastApprovedReplyAt,\n-      lastApprovedReplyById = shallApprove ? Option(authorMaybeAnon.id) | oldMeta.lastApprovedReplyById,\n-      frequentPosterIds = newFrequentPosterIds,\n-      numRepliesVisible = page.parts.numRepliesVisible + (shallApprove ? 1 | 0),\n-      numRepliesTotal = page.parts.numRepliesTotal + 1,\n-      numPostsTotal = page.parts.numPostsTotal + 1,\n-      numOrigPostRepliesVisible = page.parts.numOrigPostRepliesVisible + numNewOpRepliesVisible,\n-      version = oldMeta.version + 1)\n+    val newMeta =\n+          if (postType.isPrivate) {   // later: or if is [priv_comts] ?\n+            // Then, nothing others can see, changes.  [0_stats_for_priv_posts]\n+            // No need to bump any page fileds or version, no need to rerender.\n+            // Private things are loaded separately, only for those who can see them.\n+            // E.g. one's bookmarks, or private threads one is a member of.\n+            oldMeta\n+          }\n+          else {\n+            // If `shallApprove`, things others can see have changed; then, need\n+            // to rerender the page.\n+            oldMeta.copy(\n+                bumpedAt = shallBumpPage ? Option(now.toJavaDate) | oldMeta.bumpedAt,\n+                lastApprovedReplyAt = shallApprove ?\n+                      Option(now.toJavaDate) | oldMeta.lastApprovedReplyAt,\n+                lastApprovedReplyById = shallApprove ?\n+                      Option(authorMaybeAnon.id) | oldMeta.lastApprovedReplyById,\n+                frequentPosterIds = newFrequentPosterIds,\n+                numRepliesVisible = page.parts.numRepliesVisible + (shallApprove ? 1 | 0),\n+                numRepliesTotal = page.parts.numRepliesTotal + 1,\n+                numPostsTotal = page.parts.numPostsTotal + 1,\n+                numOrigPostRepliesVisible =\n+                      page.parts.numOrigPostRepliesVisible + numNewOpRepliesVisible,\n+                version = oldMeta.version + (shallApprove ? 1 | 0))\n+          }\n \n     // Since the post didn't exist before, it's enough to remember the refs\n     // from the new textAndHtml only. [new_upl_refs]\n@@ -316,6 +443,8 @@ trait PostsDao {\n       dieIf(uploadRefs != uplRefs2, \"TyE503SKH5\", s\"uploadRefs: $uploadRefs, 2: $uplRefs2\")\n     }\n \n+    // ----- Audit log entry\n+\n     val anyParentOrigAuthor: Opt[Pat] = anyParent.map(parentPost =>\n                                           tx.loadTheParticipant(parentPost.createdById))\n \n@@ -339,6 +468,8 @@ trait PostsDao {\n       targetPostNr = anyParent.map(_.nr),\n       targetPatTrueId = anyParentOrigAuthor.map(_.trueId2))\n \n+    // ----- Review & spam check tasks\n+\n     val anyReviewTask = if (reviewReasons.isEmpty) None\n     else Some(ReviewTask(\n       id = tx.nextReviewTaskId(),\n@@ -372,20 +503,25 @@ trait PostsDao {\n           reqrId = authorMaybeAnon.id,\n           requestStuff = spamRelReqStuff))\n \n-    val stats = UserStats(\n-      authorMaybeAnon.id,\n-      lastSeenAt = now,\n-      lastPostedAt = Some(now),\n-      firstDiscourseReplyAt = Some(now),\n-      numDiscourseRepliesPosted = 1,\n-      numDiscourseTopicsRepliedIn = 0) // SHOULD update properly\n+    // ----- Save to db\n \n+    var stats = UserStats(authorMaybeAnon.id, lastSeenAt = now)\n+    if (!newPost.isPrivate) {  // [0_stats_for_priv_posts]\n+      stats = stats.copy(\n+            lastPostedAt = Some(now),\n+            firstDiscourseReplyAt = Some(now),\n+            numDiscourseRepliesPosted = 1,\n+            numDiscourseTopicsRepliedIn = 0) // SHOULD update properly\n+    }\n     addUserStats(stats)(tx)\n+\n     tx.insertPost(newPost)\n     // Index post, also if not yet approved [ix_unappr] — can be nice for mods to be able to\n     // search & find such posts too? We _reindexed_if_approved_later.\n     tx.indexPostsSoon(newPost)\n     tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale = shallApprove)\n+\n+    // (This excludes bookmarks and private comments — they don't get approved.)\n     if (shallApprove) {\n       val pagePartsInclNewPost = PreLoadedPageParts(\n         newMeta,\n@@ -399,6 +535,7 @@ trait PostsDao {\n       staleStuff.addPageId(pageId)\n       saveDeleteLinks(newPost, textAndHtml, authorMaybeAnon.trueId2, tx, staleStuff)\n     }\n+\n     uploadRefs foreach { uploadRef =>\n       tx.insertUploadedFileReference(newPost.id, uploadRef, addedById = authorMaybeAnon.id)\n     }\n@@ -421,13 +558,20 @@ trait PostsDao {\n             ReviewDecision.InteractReply)(tx, staleStuff)\n     }\n \n+    // ----- Notify others\n+\n     val notifications =\n-      if (skipNotfsAndAuditLog) Notifications.None\n-      else notfGenerator(tx).generateForNewPost( // page dao excls new reply, ...\n-                 // ... that's ok, as of now. (See: [notf_new_post_dao])\n-            page, newPost, Some(textAndHtml),\n-            postAuthor = Some(authorMaybeAnon), trueAuthor = Some(realAuthor),\n-            anyNewModTask = anyReviewTask)\n+          if (skipNotfsAndAuditLog || newPost.tyype == PostType.Bookmark)  // [0_bokm_notfs]\n+            Notifications.None\n+          else\n+            notfGenerator(tx).generateForNewPost( // page dao excls new reply, ...\n+                  // ... that's ok, as of now. (See: [notf_new_post_dao])\n+                  // But `page` needs to incl public posts, even if the reply is private\n+                  // and only replies to private posts? See [_gen_notfs] above.\n+                  page, newPost, Some(textAndHtml),\n+                  postAuthor = Some(authorMaybeAnon), trueAuthor = Some(realAuthor),\n+                  anyNewModTask = anyReviewTask)\n+\n     tx.saveDeleteNotifications(notifications)\n \n     // Could save the poster's topics-replied-to notf pref as  [interact_notf_pref]\n@@ -1047,14 +1191,21 @@ trait PostsDao {\n     val anyEditedCategory = writeTx { (tx, staleStuff) =>\n       val realEditorAndLevels = loadUserAndLevels(who, tx)\n       val realEditor = realEditorAndLevels.user\n-      val page = newPageDao(pageId, tx)\n+      val page = newPageDao(pageId, tx,\n+            // Editing a page or ordinary comment? [_dont_load_private]\n+            if (postNr >= MinPublicNr) WhichPostsOnPage.OnlyPublic(activeOnly = false)\n+            // Editing bookmarks or private comments?\n+            else WhichPostsOnPage.OnlyPrivate(byUserId = who.id, activeOnly = false))\n       val settings = loadWholeSiteSettings(tx)\n \n       val postToEdit = page.parts.postByNr(postNr) getOrElse {\n         page.meta // this throws page-not-fount if the page doesn't exist\n         throwNotFound(\"DwE404GKF2\", s\"Post not found, id: '$postNr'\")\n       }\n \n+      dieIf(isProd && postToEdit.tyype == PostType.Bookmark,\n+            \"TyEBOOKM0ENA2\", \"Bookmarks not yet enabled in prod mode\")\n+\n       if (postToEdit.currentSource == newTextAndHtml.text)\n         return\n \n@@ -1071,6 +1222,9 @@ trait PostsDao {\n \n       val editorPersona = editorPersonaAndLevels.user\n \n+      dieIf(editorPersona.isAlias && postToEdit.isPrivate, // [both_anon_priv]\n+            \"TyEANONPRIVED2\", \"Cannot edit bookmarks or anonymous comments anonymously\")\n+\n       // [dupl_ed_perm_chk]?\n       dieOrThrowNoUnless(Authz.mayEditPost(\n             realEditorAndLevels, asAlias /* _not_same_tx, ok */,\n@@ -1102,14 +1256,27 @@ trait PostsDao {\n           val currentRevStartMs = postToEdit.currentRevStaredAt.getTime\n           val flags = tx.loadFlagsFor(immutable.Seq(PagePostNr(pageId, postNr)))\n           val anyNewFlag = flags.exists(_.flaggedAt.millis > currentRevStartMs)\n+\n+          // But what about private comment successors to public comments? Ignore them,\n+          // otherwise it'd be possible to guess if there's private comments or not,\n+          // by looking at if a new revision gets created.  (If editing a public post,\n+          // we _dont_load_private posts.)  [priv_comts]\n           val successors = page.parts.descendantsOf(postNr)\n+\n           val anyNewComment = successors.exists(_.createdAt.getTime > currentRevStartMs)\n         !anyNewComment && !anyNewFlag\n       }\n \n       // Similar to: [find_approver_id].  [mod_deanon_risk]\n       val anyNewApprovedById = {\n-        if (postToEdit.tyype == PostType.ChatMessage) {\n+        if (postToEdit.tyype == PostType.Bookmark) {\n+          // Bookmarks need not be approved.\n+          None\n+        }\n+        else if (postToEdit.isPrivate) {\n+          unimpl(\"Not approving private edits [TyEAPRPRIVED]\")\n+        }\n+        else if (postToEdit.tyype == PostType.ChatMessage) {\n           // Auto approve chat messages. Always SystemUserId for chat.\n           Some(SystemUserId)  // [7YKU24]\n         }\n@@ -1383,6 +1550,7 @@ trait PostsDao {\n         \"TyE305RK7TP\", \"Staff cannot approve and publish post via an edit\")\n \n       if (editedPost.isCurrentVersionApproved) {\n+        dieIf(editedPost.isPrivate, \"TyE603SKJ\", \"Bookmark links & notfs?\") // [0_bokm_notfs]\n         staleStuff.addPageId(editedPost.pageId)\n         saveDeleteLinks(editedPost, newTextAndHtml, editorPersona.trueId2, tx, staleStuff)\n         TESTS_MISSING // notf not sent until after ninja edit window ended?  TyTNINJED02\n@@ -1393,6 +1561,8 @@ trait PostsDao {\n \n       deleteDraftNr.foreach(nr => tx.deleteDraft(realEditorId, nr))\n \n+      // Skip for bookmarks ! [0_stats_for_priv_posts],  & skip approve / review / etc too, above\n+\n       val oldMeta = page.meta\n       var newMeta = oldMeta.copy(version = oldMeta.version + 1)\n       var makesSectionPageHtmlStale = false\n@@ -1444,6 +1614,14 @@ trait PostsDao {\n           tx: SiteTx, staleStuff: StaleStuff, skipBugWarn: Bo = false): U = {\n     // Some e2e tests: backlinks-basic.2br.d  TyTINTLNS54824\n \n+    // Skip bookmarks. And skip [priv_comts] too, for now.  [0_ln_from_priv]\n+    // Later: Nice to see links from one's private comments? But would be good if there was\n+    // then a way to easily exclude all links from private comments, so won't slow down\n+    // page rendering (by loading everyone's private comment links, might be many). Like\n+    // private posts: nr < MaxPrivateNr.\n+    if (post.isPrivate)\n+      return\n+\n     // Let's always add the page id to staleStuff before, just so that\n     // here we can check that that wasn't forgotten.\n     // Don't do from in here — that'd be unexpected?, in this fn about links.\n@@ -1506,6 +1684,7 @@ trait PostsDao {\n     // [On2], fine.\n     val deletedLinks = linksBefore.filter(lb => !linkUrlsAfter.contains(lb.linkUrl))\n \n+    require(!post.isPrivate) // double check\n     tx.deleteLinksFromPost(post.id, deletedLinks.map(_.linkUrl).toSet)\n     newLinks foreach tx.upsertLink\n \n@@ -1779,6 +1958,9 @@ trait PostsDao {\n \n \n   def changePostType(pageId: PageId, postNr: PostNr, newType: PostType, reqr: ReqrId): U = {\n+    dieIf(isProd && newType == PostType.Bookmark,\n+          \"TyEBOOKM0ENA9\", \"Bookmarks not yet enabled in prod mode\")\n+\n     writeTx { (tx, staleStuff) =>\n       val page = newPageDao(pageId, tx)\n       val postBefore = page.parts.thePostByNr(postNr)\n@@ -1903,7 +2085,14 @@ trait PostsDao {\n     import com.debiki.core.{PostStatusAction => PSA}\n     import context.security.throwIndistinguishableNotFound\n \n-    val pageBef = newPageDao(pageId, tx)\n+    // (This won't load private comments or bookmarks, if postNr is a public post.\n+    // That's as intended — deleting a comments tree, should not delete any bookmarks or\n+    // private sub threads.  Such bookmarks or private threads get orphaned if the bookmarker\n+    // or private thread members can't see the deleted posts.  [private_orphans]\n+    // They can still see their bookmarks or private comment threads, but not the deleted\n+    // bookmarked comment or deleted comments being discussed privately.)\n+    val pageBef = newPageDao(pageId, tx, WhichPostsOnPage.thoseMaybeRelatedTo(postNr))\n+\n     if (!pageBef.exists)\n       throwIndistinguishableNotFound(\"TyE05KSRDM3\")\n \n@@ -2027,10 +2216,11 @@ trait PostsDao {\n       }\n     }\n \n-    // ----- Update successors\n+    // ----- Update descendants\n \n     // Update any indirectly affected posts, e.g. subsequent comments in the same\n     // thread that are being deleted recursively.\n+    // (This ignores private descendants of public comments — as intended. [private_orphans])\n     val postsToReindex = MutArrBuf[Post]()\n     if (action.affectsSuccessors) for (successor: Post <- pageBef.parts.descendantsOf(postNr)) {\n       val anyUpdatedSuccessor: Option[Post] = action match {\n@@ -2081,6 +2271,7 @@ trait PostsDao {\n             linkedPageIds, pageModified = false, backlinksStale = true)\n     }\n \n+    SHOULD // Skip if is bookmark being deleted. ! [0_stats_for_priv_posts]\n     val oldMeta = pageBef.meta\n     var newMeta = oldMeta.copy(version = oldMeta.version + 1)\n     var markSectionPageStale = false\n@@ -2177,6 +2368,10 @@ trait PostsDao {\n       updatePagePopularity(pageAft.parts, tx)\n     }\n \n+    // (Can this be skipped if the updated post is private?  E.g. deleting a bookmark.\n+    // Yes, right now, I think so. But not later if  [remember_if_bookmarks_or_priv_comts]\n+    // gets implemented — then we need to update & remember in the mem cache.)\n+    SHOULD // Skip if is bookmark. ! [0_stats_for_priv_posts]\n     staleStuff.addPageId(pageBef.id, memCacheOnly = true)  // page version bumped above\n     tx.updatePageMeta(newMeta, oldMeta = oldMeta, markSectionPageStale)\n \n@@ -3209,6 +3404,7 @@ trait PostsDao {\n               PostQuery.PostsByAuthor(\n                 reqrInf = ReqrInf(Participant.SystemUserBr, BrowserIdData.System),\n                 authorId = userId,\n+                onlyPostType = None, // all types\n                 // Don't hide the person's anonymous posts? Because if doing that,\n                 // it'd be possible to guess that hen wrote them?  [list_anon_posts]\n                 // It's more important that people get to stay anon, if they expect to\n@@ -3418,7 +3614,7 @@ trait PostsDao {\n       require(postIds.isDefined != pagePostNrs.isDefined, \"TyE023MAEJP6\")\n \n       if (postIds.forall(_.isEmpty) && pagePostNrs.forall(_.isEmpty))\n-        return LoadPostsResult(Nil, Map.empty)\n+        return LoadPostsResult(Nil, Map.empty, Nil)\n \n       val postsInclForbidden: ImmSeq[Post] = readTx { tx =>\n         if (postIds.isDefined) {\n@@ -3430,7 +3626,9 @@ trait PostsDao {\n       }\n \n       filterMaySeeAddPages(\n-            requester, postsInclForbidden, inclUnlistedPagePosts = true)\n+            requester, postsInclForbidden, inclUnlistedPagePosts = true,\n+            // Maybe optionally include, if needed later.\n+            bookmarksInclForbidden = Nil)\n     }\n \n \n@@ -3439,6 +3637,7 @@ trait PostsDao {\n     unimplementedIf(query.orderBy != OrderBy.MostRecentFirst,\n           \"Only most recent first supported [TyE403RKTJ]\")\n \n+    var bookmarksInclForbidden: ImmSeq[Post] = Nil\n     val postsInclForbidden: ImmSeq[Post] = readTx { tx =>\n       if (query.onlyEmbComments) {\n         dieIf(query.inclTitles, \"TyE503RKDP5\", \"Emb cmts have no titles\")\n@@ -3461,6 +3660,23 @@ trait PostsDao {\n       }\n       else {\n         query match {\n+          case q: PostQuery.PatsBookmarks =>\n+            TESTS_MISSING\n+            // If asking for sbd else's bookmarks, then, currently they're\n+            // all filtered away here: [own_bookmarks]. Maybe later there'll be\n+            // shared / group bookmarks somehow.\n+\n+            // But what about `posts` whose bookmarks one may not see?\n+            // Such posts still returned? If one may see them, but then one could know if sbd\n+            // else has bookmarked them? Currently can't happen, listPostsByUser()\n+            // returns Forbidden if trying to list sbd elses bookmarks. [others_bookmarks]\n+            dieIf(q.bookmarkerId != q.reqr.id, \"TyEOTHERSBOKMS\")\n+\n+            val (bookms, posts) = tx.loadBookmarksAndBookmarkedPosts(byPatId = q.bookmarkerId,\n+                  limit = q.limit, offsetAt = When.Never, offsetId = 0)\n+            bookmarksInclForbidden = bookms\n+            posts\n+\n           case q: PostQuery.PostsRelatedToPat[_] =>  // [load_posts_by_rels]\n             // Tests incl:\n             //    - assign-to-basic.2br.d  TyTASSIGN01\n@@ -3474,25 +3690,37 @@ trait PostsDao {\n                   onlyOpenPosts = q.onlyOpen, limit = q.limit)\n             val postIds = rels.map(_.toNodeId)\n             tx.loadPostsByIdKeepOrder(postIds.distinct)\n+\n           case q: PostQuery.PostsWithTag =>\n             TESTS_MISSING // TyTLISTTAGDPOSTS\n             tx.loadPostsByTag(tagTypeId = q.tagTypeId, inclUnapproved = q.inclUnapproved,\n                   limit = query.limit, orderBy = q.orderBy)\n-          case _ =>\n+\n+          case _: PostQuery.AllPosts | _: PostQuery.PostsByAuthor =>\n             tx.loadPostsByQuery(query)\n+\n+          case x =>\n+            die(\"TyE5T3SKL5JS\", s\"Forgotten query type: ${classNameOf(x)}\")\n         }\n       }\n     }\n \n     filterMaySeeAddPages(\n           Some(query.reqr),\n           postsInclForbidden,\n-          inclUnlistedPagePosts = query.inclUnlistedPagePosts)\n+          inclUnlistedPagePosts = query.inclUnlistedPagePosts,\n+          bookmarksInclForbidden = bookmarksInclForbidden)\n   }\n \n \n-  private def filterMaySeeAddPages(requester: Opt[Pat], postsInclForbidden: ImmSeq[Post],\n-        inclUnlistedPagePosts: Bo): LoadPostsResult = {\n+  /** Returns only the `postsInclForbidden` the requester may see, plus,\n+    * the pages of those posts. And returns only the `bookmarksInclForbidden`\n+    * that are requester's own.\n+    *\n+    * @param inclUnlistedPagePosts If posts on unlisted pages should be returned or not.\n+    */\n+  def filterMaySeeAddPages(requester: Opt[Pat], postsInclForbidden: ImmSeq[Post],\n+        inclUnlistedPagePosts: Bo, bookmarksInclForbidden: ImmSeq[Post]): LoadPostsResult = {\n \n     val pageIdsInclForbidden = postsInclForbidden.map(_.pageId).toSet\n     val pageMetaById = getPageMetasAsMap(pageIdsInclForbidden)\n@@ -3509,7 +3737,16 @@ trait PostsDao {\n     val pageIds = postsOneMaySee.map(_.pageId).distinct\n     val pageStuffById = getPageStuffById(pageIds) ; COULD_OPTIMIZE // reuse pageMetaById\n \n-    LoadPostsResult(postsOneMaySee, pageStuffById)\n+    // But don't add pages for any of the bookmarks. If the requester may see those pages,\n+    // they have been added already, since the bookmarked posts got loaded together with\n+    // the bookmarks. — There might some bookmark the requester may see but can't\n+    // see the bookmarked post (any longer). That's ok, can be good to still have access\n+    // to the bookmark in case it has some important notes. [private_orphans]\n+\n+    LoadPostsResult(postsOneMaySee, pageStuffById,\n+          // For now, can only see one's own bookmarks. Maybe later there'll be\n+          // *shared* bookmarks, somehow. [own_bookmarks]\n+          bookmarks = bookmarksInclForbidden.filter(bm => requester.map(_.id) is bm.createdById))\n   }\n \n "
    },
    {
      "sha": "dec7b8d04e349a301d501406ea285d03fc72cd51",
      "filename": "appsv/server/debiki/dao/RenderContentService.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FRenderContentService.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FRenderContentService.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FRenderContentService.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -238,6 +238,7 @@ class RenderContentActor(\n     val tinyParams = PageRenderParams(\n       comtOrder = discProps.comtOrder,\n       //comtNesting = ... later\n+      comtOffset = None,\n       widthLayout = WidthLayout.Tiny,\n       isEmbedded = isEmbedded,\n       origin = dao.theSiteOrigin(),"
    },
    {
      "sha": "20d53fea53fbd255db4de13a12fb7ea936c8ef48",
      "filename": "appsv/server/debiki/dao/RenderedPageHtmlDao.scala",
      "status": "modified",
      "additions": 23,
      "deletions": 2,
      "changes": 25,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FRenderedPageHtmlDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FRenderedPageHtmlDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FRenderedPageHtmlDao.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -32,6 +32,7 @@ object RenderedPageHtmlDao {\n   private def renderedPageKey(sitePageId: SitePageId, pageRenderParams: PageRenderParams) = {\n     val pageId = sitePageId.pageId\n     val comtOrder = pageRenderParams.comtOrder.toInt\n+    val comtOffset = pageRenderParams.comtOffset\n     val comtNesting = -1 // = pageRenderParams.comtNesting.toInt  — later\n     val mobile = if (pageRenderParams.widthLayout == WidthLayout.Tiny) \"tny\" else \"med\"\n     val embedded = if (pageRenderParams.isEmbedded) \"emb\" else \"dir\"\n@@ -40,9 +41,26 @@ object RenderedPageHtmlDao {\n     // might move one's site to a custom domain, at runtime), so need to incl in the key.\n     val origin = pageRenderParams.origin\n     val cdnOrigin = pageRenderParams.cdnOriginOrEmpty // could skip, change requires restart —> cache gone\n+\n     // Skip page query and page root. Won't cache, if they're not default, anyway. [5V7ZTL2]\n-    MemCacheKey(sitePageId.siteId,\n-          s\"$pageId|$comtOrder|$comtNesting|$mobile|$embedded|$origin|$cdnOrigin|PgH\")\n+\n+    // But do consider comtOffset — people \"often\" scroll up and down in chats;\n+    // it's good to have cached chat-paginations. [to_paginate]\n+    // However, as a separate key, for now, so adding comtOffset  won't in effect\n+    // invalidate all cached pages (hence this match-case).\n+\n+    comtOffset match {\n+      case None =>\n+        // What was PgH short for? Maybe it's \"Page and host?\" ...\n+        MemCacheKey(sitePageId.siteId,\n+              s\"$pageId|$comtOrder|$comtNesting|$mobile|$embedded|$origin|$cdnOrigin|PgH\")\n+      case Some(offs) =>\n+        // ... Then \"PgOH\" can be Page-offset-host.\n+        die(\"TyEDEADMAYBE03\", \"Is this dead code?  loadManyPosts() doesn't use any cache\")\n+        // But don't cache unapproved posts or true ids! [careful_cache_range]\n+        MemCacheKey(sitePageId.siteId,\n+              s\"$pageId|$comtOrder|$offs|$comtNesting|$mobile|$embedded|$origin|$cdnOrigin|PgOH\")\n+    }\n   }\n }\n \n@@ -257,6 +275,7 @@ trait RenderedPageHtmlDao {\n   def removePageFromMemCache(sitePageId: SitePageId, pageRenderParams: Option[PageRenderParams] = None): Unit = {\n     pageRenderParams foreach { params =>\n       logger.trace(s\"Removing mem-cached page: ${sitePageId.toPrettyString}, $params [TyMMW20ZF4]...\")\n+      // Ooops! Won't remove at all offsets  [careful_cache_range]\n       memCache.remove(renderedPageKey(sitePageId, params))\n       return\n     }\n@@ -336,6 +355,8 @@ trait RenderedPageHtmlDao {\n     var renderParams = PageRenderParams(\n           comtOrder,\n           // comtNesting,  — later\n+          // This also won't remove all offsets  [careful_cache_range]\n+          comtOffset = None,\n           widthLayout = WidthLayout.Tiny,\n           isEmbedded = false,\n           origin = origin,"
    },
    {
      "sha": "0015b52515e987d043afa457682df735560cc4ab",
      "filename": "appsv/server/debiki/dao/SiteDao.scala",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FSiteDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FSiteDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FSiteDao.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -197,8 +197,12 @@ class SiteDao(\n   REFACTOR // rename to anyPageDao and return a Some(PageDao) with PageMeta pre-loaded\n   // if the page exist, otherwise None? — If callers \"always\" want a PageMeta.\n   COULD_OPTIMIZE // get loadWholeSiteSettings(tx) from cache too?\n-  def newPageDao(pageId: PageId, tx: SiteTransaction, useMemCache: Bo = false  ): PageDao =\n-    PageDao(pageId, loadWholeSiteSettings(tx), tx, if (useMemCache) Some(this) else None)\n+  def newPageDao(pageId: PageId, tx: SiteTransaction,\n+          whichPosts: WhichPostsOnPage = WhichPostsOnPage.OnlyPublic(activeOnly = false),\n+          useMemCache: Bo = false)\n+          : PageDao =\n+    PageDao(pageId, loadWholeSiteSettings(tx),\n+          tx, if (useMemCache) Some(this) else None, whichPosts)\n \n   REFACTOR // Change textAndHtmlMaker to maketextAndHtmlMaker(pageType: PageType)  Edit: Also incl page id  [ln_pv_az]\n   // which automatically knows the right embeddedOriginOrEmpty and followLinks etc,"
    },
    {
      "sha": "bba300a8c7f9a1076f68cad40bd7feb3914dd3f0",
      "filename": "appsv/server/debiki/dao/UserDao.scala",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FUserDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FUserDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FUserDao.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -2046,13 +2046,14 @@ trait UserDao {\n \n   /** Returns all users on the page. No need to filter may-see-profile or anything,\n     * because if you can see a page, you can also see all usernames participating\n-    * on that page. — Except for private comments, later.\n+    * on that page.  Except for private comment authors. Or, could include authors\n+    * of private comments the requester may see [incl_priv_authors], but let's wait.\n     */\n   def listUsernamesOnPage(pageId: PageId): ImmSeq[UserBr] = {\n     // See also: this.loadUserMayListByPrefix().\n-    // Later, [priv_comts], [dont_list_bookmarkers]: Exclude users who have posted\n-    // private comments or bookmarks only.\n-    readOnlyTransaction(tx => {\n+    // We exclude users who have posted private comments or bookmarks only, when\n+    // finding usernames, see: [dont_list_bookmarkers].\n+    readTx(tx => {\n         COULD_OPTIMIZE // could cache, + maybe use 'limit'?\n         tx.listUsernamesOnPage(pageId)\n     })"
    },
    {
      "sha": "67f9961f4f929176cbb59200af7583dd5bee057b",
      "filename": "appsv/server/debiki/dao/WatchbarDao.scala",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FWatchbarDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Fdebiki%2Fdao%2FWatchbarDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Fdebiki%2Fdao%2FWatchbarDao.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -107,6 +107,30 @@ trait WatchbarDao {\n   }\n \n \n+  def watchbarAddRecentMarkSeen(watchbarBef: BareWatchbar, page: PageMeta,\n+          authzCtx: AuthzCtxOnAllWithReqer): BareWatchbar = {\n+    val watchbarAft = watchbarBef.tryAddRecentTopicMarkSeen(page) getOrElse {\n+      // Watchbar wasn't modified.\n+      return watchbarBef\n+    }\n+\n+    // Double check we may see the page(s) we're adding to the watchbar. [WATCHSEC]\n+    SEC_TESTS_MISSING // TyT602KRGJG\n+    val pageCtx = this.maySeePageUseCacheAndAuthzCtx(page, authzCtx).ifNot { debugCode =>\n+        this.context.security.throwIndistinguishableNotFound(debugCode)\n+      }\n+\n+    this.saveWatchbar(authzCtx.theReqer.id, watchbarAft)\n+\n+    RACE // if somehow happens in two threads at the same time.\n+    // [user_watches_pages_pubsub]\n+    this.pubSub.userWatchesPages(\n+          this.siteId, authzCtx.theReqer.id, watchbarAft.watchedPageIds)\n+\n+    watchbarAft\n+  }\n+\n+\n   /* BUG race conditions, if e.g. saveWatchbar & markPageAsUnreadInWatchbar called at the\n   * same time. Could perhaps solve by creating a Watchbar actor that serializes access?\n   */"
    },
    {
      "sha": "3d36354d58cbfea36a1f0bbec5f4c1cde5500f56",
      "filename": "appsv/server/talkyard/server/JsX.scala",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2FJsX.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2FJsX.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2FJsX.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -767,14 +767,18 @@ object JsX {   RENAME // to JsonPaSe\n   }\n \n \n+  // Is duplicated here and there, oh well. At least currently there's no other\n+  // json field named \"nr\" that can have negative values (like private posts do).\n+  val PostNrIdFieldName = \"nr\"\n+\n   RENAME // add suffix:  JsPostVb_butNoPatRels  ?\n   def JsPostInclDetails(post: Post): JsObject = {\n     COULD_OPTIMIZE // Skip null / false fields, so less json.\n     // E.g. excl currRevSourcePatch, instead of 'currRevSourcePatch: null'.\n     Json.obj(\n       \"id\" -> post.id,\n       \"pageId\" -> post.pageId,\n-      \"nr\" -> post.nr,\n+      PostNrIdFieldName -> post.nr,\n       \"parentNr\" -> JsNumberOrNull(post.parentNr),\n       \"multireplyPostNrs\" -> JsArray(), // post.multireplyPostNrs\n       \"postType\" -> post.tyype.toInt,\n@@ -936,6 +940,7 @@ object JsX {   RENAME // to JsonPaSe\n     val jOb = asJsObject(jsVal, \"tag type\")\n     val id = parseInt32(jOb, \"id\")\n     val refId = parseOptSt(jOb, \"refId\")\n+    val scopedToPatId = None // later: Opt[PatId] = parseOptInt32(jOb, \"scopedToPatId\")\n     val canTagWhat = parseInt32(jOb, \"canTagWhat\")\n     val dispName = parseSt(jOb, \"dispName\")\n     val anySlug = parseOptSt(jOb, \"urlSlug\").noneIfBlank\n@@ -957,6 +962,7 @@ object JsX {   RENAME // to JsonPaSe\n     TagType(\n           id = id,\n           refId = refId,\n+          scopedToPatId = scopedToPatId,\n           canTagWhat = canTagWhat,\n           urlSlug = anySlug,\n           dispName = dispName,"
    },
    {
      "sha": "03a1745ffa67cc5341d3dd81d03e15a12910f3ed",
      "filename": "appsv/server/talkyard/server/api/PostsListFoundJson.scala",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FPostsListFoundJson.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FPostsListFoundJson.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FPostsListFoundJson.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -54,8 +54,11 @@ object PostsListFoundJson {\n \n     dieIf(anyPostsFound.nonEmpty && anySearchResults.nonEmpty, \"TyE60WKTH5\")\n \n-    val LoadPostsResult(postsFound: Seq[Post], pageStuffById: Map[PageId, PageStuff]) =\n-          anyPostsFound getOrDie \"TyE405RKDD\"\n+    val LoadPostsResult(\n+          postsFound: Seq[Post],\n+          pageStuffById: Map[PageId, PageStuff],\n+          _) =\n+            anyPostsFound getOrDie \"TyE405RKDD\"\n \n     // --- Load authors\n "
    },
    {
      "sha": "a14d941bf9920f2548c6cee2fc35c492be67bc38",
      "filename": "appsv/server/talkyard/server/api/ThingsFoundJson.scala",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FThingsFoundJson.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FThingsFoundJson.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fapi%2FThingsFoundJson.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -106,13 +106,14 @@ object ThingsFoundJson {  RENAME // to  PagesFoundJson ?\n               Vec.empty\n             }\n             else {\n-              val pageParts = PagePartsDao(pageId = stuff.pageId, settings, tx, Some(dao))\n+              val pageParts = PagePartsDao(pageId = stuff.pageId, settings, tx, Some(dao),\n+                      WhichPostsOnPage.OnlyPublic(activeOnly = true))\n               COULD_OPTIMIZE // Load all at once, look at:  loadPopularPostsByPageExclAggs\n               // — however, we want tags & assignees too?\n               // Or, if combined with say top N posts per page & their ancestors, would need\n               // some fancy recursive SQL query?\n               // Later, when there are [priv_comts], excl those.\n-              pageParts.activePosts\n+              pageParts.allPosts // note: activeOnly above\n             }\n           }\n         }"
    },
    {
      "sha": "0cc5f955ef7e1e088d8c57c446c93e1f779b5868",
      "filename": "appsv/server/talkyard/server/authz/Authz.scala",
      "status": "modified",
      "additions": 20,
      "deletions": 2,
      "changes": 22,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthz.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthz.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fauthz%2FAuthz.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -469,8 +469,8 @@ object Authz {\n     // Staff may see all posts, if they may see the page. [5I8QS2A]\n     ANON_UNIMPL // if post.createdById  is pat's own alias, han is the author and can see it.\n     // Don't fix now — wait until true author id is incl in posts3/nodes_t? [posts3_true_id]\n-    def isStaffOrAuthor =\n-          pat.exists(_.isStaff) || pat.exists(_.id == post.createdById)\n+    val isAuthor = pat.exists(_.id == post.createdById)\n+    val isStaffOrAuthor = pat.exists(_.isStaff) || isAuthor\n \n     // Later, [priv_comts]: Exclude private sub threads, also if is staff.\n \n@@ -480,6 +480,13 @@ object Authz {\n     if (!post.isSomeVersionApproved && !isStaffOrAuthor)\n       return (MaySeeOrWhyNot.NopePostNotApproved, \"6PKJ2RW-Post-0Apr\")\n \n+    if (post.nr < PageParts.MinPublicNr && !isAuthor)\n+      return (MaySeeOrWhyNot.NopePrivate, \"6PKJ2RX-Post-Priv\")\n+\n+    // This is fine, since it's pat's own post, although a bit unexpected.\n+    // Maybe would be nice to see what code path makes this happen?\n+    devDieIf(post.nr < PageParts.MinPublicNr, \"TyESEEOTRPRIV\", \"Want to debug a bit?\")\n+\n     // Later: else if is meta discussion ... [METADISC]\n \n     (MaySeeOrWhyNot.YesMaySee, \"\")\n@@ -519,11 +526,21 @@ object Authz {\n       if (!mayWhat.mayEditPage) // before: user.id != pageMeta.authorId && !user.isStaff)\n         return NoMayNot(\"EsEMAY0REMINDM\", \"Not allowed to add more items to this mind map\")\n     }\n+    else if (postType.isPrivate) {\n+      // That means the new \"reply\" is a private comment [priv_comts]  or a bookmark.\n+      // Those are ok to add — other's won't see them (except for the people one adds to\n+      // the private thread).\n+      // Later: But private comments won't have any special type?  They'll just have a\n+      // nr <= PageParts.MaxPrivateNr?  Maybe a `willBePrivate` param instead?\n+    }\n     else {\n       if (!mayWhat.mayPostComment)\n         return NoMayNot(\"EdEM0RE0RE\", \"You don't have permissions to post a reply on this page\")\n     }\n \n+    // (This prevents us from bookmarking pages that can't have replies — that's ok,\n+    // they're e.g. forum index pages, blog index pages, or special pages e.g. CSS, or\n+    // legacy pages e.g. html. Not important to bookmark, and isn't any UI for that anyway.)\n     if (!pageMeta.pageType.canHaveReplies)\n       return NoMayNot(\"EsEM0REPAGETY\", s\"Cannot post to page type ${pageMeta.pageType}\")\n \n@@ -1250,6 +1267,7 @@ object MaySeeOrWhyNot {\n   case object NopeNoPostWithThatNr extends MaySeeOrWhyNot(3)  // RENAME NopeNoSuchPost\n   case object NopePostNotApproved extends MaySeeOrWhyNot(6)\n   case object NopePostDeleted extends MaySeeOrWhyNot(4)\n+  case object NopePrivate extends MaySeeOrWhyNot(7)\n \n }\n "
    },
    {
      "sha": "7ee4acfe2188cbb4312ed005049ef38462190438",
      "filename": "appsv/server/talkyard/server/dao/StaleStuff.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fdao%2FStaleStuff.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fdao%2FStaleStuff.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fdao%2FStaleStuff.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -114,7 +114,7 @@ class StaleStuff {\n \n   def addPagesWithVisiblePostsBy(patIds: Set[PatId], tx: SiteTx): U = {\n     val _200k = 200 * 1000\n-    val pageIds: Set[PageId] = tx.loadPageIdsWithVisiblePostsBy(patIds, limit = _200k)\n+    val pageIds: Set[PageId] = tx.loadPageIdsWithPublicActivePostsBy(patIds, limit = _200k)\n     if (pageIds.size < _200k) {\n       addPageIds(pageIds, pageModified = false, bylinesStale = true)\n     }"
    },
    {
      "sha": "cdb9bfdc71b3c178951108b0c21059ce993d59b3",
      "filename": "appsv/server/talkyard/server/http/DebikiRequest.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FDebikiRequest.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FDebikiRequest.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FDebikiRequest.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -105,6 +105,7 @@ abstract class AuthnReqHeader extends SomethingToRateLimit {\n   def theRequester: Participant = theUser\n   def theReqer: Pat = theUser  // shorter, better\n   def reqr: Pat = theUser  // better\n+  def anyReqr: Opt[Pat] = user\n \n   def anyAliasPat: Opt[WhichAliasPat] =\n     die(\"TyEUSINGALIAS\", \"Cannot use an anonym or pseudonym when doing this\")"
    },
    {
      "sha": "a345e3bb29a94e1fef1e5fa7ac3cf60236578097",
      "filename": "appsv/server/talkyard/server/http/PageRequest.scala",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FPageRequest.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FPageRequest.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fhttp%2FPageRequest.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -121,6 +121,16 @@ class PageRequest[A](\n   } */\n \n \n+  /** For rendering a chat somewhere in the middle of the chat — e.g. if following a\n+    * search result link, then we'd want to render a few messages before and after\n+    * the search result chat message. Or if following a bookmark link to a chat message.\n+    */\n+  private def anyOffset: Opt[i32] =\n+    request.queryString.getFirst(\"offset\") map { intStr: St =>\n+      intStr.toIntOption getOrThrowBadArg(\"TyEOFS0INT\", \"offest\", s\"not an int: $intStr\")\n+    }\n+\n+\n   def renderParams: PageRenderParams = {\n     val discProps = DiscProps.derive(\n           selfSource = pageMeta,\n@@ -132,6 +142,7 @@ class PageRequest[A](\n     PageRenderParams(\n           discProps.comtOrder,\n           //discProps.comtNesting — later\n+          comtOffset = anyOffset,\n           widthLayout = if (isMobile) WidthLayout.Tiny else WidthLayout.Medium,\n           isEmbedded = embeddingUrl.nonEmpty,\n           origin = origin,"
    },
    {
      "sha": "97abd46ab6eb4fd7a069099eb395cfa036001c50",
      "filename": "appsv/server/talkyard/server/notf/NotificationGenerator.scala",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fnotf%2FNotificationGenerator.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fnotf%2FNotificationGenerator.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fnotf%2FNotificationGenerator.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -135,6 +135,7 @@ case class NotificationGenerator(\n     require(postAuthor.forall(_.id == newPost.createdById),\n           o\"\"\"s$siteId: Wrong postAuthor id: ${postAuthor.map(_.id)}, but\n           newPost.createdById is ${newPost.createdById}) [TyEAUTID69256]\"\"\")\n+    _abortIfBadPost(newPost)\n \n     if (newPost.isTitle)\n       return generatedNotifications  // [no_title_notfs]\n@@ -327,6 +328,8 @@ case class NotificationGenerator(\n   private def _genWatchingSomethingNotfs(notfType: NotfType, pageMeta: PageMeta,\n           about: Post, pageMemberIds: Set[UserId], sentFrom: Pat): U = {\n \n+    _abortIfBadPost(about)\n+\n     val newPost = about\n \n     val isEmbDiscFirstReply =\n@@ -771,6 +774,8 @@ case class NotificationGenerator(\n         memberIdsHandled: MutSet[PatId], wantSilencePatIds: MutSet[PatId],\n         sentFrom: Pat): U = {\n \n+    _abortIfBadPost(aboutPost)\n+\n     val membersById = tx.loadParticipantsAsMap(notfPrefs.map(_.peopleId))\n     val memberIdsHandlingNow = mutable.HashSet[MemberId]()\n     val wantSilenceHereafterPatIds = mutable.HashSet[MemberId]()\n@@ -910,6 +915,8 @@ case class NotificationGenerator(\n         anyNewSourceAndHtml: Opt[SourceAndHtml])\n         : Notifications = {\n \n+    _abortIfBadPost(oldPost)\n+\n     anyAuthor = Some(editor)\n     BUG // Harmless: Don't notify the approver. [dont_notify]\n \n@@ -1045,6 +1052,8 @@ case class NotificationGenerator(\n \n   def generateForLikeVote(post: Post, upvotedPostAuthor: Participant,\n           voter: Participant, inCategoryId: Option[CategoryId]): Notifications = {\n+    _abortIfBadPost(post)\n+\n     if (upvotedPostAuthor.isGone || upvotedPostAuthor.isBuiltIn)\n       return generatedNotifications\n \n@@ -1063,6 +1072,7 @@ case class NotificationGenerator(\n \n \n   def generateForTags(post: Post, postAuthor: Pat, tagsAdded: Set[TagLabel]): Notifications = {\n+    _abortIfBadPost(post)\n     val userIdsWatching = tx.listUsersWatchingTags(tagsAdded)\n     val userIdsNotified = tx.listUsersNotifiedAboutPost(post.id)\n     val userIdsToNotify = userIdsWatching -- userIdsNotified\n@@ -1092,6 +1102,7 @@ case class NotificationGenerator(\n   def generateForAssignees(\n           assigneesAdded: Iterable[Pat], assigneesRemoved: Iterable[Pat], postBef: Post,\n           changedBy: Pat): Notifications = {\n+    _abortIfBadPost(postBef)\n \n     val pageMeta = tx.loadThePageMeta(postBef.pageId)\n     val postAuthor = tx.loadTheParticipant(postBef.createdById) // [post_authors]\n@@ -1143,6 +1154,9 @@ case class NotificationGenerator(\n         isPrivMsgFromStaff: Bo = false, // fix later\n         ): U = {\n \n+    // If forgotten elsewhere.\n+    _abortIfBadPost(about)\n+\n     val aboutPost = about\n     val toPat = to\n     val fromPat = from\n@@ -1220,6 +1234,16 @@ case class NotificationGenerator(\n     nextNotfId getOrDie \"EsE5GUY2\"\n   }\n \n+\n+  private def _abortIfBadPost(post: Post): U = {\n+    require(post.tyype != PostType.Bookmark,  // [0_bokm_notfs]\n+          \"Can't generate notifications about bookmarks [TyEBOKMNOTF]\")\n+    require(post.tyype != PostType.MetaMessage,\n+          \"Shouldn't generate notifications for meta posts?  [TyEMETAPONOTF]\")\n+    unimplIf(post.tyype == PostType.Flag_later, \"Notifications about PostType.Flag_later\")\n+    unimplIf(post.isPrivate, \"Notifications about private comments\") // [priv_comts]\n+  }\n+\n }\n \n "
    },
    {
      "sha": "91fcd93475189224a479415db80b91f8020bc7bd",
      "filename": "appsv/server/talkyard/server/pubsub/PubSub.scala",
      "status": "modified",
      "additions": 29,
      "deletions": 4,
      "changes": 33,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fpubsub%2FPubSub.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fpubsub%2FPubSub.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fpubsub%2FPubSub.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -24,7 +24,7 @@ import com.debiki.core.Prelude._\n import com.debiki.core._\n import debiki.dao.{RedisCache, RedisCacheAllSites, SiteDao}\n import debiki.{Globals, JsonMaker}\n-import play.api.libs.json.{JsArray, JsNull, JsValue, Json}\n+import play.api.libs.json.{JsArray, JsNull, JsValue, JsNumber, Json}\n import redis.RedisClient\n import scala.collection.mutable\n import scala.collection.immutable\n@@ -604,21 +604,44 @@ class PubSubActor(val globals: Globals) extends Actor {\n     message match {\n       case patchMessage: StorePatchMessage =>\n \n+        // ----- Check for bugs\n+\n         // Make sure we [dont_leak_true_ids]. This message gets sent to different people,\n         // then, no aliases' true ids should be included.\n         val json: JsValue = patchMessage.json\n         val trueIds = (json \\\\ JsX.AnonForIdFieldName)\n         if (trueIds.nonEmpty) {\n-          logger.error(s\"\"\"True ids in WebSocket StorePatchMessage message, I won't send.\n-                The message: ${json.toString}  [TyEIDLEAKWS]\"\"\")\n+          logger.error(o\"\"\"True ids in WebSocket StorePatchMessage message, I won't send.\n+                 [TyEWSLEAK_TRUEID]  The message: ${json.toString}\"\"\")\n           return\n         }\n \n+        // Make sure we [dont_leak_private_posts]. They have negative nrs, so, shouldn't\n+        // be any such nrs in the patch.  (There's currently no other \"nr\" fields\n+        // in any Ty json, especially not that can be < PageParts.MinPublicNr.)\n+        val postNrs: collection.Seq[JsValue] = (json \\\\ JsX.PostNrIdFieldName)\n+        postNrs foreach {\n+          case jsNr: JsNumber =>\n+            assert(PageParts.MaxPrivateNr < PageParts.MinPublicNr)\n+            if (jsNr.value < PageParts.MinPublicNr) {\n+              logger.error(o\"\"\"Private post nr: ${jsNr.value} in WebSocket\n+                     StorePatchMessage message, I won't send.  [TyEWSLEAK_PRIVNR]\n+                     The message: ${json.toString}\"\"\")\n+              return\n+            }\n+            // Else: Fine.\n+          case x =>\n+            logger.error(o\"\"\"Number '$x' is not a number, it's a: ${classNameOf(x)} [TyEWS_NRNAN]\n+                  The message: ${json.toString}\"\"\")\n+            return\n+        }\n+\n+        // ----- Access control\n+\n         val pageId = patchMessage.toUsersViewingPageId\n         val userIdsWatching = usersWatchingPage(\n               patchMessage.siteId, pageId = pageId).filter(_ != byId)\n \n-        // Access control.\n         val usersMayMaybeSee = userIdsWatching.flatMap(siteDao.getUser)\n         // (Shouldn't be any non-existing users — deleting database row not implemented.)\n         val (usersWhoMaySeePage, usersMayNot) = usersMayMaybeSee partition { user =>\n@@ -641,6 +664,8 @@ class PubSubActor(val globals: Globals) extends Actor {\n           updateWatchedPages(message.siteId, user.id, stoppedWatchingPageId = Some(pageId))\n         }\n \n+        // ----- Mark unread & send\n+\n         usersWhoMaySeePage foreach { user =>\n           siteDao.markPageAsUnreadInWatchbar(user.id, pageId = pageId)\n         }"
    },
    {
      "sha": "3b669b646cb8190b5e463453dca563c9a914712a",
      "filename": "appsv/server/talkyard/server/search/SearchQueryParser.scala",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsearch%2FSearchQueryParser.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsearch%2FSearchQueryParser.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsearch%2FSearchQueryParser.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -262,6 +262,10 @@ object SearchQueryParser {\n       case \"discussion\" => isWhat = isWhat.copy(pageType = Some(PageType.Discussion))\n       case \"comments\" => isWhat = isWhat.copy(pageType = Some(PageType.EmbeddedComments))\n \n+      // For searching flags (if one is a moderator), or one's own bookmarks\n+      //case \"flag\" => isWhat = isWhat.copy(postType = Some(PostType.Flag))\n+      //case \"bookmark\" => isWhat = isWhat.copy(postType = Some(PostType.Bookmark))  [is_bokm]\n+\n       // Is \"undecided\" really the right word? Oh well, for now.\n       case \"undecided\" => isWhat = isWhat.copy(pageDoingStatus = Some(PageDoingStatus.Discussing))\n       case \"planned\" => isWhat = isWhat.copy(pageDoingStatus = Some(PageDoingStatus.Planned))"
    },
    {
      "sha": "dd43d24aa197389455c1eca446ceb8f98e9e6a8a",
      "filename": "appsv/server/talkyard/server/security/package.scala",
      "status": "modified",
      "additions": 12,
      "deletions": 4,
      "changes": 16,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsecurity%2Fpackage.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsecurity%2Fpackage.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsecurity%2Fpackage.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1413,13 +1413,21 @@ class EdSecurity(globals: Globals) {\n \n   /** Use this if page not found, or the page is private and we don't want strangers\n     * to find out that it exists. [7C2KF24]\n+    *\n+    * If the person may see the page, then, use isAboutPostNr to get a better\n+    * (but still indistinguishable) error message. (E.g. if sbd tries to reply\n+    * to a private comment han may not see, on a page han *can* see.)\n     */\n   def throwIndistinguishableNotFound(devModeErrCode: St = \"\",\n-         devModeMsg: St = \"\", showErrCodeAnyway: Bo = false): Nothing = {\n+          devModeMsg: St = \"\", showErrCodeAnyway: Bo = false, isAboutPostNr: Opt[PostNr] = None,\n+          ): Nothing = {\n     val suffix =\n-      if (showErrCodeAnyway || !globals.isProd && devModeErrCode.nonEmpty) s\"-$devModeErrCode\"\n-      else \"\"\n-    val msg = if (!globals.isProd && devModeMsg.nonEmpty) devModeMsg else \"Not found\"\n+          if (showErrCodeAnyway || !globals.isProd && devModeErrCode.nonEmpty) s\"-$devModeErrCode\"\n+          else \"\"\n+    val prodMsg = isAboutPostNr.map(nr => s\"Post nr $nr not found\") getOrElse \"Not found\"\n+    val msg =\n+          if (globals.isProd || devModeMsg.isEmpty) prodMsg\n+          else devModeMsg + s\"\\n\\nProd msg: $prodMsg\"\n     throwNotFound(\"TyE404_\" + suffix, msg)\n   }\n "
    },
    {
      "sha": "77f3eacaf09d809ed36d2388a34ab1d06a1befee",
      "filename": "appsv/server/talkyard/server/sitepatch/SitePatcher.scala",
      "status": "modified",
      "additions": 51,
      "deletions": 13,
      "changes": 64,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatcher.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatcher.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatcher.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -410,15 +410,19 @@ case class SitePatcher(globals: debiki.Globals) {\n \n       siteData.posts.groupBy(_.pageId).foreach { case (tempPageId, postsInPatch) =>\n         val realPageId = remappedPageTempId(tempPageId)\n-        val postsInDbOnPage = tx.loadPostsOnPage(realPageId)  ; COULD_OPTIMIZE // don't need them all\n+        val postsInDbOnPage = tx.loadPostsOnPage(realPageId, WhichPostsOnPage.AllByAnyone())  ; COULD_OPTIMIZE // don't need them all\n         postsInDbOnPage foreach { postInDb =>\n           postsInDbByRealPagePostNr.put(postInDb.pagePostNr, postInDb)\n         }\n-        val firstNextReplyNr =\n-          if (postsInDbOnPage.isEmpty) FirstReplyNr\n-          else postsInDbOnPage.map(_.nr).max + 1\n-        var nextReplyNr = firstNextReplyNr\n-        dieIf(nextReplyNr < FirstReplyNr, \"TyE05HKGJ5\")\n+        val firstNextPubReplyNr =\n+              if (postsInDbOnPage.isEmpty) FirstReplyNr\n+              else {\n+                // If there's only private comments and bookmarks, make sure we start with\n+                // a valid public reply nr, that is, FirstReplyNr.\n+                Math.max(postsInDbOnPage.map(_.nr).max + 1, FirstReplyNr)\n+              }\n+        var nextPubReplyNr = firstNextPubReplyNr\n+        dieIf(nextPubReplyNr < FirstReplyNr, \"TyE05HKGJ5\")\n \n         val postTempIdsToInsert = mutable.HashSet[PostId]()\n \n@@ -479,12 +483,41 @@ case class SitePatcher(globals: debiki.Globals) {\n             case None =>\n               // Probably we need to remap the post nr to 2, 3, 4, 5 ... instead of a temp nr.\n               // Unless has a real nr already, e.g. the title or body post nr.\n+              // Or unless it's a private nr — they're big negative nrs.\n+              assert(PageParts.MaxPrivateNr < PageParts.MinPublicNr)\n+              assert(PageParts.MinPublicNr < LowestTempImpId)\n               val realNr =\n-                if (postInPatch.nr < LowestTempImpId) postInPatch.nr\n-                else {\n-                  nextReplyNr += 1\n-                  nextReplyNr - 1\n-                }\n+                    if (postInPatch.isPrivate) {\n+                      UNTESTED  // TyTIMPBOOKMRK\n+                      // Later: Private comments — do we know, because of the number and also\n+                      // because of  Post.privatePatsId?  [priv_comts]\n+                      // For now, just bookmarks. Try to reuse nr, why not? [gen_priv_post_nr]\n+                      var nr =\n+                            if (postInPatch.nr <= PageParts.MaxPrivateNr) postInPatch.nr\n+                            else nextRandomPrivPostNr()\n+                      // There might be private posts with the same nr, since they're picked\n+                      // randomly.\n+                      var attemptNr = 1\n+                      while (postsInDbByRealPagePostNr.get(PagePostNr(realPageId, nr))\n+                              .isDefined) {\n+                        // This can happen if there's a large number of bookmarks or\n+                        // private comments, f.ex. a DoS attack.\n+                        dieIf(attemptNr > 10, \"TyEBADLUCK2\", o\"\"\"Unable to find a random nr for\n+                              [post nr ${postInPatch.nr} in the patch] — there was another\n+                              posts in the db with the same number, all 10 times I tried,\n+                              e.g. nr $nr just now.\"\"\")\n+                        attemptNr += 1\n+                        nr = nextRandomPrivPostNr()\n+                      }\n+                      nr\n+                    }\n+                    else if (postInPatch.nr < LowestTempImpId) {\n+                      postInPatch.nr\n+                    }\n+                    else {\n+                      nextPubReplyNr += 1\n+                      nextPubReplyNr - 1\n+                    }\n \n               postsInDbByRealPagePostNr.get(PagePostNr(realPageId, realNr)) match {\n                 case Some(postInDbSameNr: Post) =>\n@@ -597,7 +630,10 @@ case class SitePatcher(globals: debiki.Globals) {\n \n             tx.insertPost(postReal)\n             wroteToDatabase = true\n-            pageIdsWithBadStats.add(postReal.pageId)\n+\n+            if (!postReal.isPrivate) {  // [0_stats_for_priv_posts]\n+              pageIdsWithBadStats.add(postReal.pageId)\n+            }\n \n             COULD // update user stats, but so many things to think about,  [BADSTATS]\n             // so skip for now:\n@@ -630,7 +666,9 @@ case class SitePatcher(globals: debiki.Globals) {\n             // Wait with sending notfs until pages and categories have been upserted, otherwise\n             // I'd think something won't be found when running notf creation related queries.\n             // (We exclude titles further below.)\n-            postsToMaybeNotfAbout.append(postReal)\n+            if (postReal.tyype != PostType.Bookmark) {  // [0_bokm_notfs]\n+              postsToMaybeNotfAbout.append(postReal)\n+            }\n \n             if (postReal.isReply) {\n               upsertedReplies.append(postReal)"
    },
    {
      "sha": "8bdcd2794c78cfcde48e90180e469b2fc2457b2d",
      "filename": "appsv/server/talkyard/server/talk/PostsController.scala",
      "status": "modified",
      "additions": 82,
      "deletions": 28,
      "changes": 110,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Ftalk%2FPostsController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/appsv%2Fserver%2Ftalkyard%2Fserver%2Ftalk%2FPostsController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/appsv%2Fserver%2Ftalkyard%2Fserver%2Ftalk%2FPostsController.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -20,7 +20,7 @@ package talkyard.server.talk\n import com.debiki.core._\n import com.debiki.core.Prelude._\n import debiki._\n-import debiki.dao.{LoadPostsResult, SiteDao}\n+import debiki.dao.{LoadPostsResult, SiteDao, PageStuff}\n import debiki.EdHttp._\n import talkyard.server.http._\n import play.api.mvc\n@@ -71,7 +71,8 @@ class PostsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  def listPostsByUser(authorId: UserId, relType: Opt[Int], which: Opt[Int]): Action[U] =\n+  def listPostsByUser(authorId: UserId, postType: Opt[i32], relType: Opt[Int],\n+          which: Opt[Int]): Action[U] =\n           GetActionRateLimited() { req: GetRequest =>\n     import req.{dao, requesterOrUnknown}\n \n@@ -84,11 +85,41 @@ class PostsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     // (_Double_check 1/2, if calling _listPostsImpl(), oh well.)\n     _throwIfMayNotSeeActivity(requesterOrUnknown, targetUser, dao)\n \n+    val postType2 = postType.map(t => PostType.fromInt(t).getOrThrowBadRequest(\n+          \"TyEPOSTTY037\", s\"Bad post type: $t\"))\n+    val onlyOpen = which is 678321  // for now\n+\n     relType match {\n       case None =>\n-        // Later, will use PostQuery here too, just like below (and this match-case\n-        // branch maybe then no longer needed).\n-        _listPostsImpl(authorId, all = false, req)\n+        if (postType2 is PostType.Bookmark) {\n+          TESTS_MISSING  // TyTBOOKMLS\n+          // For now, can't list other's bookmarks. Maybe will be shared bookmarks some day.\n+          // Others' bookmarks are filtered away here: [own_bookmarks]  but mabye there's\n+          // a way to find out if other bookarks exist, see:  [others_bookmarks]\n+          // So, for now, to prevent that, abort directly.\n+          throwForbiddenIf(req.reqrInf.id != authorId,\n+                \"TyE0YOURBOOKMS\", \"Can't list other people's bookmarks\")\n+\n+          val query = PostQuery.PatsBookmarks(\n+                reqrInf = req.reqrInf,\n+                bookmarkerId = authorId,\n+                limit = 100, // UX, [to_paginate]\n+                orderBy = OrderBy.MostRecentFirst)\n+          OkSafeJson(\n+                _listPostsImpl2(query, req.dao))\n+        }\n+        else if (postType2.isDefined) {\n+          // This is probably totally fine, just that it's currently dead code,\n+          // never invoked by the current Ty browser client.\n+          // Later: Simply remove this `else-if`, keep the `else` below.\n+          TESTS_MISSING\n+          throwUntested(\"TyETYPE0BOKM\", \"postType != bookmarks\")\n+        }\n+        else {\n+          // Later, will use PostQuery here too, just like below (and this match-case\n+          // branch maybe then no longer needed).\n+          _listPostsImpl(authorId, onlyPostType = postType2, all = false, req)\n+        }\n       case Some(relTypeInt) =>\n \n         // Tests:\n@@ -102,7 +133,6 @@ class PostsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n         val reqrIsStaff = req.requester.exists(_.isStaff)\n         val reqrIsStaffOrSelf = reqrIsStaff || req.requester.exists(_.id == relToPatId)\n \n-        val onlyOpen = which is 678321  // for now\n         val query = PostQuery.PostsRelatedToPat(\n               reqrInf = req.reqrInf,\n               relatedPatId = relToPatId,\n@@ -172,10 +202,13 @@ class PostsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n   }\n \n \n-  private def _listPostsImpl(authorId: UserId, all: Boolean, request: GetRequest): mvc.Result = {\n+  private def _listPostsImpl(authorId: UserId, onlyPostType: Opt[PostType], all: Bo,\n+          request: GetRequest): mvc.Result = {\n     import request.dao\n     import request.{dao, requester, requesterOrUnknown}\n \n+    untestedIf(onlyPostType.isDefined, \"TyEONLYTYPE\", \"onlyPostType\")\n+\n     // Return Not Found directly, using the cache, if no such user.  Bit dupl [_6827]\n     val targetUser: Pat =\n           dao.getParticipant(authorId) getOrElse {\n@@ -195,6 +228,7 @@ class PostsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n     val res = _listPostsImpl2(\n           PostQuery.PostsByAuthor(\n                 reqrInf = request.reqrInf,\n+                onlyPostType = onlyPostType,\n                 orderBy = OrderBy.MostRecentFirst,\n                 limit = limit,\n                 // Later, include, if reqr is the author henself. [list_anon_posts]\n@@ -211,12 +245,17 @@ class PostsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n \n \n   private def _listPostsImpl2(query: PostQuery, dao: SiteDao): JsObject = {\n-    val LoadPostsResult(postsOneMaySee, pageStuffById) =\n-          // This excludes any stuff the requester may not see. [downl_own_may_see]\n-          dao.loadPostsMaySeeByQuery(query)\n+    val LoadPostsResult(\n+          postsOneMaySee,\n+          pageStuffById,\n+          bookmarksMaySee) =\n+              // This excludes any stuff the requester may not see. [downl_own_may_see]\n+              dao.loadPostsMaySeeByQuery(query)\n \n     val posts = postsOneMaySee\n \n+    // Bit dupl code. [posts_2_json]\n+\n     val patIds = mut.Set[PatId]()\n     posts.foreach(_.addVisiblePatIdsTo(patIds))\n \n@@ -238,45 +277,60 @@ class PostsController @Inject()(cc: ControllerComponents, edContext: TyContext)\n             )  // skip!  toShowForPatId = Some(query.reqr.id))  // Maybe use Opt[Pat] instead, hmm\n     })\n \n-    val postsJson = posts flatMap { post =>\n+    val bookmarksJson: ImmSeq[JsObject] = bookmarksMaySee map { post =>\n+      dao.jsonMaker.postToJsonOutsidePage(post, PageType.Discussion /* doesn't matter */,\n+            showHidden = true,\n+            // Bookmars don't get approved by anyone.\n+            includeUnapproved = true,\n+            // Some day, it'll be possible to tag one's bookmarks? [tagd_bokms]\n+            // But these tags are for the *bookmarked* posts only. Need to incl bookmark posts\n+            // (not only bookmarked posts) when calling loadPostTagsAndAuthorBadges() above.\n+            tagsAndBadges,\n+            // Bookmarks are usually on different pages, need to know which, so can jump\n+            // to the correct page (in the browser) when clicking a bookmark.\n+            inclPageId = true)\n+    }\n+\n+    val postsJson: ImmSeq[JsObject] = posts map { post =>\n       val pageStuff = pageStuffById.get(post.pageId) getOrDie \"EdE2KW07E\"\n       val pageMeta = pageStuff.pageMeta\n       var postJson = dao.jsonMaker.postToJsonOutsidePage(post, pageMeta.pageType,\n             showHidden = true,\n             // Really need to specify this again?\n             includeUnapproved = query.reqrIsStaffOrObject,\n-            tagsAndBadges)\n-\n-      pageStuffById.get(post.pageId) map { pageStuff =>\n-        // Since these posts aren't wrapped in a page, but rather listed separately\n-        // outside their parent pages, it's nice to have the page title available\n-        // to show in the browser.  [posts_0_page_json]\n-        // Typescript: PostWithPage\n-        postJson += \"pageId\" -> JsString(post.pageId)\n-        postJson += \"pageTitle\" -> JsString(pageStuff.title)\n-        postJson += \"pageRole\" -> JsNumber(pageStuff.pageRole.toInt)\n-        if (query.reqr.isStaff && (post.numPendingFlags > 0 || post.numHandledFlags > 0)) {\n-          postJson += \"numPendingFlags\" -> JsNumber(post.numPendingFlags)\n-          postJson += \"numHandledFlags\" -> JsNumber(post.numHandledFlags)\n-        }\n-        postJson\n+            tagsAndBadges,\n+            inclPageId = true)\n+\n+      if (query.reqr.isStaff && (post.numPendingFlags > 0 || post.numHandledFlags > 0)) {\n+        postJson += \"numPendingFlags\" -> JsNumber(post.numPendingFlags)\n+        postJson += \"numHandledFlags\" -> JsNumber(post.numHandledFlags)\n       }\n+\n+      // Since these posts aren't wrapped in a page, but rather listed separately\n+      // outside their parent pages, it's nice to have the page title available\n+      // to show in the browser. And page id, see `inclPageId` above.  [posts_0_page_json]\n+      // Typescript: PostWithPage\n+      assert(JsonUtils.parseOptSt(postJson, \"pageId\") == Some(pageStuff.pageId))\n+      postJson += \"pageTitle\" -> JsString(pageStuff.title)\n+      postJson += \"pageRole\" -> JsNumber(pageStuff.pageRole.toInt)\n+      postJson\n     }\n \n     Json.obj(  // Typescript: LoadPostsResponse\n             \"posts\" -> JsArray(postsJson),\n+            \"bookmarks\" -> JsArray(bookmarksJson),\n             \"storePatch\" -> Json.obj(\n               // RENAME  to patsBr? (for \"brief\", Ty standard abbreviation)\n               \"patsBrief\" -> patsJsArr,\n-              // RENAME  to tagsBr?\n+              // RENAME  to tagsBr?  no!,  \"typesBr\" ?\n               \"tagTypes\" -> JsTagTypeArray(tagTypes, inclRefId = query.reqr.isStaff)))\n   }\n \n \n   def downloadUsersContent(authorId: UserId): Action[Unit] = GetActionRateLimited(\n         RateLimits.DownloadOwnContentArchive) { request: GetRequest =>\n     // These responses can be huge; don't prettify the json.\n-    _listPostsImpl(authorId, all = true, request)\n+    _listPostsImpl(authorId, onlyPostType = None, all = true, request)\n   }\n \n "
    },
    {
      "sha": "6f13fd7e797cf3b95426a7bda8ad109b9e7dbb2a",
      "filename": "client/app-more/forum/create-category-dialog.more.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fforum%2Fcreate-category-dialog.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fforum%2Fcreate-category-dialog.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fforum%2Fcreate-category-dialog.more.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -560,6 +560,7 @@ const CatSettings = createClassAndFactory({\n       const isDef = category.isDefaultCategory;\n       anyDeleteButton =\n         r.div({ className: 's_CD_Btns'},\n+          // Break out a [red_delete_btn]?\n           Button({ onClick: this.props.deleteCategory, className: 'icon-trash s_CD_DelB',\n               disabled: isDef },\n             \"Delete category\"),   // 0I18N"
    },
    {
      "sha": "45a23c11099206a1efe479d8c2b9a24d5989f50b",
      "filename": "client/app-more/more-bundle-already-loaded.d.ts",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fmore-bundle-already-loaded.d.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fmore-bundle-already-loaded.d.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fmore-bundle-already-loaded.d.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -52,6 +52,10 @@ declare namespace debiki2 {\n     function makeResizableUp(elem, handle, onResize): (stop: Bo) => Vo;\n   }\n \n+  namespace todos {\n+    function ToDos(props);\n+  }\n+\n   namespace topbar {\n     function openMyMenu(store, where);\n   }\n@@ -133,6 +137,7 @@ declare namespace debiki2.nopage {\n declare namespace debiki2.tags {\n   var routes;\n   function openTagDropdown(atRect, ps);\n+  function openBookmarkDropdown(atRect, ps);\n }\n \n declare namespace debiki2.titleeditor {"
    },
    {
      "sha": "1caf4eb88f7a3a806ddf7ef3315d6920e2ebd1d5",
      "filename": "client/app-more/tags/bookmarks-dropdown.more.ts",
      "status": "added",
      "additions": 112,
      "deletions": 0,
      "changes": 112,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Ftags%2Fbookmarks-dropdown.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Ftags%2Fbookmarks-dropdown.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Ftags%2Fbookmarks-dropdown.more.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2024 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+/// <reference path=\"../more-prelude.more.ts\" />\n+/// <reference path=\"../morekit/proxy-diag.more.ts\" />\n+\n+\n+//------------------------------------------------------------------------------\n+   namespace debiki2.tags {\n+//------------------------------------------------------------------------------\n+\n+const r = ReactDOMFactories;\n+const ModalHeader = rb.ModalHeader;\n+const ModalTitle = rb.ModalTitle;\n+const ModalBody = rb.ModalBody;\n+const ModalFooter = rb.ModalFooter;\n+\n+\n+interface BookmarkDiag {\n+  me: Me,\n+  post: Post\n+  bookmarks?: Post[]\n+  page: Page,\n+}\n+\n+\n+export function openBookmarkDropdown(atRect: Rect, ps: BookmarkDiag) {\n+  morekit.openProxyDiag({ atRect, flavor: DiagFlavor.Dropdown, dialogClassName: 'c_BokmDrpdD' },\n+      closeDiag => BookmOrTaskDiag({ ...ps, closeDiag }));\n+}\n+\n+\n+\n+interface Props extends BookmarkDiag {\n+  closeDiag: () => V\n+}\n+\n+\n+const BookmOrTaskDiag = React.createFactory<Props>(function(ps: Props) {  // I18N bookmark dlg\n+  // Currently, can be only one not-deleted bookmark per post and person, this unique db ix:\n+  // posts_u_patid_pageid_parentnr_if_bookmark_0deld. \n+  const anyCurBookm: Post | U = ps.bookmarks?.[0];\n+\n+  // We use the source text, no CommonMark —> html formatting. [dont_format_bookmarks]\n+  const anyCurDescr: St | U = anyCurBookm?.unsafeSource;\n+\n+  const [descr, setDescr] = React.useState<St>(anyCurDescr || page_unsafeTitle(ps.page) || '');\n+\n+  // Maybe later: [bookmark_tasks]\n+  //const [isTask, setIsTask] = React.useState<Bo>(false);\n+\n+  function saveBookmark() {\n+    // Create or update a bookmark. [save_edit_bookmark]\n+    if (!anyCurBookm) {\n+      // RENAME to createPost instead? Not a reply.\n+      ReactActions.saveReply(ps.page.pageId, [ps.post.nr], descr, PostType.Bookmark,\n+              undefined /*draftToDelete*/, undefined /*doAsAnon*/, () => {\n+        ps.closeDiag();\n+      });\n+    }\n+    else {\n+      Server.saveEdits(ps.page.pageId, anyCurBookm.nr, descr,\n+              undefined /*deleteDraftNr*/, false /*doAsAnon*/, () => {\n+        // The post gets updated in the store by saveEdits().\n+        ps.closeDiag();\n+      });\n+    }\n+  }\n+\n+  function deleteBookmark() {\n+    ReactActions.deletePost(anyCurBookm.nr, false /* repliesToo */, false /*doAsAnon*/, () => {\n+      ps.closeDiag();\n+    });\n+  }\n+\n+  return rFr({},\n+      ModalHeader({}, ModalTitle({}, anyCurBookm ? \"Edit bookmark\" : \"Add bookmark\")),\n+      ModalBody({},\n+        Input({ type: 'textarea', label: \"Notes:\", className: 'e_BkmDsc', value: descr,\n+            onChange: (event) => setDescr(event.target.value) })\n+        ),\n+\n+      ModalFooter({},\n+        descr === anyCurDescr ? null :\n+        PrimaryButton({ onClick: saveBookmark, }, t.Save),\n+\n+        !anyCurBookm ? null :  // Maybe a [red_delete_btn]?\n+        Button({ onClick: deleteBookmark, className: 'btn-delete icon-trash' }, t.Delete),\n+\n+        Button({ onClick: ps.closeDiag }, t.Cancel),\n+        ));\n+});\n+\n+\n+//------------------------------------------------------------------------------\n+   }\n+//------------------------------------------------------------------------------\n+"
    },
    {
      "sha": "436782897a47384fa3240d9520d02472301d1df2",
      "filename": "client/app-more/tags/bookmarks-dropdown.styl",
      "status": "added",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Ftags%2Fbookmarks-dropdown.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Ftags%2Fbookmarks-dropdown.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Ftags%2Fbookmarks-dropdown.styl?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,30 @@\n+\n+.c_BokmDrpdD\n+  .esDropModal_content\n+    width: 550px;\n+\n+  // Too mutch whitespace — the dialog is mostly empty.\n+  .modal-header\n+    padding: 10px 10px 0;\n+    border-bottom: none;\n+\n+  .modal-body\n+    padding: 20px 10px 0px;\n+\n+  .modal-footer\n+    border-top: none;\n+    padding-right: 10px;\n+    padding-bottom: 0;\n+\n+  .input-group\n+    width: 100%;\n+\n+// Just for now. [red_delete_btn]\n+.modal-footer .btn-delete\n+  margin-left: 2em !important;  // hmm\n+  margin-right: 2em;\n+  color: hsl(0, 30%, 20%);\n+  border-color: hsl(0, 30%, 74%);\n+  // The trash icon feels a bit like whitespace, so need less.\n+  padding-left: 6px; // else 12px from .btn\n+"
    },
    {
      "sha": "fead7fd0783bab7a6660e7837f1875bb6f9e28e4",
      "filename": "client/app-more/topbar/my-menu.more.ts",
      "status": "modified",
      "additions": 20,
      "deletions": 14,
      "changes": 34,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Ftopbar%2Fmy-menu.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Ftopbar%2Fmy-menu.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Ftopbar%2Fmy-menu.more.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -99,6 +99,10 @@ export const MyMenuContent = createFactory({\n     // especially on mobile so won't need to scroll up.\n     const extraViewAllNotfsOrClear = me.notifications.length <= 10 ? null :\n         viewAllNotfsOrClear;\n+\n+    // UX BUG report [ios_bugs] [ios_notf_list_bug]: On a *real* iPhone, Safari (& Chrome),\n+    // one can't scroll down in the notification list, although works in an emulator.\n+    // Temp workaround: Make list shorter, if iOS? And notification page pagination.\n     const notfsItems = me.notifications.map((notf: Notification) =>\n         MenuItemLink({ key: notf.id, to: linkToNotificationSource(notf),\n             className: notf.seen ? '' : 'esNotf-unseen' },\n@@ -107,11 +111,11 @@ export const MyMenuContent = createFactory({\n \n     // ------- Stop impersonating\n \n-    let isViewingAsHint;\n-    let stopImpersonatingMenuItem;\n-    let notYourMenuHint;\n-    let impersonationStuffDivider;\n-    let viewAsOtherItem;\n+    let isViewingAsHint: St | U;\n+    let stopImpersonatingMenuItem: RElm | U;\n+    let notYourMenuHint: RElm | U;\n+    let impersonationStuffDivider: RElm | U;\n+    let viewAsOtherItem: RElm | U;\n \n     if (store.isImpersonating) {\n       isViewingAsHint = store.isViewingAs\n@@ -136,12 +140,13 @@ export const MyMenuContent = createFactory({\n \n     // ------- The current user\n \n-    let viewProfileLogOutMenuItem;\n-    let viewUsersOrGroups;\n-    let viewDraftsAndBookmarks;\n-    let myStuffDivider;\n-    let unhideHelpMenuItem;\n-    let showAnnouncementsMenuItem;\n+    let viewProfileLogOutMenuItem: RElm | U;\n+    let viewUsersOrGroups: RElm | U;\n+    let viewDraftsAndBookmarks: RElm | U;\n+    let myStuffDivider: RElm | U;\n+    let unhideHelpMenuItem: RElm | U;\n+    let showAnnouncementsMenuItem: RElm | U;\n+\n     if (me.isLoggedIn) {\n       // If is admin, show the logout button on the same line as the \"View profile\" link,\n       // because then there're admin links above, and lots of space for the  X close-menu button.\n@@ -158,7 +163,10 @@ export const MyMenuContent = createFactory({\n       const isMemberOfCustomGroup = _.some(me.myGroupIds, id => id >= LowestAuthenticatedUserId);\n       viewUsersOrGroups = !isStaff(me) && !isMemberOfCustomGroup ? null :\n           MenuItemsMany({},\n-            LinkUnstyled({ to: GroupsRoot, id: 'te_VwGrps' }, t.mm.ViewGroups)),\n+            LinkUnstyled({ to: GroupsRoot, id: 'te_VwGrps' }, t.mm.ViewGroups),\n+            // Good with a users link too; someone didn't find the users list.\n+            isStaff(me) && LinkUnstyled({ to: AdminUsersRoot, className: 'c_VwUsrs' },\n+                  t.mm.ViewUsers || \"View users\")), // I18N\n \n       viewDraftsAndBookmarks =\n           MenuItemsMany({},\n@@ -196,8 +204,6 @@ export const MyMenuContent = createFactory({\n         viewDraftsAndBookmarks,\n         viewAsOtherItem,\n         notfsDivider,\n-        // UX BUG [ios_bugs] On Safari (& Chrome) on iOS, one cannot scroll down\n-        // in the notifications list.\n         viewAllNotfsOrClear,\n         notfsItems,\n         extraViewAllNotfsOrClear,"
    },
    {
      "sha": "ccd1786e1cab907cdffb697ecb315fed42980f71",
      "filename": "client/app-more/users/to-dos.more.ts",
      "status": "added",
      "additions": 174,
      "deletions": 0,
      "changes": 174,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fusers%2Fto-dos.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fusers%2Fto-dos.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fusers%2Fto-dos.more.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright (c) 2024 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+/// <reference path=\"../more-prelude.more.ts\" />\n+/// <reference path=\"user-summary.more.ts\" />\n+\n+//------------------------------------------------------------------------------\n+   namespace debiki2.todos {\n+//------------------------------------------------------------------------------\n+\n+const r = ReactDOMFactories;\n+\n+// [dupl_comts_list_code]\n+const smallWindow = Math.min(window.outerWidth, window.outerHeight) < 500;\n+const windowWideEnoughForTabButtons = window.outerWidth > 1010;\n+\n+\n+interface ToDosProps {\n+  bookmarks: PostWithPageId[]\n+  bookmarkedPosts: PostWithPage[]\n+  drafts?: Draft[]  // later\n+  tasks?: Post[]    // assigned-to tasks, later\n+  curPostNr?: PostNr\n+  store: Store\n+  onPostClick: (post: Post) => V\n+  reorderThisBeforeThat: (draggingTodo: PostWithPageId, bm: PostWithPageId) => V\n+}\n+\n+\n+/// A todo item can be a bookmark or, later, a draft or task [bookmark_tasks]. \n+/// Bookmarks often mean read-later or continue-reading-here — a kind of todo thing.\n+/// And drafts are todos (finish writing and post it).\n+///\n+/// (Some bookmarks are for referece only — that probably doesn't count as todos though.)\n+///\n+export const ToDos = React.createFactory<ToDosProps>(function(ps: ToDosProps) {\n+  // Dragging a todo will, later, change its order value — which will be the default\n+  // sort field. So, you can order & prioritize your todos / bookmarks.  [order_bokms]\n+  const [draggingTodo, setDraggingTodo] = React.useState<PostWithPageId | N>(null);\n+\n+  const abbreviateHowMuch = smallWindow ? 'Much' : 'ABit';\n+  if (!ps.bookmarks.length)\n+    return r.p({}, \"No bookmarks.\");  // I18N\n+\n+  // Temp store copy where we'll add pages with postsByNr, and insert\n+  // the bookmarked posts, and bookmarks so they'll be found when rendering\n+  // the bookmarked posts. [render_bookms]\n+  const pagesById: { [id: PageId]: Page } = {};\n+\n+  // Add bookmarks & posts to `pagesById`.\n+  for (let post of [...ps.bookmarks, ...ps.bookmarkedPosts]) {\n+    let page: Page = pagesById[post.pageId];\n+    if (!page) {\n+      page = debiki2.makeAutoPage(post.pageId);\n+      pagesById[post.pageId] = page;\n+    }\n+    page.postsByNr[post.nr] = post;\n+  }\n+\n+  const result: RElm[] = [];\n+\n+  // [dupl_comts_list_code]\n+  for (let bm of ps.bookmarks) {\n+    const page: Page = pagesById[bm.pageId];\n+\n+    // Safe: Not interpreting the source as html.\n+    const bmText = r.span({}, bm.unsafeSource);\n+    const bmElm = r.div({}, r.span({ className: 'dw-p-mark icon-bookmark' }), bmText);\n+\n+    const anyPost: Post | U = page.postsByNr[bm.parentNr];\n+    const isOnCurrentPage = anyPost && anyPost.pageId === ps.store.currentPageId;\n+\n+    let postElm: RElm;\n+\n+    // The bookmarked post (parent post) might have been deleted, or moved to elsewhere\n+    // where we don't have access.  [private_orphans]\n+    if (!anyPost) {\n+      // 0Po = no (zero) post.\n+      postElm = r.div({ className: 'c_BmPo_0Po' },\n+          `${bm.parentNr === BodyNr ? \"Post\" : \"comment\"} gone`);  // I18N\n+    }\n+    else {\n+      const postProps: PostProps = {\n+        store: ps.store,\n+        post: anyPost,\n+        onClick: () => ps.onPostClick(anyPost),\n+        inTodoList: true, // so won't render bookmarks (we'll show bmElm instead)\n+        abbreviate: abbreviateHowMuch,\n+      };\n+\n+      if (isOnCurrentPage && anyPost.nr === ps.curPostNr) {\n+        postProps.className = 'dw-current-post';\n+      }\n+\n+      postElm = debiki2.page.Post(postProps);\n+    }\n+\n+    const href: St | U = !anyPost ? undefined : linkToPost(anyPost as PostWithPageId);\n+\n+    // c_BmPo = Bookmark (and) post (just below).\n+    const draggedClass = draggingTodo?.uniqueId === bm.uniqueId ? ' c_Dragging' : '';\n+\n+\n+    // Wrap the bookmark and bookmarked post in a <a href>, which when clicked SPA-navigates\n+    // to the bookmarked post. And you can right click to copy the link / open in new tab.\n+    //\n+    // Draging & reordering not yet finished.  [order_bokms]\n+    //\n+    const bmAndPostLink = LinkUnstyled({ key: bm.uniqueId, href,\n+            className: 'c_BmPo' + draggedClass,\n+\n+            draggable: true,\n+\n+            onDragStart: (event: DragEvent) => {\n+              // Without setData(), onDrop() is never called, at least not in my Chrome.\n+              // Maybe safer to not include the bookmark text in dataTransfer? People\n+              // might expect only the link to be included, and unexpectedly darg-dropping\n+              // some private note somewhere?\n+              // Skip?: event.dataTransfer.setData('text/plain',\n+              //          `Bookmark text: ${bm.unsafeSource}\\nBookmark link: ${href}`);\n+              // But this makes sense:\n+              event.dataTransfer.setData('text/uri-list', href);\n+              // What Talkyard uses: (actually doesn't need — the `draggingTodo` state is enough)\n+              event.dataTransfer.setData('talkyard/nodeid', '' + bm.uniqueId);\n+              event.dataTransfer.dropEffect = 'move';\n+              console.debug(`onDragStart todo id ${bm.uniqueId}`);\n+              setDraggingTodo(bm);\n+            },\n+\n+            onDragOver: (event: DragEvent) => {\n+              event.preventDefault();\n+              console.debug(`onDragOver bm ${bm.uniqueId}`);\n+            },\n+\n+            onDrop: (event: DragEvent) => {\n+              // Default behavior is e.g. open-as-link on drop\n+              // (says https://www.w3schools.com/html/html5_draganddrop.asp).\n+              event.preventDefault();\n+              const todoIdStr: St = event.dataTransfer.getData('talkyard/nodeid');\n+              console.debug(`onDrop: todo id ${todoIdStr} on ${bm.uniqueId}`);\n+              ps.reorderThisBeforeThat(draggingTodo, bm);\n+            },\n+\n+            onDragEnd: () => {\n+              setDraggingTodo(null);\n+            }},\n+        bmElm,\n+        postElm);\n+\n+    result.push(bmAndPostLink);\n+  }\n+\n+  return rFr({}, result);\n+});\n+\n+\n+//------------------------------------------------------------------------------\n+   }\n+//------------------------------------------------------------------------------\n+// vim: fdm=marker et ts=2 sw=2 tw=0 fo=r list"
    },
    {
      "sha": "925ffaf8014ed3938a3888611be45f375272b43f",
      "filename": "client/app-more/users/user-notifications.more.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fusers%2Fuser-notifications.more.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-more%2Fusers%2Fuser-notifications.more.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-more%2Fusers%2Fuser-notifications.more.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -112,7 +112,7 @@ export const UserNotifications = createFactory({\n         r.p({}, isMe ? t.upp.NotfsToYouC : t.upp.NotfsToOtherC(user.username || user.fullName)),\n         anyNoNotfsMessage,\n         r.ol({ className: 'esNotfs' },\n-          notfsElems)));\n+          notfsElems)));  // UX SHOULD: Load More btn. Also mitigates the [ios_notf_list_bug].\n   }\n });\n "
    },
    {
      "sha": "0d45f0f8990f3be5643d6259c6c24c02abc4c767",
      "filename": "client/app-slim/ReactActions.ts",
      "status": "modified",
      "additions": 46,
      "deletions": 6,
      "changes": 52,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2FReactActions.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2FReactActions.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2FReactActions.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -163,6 +163,7 @@ export function logout() {\n \n export function logoutClientSideOnly(ps: { goTo?: St, skipSend?: Bo, msg?: St } = {}) {\n   Server.deleteTempSessId();  // [is_logging_out]\n+  Server.clearQueryCache();   // [clear_q_cache] here to, in case of races\n \n   ReactDispatcher.handleViewAction({\n     actionType: actionTypes.Logout\n@@ -184,6 +185,7 @@ export function logoutClientSideOnly(ps: { goTo?: St, skipSend?: Bo, msg?: St }\n   // logged out: (we reload() below — but the service-worker might stay connected)\n   pubsub.disconnectWebSocket();\n \n+  // Make sure we reload() to forget all state, at least for now. [reload_on_logout]\n   if (ps.goTo) {\n     if (eds.isInIframe) {\n       // Then we'll redirect the parent window instead. [sso_redir_par_win]\n@@ -491,6 +493,7 @@ export function uncollapsePost(post) {\n }\n \n \n+// Sth a bit similar, when paginating in a chat?  [to_paginate]\n // COULD RENAME to loadIfNeededThenShow(AndHighlight)Post\n export function loadAndShowPost(postNr: PostNr, showPostOpts: ShowPostOpts = {},\n        onDone?: (post?: Post) => void) {\n@@ -744,6 +747,10 @@ export function doUrlFragmentAction(newHashFragment?: string) {\n       const newHash = postNr === BodyNr ? '#' : `#post-${postNr}`;\n       // Does this sometimes make the browser annoyingly scroll-jump so this post is at\n       // the very top of the win, occluded by the topbar? [4904754RSKP]\n+      // @ifdef DEBUG\n+      logD(`ReactActions doUrlFragmentAction loadAndShowPost: ` +\n+              `history.replaceState({}, '', newHash);`);\n+      // @endif\n       history.replaceState({}, '', newHash);\n     }\n   });\n@@ -1478,16 +1485,17 @@ export function maybeLoadAndShowNewPage(store: Store, history: ReactRouterHistor\n   // Or 3) because we just loaded it via '/-pageid', and now we're updating the url to\n   // the correct page path, say '/forum/'. (4WKBT80)\n \n-  let hasPageAlready = false;\n+  let shouldLoadPage = true;\n   let isThisPage = false;\n   let gotNewHash = false;\n+  let theNewPage: Page | U;\n \n   _.each(store.pagesById, (page: Page) => {\n     if (isThisPage) return; // break loop\n \n     const storePagePath = page.pagePath.value;\n \n-    // Is this page in the store the one we're navigating to?\n+    // Is this cached page in the store the one we're navigating to?\n     isThisPage = storePagePath === newUrlPath;\n \n     // Maybe the url path is wrong? Case 3 above (4WKBT80): test '/-pageid' urls.\n@@ -1504,7 +1512,10 @@ export function maybeLoadAndShowNewPage(store: Store, history: ReactRouterHistor\n     }\n \n     if (isThisPage) {\n-      hasPageAlready = true;\n+      // We're navigating to `page`, which we have cached in the store already. (We've looked\n+      // at it before, navigated away and back somehow.)\n+      shouldLoadPage = false;\n+      theNewPage = page;\n       if (page.pageId === store.currentPageId) {\n         // We just loaded the whole html page from the server, and are already trying to\n         // render 'page'. Or we clicked a '/-pageid#post-nr' link, to '/the-current-page'.\n@@ -1516,7 +1527,13 @@ export function maybeLoadAndShowNewPage(store: Store, history: ReactRouterHistor\n         gotNewHash = hash !== location.hash;\n         const somethingChanged = newUrlPath !== page.pagePath.value || gotNewSearch || gotNewHash;\n         if (somethingChanged && !newPathIsToThatForum) {\n-          history.replace(page.pagePath.value + search + hash);\n+          const newUrlPath = page.pagePath.value + search + hash;\n+          // @ifdef DEBUG\n+          logD(`ReactActions maybeLoadAndShowNewPage: ${\n+                              location.pathname + location.search + location.hash\n+                              } –> history.replace(${newUrlPath})`);\n+          // @endif\n+          history.replace(newUrlPath);\n         }\n       }\n       else {\n@@ -1525,7 +1542,7 @@ export function maybeLoadAndShowNewPage(store: Store, history: ReactRouterHistor\n         // to be sure they're up-to-date. They are kept up-to-date automatically, if they're\n         // in the watchbar's recent-pages list. But I haven't tested this properly, also,\n         // the recent-pages-list might suffer from race conditions? and become out-of-date?\n-        hasPageAlready = false; // [8YDVP2A]\n+        shouldLoadPage = true; // [8YDVP2A]\n         /* Later:\n         // If navigating back to EmptyPageId, maybe there'll be no myData; then create empty data.\n         const myData = store.me.myDataByPageId[page.pageId] || makeNoPageData();\n@@ -1535,7 +1552,29 @@ export function maybeLoadAndShowNewPage(store: Store, history: ReactRouterHistor\n     }\n   });\n \n-  if (!hasPageAlready) {\n+  let canUseCache = false;\n+\n+  // @ifdef DEBUG\n+  // Just testing, on localhost, for now. [8YDVP2A]\n+  // Later, maybe, for a start, use any cached page only if it's not older than X minutes?\n+  // (Unless there's some http error — then use the cached page anyway.)\n+  canUseCache = theNewPage && theNewPage.pageId !== store.currentPageId;\n+  if (canUseCache)\n+    logD(`ReactActions maybeLoadAndShowNewPage canUseCache=true —> showNewPage...`);\n+  // @endif\n+\n+  if (canUseCache) {\n+    showNewPage({\n+      newPage: theNewPage,\n+      pubCats: store.publicCategories,\n+      pats: _.values(store.usersByIdBrief),\n+      tagTypesById: store.tagTypesById,\n+      me: store.me,\n+      stuffForMe: {},\n+      history,\n+    });\n+  }\n+  else if (shouldLoadPage) {\n     loadAndShowNewPage(newUrlPath, history);\n   }\n   else if (isThisPage && gotNewHash) {\n@@ -1544,6 +1583,7 @@ export function maybeLoadAndShowNewPage(store: Store, history: ReactRouterHistor\n }\n \n \n+// REFACTOR look at server.loadPagePartsJson()  [load_page_and_parts]\n function loadAndShowNewPage(newUrlPath: St, history: ReactRouterHistory) {\n   // UX maybe dim & overlay-cover the current page, to prevent interactions, until request completes?\n   // So the user e.g. won't click Reply and start typing, but then the page suddenly changes."
    },
    {
      "sha": "16d3e3c91594f6bc5e8f4284214787b5a8930e1a",
      "filename": "client/app-slim/ReactStore.ts",
      "status": "modified",
      "additions": 289,
      "deletions": 92,
      "changes": 381,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2FReactStore.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2FReactStore.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2FReactStore.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -50,6 +50,25 @@ export function win_getSessWinStore(): SessWinStore {\n   return mainWin.theStore;\n }\n \n+/// Helps us keep track of if any change event needs to be emitted.\n+///\n+/// Emitting a change when not needed, can waste 100 ms in a VM in a slow Core i5 laptop,\n+/// and much more one a mobile phone I suppose.\n+/// (It's various StoreListenerMixin onChange() handlers that together can take some time\n+/// — search for \"onChange: function\".)\n+///\n+const enum EmitEvent {\n+  NoNothingChanged = 0,\n+  YesQuickUpdate = 1,\n+  Yes = 2,\n+  YesFullUpdate = 3,\n+}\n+\n+// For detecting unnecessary store change events (bad for perforance).\n+let numEmits = 0;\n+\n+export let __patchedStore: Store | St; // [flux_mess]\n+\n type StoreStateSetter = (store: Store) => void;\n const useStoreStateSetters: StoreStateSetter[] = [];\n \n@@ -182,6 +201,7 @@ window['theStore'] = store; // simplifies inspection in Dev Tools — and hacky\n \n store.postsToUpdate = {};\n \n+\n if (store.user && !store.me) store.me = store.user; // try to remove\n if (!store.me) {\n   store.me = makeStranger(store);\n@@ -192,9 +212,10 @@ store.user = store.me; // try to remove\n // Auto pages are e.g. admin or user profile pages, html generated automatically when needed.\n // No page id or user created data server side. Auto pages need this default empty stuff,\n // to avoid null errors.\n-export function makeAutoPage(): Page {\n+export function makeAutoPage(pageId?: PageId): Page {\n   return <Page> <any> <AutoPage> {\n     dbgSrc: 'AP',\n+    pageId,\n     ancestorsRootFirst: [],\n     pageMemberIds: [],\n     postsByNr: [],\n@@ -227,6 +248,7 @@ ReactDispatcher.register(function(payload) {\n   const action = payload.action;\n   const currentPage: Page = store.currentPage;\n   let patchedTheStore: true | U;\n+  let needEmit: EmitEvent | U;\n   // SHOULD clone the store here? [8GKB3QA] but might introduce so many bugs, so wait a bit.\n   // So becomes (more) immutable.\n   switch (action.actionType) {\n@@ -386,7 +408,11 @@ ReactDispatcher.register(function(payload) {\n       //currentPage.horizontalLayout = newMeta.page type === PageRole.MindMap || currentPage.is2dTreeDefault;\n       //const is2dTree = currentPage.horizontalLayout;\n \n-      updatePost(newData.newTitlePost, currentPage.pageId);\n+      upsertPost(newData.newTitlePost, currentPage.pageId);\n+\n+      // Maybe different posts shown, now. E.g. if sort order changed.  _break_out_process_fn\n+      stopGifsPlayOnClick();\n+      setTimeout(debiki2.page.Hacks.processPosts);\n \n       /*\n       if (was2dTree !== is2dTree) {   // [2D_LAYOUT]\n@@ -418,7 +444,8 @@ ReactDispatcher.register(function(payload) {\n       break;\n \n     case ReactActions.actionTypes.UpdatePost:\n-      updatePost(action.post, currentPage.pageId);\n+      const res = upsertPost(action.post, currentPage.pageId);\n+      _showMyNewPostsIfAny([res]);\n       break;\n \n     case ReactActions.actionTypes.VoteOnPost:\n@@ -447,11 +474,19 @@ ReactDispatcher.register(function(payload) {\n       break;\n \n     case ReactActions.actionTypes.UncollapsePost:\n-      uncollapsePostAndChildren(action.post);\n+      needEmit = uncollapsePostAndChildren(action.post);\n+      // _break_out_process_fn?\n+      setTimeout(function() {\n+        if (needEmit !== EmitEvent.NoNothingChanged) {\n+          stopGifsPlayOnClick();\n+          debiki2.page.Hacks.processPosts();\n+        }\n+        scrollAndFlashPosts(store.currentPage, [post]);\n+      });\n       break;\n \n     case ReactActions.actionTypes.ShowPost:\n-      showPostNr(action.postNr, action.showPostOpts);\n+      needEmit = showPostNr(action.postNr, action.showPostOpts);\n       break;\n \n     case ReactActions.actionTypes.SetWatchbar:\n@@ -509,11 +544,11 @@ ReactDispatcher.register(function(payload) {\n       break;\n \n     case ReactActions.actionTypes.AddNotifications:\n-      handleNotifications(action.notifications);\n+      needEmit = handleNotifications(action.notifications);\n       break;\n \n     case ReactActions.actionTypes.MarkAnyNotificationAsSeen:\n-      markAnyNotificationssAsSeen(action.postNr);\n+      needEmit = markAnyNotificationssAsSeen(action.postNr);\n       break;\n \n     case ReactActions.actionTypes.AddMeAsPageMember:\n@@ -535,6 +570,11 @@ ReactDispatcher.register(function(payload) {\n     break;\n \n     case ReactActions.actionTypes.UpdateUserPresence:\n+      // Only need to rerender the users list in the sidebar, if it's shown. — But in very\n+      // rare cases, a user might have gotten a new badge? Then we'd want to rerender any\n+      // posts by han, so the badge appears. Still, COULD_OPTIMIZE, [try_skip_emit].\n+      //store.quickUpdate = true;\n+\n       const data: UserPresenceWsMsg = action.data;\n       maybePatchTheStore(data);\n       patchedTheStore = true; // always patches, see UserPresenceWsMsg server side.\n@@ -555,6 +595,30 @@ ReactDispatcher.register(function(payload) {\n       return true;\n   }\n \n+  if (needEmit === EmitEvent.NoNothingChanged) {\n+    // Don't trigger any event.\n+    // @ifdef DEBUG\n+    dieIf(store.cannotQuickUpdate || _.size(store.postsToUpdate), 'TyE50SLN2');\n+    // @endif\n+  }\n+  else {\n+    _emitEvent(store, patchedTheStore, action);\n+  }\n+\n+  // How can one know when React is done with all updates scheduled above?\n+  // (Would need to look into how emitChange() and the hook fns work?)\n+  // Some code wants to run afterwards: [SCROLLPRVW]. For now though:\n+  if (action.onDone) {\n+    setTimeout(action.onDone, 1);\n+  }\n+\n+  // Tell the dispatcher that there were no errors:\n+  return true;\n+});\n+\n+\n+function _emitEvent(store: Store, patchedTheStore: Bo, action: any) {\n+\n   if (store.cannotQuickUpdate) {\n     resetQuickUpdateInPlace(store);\n   }\n@@ -568,6 +632,7 @@ ReactDispatcher.register(function(payload) {\n   // below gets a new object. If reusing the same obj, the useEffect fn:s aren't called.\n   const meCopy: Myself = { ...store.me };\n   const storeCopy: Store = { ...store, me: meCopy };\n+  __patchedStore = 'TyEPATSTOR';\n \n   useStoreStateSetters.forEach(setStore => {  // ... new, hooks based code\n     setStore(storeCopy);\n@@ -581,20 +646,11 @@ ReactDispatcher.register(function(payload) {\n     storeEventListeners.forEach(listener => {\n       listener(thePatch);\n     });\n+    __patchedStore = storeCopy; // [flux_mess]\n   }\n \n   resetQuickUpdateInPlace(store);\n-\n-  // How can one know when React is done with all updates scheduled above?\n-  // (Would need to look into how emitChange() and the hook fns work?)\n-  // Some code wants to run afterwards: [SCROLLPRVW]. For now though:\n-  if (action.onDone) {\n-    setTimeout(action.onDone, 1);\n-  }\n-\n-  // Tell the dispatcher that there were no errors:\n-  return true;\n-});\n+}\n \n \n function resetQuickUpdateInPlace(st: Store) {\n@@ -715,6 +771,8 @@ ReactStore.activateVolatileData = function() {\n ReactStore.activateMyself = function(anyNewMe: Myself | NU, stuffForMe?: StuffForMe) {\n   // [redux] Modifying state in-place, shouldn't do? But works fine.\n \n+  numEmits = 0;\n+\n   store.userSpecificDataAdded = true;\n \n   if (stuffForMe) {\n@@ -858,14 +916,22 @@ ReactStore.activateMyself = function(anyNewMe: Myself | NU, stuffForMe?: StuffFo\n   // ----- Websocket\n \n   debiki2.pubsub.subscribeToServerEvents(store.me);\n-  store.quickUpdate = false;\n+\n+\n+  // The caller will emit a change event — if we've done here too, that's bad\n+  // for performance.\n+  // @ifdef DEBUG\n+  dieIf(numEmits > 0, `${numEmits} pointless emits [TyEEMIT02]`)\n+  // @endif\n+\n+  resetQuickUpdateInPlace(store);\n };\n \n \n function store_addAnonsAndUnapprovedPosts(store: Store, myPageData: MyPageData) {\n   // Test:  modn-from-disc-page-approve-before  TyTE2E603RTJ\n   _.each(myPageData.unapprovedPosts, (post: Post) => {\n-    updatePost(post, store.currentPageId);\n+    upsertPost(post, store.currentPageId);\n     // COULD_FREE_MEM if other user was logged in before?\n   });\n \n@@ -955,7 +1021,7 @@ function addMyDraftPosts(store: Store, myPageData: MyPageData) {\n       if (draftType === DraftType.Reply || draftType === DraftType.ProgressPost) {\n         const post: Post | null = store_makePostForDraft(store.me.id, draft);\n         if (post) {\n-          updatePost(post, store.currentPageId);\n+          upsertPost(post, store.currentPageId);\n         }\n       }\n     });\n@@ -1010,7 +1076,11 @@ function userIdList_remove(userIds: UserId[], userId: UserId) {\n \n \n ReactStore.mayComposeBeforeSignup = function() {\n- return store.settings.mayComposeBeforeSignup;\n+  const useOnlyCustomIdps = store.settings.useOnlyCustomIdps;\n+  const enableTySso = store.settings.enableSso;\n+  // If sso enabled, the may-compose-before setting is hidden, and one should get\n+  // redirected to the SSO page directly.  [0_compose_bef_sso_redir]\n+ return store.settings.mayComposeBeforeSignup && !(enableTySso || useOnlyCustomIdps);\n };\n \n ReactStore.getPageId = function() {\n@@ -1041,6 +1111,7 @@ ReactStore.getCategories = function() {\n \n ReactStore.emitChange = function() {\n   this.emit(ChangeEvent);\n+  numEmits += 1;\n };\n \n \n@@ -1072,18 +1143,22 @@ export function clonePost(postNr: number): Post {\n }\n \n \n-function updatePost(post: Post, pageId: PageId, isCollapsing?: boolean) {\n-  const page: Page = store.currentPage;\n+interface UpsertPostResult {\n+  postBef?: Post\n+  postAft?: Post\n+}\n \n-  if (page.pageId !== pageId) {\n-    // Need to lookup the correct page then, just above, instead of using the current page?\n-    // But for now, just ignore this. We currently reload, when navigating back to a page\n-    // in the store anyway [8YDVP2A].\n-    return;\n-  }\n+function upsertPost(post: Post, pageId: PageId, ps: { isCollapsing?: Bo } = {}): UpsertPostResult {\n+  // The post might be for the page currently being shown, but could also be for a page\n+  // in our client side mem cache. [8YDVP2A]\n+  const isCurrentPage = pageId === store.currentPageId;\n+  const page: Page = store.pagesById[pageId];\n+\n+  if (!page)\n+    return {};\n \n   const oldVersion = page.postsByNr[post.nr];\n-  if (oldVersion && !isCollapsing) {\n+  if (oldVersion && !ps.isCollapsing) {\n     // If we've modified-saved-reloaded-from-the-server this post, then ignore the\n     // collapse settings from the server, in case the user has toggled it client side.\n     // If `isCollapsing`, however, then we're toggling that state client side only.\n@@ -1093,8 +1168,8 @@ function updatePost(post: Post, pageId: PageId, isCollapsing?: boolean) {\n     post.summarize = oldVersion.summarize;\n   }\n \n-  if (post.isPreview) {\n-    // Don't update num replies etc fields.\n+  if (post.isPreview || post_isPrivate(post)) {\n+    // Don't update num replies etc fields. [0_stats_for_priv_posts]\n   }\n   else if (oldVersion) {\n     if (post_isReply(post)) {\n@@ -1128,9 +1203,23 @@ function updatePost(post: Post, pageId: PageId, isCollapsing?: boolean) {\n \n   const layout: DiscPropsDerived = page_deriveLayout(page, store, LayoutFor.PageWithTweaks);\n \n-  // In case this is a new post, update its parent's child id list.\n+  // In case this is a new post, update its parent's bookmarks or replies list.\n+  // (Maybe break out some obj_addArrayItem_inPl__unimp fn? To use in the if-else branches.)\n   const parentPost = page.postsByNr[post.parentNr];\n-  if (parentPost) {\n+  if (parentPost && post.postType === PostType.Bookmark) {\n+    let bookmarkNrs = parentPost.bookmarkNrs;\n+    const alreadyHere = _.find(bookmarkNrs || [], nr => nr === post.nr);\n+    if (!alreadyHere) {\n+      if (!bookmarkNrs) {\n+        bookmarkNrs = [];\n+        parentPost.bookmarkNrs = bookmarkNrs;\n+      }\n+      bookmarkNrs.push(post.nr);\n+      sortPostNrsInPlace(\n+            bookmarkNrs, page.postsByNr, PostSortOrder.NewestFirst);\n+    }\n+  }\n+  else if (parentPost) {\n     const childNrsSorted = parentPost.childNrsSorted;\n     const alreadyAChild = _.find(childNrsSorted, nr => nr === post.nr);\n     if (!alreadyAChild) {\n@@ -1170,24 +1259,43 @@ function updatePost(post: Post, pageId: PageId, isCollapsing?: boolean) {\n         page.parentlessReplyNrsSorted, page.postsByNr, sortOrder);\n   }\n \n+  // If we aren't showing the page (but just updating the store), then we're done now.\n+  if (!isCurrentPage)\n+    return;\n+\n   rememberPostsToQuickUpdate(post.nr);\n \n-  stopGifsPlayOnClick();\n-  setTimeout(() => {\n-    debiki2.page.Hacks.processPosts();\n-    if (!oldVersion && post.authorId === store.me.id && !post.isPreview &&\n-        // Need not flash these — if one does sth that results in a meta comment,\n-        // then one is aware about that already (since one did it oneself).\n-        // And if sbd else did — then I think that's typically not that interesting,\n-        // would be distracting to scroll-and-flash-&-show?\n-        post.postType !== PostType.MetaMessage) {\n-      // Scroll to and highligt this new / edited post.\n-      // BUG (harmless) skip if we just loaded it because we're staff or the author,\n-      // and it's deleted so only we can see it\n-      // — because that doesn't mean we want to scroll to it and flash it.\n-      ReactActions.loadAndShowPost(post.nr);\n+  return { postBef: oldVersion, postAft: post };\n+}\n+\n+\n+// Maybe RENAME to sth that incl \"processPost\"? Since that's done too.\n+function _showMyNewPostsIfAny(upsertResults: UpsertPostResult[]) {\n+  if (upsertResults.length)\n+    return;\n+\n+  setTimeout(showMyPosts, 1);\n+\n+  function showMyPosts() {\n+    stopGifsPlayOnClick();\n+    for (let res of upsertResults) {\n+      const oldVersion = res.postBef;\n+      const post = res.postAft;\n+      debiki2.page.Hacks.processPosts('post-' + post.uniqueId);\n+      if (!oldVersion && post.authorId === store.me.id && !post.isPreview &&\n+          // Need not flash these — if one does sth that results in a meta comment,\n+          // then one is aware about that already (since one did it oneself).\n+          // And if sbd else did — then I think that's typically not that interesting,\n+          // would be distracting to scroll-and-flash-&-show?\n+          post.postType !== PostType.MetaMessage) {\n+        // Scroll to and highligt this new / edited post.\n+        // BUG (harmless) skip if we just loaded it because we're staff or the author,\n+        // and it's deleted so only we can see it\n+        // — because that doesn't mean we want to scroll to it and flash it.\n+        ReactActions.loadAndShowPost(post.nr);\n+      }\n     }\n-  }, 1);\n+  }\n }\n \n \n@@ -1267,6 +1375,9 @@ function markPostAsRead(postId: number, manually: boolean) {\n let lastPostIdMarkCycled = null;\n \n function cycleToNextMark(postId: number) {\n+  /* This was working 10+ years ago, but more like a demo — wasn't saved sever side.\n+     Can be useful later when implementing:  [bookmark_shapes_colors]\n+\n   const me: Myself = store.me;\n   const myPageData: MyPageData = me.myCurrentPageData;\n   const currentMark = myPageData.marksByPostId[postId];\n@@ -1307,6 +1418,7 @@ function cycleToNextMark(postId: number) {\n   myPageData.marksByPostId[postId] = nextMark;\n \n   rememberPostsToQuickUpdate(postId);\n+  */\n }\n \n \n@@ -1385,7 +1497,7 @@ function collapseTree(post: Post) {\n   post.isTreeCollapsed = 'Truncated';\n   post.summarize = true;\n   post.summary = makeSummaryFor(post, 70);\n-  updatePost(post, store.currentPageId, true);\n+  upsertPost(post, store.currentPageId, { isCollapsing: true });\n   // It's nice to see where the post is, after having collapsed it\n   // — because collapsing a post tree often makes the page jump a bit.\n   // UX COULD animate-collapse height of tree to 0? By shrinking each\n@@ -1394,12 +1506,15 @@ function collapseTree(post: Post) {\n }\n \n \n-function showPostNr(postNr: PostNr, showPostOpts: ShowPostOpts = {}) {\n+function showPostNr(postNr: PostNr, showPostOpts: ShowPostOpts = {}): EmitEvent {\n+  let needEmit = EmitEvent.NoNothingChanged;\n+\n   const page: Page = store.currentPage;\n   const postToShow: Post = page.postsByNr[postNr];\n   let post: Post = postToShow;\n   if (showPostOpts.showChildrenToo) {\n-    uncollapsePostAndChildren(post);\n+    needEmit = Math.max(needEmit,\n+            uncollapsePostAndChildren(post));\n   }\n   // Uncollapse ancestors, to make postId visible. Don't loop forever if there's any weird\n   // cycle — that crashes Chrome (as of May 3 2017).\n@@ -1413,9 +1528,11 @@ function showPostNr(postNr: PostNr, showPostOpts: ShowPostOpts = {}) {\n     }\n     postNrsSeen[post.nr] = true;\n     // But minor BUG: Usually we want to leave isPostCollapsed = false? (305RKTU).\n-    uncollapseOne(post);\n+    needEmit = Math.max(needEmit,\n+            uncollapseOne(post));\n     post = page.postsByNr[post.parentNr];\n   }\n+\n   setTimeout(() => {\n     const opts: ShowPostOpts = { ...showPostOpts };\n     if (postNr <= MaxVirtPostNr) {\n@@ -1425,52 +1542,63 @@ function showPostNr(postNr: PostNr, showPostOpts: ShowPostOpts = {}) {\n     }\n \n     if (showPostOpts.showChildrenToo) {\n-      // uncollapsePostAndChildren() will scroll-flash, don't do here too.\n+      scrollAndFlashPosts(page, [post]);\n     }\n     else {\n-      // Maybe could use instead?: scrollAndFlashPosts(page, [post]);\n       scrollAndFlashPostNr(postNr, opts);\n     }\n \n-    debiki2.page.Hacks.processPosts();\n+    // _break_out_process_fn\n+    if (needEmit !== EmitEvent.NoNothingChanged) {\n+      stopGifsPlayOnClick();\n+      // Maybe many descendants are now shown — this'll update all of them (not specifying a nr).\n+      debiki2.page.Hacks.processPosts();\n+    }\n   }, 1);\n+\n+  return needEmit;\n }\n \n \n-function uncollapsePostAndChildren(post: Post) {\n+function uncollapsePostAndChildren(post: Post): EmitEvent {\n   const page: Page = store.currentPage;\n-  uncollapseOne(post);\n+  let needEmit =\n+          uncollapseOne(post);\n   // Also uncollapse children and grandchildren so one won't have to Click-to-show... all the time.\n   for (let i = 0; i < Math.min(post.childNrsSorted.length, 5); ++i) {\n     const childNr = post.childNrsSorted[i];\n     const child = page.postsByNr[childNr];\n     if (!child)\n       continue;\n-    uncollapseOne(child);\n+\n+    needEmit = Math.max(needEmit,\n+            uncollapseOne(child));\n+\n     for (let i2 = 0; i2 < Math.min(child.childNrsSorted.length, 3); ++i2) {\n       const grandchildNr = child.childNrsSorted[i2];\n       const grandchild = page.postsByNr[grandchildNr];\n       if (!grandchild)\n         continue;\n-      uncollapseOne(grandchild);\n+\n+      needEmit = Math.max(needEmit,\n+              uncollapseOne(grandchild));\n     }\n   }\n-  setTimeout(function() {\n-    debiki2.page.Hacks.processPosts();\n-    scrollAndFlashPosts(page, [post]);\n-  });\n+\n+  return needEmit;\n }\n \n \n-function uncollapseOne(post: Post) {\n+function uncollapseOne(post: Post): EmitEvent {\n   if (!post.isTreeCollapsed && !post.isPostCollapsed && !post.summarize && !post.squash)\n-    return;\n+    return EmitEvent.NoNothingChanged;\n   const p2 = clonePost(post.nr);\n   p2.isTreeCollapsed = false;\n   p2.isPostCollapsed = false;  // sometimes we don't want this though  (305RKTU)\n   p2.summarize = false;\n   p2.squash = false;\n-  updatePost(p2, store.currentPageId, true);\n+  upsertPost(p2, store.currentPageId, { isCollapsing: true });\n+  return EmitEvent.Yes;\n }\n \n \n@@ -1672,7 +1800,7 @@ function sortPostNrsInPlaceBestFirst(postNrs: PostNr[], postsByNr: { [nr: number\n }\n \n \n-function postAppearedBefore(postA: Post, postB: Post): number {\n+export function postAppearedBefore(postA: Post, postB: Post): number {\n   // Sync w Scala [5BKZQF02]\n   // BUG  [first_last_apr_at]  use 'nr' only, to sort by date, for now.\n   /*\n@@ -1687,11 +1815,24 @@ function postAppearedBefore(postA: Post, postB: Post): number {\n   if (postA.isPreview != postB.isPreview)\n     return postA.isPreview ? +1 : -1;\n \n-  return postA.nr < postB.nr ? -1 : +1;\n+  // Private posts (incl bookmarks) have random negative nrs. Then, sort by\n+  // created-at instead of nr. (But otherwise better to sort by nr, since a comment\n+  // might have been posted long ago, and moved to the current page just recently\n+  // — then, since it's new on the current page, it appeared later.)\n+  if (postA.nr <= PostNrs.MaxPrivateNr || postB.nr <= PostNrs.MaxPrivateNr) {\n+    // They might have been created using software at the exact same timestamp.\n+    // Then skip this, and sort by nr instead, below.\n+    if (postA.createdAtMs !== postB.createdAtMs) {\n+      return postA.createdAtMs - postB.createdAtMs;\n+    }\n+  }\n+\n+  return postA.nr - postB.nr;\n }\n \n \n-function handleNotifications(newNotfs: Notification[]) {\n+function handleNotifications(newNotfs: Notification[]): EmitEvent {\n+  let needEmit = EmitEvent.NoNothingChanged;\n   const oldNotfs = store.me.notifications;\n   for (let i = 0; i < newNotfs.length; ++i) {\n     const newNotf = newNotfs[i];\n@@ -1704,11 +1845,15 @@ function handleNotifications(newNotfs: Notification[]) {\n     }\n \n     watchbar_handleNotification(store.me.watchbar, newNotf);\n+    // Only need to rerender the watchbar, MyMenu and notification icons.\n+    needEmit = EmitEvent.YesQuickUpdate;\n   }\n+  return needEmit;\n }\n \n \n function markAnyNotificationssAsSeen(postNr) {\n+  let needEmit = EmitEvent.NoNothingChanged;\n   const notfs: Notification[] = store.me.notifications;\n   _.each(notfs, (notf: Notification) => {\n     if (notf.pageId === store.currentPageId && notf.postNr === postNr &&\n@@ -1721,9 +1866,12 @@ function markAnyNotificationssAsSeen(postNr) {\n         updateNotificationCounts(notf, false);\n         // Simpler to call the server from here:\n         Server.markNotificationAsSeen(notf.id);\n+        // Only need to rerender MyMenu and notification icons.\n+        needEmit = EmitEvent.YesQuickUpdate;\n       }\n     }\n   });\n+  return needEmit;\n }\n \n \n@@ -1971,18 +2119,21 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n     // have been the old one, if any.)\n     _.each(store.pagesById, (oldPage: Page) => {\n       _.each(patchedPosts, (patchedPost: Post) => {\n+        // [On2] Maybe remember posts by page & id too, so this'll be a direct lookup?\n+        // SHOULD COULD_OPTIMIZE: But can just look up by `nr`?\n+        // like so:  oldPage.postsByNr[patchedPost.nr]  — why not?\n         _.each(oldPage.postsByNr, (oldPost: Post) => {\n           // Oops, drafts and previews have ids like = -1000101, -1000102\n           // — but they are the *newest*, so, \"old\" in oldPost is then misleading.\n           if (oldPost.uniqueId === patchedPost.uniqueId) {\n             const movedToNewPage = oldPage.pageId !== patchedPageId;\n             const movedOnThisPage = !movedToNewPage && oldPost.parentNr !== patchedPost.parentNr;\n             if (movedOnThisPage) {\n-              // It'll get reinserted into its new location, by updatePost() below.\n+              // It'll get reinserted into its new location, by upsertPost() below.\n               page_removeFromParentInPlace(oldPage, oldPost);\n             }\n             if (movedToNewPage) {\n-              // It'll get inserted into the new page by updatePost() below.\n+              // It'll get inserted into the new page by upsertPost() below.\n               page_deletePostInPlace(oldPage, oldPost);\n             }\n             // If the current page gets changed, then, need redraw arrows,\n@@ -2007,36 +2158,50 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n \n   // ----- Posts, new or edited?\n \n+  const upsertResults: UpsertPostResult[] = [];\n+\n   // Update the current page.\n-  if (!storePatch.pageVersionsByPageId) {\n-    // No page. Currently storePatch.usersBrief is for the current page (but there is none)\n-    // so ignore it too.\n+  if (!storePatch.pageVersionsByPageId && !storePatch.ignorePageVersion) {\n+    // No page to update, or we shouldn't compare page version.\n   }\n   else {\n+    // (WOULD_OPTIMIZE: For each page id in the keys of `storePatch.pageVersionsByPageId`,\n+    // look up that page directly in store.pagesById — no need to iterate through all pages.\n+    // But there're so few (in our browser cache), so doesn't matter.)\n     _.each(store.pagesById, patchPage);\n   }\n \n   function patchPage(page: Page) {\n-    const storePatchPageVersion = storePatch.pageVersionsByPageId[page.pageId];\n-    if (!storePatchPageVersion || storePatchPageVersion < page.pageVersion) {\n-      // These changes are old, might be out-of-date, ignore.\n-      return;\n-    }\n-    else if (storePatchPageVersion === page.pageVersion) {\n-      // We might be loading the text of a hidden/unapproved/deleted comment, in order to show it.\n-      // So although store & patch page versions are the same, proceed with updating\n-      // any posts below.\n+    if (storePatch.ignorePageVersion) {\n+      // Don't look at or update any `page.pageVersion`. (We might be loading\n+      // missing chat messages, if scrolling up in a chat; then, the page version\n+      // doesn't matter.)\n     }\n     else {\n-      // (Hmm this assumes we get all patches in between these two versions, or that\n-      // the current patch contains all changes, since the current page version.)\n-      page.pageVersion = storePatchPageVersion;\n+      const storePatchPageVersion = storePatch.pageVersionsByPageId[page.pageId];\n+      if (!storePatchPageVersion || storePatchPageVersion < page.pageVersion) {\n+        // These changes are old, might be out-of-date, ignore.\n+        return;\n+      }\n+      else if (storePatchPageVersion === page.pageVersion) {\n+        // We might be loading the text of a hidden/unapproved/deleted comment, in order\n+        // to show it.  So although store & patch page versions are the same,\n+        // proceed with updating any posts below.\n+      }\n+      else {\n+        // (Hmm this assumes we get all patches in between these two versions, or that\n+        // the current patch contains all changes, since the current page version.)\n+        page.pageVersion = storePatchPageVersion;\n+      }\n     }\n \n     const patchedPosts = storePatch.postsByPageId[page.pageId];\n     _.each(patchedPosts || [], (patchedPost: Post) => {\n-      // RENAME to  upsertPost?\n-      updatePost(patchedPost, page.pageId);\n+      // SHOULD_OPTIMIZE — handle all posts on a page at once, otherwise [On2]+\n+      // when loading missing chat messages.\n+      const res = upsertPost(patchedPost, page.pageId);\n+\n+      upsertResults.push(res);\n     });\n \n     // The server should have marked this page as unread because of these new events.\n@@ -2049,6 +2214,8 @@ function patchTheStore(respWithStorePatch: any) {  // REFACTOR just call directl\n     }\n   }\n \n+  _showMyNewPostsIfAny(upsertResults);\n+\n   // [update_personas], here after both comments & the user's persona mode\n   // have been patched.\n   store_updatePersonaOpts(store);\n@@ -2129,6 +2296,14 @@ function showNewPage(ps: ShowNewPageParams) {\n     }\n   }\n \n+  // If using the cache, `watchbar` wasn't changed, above. Let's update it here.\n+  // But this is in fact an optimistic UI update — looks better if the watchbar topic\n+  // directly stops being highlighted (means it's unread).\n+  // The actual http request isn't sent until a tiny bit later. [upd_watchbar_has_read]\n+  // No, let's wait, let's not update it here — harder to see & fix bugs then.\n+  //if (newPage.pageId)\n+  //  watchbar_markAsRead(store.me.watchbar, newPage.pageId);\n+\n   store.me.myCurrentPageData = myData || makeNoPageData();\n \n   // Update <title> tag. Also done from the title editor [30MRVH2].\n@@ -2237,6 +2412,11 @@ function showNewPage(ps: ShowNewPageParams) {\n     }\n     else {\n       correctedUrl = pagePath + location.search + location.hash;\n+      // @ifdef DEBUG\n+      logD(`ReactStore showNewPage: ${\n+                              location.pathname + location.search + location.hash\n+                              } –> history.replace(${correctedUrl})`);\n+      // @endif\n       history.replace(correctedUrl);  // [4DKWWY0]  TyTE2EPGID2SLUG\n     }\n   }\n@@ -2375,13 +2555,25 @@ function store_updatePersonaOpts(store: Store) {\n   }\n }\n \n+// ---- Break_out_watchbar.ts file? ----\n+\n+export function watchbar_isUnread(watchbar: Watchbar, pageId: PageId): Bo {\n+  let res = false;\n+  watchbar_foreachTopic(watchbar, watchbarTopic => {\n+    if (watchbarTopic.pageId === pageId && watchbarTopic.unread)\n+      res = true;\n+      // break, but how?\n+  });\n+  return res;\n+}\n+\n \n function watchbar_markAsUnread(watchbar: Watchbar, pageId: PageId) {\n   watchbar_markReadUnread(watchbar, pageId, false);\n }\n \n \n-function watchbar_markAsRead(watchbar: Watchbar, pageId: PageId) {\n+export function watchbar_markAsRead(watchbar: Watchbar, pageId: PageId) {\n   watchbar_markReadUnread(watchbar, pageId, true);\n }\n \n@@ -2462,6 +2654,7 @@ function watchbar_copyUnreadStatusFromTo(old: Watchbar, newWatchbar: Watchbar) {\n   });\n }\n \n+// -- / Break_out_watchbar.ts file? ----\n \n function makeStranger(store: Store): Myself {\n   const stranger = {\n@@ -2664,9 +2857,13 @@ function rememberPostsToQuickUpdate(startPostId: number) {\n   }\n }\n \n+let gifferHandle: Nr | U;\n \n function stopGifsPlayOnClick() {\n-  setTimeout(window['Gifffer'], 50);\n+  if (gifferHandle)\n+    clearTimeout(gifferHandle);\n+\n+  gifferHandle = setTimeout(window['Gifffer'], 50);\n }\n \n "
    },
    {
      "sha": "9c75c6e0e230f499a1d12b6d407cbc4ba42f51ab",
      "filename": "client/app-slim/Server.ts",
      "status": "modified",
      "additions": 106,
      "deletions": 14,
      "changes": 120,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2FServer.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2FServer.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2FServer.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -678,13 +678,64 @@ interface GetOptions {\n   suppressErrorDialog?: boolean;\n   showLoadingOverlay?: true;  // default false, for GET requests\n   notFoundAs404?: true\n+  canCache?: true | ((resp: any) => any);\n+}\n+\n+\n+interface CachedResp<T> {\n+  cachedAt: WhenMs\n+  response: T\n+}\n+\n+let _queryCache: { [url: St]: CachedResp<LoadPostsResponse> } = {};\n+\n+\n+/// Call if creating / editing bookmarks, or bookmarked posts. Better call it too often\n+/// than too rarely. — Not really needed, we do reload() after logout anyway: [reload_on_logout]\n+export function clearQueryCache() {\n+  _queryCache = {};\n }\n \n \n function getAndPatchStore(uri: string, onOk?: GetSuccessFn,\n       onErr?: GetErrorFn, opts?: GetOptions): OngoingRequest {\n-  return get(uri, function(response) {\n+  let reqrIdBef: PatId | U;\n+\n+  if (opts?.canCache) {\n+    reqrIdBef = ReactStore.getMe().id;\n+    const anyCachedResp = _queryCache[uri];\n+    if (anyCachedResp) {\n+      // Make this configurable? [cache_how_long]  & feature switch in case of bugs.\n+      // And, if disconnected, do use the cached response anyway?\n+      const tooOld = anyCachedResp.cachedAt > Date.now() - 10 * Time.OneMinuteInMillis;\n+      if (!tooOld) {\n+        onOk(anyCachedResp.response);\n+        return;\n+      }\n+    }\n+  }\n+\n+  return get(uri, function(respRaw) {\n+    // `response` is optionally preprocessed, before caching (so need do just once),\n+    // while `respRaw` is the json directly from the server.\n+    let response = respRaw;\n+    if (opts?.canCache) {\n+      if (_.isFunction(opts.canCache)) {\n+        response = opts.canCache(response);\n+      }\n+      const reqrIdAft = ReactStore.getMe().id;\n+      if (reqrIdBef === reqrIdAft) {\n+        _queryCache[uri] = { cachedAt: Date.now(), response };\n+      }\n+      else {\n+        // While the request was in-flight, the human at the computer has logged in, or is\n+        // logging out. Then, don't cache — it'd be for the wrong person, or might include\n+        // too little data (if sent when logged out, response arrived when logged in).\n+      }\n+    }\n+\n     ReactActions.patchTheStore(response);\n+\n     if (onOk) {\n       onOk(response);\n     }\n@@ -1325,6 +1376,7 @@ export function deleteTempSessId() {  // [ts_authn_modl]\n \n \n export function logoutServerAndClientSide() {\n+  Server.clearQueryCache(); // [clear_q_cache]\n   const currentUrlPath = location.pathname.toString();\n   postJsonSuccess(`/-/logout?currentUrlPath=${currentUrlPath}`, (response) => {\n     const goTo = response.goToUrl !== currentUrlPath ? response.goToUrl : '';\n@@ -1648,6 +1700,7 @@ export function listDrafts(userId: UserId,\n }\n \n \n+// [to_paginate]  upToWhen —> offset: { atMs, id }  ?\n export function loadNotifications(userId: UserId, upToWhenMs: number,\n       onOk: (notfs: Notification[]) => void, error: () => void) {\n   const query = '?userId=' + userId + '&upToWhenMs=' + upToWhenMs;\n@@ -1951,7 +2004,7 @@ export function loadVoters(postId: PostId, voteType: PostVoteType,\n export function saveEdits(editorsPageId: PageId, postNr: PostNr, text: St,\n       deleteDraftNr: DraftNr, doAsAnon: MaybeAnon, onOK: () => Vo,\n       sendToWhichFrame?: MainWin) {\n-  postJson('/-/edit', {\n+  postJson('/-/edit', {  // 4greping:  edit-post\n     data: {\n       pageId: editorsPageId ||\n           // Old (as of Jan 2020), keep for a while?:\n@@ -2030,7 +2083,7 @@ export function unpinPage(success: () => void) {\n export function saveReply(editorsPageId: PageId, postNrs: PostNr[], text: string,\n       anyPostType: number, deleteDraftNr: DraftNr | undefined, doAsAnon: MaybeAnon,\n       success: (storePatch: StorePatch) => void) {\n-  postJson('/-/reply', {\n+  postJson('/-/reply', {  // 4greping:  insert-post  save-post  create-post\n     data: {\n       pageId: editorsPageId ||\n           // Old (as of Jan 2020), keep for a while?:\n@@ -2172,6 +2225,7 @@ export function submitUsabilityTestingRequest(formData: FormData) {  // [plugin]\n }\n \n \n+// A bit similar to loading a range of posts? [load_page_and_parts]\n export function loadPostByNr(postNr: PostNr, success: (patch: StorePatch) => void) {\n   get(`/-/load-post?pageId=${getPageId()}&postNr=${postNr}`, success,\n       (errorDetails: string, satus: number) => {\n@@ -2203,13 +2257,19 @@ export function loadPostByNr(postNr: PostNr, success: (patch: StorePatch) => voi\n }\n \n \n-export function loadPostsByAuthor(authorId: UserId, showWhat: 'Tasks' | U,\n-          onlyOpen: Bo, onOk: (posts: PostWithPage[]) => Vo) {\n-  const showWhatParam = showWhat ? `&relType=${PatPostRelType.AssignedTo}` : '';\n+/// Can't `showWhat` be 'Posts' too?  That works fine currently anyway.  [or_load_bokms]\n+export function loadPostsByAuthor(authorId: UserId, showWhat: 'Tasks' | 'Bookmarks' | U,\n+          onlyOpen: Bo, onOk: (posts: PostWithPage[], bookmarks: Post[]) => V) {\n+  const showWhatParam =\n+          showWhat === 'Bookmarks' ? '&postType=' + PostType.Bookmark : (\n+            showWhat === 'Tasks' ? `&relType=${PatPostRelType.AssignedTo}` :\n+            '');\n   const onlyOpenParam = onlyOpen ? '&which=678321' : '';  // for now.\n   // RENAME 'authorId' to 'relToPatId'?\n   const url = `/-/list-posts?authorId=${authorId}${showWhatParam}${onlyOpenParam}`\n-  getAndPatchStore(url, (r: LoadPostsResponse) => onOk(r.posts));\n+  // But don't want to cache recent activity for too long?! [cache_how_long]\n+  getAndPatchStore(url, (r: LoadPostsResponse) => onOk(r.posts, r.bookmarks),\n+        undefined, { canCache: true });\n }\n \n \n@@ -2383,14 +2443,22 @@ export function listCategoriesAllSections(onOk: (cats: Cat[]) => Vo)  {\n }\n \n \n-export function createPage(data, success: (newPageId: string) => void) {\n+export interface CreatePageData {\n+  categoryId?: CatId\n+  pageRole: PageType\n+  pageStatus: 'Draft' | 'Published' | 'Deleted'\n+  folder?: St\n+  pageSlug?: St\n+  pageTitle: St\n+  pageBody: St\n+  showId?: Bo\n+  deleteDraftNr?: DraftNr,\n+  doAsAnon?: { sameAnonId?: PatId, newAnonStatus?: AnonStatus }\n+}\n+\n+export function createPage(data: CreatePageData, onOk: (newPageId: St) => V) {\n   // [DRAFTS_BUG] This doesn't delete the draft? (if any)\n-  postJson('/-/create-page', {\n-    data: data,\n-    success: (response) => {\n-      success(response.newPageId);\n-    }\n-  });\n+  postJsonSuccess('/-/create-page', (resp) => onOk(resp.newPageId), data);\n }\n \n \n@@ -2406,6 +2474,7 @@ export function savePageIdsUrls(data: PageIdsUrls, onDone: () => void) {\n }\n \n \n+// [load_page_and_parts]\n export function loadPageJson(path: string, success: (response) => void) {\n   logM(`Loading page: ${path} [TyMLDPG]`);\n   get(path + '?json', response => {\n@@ -2416,6 +2485,29 @@ export function loadPageJson(path: string, success: (response) => void) {\n }\n \n \n+// [load_page_and_parts]\n+export function loadPagePartsJson(ps: {\n+    pageId: PageId,\n+    comtOrder: PostSortOrder, // not yet in use\n+    offset: PostNr,\n+    scrollDir: RangeDir,\n+    // So can remember scroll offset, before updating page.\n+    onOkBeforePatch: () => V,\n+    // So can update scroll offset after having added the new comments, so the same\n+    // comments stay in the same place after. And to update other state e.g. comment count.\n+    onOkAfterPatch: (s: Store) => V,\n+  }) {\n+  const params = `pageId=${ps.pageId}&comtOrder=${ps.comtOrder\n+                    }&offset=${ps.offset}&rangeDir=${ps.scrollDir}`;\n+  get('/-/load-many-posts?' + params, (patch: MorePostsStorePatch) => {\n+    ps.onOkBeforePatch();\n+    ReactActions.patchTheStore(patch);\n+    logM(`Done updating store.`);\n+    ps.onOkAfterPatch(debiki2.__patchedStore as Store);\n+  });\n+}\n+\n+\n export function acceptAnswer(ps: { pageId: PageId, postId: PostId, doAsAnon: MaybeAnon },\n         onOk: (answeredAtMs: Nr) => V) {\n   postJsonSuccess('/-/accept-answer', onOk, ps);"
    },
    {
      "sha": "9849d9e8bab807c18410faad26e321c93e1248db",
      "filename": "client/app-slim/links.ts",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Flinks.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Flinks.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Flinks.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -62,6 +62,11 @@ export function linkToPostNr(pageId: PageId, postNr: PostNr): string {\n }\n \n \n+export function linkToPost(post: PostWithPageId): St {\n+  return linkToPageId(post.pageId) + '#post-' + post.nr;\n+}\n+\n+\n export function linkToType(type: TagType): St {\n   return origin() + UrlPaths.Tags + (type.urlSlug || type.id);\n }"
    },
    {
      "sha": "44ecb816f032e93a06b1566d6487092bd9e96d35",
      "filename": "client/app-slim/login/login-if-needed.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Flogin%2Flogin-if-needed.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Flogin%2Flogin-if-needed.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Flogin%2Flogin-if-needed.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -100,9 +100,14 @@ function loginIfNeededImpl(loginReason: LoginReason, toHash: St, toPath: St,\n   onOk = onOk || function() {};\n   const store: Store = ReactStore.allData();\n   const me: Myself = store.me;\n+  const useLoginPopup = eds.isInIframe && eds.ssoHow !== 'RedirPage';\n \n   // No login needed, or not until later when submitting any comment?\n   if (me.isLoggedIn || (willCompose && ReactStore.mayComposeBeforeSignup())) {\n+    // ((If `!useLoginPopup`, the text in the editor would disappear,\n+    // when redirecting the whole page later when hitting Submit. However,\n+    // compose-before-signup is disabled if sso enabled:  [0_compose_bef_sso_redir],\n+    // so, not a problem.))\n     onOk();\n     return;\n   }\n@@ -127,7 +132,7 @@ function loginIfNeededImpl(loginReason: LoginReason, toHash: St, toPath: St,\n   const returnToUrl_legacy = redirFromEmailOnly ?\n             makeReturnToPageHashForVerifEmail(toHash) : returnToUrl_new;\n \n-  if (eds.isInIframe && eds.ssoHow !== 'RedirPage') {\n+  if (useLoginPopup) {\n     // TESTS_MISSING: Compose comment before logging in? Then, we'd be  TyTEMBCOMPBEFLGI\n     // in the *editor* iframe, now, rather than the *comments* iframe.\n "
    },
    {
      "sha": "308e88d4c6fda8674ac3d1717efe2cc155c9c983",
      "filename": "client/app-slim/model.ts",
      "status": "modified",
      "additions": 107,
      "deletions": 9,
      "changes": 116,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fmodel.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fmodel.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fmodel.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -371,6 +371,7 @@ interface ShowPostOpts extends ScrollIntoViewOpts {\n }\n \n \n+// impls: `export const Post` in ./page/discussion.ts\n interface Post {\n   // Client side only ------\n   // [drafts_as_posts] Later, the drafts3 table will get deleted, and drafts moved to\n@@ -388,6 +389,9 @@ interface Post {\n   isEditing?: boolean;\n   // -----------------------\n \n+  // Needed if we're rendering a post from another page, e.g. a bookmarked post in the sidebar.\n+  pageId?: PageId\n+\n   uniqueId: PostId; // CLEAN_UP RENAME to id\n   nr: PostNr;\n   parentNr?: PostNr; // undefined, for chat messages and sometimes embedded comments [CHATPRNT]\n@@ -429,8 +433,9 @@ interface Post {\n   pinnedPosition: number;\n   branchSideways: number;\n   likeScore: number;\n-  childNrsSorted: number[];\n-  // For titles, we insert the post source, as text (no html in titles).\n+  childNrsSorted: PostNr[];\n+  bookmarkNrs?: PostNr[];\n+  // For titles and bookmarks, we insert the post source, as text (no html in titles).\n   // And for drafts, we show a <pre>the-source</pre>, for now. [DFTSRC]\n   unsafeSource?: string;\n   sanitizedHtml?: string;\n@@ -449,8 +454,12 @@ const enum WritingWhat {\n }\n \n \n-interface PostWithPage extends Post {\n+interface PostWithPageId extends Post {\n   pageId: PageId;\n+}\n+\n+\n+interface PostWithPage extends PostWithPageId {\n   pageTitle: string;\n   pageRole: PageRole;\n }\n@@ -492,6 +501,7 @@ interface MyPageData {\n   readingProgress?: ReadingProgress;\n   votesByPostNr: { [postNr: PostNr]: Vote[] };\n   internalBacklinks?: Topic[];\n+  // This includes bookmarks and private comments (none of which needs to be approved).\n   unapprovedPosts: { [id: number]: Post };\n   unapprovedPostAuthors: Participant[];\n   knownAnons?: KnownAnonym[];\n@@ -819,6 +829,7 @@ interface Cat extends DiscPropsSource {\n   defaultTopicType: PageRole;\n   newTopicTypes?: PageRole[];  // [refactor] [5YKW294] delete, use defaultTopicType instead\n   doItVotesPopFirst?: Bo;\n+  // Always included by the server. Remove '?'?\n   position?: number;\n   description: string;    // from the about category topic\n   thumbnailUrl?: string;  // from the about category topic\n@@ -838,10 +849,10 @@ interface CategoryPatch extends Category {  // or Partial<Category>?\n \n \n \n-interface TagType {\n-  id: TagTypeId;\n+interface TagType {       // RENAME to Type\n+  id: TagTypeId;          // RENAME to TypeId\n   refId?: RefId;\n-  canTagWhat: ThingType;\n+  canTagWhat: ThingType;  // RENAME & CHANGE to thingKind: KindOfThing? [ThingKind]\n   dispName: St;\n   urlSlug?: St;\n   wantsValue?: NeverAlways;\n@@ -865,6 +876,7 @@ interface Tag {\n   tagTypeId: TagTypeId;\n   onPatId?: PatId;\n   onPostId?: PostId;\n+  //order?: Nr; — maybe later, if some tags more interesting, nice to show first?\n   valType?: TypeValueType;\n   valInt32?: Nr;\n   valFlt64?: Nr;\n@@ -1113,7 +1125,7 @@ interface Page\n   numPostsRepliesSection: number;  // CLEAN_UP REMOVE server side too  [prgr_chat_sect]\n   numPostsChatSection: number;     // REMOVE, don't: change and rename to numProgressPosts  [prgr_chat_sect]\n   numPostsExclTitle: number;\n-  postsByNr: { [postNr: number]: Post };\n+  postsByNr: { [postNr: number]: Post };  // REFACTOR use Store.postsByNrByPage instead?\n   parentlessReplyNrsSorted: number[];\n   progressPostNrsSorted: number[];\n   horizontalLayout: boolean;\n@@ -1229,6 +1241,13 @@ interface DiscStore extends SessWinStore {\n   usersByIdBrief: { [userId: number]: Pat };  // = PatsById\n   pagesById: { [pageId: string]: Page };\n \n+  // Here, so can always render tags.\n+  tagTypesById?: TagTypesById;\n+\n+  // Sometimes we have posts but not pages, e.g. when listing bookmarks or sbd's recent\n+  // activity — then, we get individual posts from different pages.\n+  //postsByNrByPage_later: { [pageId: PageId]: { [postNr: PostNr]: Post } };\n+\n   // Derived client side from: MyPageData.myPersonas and Me.usePersona.\n   curPersonaOptions?: PersonaOptions  // ? move to SessWinStore ?\n   curDiscProps?: DiscPropsDerived\n@@ -1321,7 +1340,7 @@ interface Store extends Origins, DiscStore, PartialEditorStoreState {\n \n   debugStartPageId: string;\n \n-  tagTypesById?: TagTypesById;\n+  // Not in DiscStore, since only needed on the all-tags page (that's not a discussion page).\n   tagTypeStatsById?: { [tagTypeId: number]: TagTypeStats };\n \n   superadmin?: SuperAdminStuff;\n@@ -2256,7 +2275,9 @@ interface StorePatch\n \n   listingCatId?: CatId;\n \n-  pageVersionsByPageId?: { [pageId: string]: PageVersion };\n+  ignorePageVersion?: true;  // Either this or ...\n+  pageVersionsByPageId?: { [pageId: string]: PageVersion };  // ... this, but not both.\n+\n   postsByPageId?: { [pageId: string]: Post[] };\n \n   pageMetasBrief?: PageMetaBrief[];\n@@ -2307,6 +2328,14 @@ interface PageTweaksStorePatch {\n   curPageTweaks?: Partial<Page>;\n }\n \n+interface MorePostsStorePatch extends TagTypesStorePatch, PatsStorePatch {\n+  ignorePageVersion: true;\n+  pageVersionsByPageId: undefined;\n+  postsByPageId: { [pageId: string]: Post[] };\n+  patsBrief: Pat[];\n+  tagTypes: TagType[];\n+}\n+\n \n interface AuthnDiagConf {\n   // Config format version 0. Maybe that'll be enough forever.\n@@ -2664,6 +2693,71 @@ interface ChangePageDiagParams {\n }\n \n \n+/// For rendering a comment and its descendants.\n+interface ThreadProps {\n+  store: Store\n+  rootPostId?: PostNr // is in fact the pots *nr*\n+  post: Post\n+  postId?: PostId // is in fact the post *nr*. Try to remove [349063216].\n+  index?: Nr  // isn't required?\n+  depth: Nr\n+  indentationDepth: Nr\n+  isFlat?: Bo\n+  is2dTreeColumn?: Bo\n+\n+  elemType: 'div' | 'li'\n+  key?: Nr | St\n+}\n+\n+\n+/// For rendering a comment or meta post.\n+interface PostProps {\n+  store: Store\n+  post: Post\n+  postId?: PostId // is in fact the post *nr*. Try to remove [349063216].\n+  author?: BriefUser\n+  index?: Nr  // isn't required?\n+  depth?: Nr  // not needed when rendering in a flat list\n+  isFlat?: Bo\n+  is2dTreeColumn?: Bo\n+  renderCollapsed?: Bo\n+  abbreviate?: St\n+\n+  // In the todo lists, we skip bookmark icon — bookmarks are shown on a line\n+  // above instead, including any bookmark note and page name.\n+  inTodoList?: true\n+\n+  onClick?: () => V\n+  onMouseEnter?: () => V\n+  className?: St\n+\n+  // For PostHeaderProps:\n+  live?: Bo\n+  exactTime?: Bo\n+  stuffToAppend?: any; // RElm\n+  // onMarkClick?: () => V\n+}\n+\n+\n+/// For rendering the \"Author-Name [times] [bookmark] [tags] ...\"\n+/// line above each comment, and below the page title.\n+interface PostHeaderProps {\n+  store: Store\n+  post: Post\n+  depth?: Nr\n+  author?: BriefUser\n+  isFlat?: Bo\n+  is2dTreeColumn?: Bo\n+  abbreviate?: St\n+  inTodoList?: true\n+\n+  live?: Bo\n+  exactTime?: Bo\n+  stuffToAppend?: any; // RElm\n+  // onMarkClick?: () => V\n+}\n+\n+\n interface PatPanelProps {\n   me: Me;\n   store: Store;\n@@ -2677,6 +2771,7 @@ interface PatStatsPanelProps extends PatPanelProps {\n \n \n interface PatPostsPanelProps extends PatPanelProps {\n+  // Or 'Bookmarks'?  [or_load_bokms]\n   showWhat?: 'Posts' | 'Tasks';  // Posts is the default\n   /// If true, tasks that's been done or closed, are excluded.\n   onlyOpen?: Bo;\n@@ -2763,6 +2858,7 @@ interface TagListProps {\n   forPost?: Post;\n   forPat?: Pat;\n   canEditTags?: Bo;\n+  //canAddTags?: Bo; — not impl\n  }\n \n \n@@ -2772,6 +2868,7 @@ interface TagListLiveProps {\n   forPost?: Post;\n   forPat?: Pat;\n   live?: Bo; // default true\n+  // canAddTags?: Bo; — not impl\n   onChanged?: () => Vo;  // or remove, use [useStoreEvent] instead?\n }\n \n@@ -3228,6 +3325,7 @@ type TagTypesById = { [tagTypeId: number]: TagType };\n \n interface LoadPostsResponse {\n   posts: PostWithPage[];\n+  bookmarks: PostWithPageId[];\n   storePatch: TagTypesStorePatch & PatsStorePatch;\n }\n "
    },
    {
      "sha": "b36dc39b6fc6058eb7cc8aba57eb0e3a58cd34f2",
      "filename": "client/app-slim/more-bundle-not-yet-loaded.ts",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fmore-bundle-not-yet-loaded.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fmore-bundle-not-yet-loaded.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fmore-bundle-not-yet-loaded.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -37,6 +37,13 @@ export function openTagDropdown(atRect, ps: {\n }\n \n \n+export function openBookmarkDropdown(atRect, ps) {\n+  Server.loadMoreScriptsBundle(() => {\n+    tags.openBookmarkDropdown(atRect, ps);\n+  });\n+}\n+\n+\n export function openDropdown(ps: ProxyDiagParams, childrenFn: (close: () => V) => RElm) {\n   Server.loadMoreScriptsBundle(() => {\n     morekit.openProxyDiag(ps, childrenFn);\n@@ -248,7 +255,7 @@ var LazyMoreBundleComponent = createComponent({\n     return { bundleLoaded: false };\n   },\n \n-  UNSAFE_componentWillMount: function() {\n+  componentDidMount: function() {\n     Server.loadMoreScriptsBundle(() => {\n       if (this.isGone) return;\n       this.setState({ bundleLoaded: true });\n@@ -269,6 +276,15 @@ var LazyMoreBundleComponent = createComponent({\n \n \n \n+export function ToDos(props) { //: ToDosProps\n+  return LazyMoreBundleComponent({\n+    lazyContent: function() {\n+      return debiki2.todos.ToDos(props)\n+    }\n+  });\n+}\n+\n+\n export function TitleEditor(editorProps) {\n   return LazyMoreBundleComponent({\n     lazyContent: function() {"
    },
    {
      "sha": "ca21ceb25c4f8ec55822d84ea9f659d0d20f4894",
      "filename": "client/app-slim/oop-methods.ts",
      "status": "modified",
      "additions": 26,
      "deletions": 2,
      "changes": 28,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Foop-methods.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Foop-methods.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Foop-methods.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -564,6 +564,10 @@ export function post_isWiki(post: Post): boolean {\n   return post.postType === PostType.CommunityWiki;\n }\n \n+export function post_isPrivate(post: Post): Bo {  // [priv_comts]\n+  return post.nr <= PostNrs.MaxPrivateNr;\n+}\n+\n export function post_isDeleted(post: Post): boolean {   // dupl code [2PKQSB5]\n   return post.isPostDeleted || post.isTreeDeleted;\n }\n@@ -950,6 +954,14 @@ export function store_curPage(store: Store): Page | U {\n }\n \n \n+/// Returns the page that includes `post`. If page not yet loaded, then, creates\n+/// a dummy page with its id being `post.pageId`.\n+export function store_pageWith(store: DiscStore, post: Post): Page {\n+  const page: Page | U = !post.pageId ? store.currentPage : store.pagesById[post.pageId];\n+  return page || makeAutoPage(post.pageId);\n+}\n+\n+\n export function store_mainSiteSection(store: Store): SiteSection {\n   // Currently there's always just one sub site, namely the forum. [subcomms]\n   // Edit: Actually, there're some old sites, with many sub sites — they\n@@ -1074,6 +1086,9 @@ export function store_mayIReply(store: Store, post: Post): boolean {\n   if (post_isDeletedOrCollapsed(post) || !post.isApproved)\n     return false;\n \n+  // Later: If posting a private comment [priv_comts],  that's ok if one can\n+  // see the page (even if one may not reply publicly).\n+\n   // ----- Page member?\n \n   if (me_isPageMember(me, page))\n@@ -1433,7 +1448,7 @@ export function store_makePostForDraft(authorId: PatId, draft: Draft): Post | Nl\n \n export function post_makePreviewIdNr(parentNr: PostNr, newPostType: PostType): PostNr & PostId {\n   // So won't overlap with post nrs and ids.\n-  const previewOffset = -1000 * 1000;\n+  const previewOffset = -1000 * 1000;  // [preview_id_nr_lt_0]\n   const previewPostIdNr =\n       previewOffset -\n       // We create one preview posts, per parent post we're replying to, so\n@@ -1957,6 +1972,12 @@ function deriveLayoutImpl(page: PageDiscPropsSource, cat: Cat, store: DiscStore,\n }\n \n \n+export function page_unsafeTitle(page: Page): St | U {\n+  const titlePost: Post = page.postsByNr[TitleNr];\n+  return titlePost?.unsafeSource;\n+}\n+\n+\n export function page_isClosedUnfinished(page: Page | Topic): Bo {\n   return page_isClosed(page) && !page_isSolved(page) && !page_isDone(page);\n }\n@@ -2103,7 +2124,10 @@ export function page_mostRecentPostNr(page: Page): number {\n   // Related to: [fetch_alias]\n   let maxNr = -1;\n   _.values(page.postsByNr).forEach((post: Post) => {  // COULD use _.reduce instead\n-    maxNr = Math.max(post.nr, maxNr);\n+    // Maybe skip meta posts? At least skip private posts (one's bookmarks and, later, drafts).\n+    if (post.nr >= PostNrs.MinPublicNr) {\n+      maxNr = Math.max(post.nr, maxNr);\n+    }\n   });\n   // @ifdef DEBUG\n   dieIf(maxNr < TitleNr, 'TyE5FKBQATS');"
    },
    {
      "sha": "2f7d09f14350918ea099413a3a82e71cbc27327b",
      "filename": "client/app-slim/page/chat.ts",
      "status": "modified",
      "additions": 218,
      "deletions": 9,
      "changes": 227,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fchat.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fchat.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fchat.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2016, 2017 Kaj Magnus Lindberg\n+ * Copyright (c) 2016, 2017, 2024 Kaj Magnus Lindberg\n  *\n  * This program is free software: you can redistribute it and/or modify\n  * it under the terms of the GNU Affero General Public License as\n@@ -69,6 +69,17 @@ export const ChatMessages = createComponent({\n \n \n \n+interface TitleAndChatMsgsState {\n+  lastEndDir?: RangeDir\n+  numMsgsInMem?: Nr\n+  skipTopUntil?: Nr\n+  hasScrolledDown?: Bo\n+}\n+\n+const maxToShow = 100; // [max_chat_msgs_2_show]\n+const batchSize = 20;\n+\n+\n const TitleAndLastChatMessages = createComponent({\n   displayName: 'TitleAndLastChatMessages',\n \n@@ -79,6 +90,42 @@ const TitleAndLastChatMessages = createComponent({\n   componentDidMount: function() {\n     this.scrollDown();\n     this.setState({ hasScrolledDown: true });\n+\n+    const observer = new IntersectionObserver((entries: IntersectionObserverEntry[],\n+          _obsInit: IntersectionObserverInit) => {\n+      logD(`In observer clbk, ${entries.length} entries.`)\n+      let isAtTop = false;\n+      let isAtBottom = false;\n+      for (let e of entries) {\n+        if (!e.isIntersecting) continue;\n+        if (e.target.className.indexOf('c_Chat_Top') >= 0) isAtTop = true;\n+        if (e.target.className.indexOf('c_Chat_Bottom') >= 0) isAtBottom = true;\n+      }\n+      logD(`isAtTop: ${isAtTop}, bottom: ${isAtBottom}`);\n+      if (isAtTop !== isAtBottom) {\n+        // Later: If showing recent first, then flip Older/Newer.\n+        // COULD_OPTIMIZE: This makes us try to load new messages, if scrolling up a tiny\n+        // bit from the bottom, and then down. But that's unnecessary — chat msgs should\n+        // be pushed via websocket. Only if one has been disconnected for a while\n+        // does loading-more make sense?\n+        this.showMoreMessages(isAtTop ? RangeDir.Older : RangeDir.Newer);\n+      }\n+    }, {\n+      root: null, // means the viewport\n+      rootMargin: '0px',\n+      threshold: 0.01, // that's 1%\n+    });\n+\n+    observer.observe(this.refs.topRef);\n+    observer.observe(this.refs.bottomRef);\n+    this.observer = observer;\n+  },\n+\n+  componentWillUnmount: function() {\n+    this.isGone = true;\n+    if (this.observer) {\n+      this.observer.disconnect();\n+    }\n   },\n \n   UNSAFE_componentWillUpdate: function() {\n@@ -99,39 +146,185 @@ const TitleAndLastChatMessages = createComponent({\n     pageColumn.scrollTop = pageColumn.scrollHeight;\n   },\n \n+  showMoreMessages: function (scrollDir: RangeDir) {\n+    logD(`showMoreMessages(${scrollDir})`);\n+    const state: TitleAndChatMsgsState = this.state;\n+    const store: Store = this.props.store;\n+    const afterNr = scrollDir === RangeDir.Newer ? this.newestShownNr : this.oldestShownNr;\n+    let afterRectBef: Rect;\n+\n+    // Currently chat messages are always chronological, so up = older.\n+    const scrollingUp = scrollDir === RangeDir.Older;\n+    const scrollingDown = scrollDir === RangeDir.Newer;\n+\n+    const hasMoreInMem = _.isNumber(state.skipTopUntil);\n+\n+    if (hasMoreInMem) {\n+      // Note that scrollDir is +-1.\n+      const newSkipTopUntil = state.skipTopUntil + scrollDir * batchSize;\n+      const newSkipBottomAfter = newSkipTopUntil + maxToShow;\n+      const needLoadMore = scrollingUp && newSkipTopUntil <= 0 ||\n+                            scrollingDown && newSkipBottomAfter >= state.numMsgsInMem;\n+\n+      if (!needLoadMore) {\n+        const newState: Partial<TitleAndChatMsgsState> = {\n+          lastEndDir: scrollDir,\n+          skipTopUntil: newSkipTopUntil,\n+        };\n+        rememberScrollTop();\n+        this.setState(newState);\n+        // Adjust scrollTop so all messages stay at the same position in the viewport.\n+        // (Otherwise can be hard to see what happens, or look jerky.)\n+        requestAnimationFrame(updateScrollTop);\n+        return;\n+      }\n+    }\n+\n+    const offset = afterNr + scrollDir; // skips one (we have it already)\n+\n+    // Posts with lower numbers are the title, orig post and private posts (e.g. bookmarks).\n+    if (offset < PostNrs.FirstReplyNr && scrollingUp)\n+      return;\n+\n+    // This patches the store (adds more chat messages), and adjusts the scroll\n+    // position so the chat messages already visible stay in the same positions.\n+    Server.loadPagePartsJson({ pageId: store.currentPageId,\n+          comtOrder: PostSortOrder.OldestFirst, // always, for chats\n+          offset,\n+          scrollDir,\n+          onOkBeforePatch: rememberScrollTop,\n+          onOkAfterPatch: (patchedStore: Store) => {\n+            if (this.isGone) return;\n+\n+            // If there are really many chat messages, don't render all (or the browser might\n+            // get sluggish). 100 is a guess, maybe 500 is fine or 50 is a lot on mobiles?\n+            const page: Page = patchedStore.currentPage;\n+            let numMsgsInMem = 0;\n+            _.each(page.postsByNr, (post: Post) => {\n+              if (post.nr >= PostNrs.FirstReplyNr) numMsgsInMem += 1;\n+            });\n+\n+            // If we loaded so many messages so there's now too many to show all at once\n+            // (for performance reasons), then, if we're scrolling up, skip the messages\n+            // at the bottom. If scrolling down, skip the ones at the top.\n+            //\n+            // This assumes that we don't load so many messages from the server so the ones\n+            // previously visible on screen gets skipped (because of `maxToShow`). We load\n+            // only 25, see [chat_pagination_size], that's much smaller than `maxToShow`.\n+            //\n+            let skipTopUntil = null;\n+            if (numMsgsInMem > maxToShow) {\n+              if (scrollDir === RangeDir.Older) {\n+                // Scrolling up. Render all messages we just loaded, they'll be at the top. \n+                // (But we won't render the `numMsgsInMem - maxToShow` messages at the bottom.)\n+                skipTopUntil = 0;\n+              }\n+              else {\n+                // Scrolling down. Skip the \"too many\" messages at the top, but render\n+                // all messages at the bottom (those are the ones we just loaded).\n+                skipTopUntil = numMsgsInMem - maxToShow;\n+              }\n+            }\n+\n+            // Remember the scroll direction, so, if there are too many messages,\n+            // we know if we should hide messages at the top, or bottom, so there\n+            // will be fewer to render.\n+            // (Here we still haven't rerendered the page; we can still edit the\n+            // state, to affect the next rendering ..._ctd)\n+            const newState: Partial<TitleAndChatMsgsState> = {\n+              lastEndDir: scrollDir,\n+              numMsgsInMem,\n+              skipTopUntil,\n+            };\n+            this.setState(newState);\n+            requestAnimationFrame(updateScrollTop);\n+    }});\n+\n+    function rememberScrollTop() {\n+      if (this.isGone) return;\n+      // (The elem might be outside the viewport, fine.)\n+      const afterElm = document.getElementById('post-' + afterNr);\n+      afterRectBef = afterElm && afterElm.getBoundingClientRect();\n+    }\n+\n+    function updateScrollTop() {\n+      // (_ctd... But here, the page has been rerendered — however, the screen has\n+      // not yet been repainted (right?), so we can adjust the scroll position\n+      // without any flash-of-wrong-scroll-position.)\n+      if (this.isGone) return;\n+      const afterElm2 = document.getElementById('post-' + afterNr);\n+      if (!afterRectBef || !afterElm2) return;\n+      const afterRectAft = afterElm2.getBoundingClientRect();\n+      const pageColumn = document.getElementById('esPageColumn');\n+      const jumpedDownDist = afterRectAft.top - afterRectBef.top;\n+      pageColumn.scrollTop = pageColumn.scrollTop + jumpedDownDist;\n+    }\n+  },\n+\n   render: function () {\n+    const state: TitleAndChatMsgsState = this.state;\n     const store: Store = this.props.store;\n     const page: Page = store.currentPage;\n     const title = Title({ store }); // later: only if not scrolled down too far\n \n     const originalPost = page.postsByNr[store.rootPostId];\n     const origPostAuthor = store.usersByIdBrief[originalPost.authorId];\n-    const origPostHeader = PostHeader({ store, post: originalPost });\n+    //const origPostHeader = PostHeader({ store, post: originalPost });\n     const origPostBody = PostBody({ store, post: originalPost });\n     let canScrollUpToFetchOlder = true;\n \n+    let oldestShownNr = Number.MAX_SAFE_INTEGER;\n+    let newestShownNr = PostNrs.FirstReplyNr - 1;\n+\n+    const skipBottomAfter = _.isNumber(state.skipTopUntil) ?\n+            state.skipTopUntil + maxToShow : Number.MAX_SAFE_INTEGER;\n+\n+    // Chat messages don't have any parent post, aren't replies to the OP. [CHATPRNT]\n     const messages = [];\n+    let ix = 0;\n+\n     _.each(page.postsByNr, (post: Post) => {\n-      if (post.nr === TitleNr || post.nr === BodyNr) {\n-        // We show the title & body elsewhere.\n+\n+      // Skip title & body (they're shown as title & description instead),\n+      // and bookmarks (shown in message headers instead)\n+      // and private comments (not impl). [priv_comts]\n+      // But show previews of new messages — they have negative nrs [preview_id_nr_lt_0].\n+      if (post.nr < PostNrs.FirstReplyNr && !(post.isPreview && post.nr < 0))\n         return;\n+\n+      ix += 1;\n+      if (ix < state.skipTopUntil || skipBottomAfter < ix)\n+        return;\n+\n+      if (!post.isPreview) {\n+        if (post.nr < oldestShownNr)\n+          oldestShownNr = post.nr;\n+\n+        if (post.nr > newestShownNr)\n+          newestShownNr = post.nr;\n       }\n+\n       if (post.isPostDeleted) {\n         messages.push(DeletedChatMessage({ key: post.uniqueId, store: store, post: post }));\n         return;\n       }\n+\n       if (post.nr === FirstReplyNr) {\n         // (COULD make this work also if post nr FirstReplyNr has been moved to another page\n         // and hence will never be found. Fix by scrolling up, noticing that nothing was found,\n         // and remove the you-can-scroll-up indicator?)\n         canScrollUpToFetchOlder = false;\n       }\n+\n       const postProps = { key: post.uniqueId, store, post };\n       const postElem =\n           post.postType === PostType.MetaMessage ? MetaPost(postProps) : ChatMessage(postProps);\n       messages.push(postElem);\n     });\n \n+    this.oldestShownNr = oldestShownNr;\n+    this.newestShownNr = newestShownNr;\n+\n     if (!messages.length) {\n       canScrollUpToFetchOlder = false;\n     }\n@@ -143,14 +336,29 @@ const TitleAndLastChatMessages = createComponent({\n           \", \", timeExact(originalPost.createdAtMs));\n \n     let perhapsHidden;\n-    if (!this.state.hasScrolledDown) {\n+    if (!state.hasScrolledDown) {\n       // Avoid flash of earlier messages before scrolling to end.\n       perhapsHidden = { display: 'none' };\n     }\n \n-    const scrollUpTips = !canScrollUpToFetchOlder ? null :\n-      r.div({ className: 'esChat_scrollUpTips' },\n-        t.c.ScrollUpViewComments, r.br(), t.NotImplemented);\n+    // When the chat top or bottom elems scroll into view, we'll load more messages from\n+    // the server.\n+    // When can't scroll (because not many messages), don't remove them, just set\n+    // visibility: hidden — otherwise the IntersectionObserver won't work.\n+    const visHidden = { visibility: 'hidden' };\n+    const hideUpTips = canScrollUpToFetchOlder ? undefined : visHidden;\n+\n+    const scrollUpTips =\n+      r.div({ className: 'c_Chat_Top', ref: 'topRef', style: hideUpTips },\n+        r.button({ onClick: () => this.showMoreMessages(RangeDir.Older) },\n+          \"Loading more ...\"), // I18N & below\n+        ); // t.c.ScrollUpViewComments);\n+\n+    // Let's always hide for now, simpler.\n+    const scrollDownTips =\n+      r.div({ className: 'c_Chat_Bottom', ref: 'bottomRef', style: visHidden },\n+        r.button({ onClick: () => this.showMoreMessages(RangeDir.Newer) },\n+          \"Load more ...\"));\n \n     return (\n       r.div({ className: 'esLastChatMsgs', style: perhapsHidden },\n@@ -160,7 +368,8 @@ const TitleAndLastChatMessages = createComponent({\n           r.div({}, t.c.Purpose),\n           origPostBody),\n         scrollUpTips,\n-        messages));\n+        messages,\n+        scrollDownTips));\n   }\n });\n "
    },
    {
      "sha": "6019a92dea909b7067583df3263e26b4b695999b",
      "filename": "client/app-slim/page/discussion.ts",
      "status": "modified",
      "additions": 128,
      "deletions": 73,
      "changes": 201,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fdiscussion.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fdiscussion.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fdiscussion.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -25,6 +25,7 @@\n /// <reference path=\"metabar.ts\" />\n /// <reference path=\"../help/help.ts\" />\n /// <reference path=\"../rules.ts\" />\n+/// <reference path=\"../tags/tags.ts\" />\n /// <reference path=\"../widgets.ts\" />\n /// <reference path=\"../page-dialogs/open-share-popup.ts\" />\n /// <reference path=\"../login/login-if-needed.ts\" />\n@@ -774,18 +775,18 @@ const RootPostAndComments = createComponent({\n         return;\n \n       isSquashing = false;\n-      const threadProps: any = { store };\n-      if (isProgrPost || repliesAreFlat) {\n-        threadProps.isFlat = true;\n-      }\n \n-      threadProps.elemType = 'div';\n-      threadProps.post = child;\n-      threadProps.postId = childNr;  // CLEAN_UP should be .postNr. But use .post only? [349063216]\n-      threadProps.index = childIndex;\n-      threadProps.depth = 1;\n-      threadProps.indentationDepth = 0;\n-      threadProps.is2dTreeColumn = page.horizontalLayout;\n+      const threadProps: ThreadProps = {\n+        store,\n+        isFlat: isProgrPost || repliesAreFlat,\n+        elemType: 'div',\n+        post: child,\n+        postId: childNr,  // CLEAN_UP should be .postNr. But use .post only? [349063216]\n+        index: childIndex,\n+        depth: 1,\n+        indentationDepth: 0,\n+        is2dTreeColumn: page.horizontalLayout,\n+      };\n \n       if (child.squash) {\n         isSquashing = true;\n@@ -1103,6 +1104,8 @@ const SquashedThreads = createComponent({\n     const is2dColumnClass = this.props.is2dTreeColumn ? ' dw-2dcol' : '';\n     const postNrDebug = debiki.debug ? '  #' + post.nr : '';\n \n+    // COULD UX: Two unsquash buttons, one to unsquash from the top, another from the bottom\n+    // (depending on what part of the discussion one wants to see more of).\n     return (\n       baseElem({ className: 'dw-t dw-ts-squashed' + depthClass + indentationDepthClass +\n           is2dColumnClass },\n@@ -1129,9 +1132,13 @@ const Thread = createComponent({\n   resumeDraft: function(event) {\n     const post: Post = this.props.post;\n     event.preventDefault();\n-    // This will load our new reply draft text.\n-    // Let the reply be of the same post type as the post we're replying to. [REPLTYPE]\n-    ReactActions.composeReplyTo(post.parentNr, post.postType);\n+    // TESTS_MISSING: Logging in by clicking Resume.\n+    login.loginIfNeededReturnToPost(LoginReason.LoginToChat, post.nr, () => {\n+      // This will load our new reply draft text.\n+      // Let the reply be of the same post type as the post we're replying to. [REPLTYPE]\n+      if (this.isGone) return;\n+      ReactActions.composeReplyTo(post.parentNr, post.postType);\n+    }, true /* willCompose */);\n   },\n \n   askDeleteDraft: function(event) {\n@@ -1203,6 +1210,11 @@ const Thread = createComponent({\n           return null;\n         if (child.postType === PostType.Flat)\n           return null;\n+        if (child.postType === PostType.Bookmark) {\n+          // Can this happen — aren't they in  bookmarkNrs?\n+          debugger;\n+          return null;\n+        }\n         isSquashingChildren = false;\n \n         let childIndentationDepth = this.props.indentationDepth;\n@@ -1218,7 +1230,7 @@ const Thread = createComponent({\n         if (childrenSideways) {\n           childIndentationDepth = 0;\n         }\n-        const threadProps = _.clone(this.props);\n+        const threadProps: ThreadProps = { ...this.props };\n         threadProps.elemType = childrenSideways ? 'div' : 'li';\n         threadProps.post = child;\n         threadProps.postId = childNr;   // CLEAN_UP should be .postNr. But use .post only? [349063216]\n@@ -1227,7 +1239,7 @@ const Thread = createComponent({\n         threadProps.indentationDepth = childIndentationDepth;\n         threadProps.is2dTreeColumn = childrenSideways;\n         threadProps.key = childNr;\n-        let thread;\n+        let thread: RElm;\n         if (child.squash) {\n           isSquashingChildren = true;\n           thread = SquashedThreads(threadProps);\n@@ -1415,11 +1427,12 @@ export const Post = createComponent({\n   displayName: 'Post',\n \n   onUncollapseClick: function(event) {\n-    debiki2.ReactActions.uncollapsePost(this.props.post);\n+    const props: PostProps = this.props;\n+    debiki2.ReactActions.uncollapsePost(props.post);\n   },\n \n   onClick: function(event) {\n-    const props = this.props;\n+    const props: PostProps = this.props;\n     if (!props.abbreviate) {\n       if (props.post.isTreeCollapsed || props.post.isPostCollapsed) {\n         this.onUncollapseClick(event);\n@@ -1440,28 +1453,33 @@ export const Post = createComponent({\n     // debiki2.ReactActions.markPostAsRead(this.props.post.nr, true);\n   },\n \n-  onMarkClick: function(event) {\n+  /* Not currently needed, with the new bookmarks. Maybe will add back one day?\n+   * so let's keep for now.\n+  onMarkClick: function(event) {  // [bookmark_shapes_colors]\n     // Try to avoid selecting text:\n     event.stopPropagation();\n     event.preventDefault();\n-    debiki2.ReactActions.cycleToNextMark(this.props.post.nr);\n-  },\n+    const props: PostProps = this.props;\n+    debiki2.ReactActions.cycleToNextMark(props.post.nr);\n+  }, */\n \n   render: function() {\n-    const store: Store = this.props.store;\n-    const page: Page = store.currentPage;\n-    const post: Post = this.props.post;\n-    const me: Myself = store.me;\n+    const props: PostProps = this.props;\n+    const store: Store = props.store;\n+    const post: Post = props.post;\n     if (!post)\n       return r.p({}, '(Post missing [TyE0POST])');\n \n+    const page: Page = store_pageWith(store, post);\n+    const me: Myself = store.me;\n+\n     let pendingApprovalElem;\n     let headerElem;\n     let bodyElem;\n     let clickToExpand;\n     let clickCover;\n-    let extraClasses = this.props.className || '';\n-    const isFlat = this.props.isFlat;\n+    let extraClasses = props.className || '';\n+    const isFlat = props.isFlat;\n \n     extraClasses += post.isPreview ? ' s_P-Prvw' : '';\n     extraClasses += post_isWiki(post) ? ' s_P-Wiki' : '';\n@@ -1473,30 +1491,30 @@ export const Post = createComponent({\n       // The post doesn't yet exist, shouldn't have a real post nr.\n       dieIf(post.nr > MaxVirtPostNr, 'TyE50SKRPJAECW2');\n       // @endif\n-      bodyElem = PostBody(this.props);\n+      bodyElem = PostBody(props);\n       extraClasses += ' s_P-Prvw-NotEd';\n     }\n     else if (post_isDeleted(post)) {\n       headerElem = r.div({ className: 'dw-p-hd' }, post.isTreeDeleted ? t.d.ThreadDeld : t.d.CmntDeld);\n       extraClasses += ' s_P-Dd';\n     }\n-    else if (this.props.renderCollapsed &&\n+    else if (props.renderCollapsed &&\n         // COULD rename isTreeCollapsed since it's not always a boolean.\n         post.isTreeCollapsed !== 'Truncated') {\n       // COULD remove this way of collapsing comments, which doesn't show the first line?\n       // Currently inactive, this is dead code (!== 'Truncated' is always false).\n-      let text = this.props.is2dTreeColumn ? '' : (\n+      let text = props.is2dTreeColumn ? '' : (\n           post.isTreeCollapsed ? t.d.ClickSeeMoreComments : t.d.ClickSeeThisComment);\n-      if (debiki.debug) text +='  #' + this.props.postId;\n-      const iconClass = this.props.is2dTreeColumn ? 'icon-right-open' : 'icon-down-open';\n+      if (debiki.debug) text +='  #' + props.postId;\n+      const iconClass = props.is2dTreeColumn ? 'icon-right-open' : 'icon-down-open';\n       bodyElem =\n           r.span({}, text, r.span({ className: 'dw-a-clps ' + iconClass }));\n       extraClasses += ' dw-zd clearfix';\n     }\n     else if (!post.isApproved && !post.sanitizedHtml && !post.isPreview) {\n       // (Dupl code, for anyAvatar [503KP25])\n-      const showAvatar = this.props.depth > 1 || this.props.is2dTreeColumn;\n-      const author: BriefUser = this.props.author || // author specified here: [4WKA8YB]\n+      const showAvatar = props.depth > 1 || props.is2dTreeColumn;\n+      const author: BriefUser = props.author || // author specified here: [4WKA8YB]\n           store_getAuthorOrMissing(store, post);\n       const anyAvatar = !showAvatar ? null : avatar.Avatar({ user: author, origins: store });\n       headerElem =\n@@ -1519,13 +1537,13 @@ export const Post = createComponent({\n             onClick: this.onUncollapseClick },\n           t.d.CmtBelowPendAppr(isMine));\n       }\n-      const headerProps = _.clone(this.props);\n-      headerProps.onMarkClick = this.onMarkClick;\n+      const headerProps: PostHeaderProps = _.clone(this.props);\n+      // headerProps.onMarkClick = this.onMarkClick;\n       // For mind maps, each node is part of the article/page (rather than a comment) so skip author.\n       headerElem = page.pageRole === PageRole.MindMap ? null : PostHeader(headerProps);\n-      bodyElem = PostBody(this.props);\n+      bodyElem = PostBody(props);\n \n-      if (post.isTreeCollapsed === 'Truncated' && !this.props.abbreviate) {\n+      if (post.isTreeCollapsed === 'Truncated' && !props.abbreviate) {\n         extraClasses += ' dw-x';\n         clickToExpand = r.div({ className: 'dw-x-show' }, t.d.clickToShow);\n         clickCover = r.div({ className: 'dw-x-cover' });\n@@ -1536,8 +1554,8 @@ export const Post = createComponent({\n     // instead we draw an arrow. For flat replies, show \"In response to\" inside the header instead,\n     // that looks better (see PostHeader).\n     let replyReceivers;\n-    if (!this.props.abbreviate && !isFlat && (\n-          this.props.index > 0 || post.multireplyPostNrs.length)) {\n+    if (!props.abbreviate && !isFlat && (\n+          props.index > 0 || post.multireplyPostNrs.length)) {\n       replyReceivers = ReplyReceivers({ store, post });\n     }\n \n@@ -1571,11 +1589,11 @@ export const Post = createComponent({\n       unwantedCross = r.div({ className: 'dw-unwanted-cross' });\n     }\n \n-    const id = this.props.abbreviate ? undefined : 'post-' + post.nr;\n+    const id = props.abbreviate ? undefined : 'post-' + post.nr;\n \n     return (\n       r.div({ className: 'dw-p ' + extraClasses, id: id,\n-            onMouseEnter: this.props.onMouseEnter, onClick: this.onClick },\n+            onMouseEnter: props.onMouseEnter, onClick: this.onClick },\n         pendingApprovalElem,\n         replyReceivers,\n         headerElem,\n@@ -1592,10 +1610,11 @@ const ReplyReceivers = createComponent({\n   displayName: 'ReplyReceivers',\n \n   render: function() {\n-    const store: Store = this.props.store;\n-    const page: Page = store.currentPage;\n-    let multireplyClass = ' dw-mrrs'; // mrrs = multi reply receivers\n+    const store: DiscStore = this.props.store;\n     const thisPost: Post = this.props.post;\n+    const page: Page = store_pageWith(store, thisPost);\n+\n+    let multireplyClass = ' dw-mrrs'; // mrrs = multi reply receivers\n     let repliedToPostNrs = thisPost.multireplyPostNrs;\n     if (!repliedToPostNrs || !repliedToPostNrs.length) {\n       multireplyClass = '';\n@@ -1654,31 +1673,34 @@ export const PostHeader = createComponent({\n \n   onUserClick: function(event: Event) {\n     // Dupl code [1FVBP4E]\n-    morebundle.openAboutUserDialogForAuthor(this.props.post, event.target);\n+    const props: PostHeaderProps = this.props;\n+    morebundle.openAboutUserDialogForAuthor(props.post, event.target);\n     event.preventDefault();\n     event.stopPropagation();\n   },\n \n   onCollapseClick: function(event) {\n-    debiki2.ReactActions.collapseTree(this.props.post);\n+    const props: PostHeaderProps = this.props;\n+    debiki2.ReactActions.collapseTree(props.post);\n     event.stopPropagation();\n   },\n \n   showEditHistory: function() {\n-    morebundle.openEditHistoryDialog(this.props.post.uniqueId);\n+    const props: PostHeaderProps = this.props;\n+    morebundle.openEditHistoryDialog(props.post.uniqueId);\n   },\n \n   render: function() {\n-    const props = this.props;\n-    const store: Store = this.props.store;\n-    const page: Page = store.currentPage;\n-    const me: Myself = store.me;\n-    const post: Post = this.props.post;\n-    const abbreviate = this.props.abbreviate;\n-\n+    const props: PostHeaderProps = this.props;\n+    const store: Store = props.store;\n+    const post: Post = props.post;\n     if (!post)\n       return r.p({}, '(Post missing [DwE7IKW2])');\n \n+    const page: Page = store_pageWith(store, post);\n+    const me: Myself = store.me;\n+    const abbreviate = props.abbreviate;\n+\n     const assignees = (capitalizeClass: St = '') => !post.assigneeIds ? null :\n         r.span({ className: 'n_Asgd2' },\n           r.span({ className: 'n_Asgd2_Ttl' + capitalizeClass }, \"assigned to \"),  // I18N\n@@ -1694,7 +1716,7 @@ export const PostHeader = createComponent({\n               // How does this look? Currently always null — cannot yet [assign_comments].\n               anyAssigneesCaps);\n       }\n-      if (this.props.is2dTreeColumn || post.isTreeCollapsed || post.nr === BodyNr) {\n+      if (props.is2dTreeColumn || post.isTreeCollapsed || post.nr === BodyNr) {\n         return anyAssigneesCaps;\n       }\n       // Show a collapse button for this wiki post, but no author name because this is\n@@ -1713,10 +1735,10 @@ export const PostHeader = createComponent({\n       : null;\n \n     // (Dupl code, for anyAvatar [503KP25])\n-    const author: BriefUser = this.props.author || // author specified here: [4WKA8YB]\n+    const author: BriefUser = props.author || // author specified here: [4WKA8YB]\n         store_getAuthorOrMissing(store, post);\n     // Currently no page author avatar (looks better without). [no_op_avatar]\n-    const showAvatar = this.props.depth > 1 || this.props.is2dTreeColumn;\n+    const showAvatar = props.depth > 1 || props.is2dTreeColumn;\n     const anyAvatar = !showAvatar ? null : avatar.Avatar({ user: author, origins: store });\n \n     let editInfo = null;\n@@ -1742,14 +1764,37 @@ export const PostHeader = createComponent({\n       }\n     }\n \n-    let bookmark; /*\n-    if (true) { // me.bookmarks[post.uniqueId]) {\n-      let starClass = ' icon-bookmark-empty';\n-      bookmark =\n+    // Show a bookmark icon-button, filled, if the post is bookmarked.  [render_bookms]\n+    // (But not if we're in the todo list in the right sidebar — then a bookmark icon and\n+    // bookmark description are shown instead, above the bookmarked post.)\n+    let bookmarkBtn: RElm | U;\n+    let skipBookmarks = true;\n+    // @ifdef DEBUG\n+    skipBookmarks = false;\n+    // @endif\n+\n+    if (!skipBookmarks &&\n+          me.isAuthenticated && !post.isForDraftNr && !post.isPreview && !props.inTodoList) {\n+      const postsByNr: { [postNr: number]: Post; } = page.postsByNr;\n+      // WOULD_OPTIMIZE: Can stop the search when nr >= PostNrs.MinPublicNr.\n+      const bookmarkPosts: Post[] = _.flatMap(post.bookmarkNrs || post.childNrsSorted, (childNr) => {\n+        const child = postsByNr[childNr];\n+        return child && child.postType === PostType.Bookmark && !child.isPostDeleted ?\n+                  [child] : [];\n+      });\n+\n+      // Are the -p-mark clases below needed today?\n+      const iconClass = bookmarkPosts.length ? 'icon-bookmark' : 'icon-bookmark-empty';\n+      bookmarkBtn =\n         // The outer -click makes the click area larger, because the marks are small.\n-        r.span({ className: 's_P_H_Bm dw-p-mark-click', onClick: this.props.onMarkClick },\n-          r.span({ className: 'dw-p-mark icon-bookmark' + starClass }));\n-    } */\n+        r.span({ className: 's_P_H_Bm dw-p-mark-click',   // onClick: props.onMarkClick\n+              onClick: (event: MouseEvent) => {\n+                const atRect = cloneEventTargetRect(event);\n+                morebundle.openBookmarkDropdown(atRect, {\n+                            me, post, page, bookmarks: bookmarkPosts });\n+              }},\n+          r.span({ className: 'dw-p-mark ' + iconClass }));\n+    }\n \n     const unreadMark = !me.isLoggedIn || me_hasRead(me, post) ? null :\n         r.span({ className: 's_P_H_Unr icon-circle' });\n@@ -1763,17 +1808,17 @@ export const PostHeader = createComponent({\n \n     const isBodyPostClass = isPageBody ? ' dw-ar-p-hd' : '';\n \n-    const is2dColumn = page.horizontalLayout && this.props.depth === 1;\n+    const is2dColumn = page.horizontalLayout && props.depth === 1;\n     const collapseIcon = is2dColumn ? 'icon-left-open' : 'icon-up-open';\n-    const isFlat = this.props.isFlat;\n+    const isFlat = props.isFlat;\n     const toggleCollapsedButton =\n         is2dColumn || abbreviate || post.isTreeCollapsed || isPageBody || isFlat\n           ? null\n           : r.span({ className: 'dw-a-clps ' + collapseIcon, onClick: this.onCollapseClick });\n \n     // For flat replies, show \"In response to\" here inside the header instead,\n     // rather than above the header — that looks better.\n-    let inReplyTo;\n+    let inReplyTo: RElm | U;\n     if (abbreviate) {\n        // We'd like to show as little as possible: just an excerpt. So skip \"replies to\".\n     }\n@@ -1791,7 +1836,8 @@ export const PostHeader = createComponent({\n     const patTagList: RElm | U =\n             TagList({ className: 'n_TagL-Pat', forPat: author, store });\n     const postTagList: RElm | U =\n-            TagListLive({ className: 'n_TagL-Po', forPost: post, store, live: props.live });\n+            TagListLive({ className: 'n_TagL-Po', forPost: post, store,\n+                  live: props.inTodoList ? false : props.live });\n \n     const timeClass = 'esP_H_At';\n \n@@ -1807,15 +1853,24 @@ export const PostHeader = createComponent({\n           // COULD add \"Posted on ...\" tooltip.\n           r.span({ className: 'n_EdAt'},\n             post.isPreview ? null : (\n-              this.props.exactTime ?\n-                timeExact(post.createdAtMs, timeClass) : timeAgo(post.createdAtMs, timeClass)),\n+                // Previously, were using exact timestamps in the chat, since it tend to\n+                // upate more often, and \"10 seconds ago\" can quickly become misleading.\n+                // But now, moment.js not available. [E5F29V] \n+                //props.exactTime ? timeExact(post.createdAtMs, timeClass) : \n+\n+                // If we aren't hydrating the server's cached html, we can generate time-ago\n+                // timestamps directly. (But won't work when hydrating, since \"X time ago\"\n+                // changes all the time, wouldn't match the cached html.)  [hydrate_done]\n+                isDoneHydrating() ? r.span({ className: 'dw-ago esTimeDone' },\n+                                      debiki.prettyDuration(post.createdAtMs, Date.now())) :\n+                timeAgo(post.createdAtMs, timeClass)),\n             editInfo),\n           inReplyTo,\n           assignees(),\n           toggleCollapsedButton,\n-          bookmark,\n           unreadMark,\n-          this.props.stuffToAppend,\n+          bookmarkBtn,\n+          props.stuffToAppend,\n           ),\n         postTagList,\n         ));"
    },
    {
      "sha": "54cddabc3455f5162cdca3cd593c5c69549c1a24",
      "filename": "client/app-slim/page/hacks.ts",
      "status": "modified",
      "additions": 21,
      "deletions": 2,
      "changes": 23,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fhacks.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fhacks.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fhacks.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -47,7 +47,8 @@ let doNavigate: (url: St) => Vo = function(url: St) {\n export const ExtReactRootNavComponent = createReactClass({\n   displayName: 'ExtReactRootNavComponent',\n \n-  UNSAFE_componentWillMount: function() {\n+  getInitialState: function() {\n+    // Just init doNavigate(), not using any state.\n     doNavigate = (url: St): V | true => {\n       // this.props.location is made available by ReactRouter — we should be\n       // wrapped in a Router(..., Routes( ... )) component.\n@@ -72,12 +73,16 @@ export const ExtReactRootNavComponent = createReactClass({\n       }\n \n       // We can single-page-navigate without any page reload.\n+      // @ifdef DEBUG\n+      logD(`ExtReactRootNavComponent.getInitialState: history.push(${localPath})`);\n+      // @endif\n       this.props.history.push(localPath);\n       return true;\n \n       // (Now, ReactRouter will mount new routes and components — and they'll\n       // typically fetch json from the server.)\n     }\n+    return null;\n   },\n \n   render: function() {\n@@ -140,15 +145,29 @@ export function reactRouterLinkifyTopHeaderLinks() {\n }\n \n \n+let _processedAll = false;\n+\n export function processPosts(startElemId?: string) {\n   const startElemSelector = startElemId ? '#' + startElemId : undefined;\n-  processTimeAgo(startElemSelector);\n+\n+  // On page load, we process all posts once, to convert the server's cached ISO dates\n+  // to time-ago, e.g. \"5 hours ago\". But that's needed just once, because after we've\n+  // hydrated the html, we generate time-ago times directly instead. [hydrate_done]\n+  if (!_processedAll) {\n+    processTimeAgo(startElemSelector);\n+  }\n+\n   hideShowCollapseButtons();\n   addCanScrollHintsSoon();\n   makeMentionsInEmbeddedCommentsPointToTalkyardServer();\n   if (talkyard.postElemPostProcessor) {\n     talkyard.postElemPostProcessor(startElemId || 't_PageContent');\n   }\n+\n+  // If no specific elem, we've processed all.\n+  if (!startElemId) {\n+    _processedAll = true;\n+  }\n }\n \n "
    },
    {
      "sha": "5ed64d48ecd2bb93a7c87ab64a72081d804643cf",
      "filename": "client/app-slim/page/metabar.styl",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fmetabar.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fmetabar.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fmetabar.styl?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -16,6 +16,7 @@\n  */\n \n $paddingLeft = 12px;\n+$paddingTopBtn = 7px;\n \n // BEM name: esMB (no longer esMetabar)\n \n@@ -55,11 +56,11 @@ $paddingLeft = 12px;\n   border-right: none\n \n   .dw-cmts-tlbr-head\n-\n-    position: relative; // so dw-cmts-tlbr-open height: 100% works\n+    display: flex;\n \n     .dw-cmts-tlbr-summary\n-      padding: 7px 55px 7px $paddingLeft; // COULD extract variable, 50px [KP409f]\n+      padding: $paddingTopBtn 55px $paddingTopBtn $paddingLeft; // COULD extract var, 50px [KP409f]\n+      flex: 1;\n \n       & > li\n         display: inline-block;\n@@ -97,9 +98,10 @@ $paddingLeft = 12px;\n       .dw-page-notf-level\n         cursor: pointer\n \n+    .c_NavBs\n+      padding: $paddingTopBtn 19px $paddingTopBtn 12px;\n+\n     .dw-cmts-tlbr-open\n-      position: absolute;\n-      height: 100%;\n       width: 50px; // COULD extract variable, 50px [KP409f]\n       right: 0;\n       top: 0;"
    },
    {
      "sha": "1fabce5c720e31b5488c6fb686bbc68a54828d5b",
      "filename": "client/app-slim/page/metabar.ts",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fmetabar.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fmetabar.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fmetabar.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -71,6 +71,13 @@ export var Metabar = createComponent({\n     die('unimpl [EdE2QKT0]');  // was: d.i.showReplyFormEmbeddedComments(); [todo-emb-cmts]\n   },\n \n+  // Scrolls to & highlights the most recent comment.\n+  goToLatest: function() {\n+    const store: Store = this.state.store;\n+    const maxNr = page_mostRecentPostNr(store.currentPage);\n+    ReactActions.loadAndShowPost(maxNr);\n+  },\n+\n   onToggleDetailsClick: function() {\n     // [redux] modifying in place :-/\n     this.state.ui.showDetails = !this.state.ui.showDetails;\n@@ -113,6 +120,17 @@ export var Metabar = createComponent({\n     const nameLoginBtns = !isBlogComments ? null :\n         r.li({}, reactelements.NameLoginBtns({}));\n \n+    // A go-to-latest-comment button. People often don't open the right hand sidebar\n+    // and notice that there's a Recent tab with comments by time, descending,\n+    // but this button is visible directly.\n+    // UX:  But how make them realize they can go to the last-but-one,  [big_page_nav]\n+    // last-but-two etc too?\n+    const goToBtns = page.numPostsExclTitle <= 2 // skip if just orig post + 1 reply\n+              // and *for now*, if not logged in, so won't have to update the [renderer_version]:\n+              || !me.isLoggedIn ? null :\n+          r.div({ className: \"c_NavBs\" },\n+            Button({ className: \"c_GoLtst\", onClick: this.goToLatest }, \"Go to latest\"));\n+\n     const summaryElem =\n       r.div({ className: 'dw-cmts-tlbr-head' },\n           r.ul({ className: 'dw-cmts-tlbr-summary' },\n@@ -128,8 +146,10 @@ export var Metabar = createComponent({\n                         curPageTweaks: newLayout,\n                       });\n                     } })),\n+\n               nameLoginBtns,\n               r.li({}, notfLevelElem)),\n+          goToBtns,\n           toggleDetailsBtn);\n \n     const detailsElem = ui.showDetails"
    },
    {
      "sha": "7281d532bb84eb4438831e78ab6efa2f0ef7bb34",
      "filename": "client/app-slim/page/page.styl",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fpage.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fpage.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fpage.styl?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -7,6 +7,17 @@\n   a\n     cursor: pointer\n \n+  // When jumping between bookmarks, and pages are cached client side, new pages appear\n+  // so fast so it's hard to see what's happening. But with this fade-in animation,\n+  // it's more clear that a new page got shown, after clicking a bookmark.  [render_bookms]\n+  animation: fadeInPage 200ms ease-in-out;\n+\n+@keyframes fadeInPage\n+  from\n+    opacity: 0.2;\n+  to\n+    opacity: 1;\n+\n \n // Deleted?\n //=============================="
    },
    {
      "sha": "9dd1828aa02257327c4c349e71fcddac80cf9d66",
      "filename": "client/app-slim/page/page.ts",
      "status": "modified",
      "additions": 108,
      "deletions": 18,
      "changes": 126,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fpage.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fpage.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fpage.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -53,6 +53,20 @@ function scrollToLastPosition(pageId: PageId) {\n }\n \n \n+interface PageWithStateComponentState {\n+  store: Store\n+\n+  // What does isMaybePrevPage mean? Let's say we're in the forum. Then we click a link\n+  // to /some-page. The URL will update immediately to /some-page, and React will activate\n+  // the route to that page, i.e. this component, PageWithStateComponent.\n+  // And we'll run this code — but we haven't yet loaded the new page. The current page\n+  // is still the forum page. We'd render the forum, as a normal page, instead of as a topic list.\n+  // That'd result in \"a flash of the forum rendered incorrectly\" and doesn't look nice.\n+  // Instead, until we've loaded the new page, render nothing.\n+  isMaybePrevPage?: Bo\n+}\n+\n+\n export const PageWithStateComponent = createReactClass(<any> {\n   displayName: 'PageWithStateComponent',\n   mixins: [debiki2.StoreListenerMixin],\n@@ -70,16 +84,30 @@ export const PageWithStateComponent = createReactClass(<any> {\n \n \n   makeState: function() {\n+    // @ifdef DEBUG\n+    logD(`PageWithStateComponent.makeState`);\n+    // @endif\n     const store: Store = ReactStore.allData();\n+    const isMaybePrevPage = this._isMaybePrevPage(this.props.location, store);\n+    return { store, isMaybePrevPage } satisfies PageWithStateComponentState;\n+  },\n+\n+\n+  // When going to a new page, the url is updated before the page has been loaded. This\n+  // fn says if the `store.currentPage` is in fact the page we were showing at the *previous*\n+  // url path — then it's too soon to render the new url path (we'd show the wrong page,\n+  // possibly of a different type e.g. trying to render a forum index page\n+  // as a discussion page).\n+  //\n+  _isMaybePrevPage: function(location, store: Store): Bo | U {\n \n     // Is undef if on an embedded comments page (then, no router).\n-    const location = this.props.location;\n     if (!location)\n-      return { store };\n+      return undefined;\n \n     const curPage: Page = store.currentPage;\n     const curPagePath: St = curPage.pagePath.value;\n-    let isMaybeWrongPage = location.pathname !== curPagePath;\n+    let isMaybePrevPage = location.pathname !== curPagePath;\n \n     // We can get to here, if curPage is a *deleted* site section page  [subcomms]\n     // (e.g. a deleted forum) — because then it wouldn't be included in\n@@ -92,17 +120,24 @@ export const PageWithStateComponent = createReactClass(<any> {\n     if (isSectionPage && location.pathname.startsWith(curPagePath)) {\n       // (Maybe check if curPagePath + RoutePathLatest or RoutePathNew etc\n       // becomes pathname?)\n-      isMaybeWrongPage = false;\n+      isMaybePrevPage = false;\n     }\n \n-    return { store, isMaybeWrongPage };\n+    // @ifdef DEBUG\n+    logD(`PageWithStateComponent._isMaybePrevPage  props.location.pathname=${location.pathname\n+            } & store.currentPage.pagePath=${store.currentPage.pagePath.value\n+            }  —> isMaybePrevPage=${isMaybePrevPage}`);\n+    // @endif\n+\n+    return isMaybePrevPage;\n   },\n \n \n   componentDidMount: function() {\n-    const store: Store = this.state.store;\n+    const state: PageWithStateComponentState = this.state;\n+    const store: Store = state.store;\n     ReactActions.maybeLoadAndShowNewPage(store, this.props.history, this.props.location);\n-    if (!this.state.isMaybeWrongPage) {\n+    if (!state.isMaybePrevPage) {\n       scrollToLastPosition(store.currentPageId);\n     }\n   },\n@@ -114,19 +149,65 @@ export const PageWithStateComponent = createReactClass(<any> {\n       return;\n \n     // If we're about to show another page, remember the current page's scroll offset.\n-    const store: Store = this.state.store;\n+    const state: PageWithStateComponentState = this.state;\n+    const store: Store = state.store;\n     const nextUrlPath = nextProps.location.pathname;\n     if (nextUrlPath !== location.pathname && !urlPath_isToPageId(nextUrlPath, store.currentPageId)) {\n       rememberScrollPosition(store.currentPageId);\n     }\n \n+    // @ifdef DEBUG\n+    logD(`PageWithStateComponent.UNSAFE_componentWillReceiveProps  props.location.pathname=${\n+            location.pathname\n+            }  state.store.currentPage.pagePath.value=${store.currentPage.pagePath.value\n+            }  state.isMaybePrevPage=${state.isMaybePrevPage\n+            }  nextProps.location.pathname=${nextProps.location.pathname}\n+        calling ReactActions.maybeLoadAndShowNewPage ...`);\n+    // @endif\n+\n     ReactActions.maybeLoadAndShowNewPage(store, this.props.history, location, nextProps.location);\n+\n+    // @ifdef DEBUG\n+    logD(`... ReactActions.maybeLoadAndShowNewPage done.`);\n+    // @endif\n   },\n \n \n+  /* Never called. Needs to be static, but this is not a class.\n+   * Using componentDidUpdate() just below, instead.\n+  getDerivedStateFromProps: function(props, state) {\n+    logD(`PageWithStateComponent.getDerivedStateFromProps`);\n+    const isMaybePrevPage = this._isMaybePrevPage(props.location, state.store);\n+    return { isMaybePrevPage };\n+  }, */\n+\n+\n   componentDidUpdate: function(oldProps, oldState) {\n-    const store: Store = this.state.store;\n-    if (this.scrollPageId !== store.currentPageId && !this.state.isMaybeWrongPage) {\n+    const state: PageWithStateComponentState = this.state;\n+    // @ifdef DEBUG\n+    logD(`PageWithStateComponent.componentDidUpdate  props.location.pathname=${\n+        this.props.location?.pathname\n+        }  state.store.currentPage.pagePath.value=${state.store.currentPage.pagePath.value\n+        }  state.isMaybePrevPage=${state.isMaybePrevPage}`);\n+    // @endif\n+\n+    // Have we loaded the new page, so store.currentPage is the page for the new url path?\n+    const isMaybePrevPage = this._isMaybePrevPage(this.props.location, state.store);\n+    if (state.isMaybePrevPage && isMaybePrevPage === false) {\n+      // Now `store.currentPage` matches the current url path.\n+      // @ifdef DEBUG\n+      logD(`PageWithStateComponent.componentDidUpdate setState({ isMaybePrevPage: false })`);\n+      // @endif\n+      this.setState({ isMaybePrevPage: false });\n+\n+      // Wait until the page has been rendered, before updating the scroll position.\n+      // (Otherwise the page might be too short; the scroll position would be truncated.)\n+      return;\n+    }\n+\n+    // Update scroll position, but just once after a navigation.\n+    const store: Store = state.store;\n+    if (this.scrollPageId !== store.currentPageId && !state.isMaybePrevPage) {\n       this.scrollPageId = store.currentPageId;\n       const hash = location.hash;\n       // Magic hash params start with &, like &param=value or &debug. [2FG6MJ9]\n@@ -156,22 +237,27 @@ export const PageWithStateComponent = createReactClass(<any> {\n \n \n   componentWillUnmount: function() {\n+    // @ifdef DEBUG\n+    logD(`PageWithStateComponent.componentWillUnmount`);\n+    // @endif\n     // Close any [scroll locally on the current page] scroll dialog the user might\n     // have opened — we're leaving the current page.\n     page.closeAnyScrollButtons();\n   },\n \n \n   render: function() {\n-    // 1. What does isMaybeWrongPage mean? Let's say we're in the forum. Then we click a link\n-    // to /some-page. The URL will update immediately to /some-page, and React will activate\n-    // the route to that page, i.e. this component, PageWithStateComponent.\n-    // And we'll run this code — but we haven't yet loaded the new page. The current page\n-    // is still the forum page. We'd render the forum, as a normal page, instead of as a topic list.\n-    // That'd result in \"a flash of the forum rendered incorrectly\" and doesn't look nice.\n-    // Instead, until we've loaded the new page, render nothing.\n+    const state: PageWithStateComponentState = this.state;\n+    // @ifdef DEBUG\n+    logD(`PageWithStateComponent.render  isMaybePrevPage=${state.isMaybePrevPage}`);\n+    // @endif\n+\n+    // 1. If `store.currentPage` is still from the previous url path, don't render\n+    // anything yet — we'd render the wrong (previous) page using React components\n+    // for the new url, which might look funny (e.g. trying to render a topic list\n+    // as a discussion page with comments).\n     // 2. About ...this.props: That sends router props to the new page.\n-    return this.state.isMaybeWrongPage ? null : Page({ store: this.state.store, ...this.props });\n+    return state.isMaybePrevPage ? null : Page({ store: state.store, ...this.props });\n   }\n });\n \n@@ -222,6 +308,10 @@ const Page = createComponent({\n     const compactClass = this.state.useWideLayout ? '' : ' esPage-Compact'; // BUG React rendering: Was missing server side, present in browser\n     const pageTypeClass = ' s_PT-' + page.pageRole;  // REFACTOR place here: [5J7KTW2] instead\n     const isChat = page_isChat(page.pageRole);\n+    // @ifdef DEBUG\n+    logD(`Page.render  page id: ${page.pageId}`);\n+    // @endif\n+\n     return rFragment({},\n       isChat ? r.div({ id: 'theChatVspace' }) : null,\n       r.div({ className: 'esPage' + compactClass + pageTypeClass },"
    },
    {
      "sha": "3ddbe7737eee725ddeaa612615e5e292ce89745d",
      "filename": "client/app-slim/page/posts-read-tracker.ts",
      "status": "modified",
      "additions": 19,
      "deletions": 3,
      "changes": 22,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fposts-read-tracker.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fposts-read-tracker.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fposts-read-tracker.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -158,6 +158,8 @@ function sendAnyRemainingDataWithBeacon(unloadEventIgnored) {\n }\n \n \n+// COULD_OPTIMIZE: Send this data together with the next track-reading-activity request\n+// instead.  [batch_track_reading_reqs]\n export function sendAnyRemainingData(success: () => void | null) {\n   let skip = false;\n   if (talksWithSererAlready) {\n@@ -292,7 +294,11 @@ function trackReadingActivity() {\n   let millisSinceLastReport = nowMs - lastReportedToServerAtMs;\n   let millisSinceFirstNewRead = nowMs - firstUnreportedPostReadAtMs;\n \n-  if (!talksWithSererAlready &&\n+  // We don't send an  update-watchbar-mark-page-read  request until  [upd_watchbar_has_read]\n+  // here, when we can include a bit more data in the same request. More efficient.\n+  const pageIsUnreadInWatchbar = watchbar_isUnread(me.watchbar, page.pageId);\n+\n+  const timeToTrackReading =\n       // It's undef, if haven't looked at the page for long enough. (5AKBR02)\n       lastViewedPostNr &&\n       // Don't report uninteresting just-a-few-seconds.\n@@ -302,8 +308,9 @@ function trackReadingActivity() {\n       (millisSinceFirstNewRead > AfterReadThenWaitMillis) &&\n       // Only report something, if there's something to report.\n       (unreportedPostsRead.length ||\n-          millisSinceLastReport > ReportToServerIntervalSeconds * 1000)) {\n+          millisSinceLastReport > ReportToServerIntervalSeconds * 1000);\n \n+  if (!talksWithSererAlready && (pageIsUnreadInWatchbar || timeToTrackReading)) {\n     // @ifdef DEBUG\n     !debug || logD(`Reporting to server: lastViewedPostNr: ${lastViewedPostNr}, ` +\n         `${unreportedSecondsReading} seconds reading, these post nrs: ${toNrs(unreportedPostsRead)}`);\n@@ -313,13 +320,22 @@ function trackReadingActivity() {\n     // BUG this won't retry, if there's a netw disconnection. Instead, somehow merge with\n     // the pubsub (long-polling / websocket) requests? which auto-retries, if reconnects.\n     // See subscribeToServerEvents().\n-    // Later, send via WebSocket [VIAWS]. COULD_OPTIMIZE\n+    // COULD_OPTIMIZE: Later, send via WebSocket [VIAWS].\n+    // COULD_OPTIMIZE: Merge this other request:  [batch_track_reading_reqs] into here.\n+    // Would then maybesend an *array* of page reading stats (2 items: prev and current page).\n     Server.trackReadingProgress(lastViewedPostNr, unreportedSecondsReading,\n         unreportedPostsRead, () => {\n       talksWithSererAlready = false;\n       // In case the server is slow because under heavy load, better reset this here in\n       // the done-callback, when the response arrives, rather than when the request is being sent.\n       lastReportedToServerAtMs = Date.now();\n+\n+      if (pageIsUnreadInWatchbar) {\n+        // Update the watchbar object:\n+        watchbar_markAsRead(me.watchbar, pageId); // [flux_mess] updating in-place\n+        // Update the store & show the changes: (that is, un-highlight the topic in the watchbar)\n+        ReactActions.patchTheStore({ me: { watchbar: me.watchbar }});\n+      }\n     });\n \n     // (Don't do this inside the callback above — that could overwrite values"
    },
    {
      "sha": "27d78a9a158ee1a18ea74704a885ab3fc7becc5d",
      "filename": "client/app-slim/page/posts.styl",
      "status": "modified",
      "additions": 18,
      "deletions": 2,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fposts.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fpage%2Fposts.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fpage%2Fposts.styl?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -693,7 +693,12 @@ html:not(.mouse) .dw-rr\n   display: inline-block;\n   position: relative;\n   top: -1px;\n-  margin-right: 10px;\n+  // margin-right: 10px;\n+  // But this looks better if there's a bookmark button just after. Hmm.\n+  // But 10px is better, if tags after. Maybe margin-left on tags instead?\n+  // margin: 0 2px 0 2px;\n+  // Sort of ok w both:\n+  margin: 0 5px 0 1px;\n \n .dw-a-clps.icon-left-open,\n .dw-a-clps.icon-right-open\n@@ -969,9 +974,13 @@ html:not(.mouse) .dw-rr\n     opacity: 0.76\n \n \n-// Marks\n+// Marks  incl bookmarks\n //===========================\n \n+span.s_P_H_Bm.dw-p-mark-click\n+  padding: 5px;\n+  margin-right: 4px;\n+\n .dw-p-mark-click\n   padding: 7px 0px 7px 5px;\n   cursor: pointer;\n@@ -985,6 +994,13 @@ html:not(.mouse) .dw-rr\n     outline: 2px solid hsl($uiHue, 100%, 77%);\n     background: hsl($uiHue, 100%, 97%);\n \n+// A bookmark icon <span> — maybe skip, and add class to the wrapping <span> instead?\n+.dw-p-mark.icon-bookmark\n+  color: hsl($uiHue, 85%, 60%);\n+  margin: 0;\n+  &:before\n+    font-size: 122%;\n+\n html.touch .dw-p-mark-click\n   padding: 9px 5px 9px 5px;\n "
    },
    {
      "sha": "462a84a165491761f2796e161b2c134e3b6a0011",
      "filename": "client/app-slim/prelude.ts",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fprelude.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fprelude.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fprelude.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -124,6 +124,14 @@ function doNextFrameOrNow(something: () => void) {\n    namespace debiki2 {\n //------------------------------------------------------------------------------\n \n+\n+export let __doneHydrating: true | U;\n+\n+export function isDoneHydrating(): Bo {\n+  return __doneHydrating;\n+}\n+\n+\n // Typescript changes this so the macro breaks somehow, in prod builds:\n // x ifdef DEBUG\n export function toStr(x: any, indentation: number = 2): string {\n@@ -604,6 +612,14 @@ export function obj_isDeepEqIgnUndef(a: Object, b: Object): Bo {\n }\n \n \n+/// Create this if needed at many more places:\n+///\n+/// Adds an item to a field that is an array. Creates the array if needed.\n+///\n+export function obj_addArrayItem_inPl__unimp<T>(obj: T, field: keyof T, item: Nr | St) {\n+}\n+\n+\n /** Like _.groupBy but keeps just one value per key.\n     RENAME to arr_groupByKeepOne ?\n   */\n@@ -729,6 +745,14 @@ export function url_getHost(url: St): St {\n }\n \n \n+/// Always returns an array — empty if `a` and `b` are nullish.\n+export function arr_concat<V>(a: V[] | NU, b: V[] | NU): V[] {\n+  if (!a) return b || [];\n+  if (!b) return a || [];\n+  return a.concat(b);\n+}\n+\n+\n export function arr_sortAlphaInPlace<V>(vs: V[], strFn: (v: V) => St) {\n   const langCode = 'en';  // for now. Later, add a t.localeCompareLangCode field? I18N  [subcats]\n   // See:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation"
    },
    {
      "sha": "1bcd052454bf7b0bd7ab0408d5d63c101e4ed802",
      "filename": "client/app-slim/sidebar/sidebar.styl",
      "status": "modified",
      "additions": 27,
      "deletions": 3,
      "changes": 30,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fsidebar%2Fsidebar.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fsidebar%2Fsidebar.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fsidebar%2Fsidebar.styl?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -18,6 +18,8 @@\n // There's probably some cruft here that can be removed. Previously, the sidebar\n // was *a lot* more complicated and I might not have cleaned up all old styles.\n \n+.c_Dragging  // move to where?\n+  opacity: 0.6;\n \n // RENAME 'sidebar' to 'contextbar'.\n \n@@ -170,6 +172,15 @@ html:not(.dw-hz):not(.mouse) #dw-comment-counts\n     flex: 1;\n     overflow-y: scroll;\n \n+\n+    // Don't want blue text just because some posts are links to other pages (e.g. a\n+    // bookmark to another page).\n+    a, a:visited\n+      color: inherit;\n+    a:hover, a:focus\n+      text-decoration: inherit;\n+\n+\n     @media (max-height: 500px)\n       padding-top: 7px;\n \n@@ -182,13 +193,26 @@ html:not(.dw-hz):not(.mouse) #dw-comment-counts\n     p\n       margin-top: 8px;\n \n-    .dw-p\n+    // This is a link — padding & margin won't work, unless:\n+    .c_BmPo\n+      display: block;\n \n-      cursor: pointer;\n-      margin: 0;\n+    // Border between recent comments, and to-do items\n+    &.c_Cb_P-ToDos .c_BmPo,\n+    &.c_Cb_P-Recent .dw-p\n       border-top: 1px solid #eee;\n       padding: 4px 0 1px;\n \n+    &.c_Cb_P-ToDos .c_BmPo\n+      padding: 5px 0 2px;\n+      .c_BmPo_Bm\n+        font-style: italic;\n+        margin-bottom: 3px;\n+\n+    .dw-p\n+      cursor: pointer;\n+      margin: 0;\n+\n       &:hover\n         .dw-p-hd,\n         .dw-p-bd"
    },
    {
      "sha": "eb3dd7a5ecd5dd31a84b934c1b08dd84ca5ddbfb",
      "filename": "client/app-slim/sidebar/sidebar.ts",
      "status": "modified",
      "additions": 203,
      "deletions": 50,
      "changes": 253,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fsidebar%2Fsidebar.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fsidebar%2Fsidebar.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fsidebar%2Fsidebar.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -37,6 +37,7 @@ const ModalDropdownButton = utils.ModalDropdownButton;\n \n // COULD UX RESPONSIVE: add some screen/window/widget width or size state to some React store somehow. [6KP024]\n // Use outerWidth, it won't force a layout reflow.\n+// [dupl_comts_list_code]\n const smallWindow = Math.min(window.outerWidth, window.outerHeight) < 500;\n const windowWideEnoughForTabButtons = window.outerWidth > 1010;\n \n@@ -59,6 +60,23 @@ interface ContextbarState {\n   commentsType: WhichPanel\n   curPostNr?: PostNr\n   adminGuide?: RElm\n+  // For the current page only:\n+  commentsFound: CommentsFound\n+  // These includes bookmarks from all pages:\n+  bookmarkedPosts?: PostWithPage[]\n+  bookmarks?: Post[]\n+}\n+\n+\n+interface CommentsFound {\n+  unread?: Post[]\n+  recent?: Post[]\n+  // Bookmarks not already in the sidebar bookmark list:\n+  // RENAME to newBookmarks  and  newlyBookmarkedPosts?\n+  bookmarks?: Post[]\n+  bookmarkedPosts?: Post[]\n+  // But this is total num bookmarks on the current page:\n+  numBookmarks?: Nr\n }\n \n \n@@ -109,25 +127,38 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n       store: store,\n       lastLoadedOnlineUsersAsId: null,\n       commentsType: commentsType,\n+      commentsFound: {},\n       // showPerhapsUnread: false,\n     };\n     return state;\n   },\n \n   onChange: function() {\n+    // This'll run if any bookmark is created or edited, [save_edit_bookmark], and,\n+    // COULD_OPTIMIZE, for lots of other unrealted reasons that we'd rather ignore. Solve by:\n+    // REFACTOR Rewrite to a React hook instead, and use  useStoreEvent().  Or, include the\n+    // store in the emit()  — then, we can easily ignore all off-topic things. And also\n+    // handle [bookmark_edits_and_updates], BUG: right now ignored.\n+    const state: ContextbarState = this.state;\n     const newStore: Store = debiki2.ReactStore.allData();\n+    const page: Page = newStore.currentPage;\n+    const commentsFound = !isPageWithComments(page.pageRole) ? {} :\n+            // This finds only missing bookmarks, won't duplicate those in the sidebar alraedy.\n+            this.findComments(newStore);\n+    const bookmarks = (\n+            arr_concat(commentsFound.bookmarks, state.bookmarks)\n+                .sort(posts_sortNewFirst));\n     this.setState({\n       store: newStore,\n+      commentsFound,\n+      bookmarks,\n+      bookmarkedPosts: arr_concat(commentsFound.bookmarkedPosts, state.bookmarkedPosts),\n     } as ContextbarState);\n     this.maybeLoadOnlineUsers(newStore);\n   },\n \n   showRecent: function() {\n     this.setState({ commentsType: 'Recent' } as ContextbarState);\n-    setTimeout(() => {\n-      if (this.isGone) return;\n-      processTimeAgo('.esCtxbar_list')\n-    });\n   },\n \n   /*\n@@ -185,6 +216,7 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n       putInLocalStorage(\n           'showAdminGuide', state.commentsType === 'AdminGuide' ? 'true' : 'false');\n     }\n+    this.loadBookmarksIfNeeded();\n     // And:\n     // if is-2d then: this.updateSizeAndPosition2d(event);\n   },\n@@ -210,6 +242,34 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n     //Server.loadOnlineUsers();\n   },\n \n+  loadBookmarksIfNeeded: function() {\n+    const state: ContextbarState = this.state;\n+    const store: Store = state.store;\n+    const me: Myself = store.me;\n+    if (!me.isAuthenticated)\n+      return;\n+    if (state.commentsType !== 'Starred')\n+      return;\n+\n+    if (!this.loadedBookmarks) {\n+      this.loadedBookmarks = 111; // about to load. Later: [React19_actions]\n+      // Load bookmarks, for current page first (`store.currentPage`), then recent first.\n+      // For now, we're probably just loading all bookmarks.  [how_load_bookmarks]\n+\n+      Server.loadPostsByAuthor(me.id, 'Bookmarks', false /* onlyOpen */,\n+              (posts: PostWithPage[], bookmarks: Post[]) => {\n+        this.loadedBookmarks = 222; // loaded\n+        const store2: Store = this.state.store;\n+        if (this.isGone || store2.me.id !== me.id)\n+          return;\n+\n+        const bookmarksNewestFirst = [...bookmarks].sort(posts_sortNewFirst);\n+        // Since we're loading all bookmarks, it's ok to overwrite the current bookmark state.\n+        this.setState({ bookmarkedPosts: posts, bookmarks: bookmarksNewestFirst });\n+      });\n+    }\n+  },\n+\n   updateSizeAndPosition2d: function(event) {\n     /* Try to remove. Or does this do sth useful for the minimap? Test if it's broken, to find out.\n     var win = debiki.window;\n@@ -253,13 +313,19 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n     ReactActions.setPagebarOpen(false);\n   },\n \n-  findComments: function() {\n+  findComments: function(store: Store): CommentsFound {\n     const state: ContextbarState = this.state;\n-    const store: Store = state.store;\n     const page: Page = store.currentPage;\n-    const unreadComments = [];\n-    let recentComments = [];\n-    const starredComments = [];\n+    const unreadComments: Post[] = [];\n+    const recentComments: Post[] = [];\n+\n+    // Although we loaded all bookmarks when opening the sidebar, we might have added new\n+    // bookmarks via another browser tab or computer. To make sure all bookmarks on\n+    // the current page are included in the sidebar, we'll look at all posts & bookmarks\n+    // shown on the current page, and add any new to the sidebar.\n+    const bookmarkedPosts: PostWithPage[] = [];\n+    const bookmarks: PostWithPageId[] = [];\n+    let numBookmarks = 0;\n \n     // Find 1) all unread comments, sorted in the way they appear on the page\n     // And 2) all visible comments.\n@@ -278,9 +344,43 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n       if (isDeleted(post))\n         return;\n \n-      recentComments.push(post);\n-      if (this.isStarred(post.nr)) {\n-        starredComments.push(post);\n+      // Add to the recent comments list (sorted later).\n+      // But the root post (typically the orig post) is older than all others shown; it's\n+      // uninteresting to show it in the most recent comments list.\n+      if (post.uniqueId !== store.rootPostId)\n+        recentComments.push(post);\n+\n+      // Find any newly added bookmarks, not included in the loadBookmarksIfNeeded() response.\n+      for (let bmNr of post.bookmarkNrs || []) {\n+        const bmInPage: Post | U = page.postsByNr[bmNr];\n+        if (!bmInPage || bmInPage.isPostDeleted) continue;\n+\n+        numBookmarks += 1;\n+\n+        // This bookmark not listed in the sidebar?\n+        const bmInList = state.bookmarks?.find(b => b.uniqueId == bmInPage.uniqueId);\n+        if (!bmInList) {\n+          // Page id needed to look up the bookmarked comment. See comment below, and ToDosProps.\n+          const bmWithPageId: PostWithPageId = { ...bmInPage, pageId: page.pageId };\n+          bookmarks.push(bmWithPageId);\n+        }\n+\n+        // The posts are needed to render the bookmarks. [render_bookms]  We need the\n+        // page ide too, since the bookmarked comments are identified via page id + post nr.\n+        // However, the server doesn't include the page id (not normally needed), so we'll\n+        // add it here.  (Only when loading bookmarks specificaly, is the page id\n+        // included by the server. [posts_0_page_json])\n+        const postInList = state.bookmarkedPosts?.find(p => p.uniqueId == post.uniqueId);\n+        if (!postInList) {\n+          const postWithPage: PostWithPage = {\n+                ...post,\n+                pageId: page.pageId,\n+                pageRole: page.pageRole,\n+                // The title is plain text. [title_plain_txt]\n+                pageTitle: page.postsByNr[TitleNr]?.unsafeSource || \"TyE0TTL073\",\n+              };\n+          bookmarkedPosts.push(postWithPage);\n+        }\n       }\n \n       /* Unread? Skip for now, not saved anywhere anyway\n@@ -301,26 +401,24 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n       */\n     };\n \n-    const rootPost = page.postsByNr[store.rootPostId];\n-    addRecursively(rootPost.childNrsSorted);\n+    addRecursively([store.rootPostId]);\n \n     _.each(page.postsByNr, (child: Post) => {\n       if (child.postType === PostType.Flat) {\n         addPost(child);\n       }\n     });\n \n-    recentComments.sort((a: Post, b: Post) => {\n-      // Newest first.\n-      if (a.createdAtMs < b.createdAtMs)\n-        return +1;\n-      if (a.createdAtMs > b.createdAtMs)\n-        return -1;\n-      return a.nr < b.nr ? +1 : -1;\n-    });\n-    recentComments = _.take(recentComments, 50);\n+    recentComments.sort(posts_sortNewFirst);\n+    const lastRecent = _.take(recentComments, 50);\n \n-    return { unread: unreadComments, recent: recentComments, starred: starredComments };\n+    return {\n+          unread: unreadComments,\n+          recent: lastRecent,\n+          bookmarks,\n+          bookmarkedPosts,\n+          numBookmarks,\n+        } satisfies CommentsFound;\n   },\n \n   manuallyMarkedAsRead: function(postId: number): boolean {\n@@ -330,12 +428,13 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n     return !!mark; // any mark means it's been read already.\n   },\n \n-  isStarred: function(postId: number) {\n+  /*\n+  isStarred: function(postId: number) {  [bookmark_shapes_colors]\n     const state: ContextbarState = this.state;\n     const store: Store = state.store;\n     const mark = store.me.myCurrentPageData.marksByPostId[postId];\n     return mark === BlueStarMark || mark === YellowStarMark;\n-  },\n+  }, */\n \n   onPostClick: function(post: Post) {\n     this.focusPost(post);\n@@ -344,9 +443,17 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n   focusPost: function(post: Post) {\n     const state: ContextbarState = this.state;\n     const store: Store = state.store;\n+\n+    // Do before any SPA navigation below, or the wrong bookmark gets highlighted afterwards.\n     this.setState({\n       curPostNr: post.nr\n     } as ContextbarState);\n+\n+    if (post.pageId && post.pageId !== store.currentPageId) {\n+      page.Hacks.navigateTo(linkToPost(post as PostWithPageId));\n+      // SPA-navigation, so we'd continue below unless:\n+      return;\n+    }\n     page.addVisitedPosts(null, post.nr);\n     ReactActions.loadAndShowPost(post.nr);\n     if (store.shallSidebarsOverlayPage) {\n@@ -361,8 +468,11 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n     const page: Page = store.currentPage;\n     const me: Myself = store.me;\n \n+    if (!store.isContextbarOpen)\n+        return null;\n+\n     //var minimapProps = _.assign({ ref: 'minimap' }, store);\n-    const commentsFound = isPageWithComments(page.pageRole) ? this.findComments() : null;\n+    const commentsFound: CommentsFound = state.commentsFound;\n     const isChat = page_isChat(page.pageRole);\n     const isStaffOrMyPage = isStaff(me) || store_thisIsMyPage(store);\n \n@@ -379,7 +489,13 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n     const numOnlineTextSlash = usersHere.onlyMeOnline ? t.you + ' / ' : usersHere.numOnline + \"/\";\n \n     //var unreadBtnTitle = commentsFound ? 'Unread (' + commentsFound.unread.length + ')' : null;\n-    const starredBtnTitle = commentsFound ? `${t.Bookmarks} (${commentsFound.starred.length})` : null;\n+\n+    const bookmarksBtnTitle = t.Bookmarks + (commentsFound.numBookmarks\n+            // \"N here\" means \"N bookmarks on this page\". (That's interesting, though, & quick.)\n+            ? ` (${commentsFound.numBookmarks} here)`  // I18N\n+            // Maybe show \"Bookmarks (123 in total)\" where 123 is one's total num bookmarks? Or,\n+            // let's skip, forever. Not so interesting, compared to the work & e2e tests needed.\n+            : '');\n \n     const specificPage = usersHere.areChatChannelMembers || usersHere.areTopicContributors;\n     const anyUsersBtnTitle: St | N = (\n@@ -405,32 +521,47 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n     let starredClass = '';\n     let usersClass = '';\n     let adminGuideActiveClass = '';\n-    let listItems: any[];\n+    let listItems: any; // [];\n+    let panelClass = '';\n \n-    // (If the page type was just changed to a page without comments, the Recent or Bookmarks\n-    // tab might be open, although commentsFound is now null (40WKP20) )\n+    // (If the page type was just changed to a page without comments, the Recent or Unread\n+    // tab might be open, although commentsFound is now {}. (40WKP20) )\n     switch (state.commentsType) {\n       case 'Recent':\n-        let recentComments = commentsFound ? commentsFound.recent : []; // see (40WKP20) above\n+        const recentComments = commentsFound.recent || []; // see (40WKP20) above\n         title = recentComments.length ? t.cb.RecentComments : t.cb.NoComments;\n         recentClass = ' active';\n+        panelClass = 'c_Cb_P-Recent';\n         listItems = makeCommentsContent(recentComments, state.curPostNr, store,\n             this.onPostClick);\n         break;\n       /*\n       case 'Unread':\n-        let unreadComments = commentsFound ? commentsFound.unread : []; // see (40WKP20) above\n+        const unreadComments = commentsFound.unread || []; // see (40WKP20) above\n         title = unreadComments.length ?\n             'Unread Comments: (click to show)' : 'No unread comments found.';\n         unreadClass = ' active';\n-        listItems = ...\n+        listItems = makeCommentsContent(unreadComments, state.curPostNr, store,\n+            this.onPostClick);\n         break; */\n       case 'Starred':\n+        // [to_paginate]\n         title = t.cb.YourBookmarks;\n         starredClass = ' active';\n-        let starredComments = commentsFound ? commentsFound.starred : []; // see (40WKP20) above\n-        listItems = makeCommentsContent(starredComments, state.curPostNr, store,\n-            this.onPostClick);\n+        panelClass = 'c_Cb_P-ToDos';\n+\n+        // These are bookmarks from the current page and other pages too.\n+        // Later: Search & sort fields [bookmark_search_sort].\n+        listItems = !state.bookmarks ? r.p({}, t.Loading) :\n+              morebundle.ToDos({ bookmarkedPosts: state.bookmarkedPosts,\n+                  bookmarks: state.bookmarks, curPostNr: state.curPostNr, store,\n+                  onPostClick: this.onPostClick,\n+                  reorderThisBeforeThat: (todoA, todoB) => {\n+                    // Later. [order_bokms]\n+                    const ixA = state.bookmarks.indexOf(todoA);\n+                    const ixB = state.bookmarks.indexOf(todoB);\n+                    // ReactActions.alterBookmarks()  ??\n+                  }});\n         break;\n       case 'Users':\n         let numOnlineStrangers: Nr | N = store.numOnlineStrangers;\n@@ -459,11 +590,13 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n           numOnlineStrangers = null;\n         }\n         usersClass = ' active';\n+        panelClass = 'c_Cb_P-Users';\n         listItems = makeUsersContent(store, usersHere.users, store.me.id, numOnlineStrangers);\n         break;\n       case 'AdminGuide':\n         title = t.cb.GettingStartedGuide;\n         adminGuideActiveClass = ' active';\n+        panelClass = 'c_Cb_P-Guide';\n         break;\n       default:\n         console.error('[DwE4PM091]');\n@@ -481,10 +614,9 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n       */\n     }\n     if (state.commentsType === 'Starred') {\n-      tipsGuideOrExtraConfig =\n+      /* tipsGuideOrExtraConfig =\n         r.div({},\n-          r.p({}, t.NotImplemented)); /*\n-          r.p({}, \"You have not bookmarked any comments on this page.\"),\n+          // Old. Now there's a bookmark icon, not a star icon. [bookmark_shapes_colors]\n           r.p({}, 'To bookmark a comment, click the star in its upper left ' +\n             \"corner, so the star turns blue or yellow. (You can use these two colors in \" +\n             'any way you want.)'));\n@@ -510,10 +642,11 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n       tipsGuideOrExtraConfig = state.adminGuide || r.p({}, t.Loading);\n     }\n \n-    let recentButton;\n-    let starredButton;\n-    let unreadButton;\n-    let adminGuideButton;\n+    let recentButton: RElm | N;\n+    let starredButton: RElm | N;\n+    let unreadButton: RElm | N;\n+    let adminGuideButton: RElm | N;\n+\n     if (commentsFound) {\n       if (windowWideEnoughForTabButtons) {\n         recentButton = isChat ? null :\n@@ -522,18 +655,31 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n         //unreadButton =\n         // r.button({ className: 'btn btn-default' + unreadClass, onClick: this.showUnread },\n         //   unreadBtnTitle);\n-        starredButton =\n-            r.button({ className: 'btn btn-default' + starredClass, onClick: this.showStarred },\n-              starredBtnTitle);\n       }\n       else {\n         recentButton = isChat ? null : MenuItem({ onClick: this.showRecent }, t.Recent);\n         //unreadButton = MenuItem({ onClick: this.showUnread }, \"Unread\"),\n-        starredButton = MenuItem({ onClick: this.showStarred },\n-          starredBtnTitle);\n       }\n     }\n \n+    let skipBookmarks = true;\n+    // @ifdef DEBUG\n+    skipBookmarks = false;\n+    // @endif\n+\n+    if (skipBookmarks) {\n+      starredButton = null;\n+    }\n+    else if (windowWideEnoughForTabButtons) {\n+      starredButton =\n+          r.button({ className: 'btn btn-default' + starredClass, onClick: this.showStarred },\n+              bookmarksBtnTitle);\n+    }\n+    else {\n+      starredButton = MenuItem({ onClick: this.showStarred },\n+              bookmarksBtnTitle);\n+    }\n+\n     if (me.isAdmin) {\n       if (windowWideEnoughForTabButtons) {\n         adminGuideButton = r.button({ className: 'btn btn-default' + adminGuideActiveClass,\n@@ -616,7 +762,7 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n         r.div({ className: 'esCtxbar_btns', style: dimCommentsStyle  },\n           CloseSidebarButton({ onClick: this.closeSidebar }),\n           tabButtons),\n-        r.div({ className: 'dw-comments esCtxbar_list' },\n+        r.div({ className: 'dw-comments esCtxbar_list ' + panelClass },\n           helpMessageBoxTree,\n           helpMessageBoxFour,\n           r.div({ style: dimCommentsStyle },\n@@ -632,6 +778,7 @@ export var Sidebar = createComponent({  // RENAME to ContextBar\n });\n \n \n+// [dupl_comts_list_code]\n function makeCommentsContent(comments: Post[], currentPostNr: PostNr, store: Store, onPostClick) {\n   const abbreviateHowMuch = smallWindow ? 'Much' : 'ABit';\n   return comments.map((post: Post, index) => {\n@@ -748,6 +895,12 @@ function CloseSidebarButton(props) {\n }\n \n \n+function posts_sortNewFirst(a: Post, b: Post) {\n+  // Note: b, a  not  a, b  so we'll get newst (not oldest) first.\n+  return postAppearedBefore(b, a);\n+}\n+\n+\n //------------------------------------------------------------------------------\n    }\n //------------------------------------------------------------------------------"
    },
    {
      "sha": "3488ba15a03e7abebab8fd429cb32b1ffcc8095e",
      "filename": "client/app-slim/slim-bundle.d.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fslim-bundle.d.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fslim-bundle.d.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fslim-bundle.d.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -79,9 +79,6 @@ declare const UnknownUserId: UserId;\n \n declare const ReviewDecisionUndoTimoutSeconds: number;\n \n-declare function makeNoPageData(): MyPageData;\n-declare function makeAutoPage(): any;\n-\n declare const ManualReadMark;\n declare const YellowStarMark;\n declare const FirstStarMark;\n@@ -213,6 +210,7 @@ declare namespace debiki2 {\n   function replaceById(itemsWithId: any[], replacement);\n   function deleteById(itemsWithId: any[], id);\n   function url_getHost(url: St): St;\n+  function arr_concat<V>(a: V[] | NU, b: V[] | NU): V[];\n   function arr_sortAlphaInPlace<V>(vs: V[], strFn: (v: V) => St);\n \n   namespace notfs {\n@@ -428,6 +426,9 @@ declare namespace debiki2 {\n \n   function categories_sortTree(categories: Category[]): CatsTree;\n \n+  function makeNoPageData(): MyPageData;\n+  function makeAutoPage(pageId?: PageId): Page;\n+\n   function store_curPage(store: Store): Page | U;\n \n   function page_makePostPatch(page: Page, post: Post): StorePatch;\n@@ -466,6 +467,7 @@ declare namespace debiki2 {\n   function origin(): string;\n   function linkToPageId(pageId: PageId): string;\n   function linkToPostNr(pageId: PageId, postNr: PostNr): string;\n+  function linkToPost(post: PostWithPageId): St;\n   function linkToType(type: TagType): St;\n   function linkToDraftSource(draft: Draft, pageId?: PageId, postNr?: PostNr): string;\n   function linkToNotificationSource(notf: Notification): string;\n@@ -510,6 +512,7 @@ declare namespace debiki2 {\n   function tags_mkSortFn(tagTypesById: TagTypesById): (a: Tag, b: Tag) => Nr;\n \n   function isSection(pageRole: PageRole): boolean;\n+  function page_unsafeTitle(page: Page): St | U;\n   function page_isClosedUnfinished(page: Page): Bo;\n   function page_isDone(page: Page | Topic): Bo;\n   function page_canBeDone(page: Page | Topic): Bo;"
    },
    {
      "sha": "7a28c74a1f9cdc0280e6df71aa4b8cd0795bd3b2",
      "filename": "client/app-slim/start-page.ts",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fstart-page.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fstart-page.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fstart-page.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -258,7 +258,23 @@ function renderPageInBrowser() {\n \n   const timeBefore = performance.now();\n \n+  // ((You might look at a profiler, and realize that it'd be faster to call\n+  // `activateVolatileData()` here — that is, to include your own data,\n+  // when running React the first time, and avoiding partly rerendering the page, once\n+  // your own data has been added (e.g. any unapproved comments of yours).\n+  // However! The server side generated html, doesn't include your personal stuff,\n+  // so it'd be different from the html you'd get when running React in the browser\n+  // (with your personal stuff included), which messes up various html things randomly.\n+  // So, don't do here:  (but do later, below)\n+  // debiki2.ReactStore.activateVolatileData(); ))\n+\n   const doNext = debiki2.startMainReactRoot(reactRenderMethod);\n+\n+  // We won't hydrate any more html from the server, so, hereafter we can serialize\n+  // timestamps to time-ago (e.g. \"5 hours ago\") directly, rather than hydrating the\n+  // timestamps and `processTimeAgo()` converting to \"5 hours ago\" strings. [hydrate_done]\n+  debiki2.__doneHydrating = true;\n+\n   if (doNext === 'SkipTheRest')\n     return;\n \n@@ -282,7 +298,7 @@ function renderPageInBrowser() {\n   debiki2.processTimeAgo(numPosts > 20 ? '.dw-ar-p-hd' : '');\n   const timeAfterTimeAgo = performance.now();\n \n-  // (Also calls ReactStore.activateMyself().)\n+  // (Also calls ReactStore.activateMyself(), ends with emitChange().)\n   debiki2.ReactStore.activateVolatileData();\n   const timeAfterUserData = performance.now();\n "
    },
    {
      "sha": "4eba9b08a76b35f7aeaa64bf24a774f5b8ff9001",
      "filename": "client/app-slim/store-getters.ts",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fstore-getters.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fstore-getters.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fstore-getters.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -87,8 +87,8 @@ export function store_getAuthorOrMissing(store: DiscStore, post: Post): Pat {\n \n   const user = store_getUserOrMissing(store, post.authorId);\n   if (user.isMissing) {\n-    logError(\"Author \" + post.authorId + \" missing, page: \" +\n-      store.currentPageId + \", post nr: \" + post.nr + \" [EsE6TK2R0]\");\n+    logError(\"Author \" + post.authorId + \" missing, post id: \"\n+          + post.uniqueId + \", nr: \" + post.nr + \" [TyE6TK2R0]\");\n   }\n   return user;\n }\n@@ -99,8 +99,7 @@ export function store_getUserOrMissing(store: DiscStore, userId: PatId,\n   const user = store.usersByIdBrief[userId];\n   if (!user) {\n     if (errorCode2) {\n-      logError(`Participant ${userId} missing, page: ${store.currentPageId}` +\n-        ` [TyE0PP-${errorCode2}]`);\n+      logError(`Participant ${userId} missing [TyE0PP-${errorCode2}]`);\n     }\n     return {\n       id: userId,"
    },
    {
      "sha": "6c23dbb268dd49e584bb9255a3d01072776374b7",
      "filename": "client/app-slim/tags/tags.styl",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Ftags%2Ftags.styl",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Ftags%2Ftags.styl",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Ftags%2Ftags.styl?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -35,7 +35,6 @@\n     box-shadow: 1px 1px 3.3px hsl($uiHue 100% 40%);\n     color: black;\n \n-\n .c_TagL_AddB\n   vertical-align: baseline;\n   box-shadow: 1px 1px 3.7px hsl(0 0% 70%);  // brighter shadow, not a real tag\n@@ -98,3 +97,4 @@\n   h2\n     margin-bottom: 2.5ex;\n     font-size: 22px;\n+"
    },
    {
      "sha": "94a75455d8aeabbfffc8729dd1d7921d5398671f",
      "filename": "client/app-slim/translations.d.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Ftranslations.d.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Ftranslations.d.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Ftranslations.d.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -622,6 +622,7 @@ interface TalkyardTranslations {\n     DismNotfs: string;\n     ViewProfile: string;\n     ViewGroups: string;\n+    ViewUsers: string;\n     LogOut: string;\n     UnhideHelp: string;\n   },"
    },
    {
      "sha": "68de2e433bdde42861bd0cf548b475941d5e7626",
      "filename": "client/app-slim/watchbar/watchbar.ts",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fwatchbar%2Fwatchbar.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-slim%2Fwatchbar%2Fwatchbar.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-slim%2Fwatchbar%2Fwatchbar.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -260,12 +260,19 @@ const DirectMessages = createComponent({\n const SingleTopic = createComponent({\n   displayName: 'SingleTopic',\n \n-  UNSAFE_componentWillMount: function() {\n+  getInitialState: function() {\n+    // Just init _url — not using any state.\n     const topic: WatchbarTopic = this.props.topic;\n     this._url = linkToPageId(topic.pageId);\n+    return null;\n   },\n \n   // If this topic is clicked, when it's the current topic already, then open the dropdown.\n+  //\n+  // If it's clicked when it's not the current, then the corresponding page is opened.\n+  // And after a second or so, it's marked as no-longer-unread, but that happens via a\n+  // track-reading request, here: [upd_watchbar_has_read].\n+  //\n   onListItemClick: function(event) {\n     if (!this.props.isCurrent)\n       return;"
    },
    {
      "sha": "b9183024ee835af398d7f6bc9b0d9e00a5bbfea4",
      "filename": "client/app-staff/admin/admin-app.staff.ts",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-staff%2Fadmin%2Fadmin-app.staff.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-staff%2Fadmin%2Fadmin-app.staff.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-staff%2Fadmin%2Fadmin-app.staff.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -741,7 +741,10 @@ const LoginAndSignupSettings = createFactory({\n         }),\n \n         // If SSO enabled, email addresses must always have been verified, by the external\n-        // login provider.\n+        // login provider. [0_compose_bef_sso_redir]\n+        // Could theoretically make compose-before work also with sso, but then, for embedded\n+        // comments, would need to save the comment (in session storage?), before redirecting\n+        // the page to sso login.\n         enableTySsoOrOnlyCustIdps || !allowSignup ? null : Setting2(props, {\n           type: 'checkbox', label: \"Require verified email\",\n           className: 'e_A_Ss_S-RequireVerifiedEmailCB',"
    },
    {
      "sha": "4eb7b8ea264b251f6165d16f1d920fdb350a8dae",
      "filename": "client/app-staff/admin/inspect.staff.ts",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-staff%2Fadmin%2Finspect.staff.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fapp-staff%2Fadmin%2Finspect.staff.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fapp-staff%2Fadmin%2Finspect.staff.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -42,8 +42,10 @@ export const InspectPanel = React.createFactory<AdminPanelProps>(\n   const myId = React.useRef(me.id);\n   const [inspectForumResp, setResp] = React.useState<InspectForumResp>(null);\n \n-  const groups: GroupVb[] = inspectForumResp?.groupsMaySee || [];\n-  const cats: Cat[] = inspectForumResp?.catsMaySee || [];\n+  const groups0: GroupVb[] = inspectForumResp?.groupsMaySee || [];\n+  const groups = [...groups0].sort((a, b) => a.id - b.id); // sort ascending\n+  const cats0: Cat[] = inspectForumResp?.catsMaySee || [];\n+  const cats: Cat[] = [...cats0].sort((a, b) => a.position - b.position);\n   const allPerms: PermsOnPage[] = inspectForumResp?.allPerms || [];\n \n "
    },
    {
      "sha": "021456cdb5f1e8cee5f2e438f5d83abf71e5e53b",
      "filename": "client/server/ReactStore.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fserver%2FReactStore.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Fserver%2FReactStore.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Fserver%2FReactStore.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -10,7 +10,7 @@ export function win_getSessWinStore(): SessWinStore {\n }\n \n export function makeNoPageData() { die('K42B01'); }\n-export function makeAutoPage(path?: string) { die('K42B02'); }\n+export function makeAutoPage(pageId?: PageId): any { die('K42B02'); }\n \n //------------------------------------------------------------------------------\n    }"
    },
    {
      "sha": "149cd62ca0428b03ce8fc3022866a77db2b209fd",
      "filename": "client/types-and-const-enums.ts",
      "status": "modified",
      "additions": 38,
      "deletions": 11,
      "changes": 49,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Ftypes-and-const-enums.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/client%2Ftypes-and-const-enums.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/client%2Ftypes-and-const-enums.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -192,16 +192,20 @@ const enum TypeValueType {\n   // Flt64Range?\n   // BigDecRange?\n \n-  StrKwd          = 17,\n+  StrKwd          = 17,   // 2^4 + 1\n   /*\n   StrTxt          = 18,\n   StrUrl          = 19,\n   SemanticVersion = 2?,\n \n-  Date            = 33,\n+  Date            = 33,   // 2^5 + 1\n   DateRange       = 34,\n \n-  LocationLatLong = 49,\n+  LocationLatLong = 49,   // 2^5 + 2^4 + 1\n+\n+  Reminder ?      = 129,  // 2^7 + 1\n+\n+  PostLink ?      = 193,  // 2^7 + 2^6 + 1\n   */\n }\n \n@@ -214,16 +218,20 @@ const enum TopicFilters {\n \n \n // Also see type FindWhat in tests/e2e-wdio7/pub-api.ts. [ty_things_types]\n+// And [ThingType_ids] in docs/design-docs/tags.dd.adoc.\n //\n-const enum ThingType {  // or RENAME to TaggableThingType?\n-  // How was I thinking? These numbers? Some kind of bitmasks, hmm.\n-  // Pats = 1 + 2 + 4 = guests, users, groups (but which order?).\n+const enum ThingType {  // or RENAME to TaggableThingType? no CHANGE to [ThingKind]?\n+  // Pats = 1 + 2 + 4 = guests, users, groups.\n   Pats = 7,\n-  // Posts = Orig Posts (pages) + comments + ...what? + hmm. 32 + 16 + 8 = 56\n+  // Posts = Pages = 8, comments = 16, meta posts = 32\n   Posts = 56,\n-  // And: Post tags = 64? Pat tags = 128?\n-  // And cats 256, then? For now.\n-  //Cats = 256,\n+  // Bookmarks = ?  (a post of type Bookmark)  [ThingKind]\n+  // Flags = ?  (later: a post of type Flag)\n+  // And: Post tags = 256? User badges (pat tags) = 512?\n+  //\n+  // Cats = 1024  ?\n+\n+  // Bookmark = 78,  // what? why? Above instead\n \n   All = Pats + Posts,  // RENAME to AllThatCanBeTagged\n }\n@@ -340,6 +348,16 @@ const enum PostType {   // sync with test code [26BKA01]\n   CommunityWiki = 12,\n   CompletedForm = 21,\n   MetaMessage = 31,   // RENAME to MetaPost\n+  Bookmark = 51,\n+}\n+\n+\n+const enum PostNrs {\n+  MaxPrivateNr = -1001,\n+  MinPublicNr = 0,\n+  TitleNr = 0,\n+  BodyNr = 1,\n+  FirstReplyNr = 2,\n }\n \n \n@@ -765,7 +783,9 @@ const enum Verbosity {\n \n \n const enum Time {\n-  OneDayInMillis = 24 * 3600 * 1000,\n+  OneMinuteInMillis = 60 * 1000,\n+  OneHourInMillis = 60 * OneMinuteInMillis,\n+  OneDayInMillis = 24 * OneHourInMillis,\n }\n \n \n@@ -777,6 +797,13 @@ const enum Sizes {\n }\n \n \n+const enum RangeDir {\n+  Older = -1,\n+  // Around = 0, — later\n+  Newer = +1,\n+}\n+\n+\n const enum WhichStorage {\n   PageVar = 1,\n   SessionStorage = 4,"
    },
    {
      "sha": "e5be55d4d038eda9a00789d9bf3c8cce0bbac761",
      "filename": "conf/routes",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/conf%2Froutes",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/conf%2Froutes",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/conf%2Froutes?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -213,10 +213,11 @@ POST  /-/config-watchbar        controllers.PageController.configWatchbar\n POST  /-/change-pat-node-rels   controllers.PageController.changePatNodeRels\n \n GET   /-/list-topics-by-user    talkyard.server.talk.PostsController.listTopicsByUser(userId: Int)\n-GET   /-/list-posts             talkyard.server.talk.PostsController.listPostsByUser(authorId: Int, relType: Option[Int], which: Option[Int])\n+GET   /-/list-posts             talkyard.server.talk.PostsController.listPostsByUser(authorId: Int, postType: Option[Int], relType: Option[Int], which: Option[Int])\n GET   /-/download-my-content    talkyard.server.talk.PostsController.downloadUsersContent(authorId: Int)\n GET   /-/list-posts-with-tag    talkyard.server.talk.PostsController.listPostsWithTag(typeIdOrSlug)\n \n+# Also handles bookmarks. Should rename to  create-post?\n POST  /-/reply                  controllers.ReplyController.handleReply\n POST  /-/chat                   controllers.ReplyController.handleChatMessage\n \n@@ -430,6 +431,7 @@ OPTIONS  /*whatever             controllers.ApiV0Controller.getFromApi(whatever)\n # ----- View pages/posts\n \n GET   /-/load-post              controllers.ViewPageController.loadPost(pageId: String, postNr: Int)\n+GET   /-/load-many-posts        controllers.ViewPageController.loadManyPosts(pageId, comtOrder: Int, offset: Int, rangeDir: Int)\n \n # COULD remove? use only /-/track-reading-activity ?\n POST  /-/mark-as-seen           controllers.ViewPageController.markPageAsSeen(pageId)"
    },
    {
      "sha": "577c692a7bc573432878fd716c8d9a3a2f4066c1",
      "filename": "docs/abbreviations.txt",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fabbreviations.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fabbreviations.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fabbreviations.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -107,6 +107,8 @@ Bitf = bitfield\n Em  = email\n Enb = enabled, Dsb? Disb? = disabled\n B   = button, e.g. ReplyB\n+Bm,\n+Bokm = bookmark\n Br  = brief. Also, Tn  = tiny, Vb = verbose, Vvb = very verbose.\n It  = list item\n C,\n@@ -192,6 +194,7 @@ Pat = participant\n Prs = persona, e.g. PrsMde = persona mode\n Pb  = pagebar\n Pf  = preference, e.g. NfPfs = notification preferences\n+P   = panel, e.g. c_Cb_P = contextbar panel\n Pnl = panel\n Py  = property?\n Pw  = password, e.g. NwPwI"
    },
    {
      "sha": "a997f0c08f9f075505a3dcad429edde7ab2af110",
      "filename": "docs/design-docs/bookmarks.dd.adoc",
      "status": "added",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fdesign-docs%2Fbookmarks.dd.adoc",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fdesign-docs%2Fbookmarks.dd.adoc",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdesign-docs%2Fbookmarks.dd.adoc?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,33 @@\n+\n+Bookmarks are posts, stored in posts3 / nodes_t. Then they'll get doing status fields\n+\"for free\" and can later function as one's personal tasks too: planned, doing, done.\n+  And  due-at  or  remind-at  properties, just like posts might one day have.\n+\n+At the same time, means we have to avoid accidentally loading bookmarks (>= MinPublicNr tests)\n+or bookmark authors. [dont_list_bookmarkers]\n+\n+The parent post is the bookmarked post.\n+\n+The post nr is <= MaxPrivateNr — bookmarks are private: others can't see one's bookmarks.\n+\n+  _________________________\n+  |                        |\n+  |  Add [Bookmark | Task] |  \n+  |                        |\n+  | Tags:  Read later v    |    (or e.g.  Reply-to | To-do | Reference)\n+  |                        |\n+  | Text: _Parrots_Petr__  |\n+  |                        |\n+  | Order: [7]             |\n+  |                        |\n+  | Date  /  reminder  ?   |\n+  |                        |\n+  |________________________|\n+\n+\n+Bookmarks are shown in the sidebar, so one can single-click jump between different\n+bookmarked posts, without having to click and open a bookmarks dropdown in between.\n+(Plus, in a tab on one's profile page.)\n+\n+For more work-in-progress bookmark things, see: ../../wip/bookmarks/bookmarks-wip.txt\n+"
    },
    {
      "sha": "f2175c7ef24049e1808ae2623caaeb5e37189b69",
      "filename": "docs/design-docs/tags.dd.adoc",
      "status": "modified",
      "additions": 26,
      "deletions": 140,
      "changes": 166,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fdesign-docs%2Ftags.dd.adoc",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fdesign-docs%2Ftags.dd.adoc",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fdesign-docs%2Ftags.dd.adoc?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -86,7 +86,7 @@ create table tag_synonyms_t (\n \n \n \n--- This'd be in  pat_rels_t instead? E.g.  Sarah —> PatRelType.SuggestDelete —> a-tag\n+-- This'd be in  pat_node_rels_t  instead? E.g.  Sarah —> PatRelType.SuggestDelete —> a-tag\n --\n create table tag_actions_t (  -- maybe never\n   site_id_c\n@@ -115,7 +115,7 @@ create table perms_on_types_t(    -- much later.\n   may_see_others_c,      -- false —> becomes personal bookmark / star?\n   may_add_c,\n   may_edit_others_c,\n-  may_add_own_inst_c,\n+  may_add_own_inst_c,   -- inst = \"instance\"?\n   may_edit_own_inst_c,\n   may_merge_c,\n );\n@@ -138,16 +138,14 @@ create table types_use_where_t(    -- much later\n \n \n \n-create table tags_t(\n+create table tags_t\n+  Done, see: /home/user/styd/ty2/docs/db-schema-dump/tags_t.txt .\n \n   -- mayeb add later: ------------\n   on_cat_id_c,\n   on_tag_id_c,       -- tag a tag? Maybe later\n   on_type_id_c,      -- e.g. tag a type with a \"Merge this type with: (other type)\"?\n \n-  cust_i32_c   i32_d,\n-  cust_json_c  jsonb_ste100_000_d,  -- simpler than  tag_vals_t?\n-\n   -- So anyone can suggest tags, but, say, a trusted member needs to review and\n   -- approve — so tags end up getting wisely used: (tags are often a mess, in other\n   -- software systems)\n@@ -157,7 +155,6 @@ create table tags_t(\n   hidden_by_id_c,  -- e.g. if staff added tag, but pat hides it, doesn't like it, then hidden_by_id_c = pat's id\n   ----------------------------\n );\n-----\n \n \n == Can tag what?\n@@ -175,7 +172,7 @@ Guests, (built-in users), users, bot users, groups,  = 2^5 - 1 = 31.\n   — what about accounts controlled by both a bot and a human? Or if unknown.\n Pages (orig posts), replies, meta posts, = 2^5 + 2^6 + 2^7 - 1 = 32+64+128 = 224\n Think about later: categories, tags, votes, flags, edit suggestions, plugins, ... .\n------- Intstead?: -----\n+------ Intstead?: -----  [ThingType_ids]\n   Guests = 2^0 + Users = 2^1 + Groups = 2^2       =  7  (instead of 31)\n      but what about anons, pseudonyms and circles?\n   Pages  = 2^3 + Replies = 2^4 + Meta posts = 2^5 = 56  (instead of 224)\n@@ -198,115 +195,48 @@ Therefore: domain thing_types_d, can be only 7 or 56, for now.\n \n == Tag values\n \n-Maybe:  If a tag needs many values, let a single tag in  tags_t  consist of many rows,\n-each row with one value?  — Instead of a new table tag_vals_t?\n-NO, so complicated! Just add a  cust_jsonb_c  column and that's it — if a plugin\n-    needs to store an array of values, then, it can do so in that jsonb thing.\n-\n-either:  (but too complicated!?)\n-    tags_t: remove pk\n-    tags_t +=\n-      has_extra_vals          bool\n-      extra_val_for_tag_id_c  tag_id_d,\n-\n-or:      (but too complicated!?)\n-    tags_t: add val_nr: 0,1,2,... , 0 could be the main\n-    tags_t +=\n-      has_extra_vals          bool\n-      extra_val_for_tag_id_c  tag_id_d,\n-      val_type_c     val_type_d,   -- e.g. date —> val_i64_c = unix time millis?\n-                                    -- date_range —> val_i64_end_c  = end date range?\n-                                    -- CVE score: (0, 10]\n-                                    -- SemVer2 —> regex check?\n-                                    -- etc etc\n-\n-and/or just inline all values, maybe:\n-(Foreign keys won't work, but the simplicity and the higher performance and the\n-lower bug risk (than if joining with a tag values table) is worth it I think!\n-See: http://www.databasesoup.com/2015/01/tag-all-things.html & part 2 & 3.\n-BUT there can be a  tag_rels_t  with links from tags to posts or pats, if that\n-   ever makes sense. With foreign keys.  Just like there's  post_rels_t and pat_rels_t.)\n-\n-    -- Hmm this can handle almost everything?:\n-    val_type_c     i32,\n-    val_f64_c      f64,\n-    val_text_c     text,\n-    val_http_url_c http_url_d,\n-    val_jsonb_c    jsonb_ste100_000_d,\n-    ----------\n-\n-    val_i64_c      i64_d,    -- name it  cust_i64_c ?\n-    -- Mabye skip all this (just an i64 and a jsonb can be enough?!) -----\n-    val_i64_end_c  i64_d,\n-    val_f64_c      f64_d,\n-    val_f64_end_c  f64_d,\n-\n-    val_title_c    text w max len,\n-    val_http_url_c http_url_d,\n+If ever needs tag values that are lists of user or page ids, then:\n+Interesting about arrays of ids, instead of an id table with foreign keys,\n+it's really fast:\n+http://www.databasesoup.com/2015/01/tag-all-things.html & part 2 & 3.\n+(But with arrays/json, foreign keys won't work.)\n \n+Maybe later, probably never: (instead, the val_jsonb_c is flexible enough?)\n     val_i32_arr_c   i32[],\n     val_i64_arr_c   i64[],\n     val_f64_arr_c   f64[],\n     val_text_arr_c  text[],\n-    ----------------------------------------------------------------------\n-\n-\n-And tag_types_t:\n-  allowed_val_types_c  User   for example    — maybe a bitfield?\n-  max_num_vals_c      5   (0..=100 for example)   — e.g. assign sth to 5 ppl?\n \n \n Mat views are reealy slow, often out of sync:\n     https://stackoverflow.com/questions/29437650/how-can-i-ensure-that-a-materialized-view-is-always-up-to-date\n \n-Later:\n-\n-In Talkyard, tags will be able to have values. E.g. an Assigned-To page tag,\n-with its value being the person (or people, or group) responsible for gettin it done.\n-*NO*, instead, the links tables, just 1 row:\n-        pat_rels_t:\n-            from_pat_id_c = ...\n-            to_post_id_c = ...\n-            rel_type_c = PatLinkType.AssignedTo\n-    That's simpler. But with tags, would need 2 rows (or 3 if counting the types_t row)\n-    that's pointless indirection (linking a post and a person via a tag, not directly),\n-    more complicated:\n-        types_t:  Assigned-To tag type,\n-        tags_t:   a tag of type Assigned-To, tagging the post\n-        tag_rels_t:\n-            from_tag_id_c =  the tag just above (in tags_t)\n-            to_pat_id_c =    the person assigned\n-\n-And also, this makes it harder to write queries for looking up who's assigned to what\n+\n+------------------------------------------------\n+Update 2024: Now each tag has only one reference value — seems there won't be any\n+tag_rels_t.  Therefore, can use tags also for things like AssignedTo.\n+------------------------\n+We don't use tags for Assigned-To and Like etc relationships. That would have\n+made it harder to write queries for looking up who's assigned to what\n — need to join all of:  posts_t, tags_t, types_t, tag_rels_t, pats_t\n \n                           ,——> types_t: AssignedTo\n                          /\n             [post] <—— tag ——————> [person]\n                           `~—————> [person-2]  (2 ppl assigned)\n \n-     instead of just:   posts_t, pat_rels_t, pats_t\n+     instead of just:   posts_t, pat_node_rels_t, pats_t\n \n             [post] <——— AssignedTo ——— [person]\n                  ^————— AssignedTo ——— [person-2]\n \n-So don't use tags for AssignedTo etc.  Instead, pat_rels_t and the AssignedTo type.\n-\n--- Don't: ----------\n-Or a Do-After tag, saying that something should/needs-to wait until\n-after another feature/problem has been done/fixed.\n--- Instead: --------\n-A  post_post_rels_t  relationship of type  PostPostRelType.DoAfter?\n-Just one row:\n-            [idea post] ——> Depends-On ———> [other idea post]\n-instead of with tags:  3 rows?\n-            the tag itself\n-            tag ——> do first post\n-            tag ——> do later post\n-But the  types_t  table is still needed, where not built-in types like  Depends-On  can be stored?\n---------------------\n-\n---- NO, this'll probably be a post of type sth like AboutNotes, and a post_rels_t entry\n+So don't use tags for AssignedTo etc.  Instead, pat_node_rels_t and the AssignedTo type.\n+------------------------------------------------\n+\n+--- Update 2024: Yes, it's better with tags? Because then the *type* of relationship\n+  (the tag type) is available directly, rather than having to look up the post too, first.\n+  This makes it simpler to skip all for-the-moment off-topic posts.\n+--- Old: NO, this'll probably be a post of type sth like AboutNotes, and a post_rels_t entry\n       linking the post to the person?  No need to bring tags into this. Links are simpler,\n       more direct.\n Or a \"Staff Notes\" tag (user badge) on a person, visible only to staff,\n@@ -344,50 +274,6 @@ Many date-time ranges? (a many evenings / days event)\n Cat list?\n Tag list? Hmm\n \n-----\n-create table tag_vals_t(\n-  site_id_c int,\n-  tag_id_c int,\n-\n-  ----------------------------------------\n-  -- But this would instead be in a table  tag_rels_t,\n-  -- Like post_rels_t and pat_rels_t?\n-  val_pat_id_c     i32,    -- e.g.  Assigned to: {some-user}  on a page\n-\n-  val_page_id_c    i32,    -- this tag or user badge, links to a page\n-                           -- e.g. a \"Maybe Promote\" tag, placed on a user,\n-                           -- visible only to core members,\n-                           -- which links to a page with a discussion about\n-                           -- what this user is doing well / why-very-helpful,\n-                           -- explaining why s/he should be made a Trusted member.\n-  val_cat_id_c     i32,\n-  ----------------------------------------\n-\n-\n-  -- Maybe not: -----------\n-  -- Maybe simple_vals_c (see above) instead?\n-\n-  -- Link from a tag, to another tag, which could be on a different page? But why?\n-  -- val_tag_id_c     i32,\n-\n-  -- val_type_id_c     i32,  -- link to a type? Mabye not.\n-\n-  --  val_i64_c         i64,\n-  --  val_i64_len_c     i64_gez,  -- if a range\n-\n-  --  val_f64_c         f64,\n-  --  val_f64_len_c     f64_gez,\n-\n-  --  -- val_f64_perc_c    f64,  -- for confidence intervals, percent?\n-\n-  --  val_text varchar,\n-  --  val_text_end varchar,  -- if a text range, e.g. v0.2021.30 to v0.2021.40\n-  --  val_json  jsonb_ste100_000_d,\n-\n-  --  val_link_url_c url_d,\n-  --  val_link_title_c title_d,\n-);\n-----\n \n \n "
    },
    {
      "sha": "6b793d717542ce3d85935d66ddf1da5d0bcda887",
      "filename": "docs/everything-is-a-node.txt",
      "status": "modified",
      "additions": 115,
      "deletions": 44,
      "changes": 159,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Feverything-is-a-node.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Feverything-is-a-node.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Feverything-is-a-node.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1,13 +1,52 @@\n-[add_nodes_t]\n+[add_nodes_t]  [its_a_node]\n+\n+See the _explanation below.\n+\n \n alter table posts3 rename to nodes_t\n+  & move pages & categories to that table too — they're all nodes.\n+  & move drafts3 to nodes_t too? [drafts3_2_nodes_t]\n+  Maybe assigned-to would be better as a node too? [tasks_2_nodes_t]\n \n alter table post_actions3 rename to  pat_node_rels_t\n — if it's interesting to know when and by who a relationship was added, e.g.:\n Assigned to Alice by Bob on 2023-04-05. Or post revision nr, or any rel specific\n value (pat_node_rels_t.val_i32_c).\n \n+But keep  tags_t  — don't merge into pat_node_rels_t (which, if you look at the tables,\n+might seem like a possibly good thing).  There's a difference between tags (in tags_t)\n+and relationships (in pat_node_rels_t):    [tags_vs_pat_node_rels]\n+\n+   There can be just one relationship of a specific type between a person & a node.\n+   (e.g. only one Like vote per person and comment)\n+   But there can be many *tags* of the same type, on a node (added by the same person).\n+   For example, a Like relationships: it's nice that the database enforces that there's\n+   just one Like relationships between each person & comment.\n+   But tags:  You might tag an event with \"Happens-in\", and if it happens in two\n+   cities, you'd like two tags of the same type, e.g.:  \"Happens-in: New York\" and\n+   \"Happens-in: London\", or \"Happens-on: 2024-09-01\" and \"Happens-on: 2024-10-01\".\n+   And tag values are searchable in ElasticSearch, but the things in pat_node_rels_t\n+   don't have any searchable values (at least not now).\n+  \n+   (Still unsure if maybe a single table would have been better, and having\n+   a \"sub-id\" for the (rare?) cases where many relationships of the same type\n+   makes sense. — Maybe ok either way)\n+\n+   Also,  on_parent_tag_c  maybe won't ever make sense for relationships? (At least not\n+   in Talkyard's case?) Relationships in graph databases don't have parent *relationships*\n+   (only parent & child *nodes*).\n+   But tags can be nested, and the tag_t table enforces that nested tags are indeed\n+   on the same post (so you can't nest a tag C on post B in a tag P on post A\n+   — tag C needs to be on the same post as tag P, that is, post A).\n+   So maybe it's good with tags_t after all?  Some things are a bit specific to tags?\n+   (Tag hierarchies are pretty common in software — websearch for \"tag hierarchies\".) \n+\n+\n alter table perms_on_pages3 rename to  pat_node_multi_rels_t\n+-- \"multi\", because many relationships in the same table row, e.g.:\n+-- may_edit_page, may_post_comment, may_see.\n+-- Each one isn't that interesting. Unlike pat_node_rels_t, which has one\n+-- relationship per row, plus some relationship properties.\n \n Move from  categories_t, pages3, posts3  to pat_node_multi_rels_t:\n     comts_start_hidden_c  never_always_d\n@@ -61,7 +100,7 @@ Pages:\n   - Child node nr 2, 3, 4: Comments.\n   - *Page* child nodes = typially sub tasks or comment trees important enough\n       to be moved to their own child page?\n-      (That is, pages with sub pages — or, you could say: tasks with sub tasks.)\n+      (That is, pages with [sub_pages] — or, you could say: tasks with sub tasks.)\n   - Category child nodes: Sub tasks grouped in categories?\n       For really big projects?\n     Don't appear on any category list page. Instead, only if clicking [+]\n@@ -70,12 +109,16 @@ Pages:\n Comments:\n   - NodeType.Comment.\n   - Node text = comment text.\n-  - Child nodes = replies.\n-  And, helpful for a bookmarks tree or to specify sidebar contents?:\n-  - Page child nodes: Show as a list below the comment? (When would that be useful?)\n-  - Category child nodes: Show as a list, too?\n-  Hmm but it's all a tree, currently — can't have many parent nodes.\n-  Need new table, maybe node_node_rels_t with column  other_parent_id_c  ?\n+  - Child nodes = replies,  or PostType.Bookmark and nr < MaxPrivateNr.\n+\n+        Not flags thuogh? Flags would instead be a sub *page* of type Flag.\n+        But skip this?: Maybe should be in a node_node_rels_t, if one flag can\n+              flag many posts (by the same spammer)?\n+\n+  (But maybe a  node_node_rels_t  table, for e.g.  PostPostRelType.DoAfter:\n+        [idea post] ——> Depends-On ———> [other idea post]\n+  or  PostPostRelType.IsAlsoAnswerTo  for \"secondary\" answers, if many ok answers.)\n+  (Would look a bit like  links_t  but without link_url_c, and added_* not neede?)\n \n Then can:\n   - Delete duplicated settings in:\n@@ -159,7 +202,7 @@ perms_on_pages3  ——> perms_on_nodes_t (& perms_on_pats_t)  NO,  pat_node_mul\n  perm_id                 | integer           |           | not null | \n  for_people_id           | integer           |           | not null | \n  on_whole_site           | boolean           |           |          | \n- on_category_id          | integer       ^^^\\\n+ on_category_id          | integer       ‾‾‾\\\n  on_page_id              | character varying >——>  on_node_id  —>  nodes_t  (currently \"posts3\")\n  on_post_id              | integer       ___/\n  on_tag_id               | integer           |           |          | \n@@ -226,7 +269,35 @@ NEXT: Add these fields to perms_on_pages3  (to be renamed to  pat_node_multi_rel\n   )\n \n \n- (s = site)\n+The leftmost column below is a list of these, e.g. \"c,p,po\":  _explanation\n+    s       = exists in site settings\n+    c       = is a cat prop\n+    proj    = project page ? (a page with sub pages, probably w doing-status)\n+    p       = is a page prop\n+    po      = is a post prop\n+    pstat   = is page statistics\n+    postat  = is post statistics\n+    ppostat = is page & post statistics\n+    g       = is a group prop ?  (or user, but usually better to configure groups)\n+    jn      = journal ?  (similar to audit log, but shouldn't be deleted —\n+                                      is needed to know e.g. who may undo sth)\n+    rel     = node —> node relationship, e.g. X-is-answer-of-Y, or X-is-flag-of-Y.\n+    rm      = remove (column not needed)\n+    tty     = is a type property, needed in the types_t table (currently named tagtypes_t)\n+    tag     = is a tag prop\n+    b       = is a bookmark prop\n+And \"c,p,po\" means that the database table column just to the right,\n+is needed for categories, pages and posts. For example:\n+\"c,p,po  may_edit_comment\"  — if it's set on a category, then one may edit\n+comments everywhere in the category. Or everywhere on a page, if set on a page.\n+Or one may edit a specific comment.\n+\n+But, with everything as a node,  \"c,p,po\" wouldn't be 3 separate tables, but\n+instead one table, with different types of rows (nodes are cats, others pages,\n+others comments). — And now, with everything in one table, there's no need to\n+repeat these columns x 3.\n+\n+\n \n group_participants3  ——>  pat_rels_t   (or  pat_pat_rels_t ?)\n --------------------------------------------------------------------------\n@@ -602,7 +673,7 @@ pages3\n  c,p      locked_at              | timestamp\n  c,p      frozen_at              | timestamp\n  p        unwanted_at            | timestamp\n- p        planned_at             | timestamp\n+ p,po     planned_at             | timestamp\n  p        version                | integer\n  pstat    last_reply_by_id       | integer\n  pstat    frequent_poster_1_id   | integer\n@@ -615,8 +686,8 @@ pages3\n  c,p      layout                 | bigint              pers_pref: layout\n  p        hidden_at              | timestamp\n  c,p      incl_in_summaries      | smallint            pers_pref: emails\n- p        started_at             | timestamp\n- p        postponed_til_c        | timestamp\n+ p,po     started_at             | timestamp\n+ p,po     postponed_til_c        | timestamp\n  p        num_posts_total        | integer\n  c,p      ext_id                 | character varying\n  pstat    num_op_do_it_votes_c   | i32_gez_d\n@@ -631,9 +702,9 @@ pages3\n  c?,p,po  closed_by_id_c ‾‾‾\\\n  c?,p,po  locked_by_id_c     >  closed_status_c:  colsed, locked, frozen\n  c?,p,po  frozen_by_id_c ___/\n- p        unwanted_by_id_c       | integer\n- p        hidden_by_id_c         | integer\n- c,p      deleted_by_id_c        | integer\n+ p,po     unwanted_by_id_c       | integer\n+ p,po     hidden_by_id_c         | integer\n+ c,p,po   deleted_by_id_c        | integer\n  s,c,p    forum_search_box_c     | i16_gz_d\n  s,c,p    forum_main_view_c      | i16_gz_d\n  s,c,p    forum_cats_topics_c    | i32_gz_d\n@@ -665,29 +736,29 @@ page_users3\n posts3\n --------------------------------------------------------------------------\n         site_id                  | integer\n-        unique_post_id           | integer\n-        page_id                  | character varying\n+ c,p,po unique_post_id           | integer\n+ p,po   page_id                  | character varying\n  po     post_nr                  | integer\n  po     parent_nr                | integer\n  po     multireply               | character varying\n         created_at               | timestamp\n         created_by_id            | integer\n  jn     curr_rev_started_at      | timestamp\n  jn     curr_rev_last_edited_at  | timestamp\n- po     curr_rev_by_id           | integer\n+ p,po   curr_rev_by_id           | integer\n  jn     last_approved_edit_at    | timestamp\n- po     last_approved_edit_by_id | integer\n+ p,po   last_approved_edit_by_id | integer\n  postat num_distinct_editors     | integer\n  postat num_edit_suggestions     | smallint\n  jn     last_edit_suggestion_at  | timestamp\n- po     safe_rev_nr              | integer\n- po     approved_source          | text\n- po     approved_html_sanitized  | text\n+ p,po   safe_rev_nr              | integer\n+ p,po   approved_source          | text\n+ p,po   approved_html_sanitized  | text\n  jn     approved_at              | timestamp\n- po     approved_by_id           | integer\n- po     approved_rev_nr          | integer\n- po     curr_rev_source_patch    | text\n- po     curr_rev_nr              | integer\n+ p,po   approved_by_id           | integer\n+ p,po   approved_rev_nr          | integer\n+ p,po   curr_rev_source_patch    | text\n+ p,po   curr_rev_nr              | integer\n  po     collapsed_status         | smallint           pers_pref\n  jn     collapsed_at             | timestamp\n  jn     collapsed_by_id          | integer\n@@ -697,21 +768,21 @@ posts3\n  jn     hidden_at                | timestamp\n  jn     hidden_by_id             | integer\n  p,po   hidden_reason            | character varying\n- p,po   deleted_status           | smallint\n+ c,p,po deleted_status           | smallint\n  jn     deleted_at               | timestamp\n  jn     deleted_by_id            | integer\n  c,p,po pinned_position          | smallint           pers_pref: unpin?\n  jn     pinned_at                | timestamp\n  jn     pinned_by_id             | integer\n- postat num_pending_flags        | smallint\n- postat num_handled_flags        | smallint\n- postat num_like_votes           | integer\n- postat num_wrong_votes          | integer\n- postat num_times_read           | integer\n- postat num_bury_votes           | integer\n- postat num_unwanted_votes       | integer\n- po     type                     | post_type_d\n- po     prev_rev_nr              | integer\n+ ppostat num_pending_flags       | smallint\n+ ppostat num_handled_flags       | smallint\n+ ppostat num_like_votes          | integer\n+ ppostat num_wrong_votes         | integer\n+ ppostat num_times_read          | integer\n+ ppostat num_bury_votes          | integer\n+ ppostat num_unwanted_votes      | integer\n+ p,po   type                     | post_type_d\n+ p,po   prev_rev_nr              | integer\n  po     branch_sideways          | smallint           pers_pref: layout. But depends on one's device\n         ext_id                   | character varying\n  po     smtp_msg_id_prefix_c     | smtp_msg_id_out_prefix_d\n@@ -756,7 +827,7 @@ post_actions3\n \n \n \n-tagtypes_t  — better of staying in their own table? (don't incl in nodes_t)\n+tagtypes_t  — better of staying in their own table? (don't incl in nodes_t)  rename to types_t\n --------------------------------------------------------------------------\n               site_id_c                | integer\n               id_c                     | i32_gz_d\n@@ -782,11 +853,11 @@ tagtypes_t  — better of staying in their own table? (don't incl in nodes_t)\n \n tags_t\n --------------------------------------------------------------------------\n-            site_id_c       | integer\n-            id_c            | i32_gz_d\n- tag,post   tagtype_id_c    | integer\n- tag,post   parent_tag_id_c | integer\n- tag        on_pat_id_c     | integer\n- tag        on_post_id_c    | integer\n+              site_id_c       | integer\n+              id_c            | i32_gz_d\n+ b,tag,post   tagtype_id_c    | integer\n+ b,tag,post   parent_tag_id_c | integer\n+ b,tag        on_pat_id_c     | integer\n+ b,tag        on_post_id_c    | integer\n \n "
    },
    {
      "sha": "b253787c72bd3c7bc4fef384b89ab0ad892981d7",
      "filename": "docs/maybe-do-later.txt",
      "status": "modified",
      "additions": 38,
      "deletions": 2,
      "changes": 40,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fmaybe-do-later.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Fmaybe-do-later.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Fmaybe-do-later.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -38,6 +38,14 @@ Primary button colors, secondary, background, arrows, fonts,\n and embedded widgets, e.g. Twitter's oEmbed has a 'link_color: #223344' attr,\n                             and  theme=light/dark.\n \n+[big_page_nav]\n+How make the sidebar and the Recent tab more discoverable?\n+Maybe if there's more than 5 comments, pop up a tips when someone clicks \"Go to latest\"?\n+And / or if the display is wide, auto open the sidebar and show the Recent tab?\n+(But not if it's open already, maybe they are doing something there, e.g. looking at\n+their bookmarks.)\n+And tips about keyboard shortcuts too, and add keybindings for prev/next comment.\n+\n [post_owners] posts_t.owners_id_c — if ownership of a post has been transferred.\n The new owner can, but the original author can't, edit it and delete it etc.\n \n@@ -52,6 +60,17 @@ post A is-answer-to post Q (could be many answers), multireplies, here.\n table  post_rels_t  to link to flagged posts or user accounts.\n Why? See <./tyworld.adoc>, the Flag Pages and Posts section.\n \n+[about_user_notes] Should these be tags or posts? Maybe tags are better,\n+because then many users can be linked to the same about-user-note — useful, if\n+an astroturfer creates many accounts?\n+So, there's a post with text, and then a badge (that's a tag on a user)\n+linking from the user (or badges linking from many users)\n+to that post? (The note itself is a post — it's text.)  Maybe the badge could show\n+inline the first line of the post?  So one better knows if it's worth clicking\n+the note & reading more.\n+And these badges are visible only to mods, f.ex., as per permissions in the\n+upcoming tagtype_perms_t table?\n+\n [do_it_votes]\n Optionally, use separate Do-It and Do-Not votes, to show if one wants\n to implement an idea or not — in addition to Like votes. Sometimes,\n@@ -119,13 +138,24 @@ See: ./everything-is-a-node.txt\n DONE: Implement sub categories.\n But missing: Search in sub cats, if searching in base cat.\n \n+[sub_pages]  aka sub_tasks, nested_pages, child_pages, parent_page, project_pages\n+Let pages optionally have a parent page. This can be nice, to create small projects:\n+A page that describes the project, and one child page per major task-to-be-done.\n+(Small tasks might instead just be comments.)\n+Now there's:  pages3.parent_post_id_c.\n+But better wait until after [add_nodes_t]?\n+\n [forum_page]\n More configurable, & discussions too, see:  y2999/wip_sect_disc_props_views_stats.sql\n \n [watchbar_to_linkbar][metabar_2_pagebar]\n RENAME the \"watchbar\" to \"linkbar\", the page meta bar to \"pagebar\", and the right\n sidebar to \"contextbar\" ?\n \n+[sidebar_menu]\n+Customizable sidebar menu (or \"linkbar\"?).\n+See: ../appsv/rdb/src/main/resources/db/migration/y2999/wip_v427__sidebar_menu.sql\n+\n [propagate_cat_perms]\n It'd be nice if there was a way to get an overview of sub cat permissions,\n when looking at a base cat. And if one could propagate the base category's\n@@ -188,7 +218,7 @@ Wasn't fixed in first iteration.\n \n [nested_tags][child_tags] hierarchical tags\n \n-[to_paginate]\n+[to_paginate][needs_pagination][pagination]\n E.g. don't list only 100 tags — add a Show More ... button.\n \n [sw] [sse]\n@@ -651,9 +681,12 @@ New permission.\n Later, comments can be tasks with their own DoingStatus, and marked done or closed.\n (The db is prepared for this, but not implemented UX wise.)\n \n-[priv_comts] Private comments:\n+[priv_comts] Private comments:  see  ../wip/priv-comts/priv-comts-wip.txt.\n (Aka \"whispers\" in Discourse and \"private items\" in Basecamp long ago, and \"private comments\"\n in other software.)\n+To show the right private comments: Probably we'll need to [load_all_private_comments] on\n+the relevant page, and then do a tree search & access permission checks on each comment,\n+to find the ones the current user may see.\n Add posts_t.private_pats_id_c, and a new participant type:  lists of pats,\n to remember who can see private comments.\n New permissions\n@@ -691,6 +724,8 @@ Don't bump page if private comments — or do, for those who can see? Hmm.\n       Do send notifications about priv comts to those who can see them & want though.\n       Same notf level as for direct messages — instead of the page's notf level?\n \n+[bookmarks_wip]\n+See ../wip/bookmarks/bookmarks-wip.txt.\n \n [see_who_notfd]\n When composing a message, see who will get notified — e.g. if mentioning a group,\n@@ -840,6 +875,7 @@ Things to think about, if making Ty work offline.\n Use two session ids and cookies — one HttpOnly, another not-HttpOnly. Both needs to be\n present, to be logged in. By deleting the not-HttpOnly, one can log out, also if\n the server is offline.  And, the HttpOnly session offers a bit extra security.\n+Partly impl, pages are cached, see: [cache_how_long], but only in dev builds [8YDVP2A].\n \n [serversid]\n Server side sesison ids, maybe in Redis? So can log ppl out, without having access"
    },
    {
      "sha": "a51b990ca72837c6638705eb6008e3a3be3e1333",
      "filename": "docs/tests-map.txt",
      "status": "modified",
      "additions": 23,
      "deletions": 7,
      "changes": 30,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Ftests-map.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Ftests-map.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Ftests-map.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -432,7 +432,7 @@ navigation:\n           - navigation-as-admin.test.ts  TyT7WAAR2J4\n           - embedded-comments-navigation-as-guest.test.ts  TyT2P067WKT2\n   to topic with unapproved posts:\n-          - modn-from-disc-page-appr-befr.2browsers.test.ts  TyTE2E603RTJ.TyTE2E603SKD\n+          - modn-from-disc-page-appr-befr.2br.f  TyTE2E603RTJ.TyTE2E603SKD\n   from user profile topic list to page:\n             - tags-basic.2br  TyTE2ETAGSBSC.TyTNAVUSR2PG\n   from user profile posts list to page:\n@@ -833,6 +833,14 @@ tags with values:\n   cannot create tags with the wrong value type: (different from the tag type's value type)\n             - TESTS_MISSING  TyTTAGVALBADTYPE\n \n+bookmarks:\n+            - TESTS_MISSING   TyTBOOKMLS\n+            - TESTS_MISSING   case q: PostQuery.PatsBookmarks\n+            - TESTS_MISSING   TyTIMPBOOKMRK\n+            - TESTS_MISSING   Check bookmarks not sent over WebSocket [dont_leak_private_posts]\n+            - Edit & delete & recreate bookmarks\n+            - add more ...\n+\n # Move to ^security:  ?\n access permissions,\n permissions -\n@@ -1123,6 +1131,7 @@ direct messages:\n             - block-dir-msgs.2br.d  TyTBLOCKDIRMSGS\n \n chat:\n+            - chat-basic.2br.f.mtime  TyTCHATBASC\n   create channel:  chat.2browsers.test.ts  (4FE2)\n     two users chat:         ==\n           - login-required-join-global-chat.2br.test.ts  TyTE2E603MAT53\n@@ -1150,6 +1159,13 @@ chat:\n           - admin-review-cascade-approval.2browsers.test.ts  TyT0SKDE24.TyT052SKDGJ37\n   messages not merged:\n           - admin-review-cascade-approval.2browsers.test.ts  TyT0SKDE24.TyT0527X8M302\n+  scroll\n+    up to fetch older messages:\n+            - chat-scroll.2br.f  TyTCHATSCROLL\n+    down to fetch newer:\n+            - TESTS_MISSING, will incl in  chat-scroll.2br.f  just above.\n+    but skip deleted:\n+            - TESTS_MISSING\n \n embedded comments:\n   create site:\n@@ -1181,9 +1197,9 @@ embedded comments:\n   scroll and show #comment-n:\n           - embedded-comments-scroll  TyT2K4DHR49-05\n   scroll and load #comment-nnn:\n-          - embedded-comments-scroll-and-load-more.2browsers.test.ts  TyT603MRKH592S.TyT03RMET742M\n+          - embcom.scroll-and-load-more.2br.ec  TyT603MRKH592S.TyT03RMET742M\n   load more comments:\n-          - embedded-comments-scroll-and-load-more.2browsers.test.ts  TyT603MRKH592S\n+          - embcom.scroll-and-load-more.2br.ec  TyT603MRKH592S\n   won't auto scroll to last read comment:\n   (usually the blog post more interesting? so don't auto scroll):\n           - embedded-comments-scroll  TyT2K4DHR49\n@@ -1447,7 +1463,7 @@ review after:\n           - admin-review-cascade-approval.2browsers.test.ts  TyT0SKDE24\n   mod new page:\n             - modn-approve-before.2browsers.test.ts  TyTE2E52RKDHI.TyTAPRTHRPG01\n-            - modn-from-disc-page-appr-befr.2browsers.test.ts  TyTE2E603RTJ\n+            - modn-from-disc-page-appr-befr.2br.f  TyTE2E603RTJ\n             - topic-prominent-pats-reply-approve.2br.d  TyTPROMPATS_REAPR.TyTAPRTHRT\n   mod first posts:\n           - FirstPostsAppSpec.scala  TyTIT205RKDJ4\n@@ -1456,11 +1472,11 @@ review after:\n   require approval before:\n     see own, not others:\n           - new-member-allow-approve.2browsers.test.ts  TyT4AKBJ20.TyTE2E042RT\n-          - modn-from-disc-page-appr-befr.2browsers.test.ts  TyTE2E603RTJ.TyTE2E603SKD\n+          - modn-from-disc-page-appr-befr.2br.f  TyTE2E603RTJ.TyTE2E603SKD\n     edit own:\n           - new-member-allow-approve.2browsers.test.ts  TyT4AKBJ20.TyTE2E306RKP\n     staff can edit:\n-          - modn-from-disc-page-appr-befr.2browsers.test.ts  TyTE2E603RTJ.TyTE2E407RKS\n+          - modn-from-disc-page-appr-befr.2br.f  TyTE2E603RTJ.TyTE2E407RKS\n     staff can reply to not yet approved pages and comments:\n             - topic-prominent-pats-reply-approve.2br.d  TyTPROMPATS_REAPR.TyTREBEFAPR\n   require approval before, if trust less than:\n@@ -1485,7 +1501,7 @@ review after:\n     # Undo reject, and undelete — then, can approve?\n     # Delete whole page. Undelete page. Then can approve / reject afterwards.\n   moderate from page:\n-            - modn-from-disc-page-appr-befr.2browsers.test.ts  TyTE2E603RTJ\n+            - modn-from-disc-page-appr-befr.2br.f  TyTE2E603RTJ\n             - tags-badges-not-missing.2br  TyTETAGS0MISNG.TyTAPRTGDPO\n             - topic-prominent-pats-reply-approve.2br.d  TyTPROMPATS_REAPR.TyTAPRTHRT\n     other mod moderates just after, from moderation page:"
    },
    {
      "sha": "954f07ead9809610e2af870831bc3d89f5df5bfe",
      "filename": "docs/tyworld.adoc",
      "status": "modified",
      "additions": 28,
      "deletions": 3,
      "changes": 31,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Ftyworld.adoc",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/docs%2Ftyworld.adoc",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs%2Ftyworld.adoc?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -457,13 +457,14 @@ on edge start or endpoint as appropriate).\n \n == Custom types and values\n \n-Custom types, e.g. tag types, user badge types, are stored in types_t\n-(currently named tagtypes_t). For example, a tag has a tag type that\n+Custom types, e.g. tag types, user badge types, are kept in\n+types_t (currently named tagtypes_t). For example, a tag has a tag type that\n says how the tag should be displayed: title, color, descr,\n if the tag can have values and then of what type.\n \n A type has a kind id, type id and sub type id.  Once a type has been\n created, these never changes. (Is primary key.)\n+(But I didn't add any kind id column yet to tagtypes_t? Or yes, it's can_tag_what_c?)\n \n The \"kind\" says what kind of thing the type is for: nodes (in nodes_t,\n currently named posts3), or participants (pats_t, currently users3),\n@@ -486,10 +487,34 @@ To do?: See `[Custom_types] [Alt_5]`\n in ../appsv/rdb/src/main/resources/db/migration/db-wip.sql\n \n \n+== Tags & Badges\n+\n+In Talkyard, tags and user badges are pretty much the same thing: they're\n+in the tags_t table, and can have searhcable values\n+\n+\n === Tags with values\n \n Tags can have values, e.g. \"Version: v1.23.4\" or \"Event-Location: Paris\"\n-or \"Published-Year: 1999\". This is not that much implemented though.\n+or \"Published-Year: 1999\".  You can search & sort for tags and their values,\n+e.g. this gives you a sorted prio list at forum.talkyard.io:\n+\"tags:priority:desc>2 is:open\"\n+\n+\n+\n+\n+== Private posts\n+\n+Private pots have nrs < `PostType.MaxPrivateNr`, and no one else can see\n+one's private posts. Bookmarks, and later: personal todos and drafts,\n+are private posts. (But drafts are currently in the `drafts3` table.)\n+\n+\n+=== Bookmarks\n+\n+(Not yet enabled in prod.) Bookmarks are private posts of PostType.Bookmark.\n+See: ./design-docs/bookmarks.dd.adoc.\n+\n \n \n "
    },
    {
      "sha": "cc25ebea0fb9286f6b73bfe86e2236dcc23b12b5",
      "filename": "relchans/tyse-v0-dev",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": null,
      "raw_url": null,
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/relchans%2Ftyse-v0-dev?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1 +1 @@\n-Subproject commit 883fa161a7f042b93f8f9daea99ab01169c72db4\n+Subproject commit cc25ebea0fb9286f6b73bfe86e2236dcc23b12b5"
    },
    {
      "sha": "97058937398db1a8a63f0ff37f04ad843637d343",
      "filename": "relchans/tyse-v0-regular",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": null,
      "raw_url": null,
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/relchans%2Ftyse-v0-regular?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1 +1 @@\n-Subproject commit 2bc50656d973019f8de56a3b142e5f2e7d620f0e\n+Subproject commit 97058937398db1a8a63f0ff37f04ad843637d343"
    },
    {
      "sha": "982e5f72576a31f99b803609d5d60cc927cbe54b",
      "filename": "s/git-merge-into-release-branch.sh",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/s%2Fgit-merge-into-release-branch.sh",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/s%2Fgit-merge-into-release-branch.sh",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/s%2Fgit-merge-into-release-branch.sh?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -39,9 +39,9 @@ if [[ ! $next_version =~ ^v0\\.$year\\. ]]; then\n   echo\n   echo \"Edit  version.txt — bump the year, and reset the in-year version to 001.\"\n   echo\n-  echo \"And, don't forget to bump the Business Source License change date\"\n-  echo \"in  README.md   and  LICENSE-BUSLv11.txt,  and the copyright-up-to\"\n-  echo \"year in  README.md.  (4 edits in total, in 3 files.)\"\n+  echo \"And, don't forget to bump the GPLv2 change dates\"\n+  echo \"in  README.md,  and the copyright-up-to year too.\"\n+  echo \"(4 edits in total, in 2 files.)\"\n   echo\n   exit 1\n fi"
    },
    {
      "sha": "733effacdca2dfd6d7b8ef779db64fb5544901c2",
      "filename": "s/run-e2e-tests.sh",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/s%2Frun-e2e-tests.sh",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/s%2Frun-e2e-tests.sh",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/s%2Frun-e2e-tests.sh?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -341,9 +341,10 @@ function runAllE2eTests {\n   $r s/wdio --only upload-images-and-files.2br $args\n   $r s/wdio-7 --only direct-messages-notfs.3br.d --cd -i $args\n   $r s/wdio --only direct-messages-delete.2browsers $args\n-  $r s/wdio --only chat-basic.2br.mtime $args  #  broken [DRAFTS_BUG]\n+  $r s/wdio-7 --only chat-basic.2br.f.mtime --cd -i $args  #  broken [DRAFTS_BUG]\n   $r s/wdio --only chat-create-from-direct-message.2browsers $args\n   $r s/wdio --only chat-create-from-profile-pages.2browsers $args\n+  $r s/wdio-7 --only chat-scroll.2br.f --cd -i $args\n \n   $r s/wdio-7 --only categories-basic.3br.d --cd -i $args\n   # There're more category tests below. [.more_cat_tests]\n@@ -395,7 +396,7 @@ function runAllE2eTests {\n   $r s/wdio --only modn-appr-bef-comb-w-revw-aftr.2br.mtime $args\n   $r s/wdio --only mod-review.2br.mtime $args  # RENAME to modn-by-moderator-not-admin\n \n-  $r s/wdio --only modn-from-disc-page-appr-befr.2browsers $args\n+  $r s/wdio-7 --only modn-from-disc-page-appr-befr.2br.f --cd -i $args\n   $r s/wdio --only modn-from-disc-page-review-after.2browsers $args\n \n   # TESTS_MISSING\n@@ -692,7 +693,7 @@ function runAllE2eTests {\n   $r s/wdio       --only embedded-comments-create-site-forum-intro-tour $args\n   $r s/wdio       --only embedded-comments-create-site-import-disqus.2br $args\n   $r s/wdio-7     --only embcom.drafts-previews-not-logged-in.2br --cd -i $args\n-  $r s/wdio       --only embedded-comments-scroll-and-load-more.2browsers $args\n+  $r s/wdio-7     --only embcom.scroll-and-load-more.2br.ec --cd -i $args\n   $r s/wdio       --only embedded-comments-scroll-embedding-page $args\n   # (no -old-name version, because the new name is always included in the server's genetarted html.)\n "
    },
    {
      "sha": "1c1383082d2db6cefab3f603bca1fac8d77e92db",
      "filename": "tests/app/server/talkyard/server/search/SearchQueryParserSpec.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fapp%2Fserver%2Ftalkyard%2Fserver%2Fsearch%2FSearchQueryParserSpec.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fapp%2Fserver%2Ftalkyard%2Fserver%2Fsearch%2FSearchQueryParserSpec.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Fserver%2Ftalkyard%2Fserver%2Fsearch%2FSearchQueryParserSpec.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -239,6 +239,8 @@ class SearchQueryParserSpec extends AnyFreeSpec with must.Matchers {\n           query.isWhat.pageType mustBe Some(PageType.Discussion)\n           query = parseRawSearchQueryString(s\"is:comments\", dao)\n           query.isWhat.pageType mustBe Some(PageType.EmbeddedComments)\n+          //query = parseRawSearchQueryString(s\"is:bookmark\", dao)  [is_bokm]\n+          //query.isWhat.pageType mustBe Some(PageType.Bookmark)\n \n           query = parseRawSearchQueryString(s\"is:open\", dao)\n           query.isWhat.pageOpen mustBe Some(true)"
    },
    {
      "sha": "992ef6b70f3320043d7a515a92ae5d64343eb695",
      "filename": "tests/app/talkyard/server/sitepatch/SitePatcherAppSpec.scala",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fapp%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatcherAppSpec.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fapp%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatcherAppSpec.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fapp%2Ftalkyard%2Fserver%2Fsitepatch%2FSitePatcherAppSpec.scala?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -745,7 +745,7 @@ class SitePatcherAppSpec extends DaoAppSuite // (disableScripts = false)  // TyT\n       textAndHtmlMaker.testBody(\"Forum intro text.\"), SysbotUserId, browserIdData,\n       dao, Some(forum.defaultCategoryId), extId = pageExtId, discussionIds = pageDiscussionIds)\n \n-    val pagePosts = dao.readOnlyTransaction { tx => tx.loadPostsOnPage(pageId) }\n+    val pagePosts = dao.readTx(_.loadPostsOnPage(pageId, WhichPostsOnPage.OnlyPublic()))\n \n     (site, forum, pageId, pagePosts, owen, merrylMember, dao)\n   }\n@@ -1127,6 +1127,9 @@ class SitePatcherAppSpec extends DaoAppSuite // (disableScripts = false)  // TyT\n         postsWithExtImpId.length mustBe 1\n       }\n     }\n+\n+    \"Import bookmarks?  TyTIMPBOOKMRK\" - {\n+    }\n   }\n \n "
    },
    {
      "sha": "1f10768a756cab35f6c828db3624dddfa3755e72",
      "filename": "tests/e2e-wdio7/specs/chat-basic.2br.f.mtime.e2e.ts",
      "status": "added",
      "additions": 254,
      "deletions": 0,
      "changes": 254,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fchat-basic.2br.f.mtime.e2e.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fchat-basic.2br.f.mtime.e2e.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fspecs%2Fchat-basic.2br.f.mtime.e2e.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,254 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert from '../utils/ty-assert';\n+import server from '../utils/server';\n+import * as make from '../utils/make';\n+import { TyE2eTestBrowser } from '../utils/ty-e2e-test-browser';\n+import c from '../test-constants';\n+\n+\n+let brA: TyE2eTestBrowser;\n+let brB: TyE2eTestBrowser;\n+\n+let everyone;\n+let owen;\n+let owensBrowser: TyE2eTestBrowser;\n+let maria;\n+let mariasBrowser: TyE2eTestBrowser;\n+let maja;\n+let michael;\n+let michaelsBrowser: TyE2eTestBrowser;\n+\n+let idAddress: IdAddress;\n+let siteId;\n+\n+\n+describe('chat-basic.2br.f.mtime  TyTCHATBASC', () => {\n+\n+  it('create site with two members', async () => {\n+    everyone = new TyE2eTestBrowser(allWdioBrowsers, 'brAll');\n+    brA = new TyE2eTestBrowser(wdioBrowserA, 'brA');\n+    brB = new TyE2eTestBrowser(wdioBrowserB, 'brB');\n+\n+    owen = make.memberOwenOwner();\n+    owensBrowser = brA;\n+    maria = make.memberMaria();\n+    mariasBrowser = brB;\n+\n+    maja = make.memberMaja();\n+    michael = make.memberMichael();\n+    michaelsBrowser = mariasBrowser;\n+\n+    const site: SiteData = make.forumOwnedByOwen('basicchat');\n+    site.members.push(maria);\n+    site.members.push(maja);\n+    site.members.push(michael);\n+    idAddress = await server.importSiteData(site);\n+    siteId = idAddress.id;\n+  });\n+\n+  it(`Everyone goes to the forum`, async () => {\n+    await everyone.go2(idAddress.origin);\n+    mariasBrowser.disableRateLimits();\n+    owensBrowser.disableRateLimits();\n+  });\n+\n+  it(\"Owen logs in\", async () => {\n+    await owensBrowser.watchbar.clickCreateChat();\n+    await owensBrowser.loginDialog.loginWithPassword(owen);\n+  });\n+\n+  it(\"... creates a chat topic\", async () => {\n+    await owensBrowser.editor.editTitle(\"Chat channel title\");\n+    await owensBrowser.editor.editText(\"Chat channel purpose\");\n+    await owensBrowser.rememberCurrentUrl();\n+    await owensBrowser.editor.clickSave();\n+    await owensBrowser.waitForNewUrl();\n+    await owensBrowser.chat.joinChat();\n+  });\n+\n+\n+  // ----- In public chat, can @mention-notify others  [PRIVCHATNOTFS]\n+\n+  let prevNumEmails: number;\n+\n+  it(\"Owen writes a chat message, mentions @maria\", async () => {\n+    prevNumEmails = (await server.getEmailsSentToAddrs(siteId)).num;\n+    await owensBrowser.chat.addChatMessage(`Hi, I'm Owen, and my name is Owen. Who is @${maria.username}?`);\n+    await owensBrowser.chat.waitForNumMessages(1);\n+    await owensBrowser.assertTextMatches('.esC_M', /Owen/);\n+  });\n+  it(\"... Maria gets email notf, since @mentioned, and chat not private [PRIVCHATNOTFS]\", async () => {\n+    await server.waitUntilLastEmailMatches(\n+        siteId, maria.emailAddress, ['my name is Owen'], mariasBrowser);\n+  });\n+  it(\"... but only Maria\", async () => {\n+    const { num, addrsByTimeAsc } = await server.getEmailsSentToAddrs(siteId);\n+    assert.eq(num, prevNumEmails + 1, `Emails sent to: ${addrsByTimeAsc}`);\n+    prevNumEmails = num;\n+  });\n+\n+  it(\"Maria opens the chat page\", async () => {\n+    await mariasBrowser.go2(await owensBrowser.getUrl());\n+  });\n+\n+  it(\"... sees Owens message\", async () => {\n+    await mariasBrowser.chat.waitForNumMessages(1);\n+    await mariasBrowser.assertTextMatches('.esC_M', /Owen/);\n+  });\n+\n+\n+  // ----- Live updates work\n+\n+  it(\"Maria joins the chat topic\", async () => {\n+    await mariasBrowser.chat.joinChat();\n+    await mariasBrowser.loginDialog.loginWithPassword(maria);\n+  });\n+\n+  it(\"Maria posts a chat message, and sees it\", async () => {\n+    await mariasBrowser.chat.addChatMessage(\"Hi, I'm Maria.\");\n+    await mariasBrowser.chat.waitForNumMessages(2);\n+    await mariasBrowser.assertNthTextMatches('.esC_M', 2, /Maria/);\n+  });\n+\n+  it(\"Owen sees it\", async () => {\n+    await owensBrowser.chat.waitForNumMessages(2);\n+    await owensBrowser.assertNthTextMatches('.esC_M', 2, /Maria/);\n+  });\n+\n+  it(\"Owen posts a chat message, and sees it\", async () => {\n+    await owensBrowser.chat.addChatMessage(\"Hi, and is your name Maria?\");\n+    await owensBrowser.assertNthTextMatches('.esC_M', 3, /is your name/);\n+  });\n+\n+  it(\"Maria sees it\", async () => {\n+    await mariasBrowser.assertNthTextMatches('.esC_M', 3, /is your name/);\n+  });\n+\n+  it(\"A minute elapses, ... the browsers re-send long polling requests\", async () => { // break out fn? [4KWBFG5]  [8T5WKBQT]\n+    //const mariaReqNrBefore = await mariasBrowser.countLongPollingsDone();\n+    //const owenReqNrBefore = await owensBrowser.countLongPollingsDone();\n+\n+    // This'll make the browsers send 2 new long polling requests.\n+    await everyone.playTimeSeconds(60);\n+    await everyone.pause(c.MagicTimeoutPollMs + 100);  // ... nr 1 gets sent here\n+    await everyone.playTimeSeconds(60);\n+    await everyone.pause(c.MagicTimeoutPollMs + 100);  // ... nr 2\n+\n+    /*\n+    const mariaReqNrAfter = await mariasBrowser.countLongPollingsDone();\n+    const owenReqNrAfter = await owensBrowser.countLongPollingsDone();\n+\n+    console.log(`Maria's num long pollings after: ${mariaReqNrAfter}, before: ${mariaReqNrBefore}`);\n+    console.log(`Owen's num long pollings after: ${owenReqNrAfter}, before: ${owenReqNrBefore}`);\n+\n+    TESTS_MISSING  TyT20956QKSP2  these were for LongPolling — are some similar types of tests\n+    needed for WebSocket? Maybe disconnect and reconnect tests?\n+\n+    assert.ok(mariaReqNrAfter > mariaReqNrBefore + 1,\n+        `Maria's browser: Long polling didn't happen? Req nr after: ${mariaReqNrAfter}, ` +\n+        `before: ${mariaReqNrBefore} [TyE4WKBZW1]`);\n+    assert.ok(owenReqNrAfter > owenReqNrBefore + 1,\n+        `Owen's browser: Long polling didn't happen? Req nr after: ${owenReqNrAfter}, ` +\n+        `before: ${owenReqNrBefore} [TyE4WKBZW2]`);\n+        */\n+  });\n+\n+  it(\"Maria replies, and Owen posts another message\", async () => {\n+    await mariasBrowser.chat.addChatMessage(\"What?\");\n+    await mariasBrowser.chat.addChatMessage(\"Why, yes.\");\n+    await owensBrowser.chat.addChatMessage(\"Can I call you Maria then?\");\n+  });\n+\n+  it(\"Owen sees Maria's last chat message — live updates still work, after many minutes\", async () => {\n+    await owensBrowser.assertNthTextMatches('.esC_M', 4, /Why, yes/);\n+  });\n+\n+  it(\"Maria sees Owen's\", async () => {\n+    await mariasBrowser.assertNthTextMatches('.esC_M', 5, /Can I call you Maria/);\n+  });\n+\n+\n+  // ----- No notfs in public chat, unless @mentioned  [PRIVCHATNOTFS]\n+\n+  it(\"Maria goes to another page\", async () => {\n+    await mariasBrowser.topbar.clickHome();\n+  });\n+\n+  it(\"?? BUG Annoyingly, needs to click the chat channel so it stops being unread ??\", async () => {\n+    // This makes the topic unread. Why is this needed? Mildly annoying.\n+    await mariasBrowser.watchbar.openUnreadTopic();\n+    await mariasBrowser.watchbar.waitUntilNumUnreadTopics({ atMost: 0, exactly: 0 });\n+    // Then go back to Home.\n+    await mariasBrowser.topbar.clickHome();\n+  });\n+\n+  it(\"Owen posts another message — Maria won't get notified, because \" +\n+     \"not directly to her and isn't a private chat\", async () => {\n+    prevNumEmails = (await server.getEmailsSentToAddrs(siteId)).num;\n+    assert.eq(await mariasBrowser.watchbar.numUnreadTopics(), 0);\n+    await owensBrowser.chat.addChatMessage(`But what is @${michael.username}'s name?`);\n+  });\n+  it(\"... Michael gets notified\", async () => {\n+    await server.waitUntilLastEmailMatches(\n+        siteId, michael.emailAddress, ['But what is @michael'], michaelsBrowser);\n+  });\n+  it(\"... Maria sees the topic get highlighted in the sidebar\", async () => {\n+    await mariasBrowser.watchbar.waitUntilNumUnreadTopics({ atLeast: 1, exactly: 1 });\n+    assert.eq(await mariasBrowser.watchbar.numUnreadTopics(), 1);\n+  });\n+  it(\"... but she won't get any email notf\", async () => {\n+    const { num, addrsByTimeAsc } = await server.getEmailsSentToAddrs(siteId);\n+    // Only 1 email, to Michael.\n+    assert.eq(num, prevNumEmails + 1, `Emails sent to: ${addrsByTimeAsc}`);\n+    prevNumEmails = num;\n+  });\n+\n+\n+  // ----- Appends to the last message, unless @mention sbd else   TyT306WKCDE4\n+\n+  let numMessages: number;\n+\n+  it(\"Owen continues typing\", async () => {\n+    numMessages = await owensBrowser.chat.countMessages({ inclAnyPreview: false }); // [DRAFTS_BUG] ...\n+    // ... namely Owen's browser might show a preview of an empty chat message, after this,\n+    // resulting in +1 more chat messages for Owen, than for Maria;\n+    // then, mariasBrowser.chat.waitForNumMessages(numMessages) below never completes.\n+\n+    await owensBrowser.chat.addChatMessage(`Nothing going`);\n+    await owensBrowser.chat.addChatMessage(`on here`);\n+  });\n+\n+  it(\"Maria clicks the chat in the watchbar — curious about what's going on\", async () => {\n+    await mariasBrowser.watchbar.openUnreadTopic();\n+  });\n+\n+  it(\"... She sees Owens last messages in a single post\", async () => {\n+    await mariasBrowser.chat.waitForNumMessages(numMessages);\n+    assert.eq(await mariasBrowser.chat.countMessages(), numMessages);  // but not more\n+  });\n+\n+  // The regex modifier /s makes '.' match line breaks too.\n+  const chatMessage6Regex = /.*michael's name.*Nothing going.*on here/s;\n+\n+  it(\"... with the 3 last texts Owen typed\", async () => {\n+    await mariasBrowser.chat.assertMessageNrMatches(6, chatMessage6Regex);\n+  });\n+\n+  it(\"Owen continues typing, @mentions Maja\", async () => {\n+    await owensBrowser.chat.addChatMessage(`@${maja.username} do you know what's ANYONE'S name?`);\n+  });\n+\n+  it(\"... this becomes a separate message, since @mentions sbd else\", async () => {\n+    numMessages += 1;\n+    await mariasBrowser.chat.waitForNumMessages(numMessages);\n+    await mariasBrowser.chat.assertMessageNrMatches(7, /ANYONE'S name/);\n+  });\n+\n+  it(\"... didn't change Owen's previous message\", async () => {\n+    await mariasBrowser.chat.assertMessageNrMatches(6, chatMessage6Regex);\n+  });\n+\n+});\n+"
    },
    {
      "sha": "5bfd86d346a6369c4b3fe4f4a372ff02e590e2b8",
      "filename": "tests/e2e-wdio7/specs/chat-scroll.2br.f.e2e.ts",
      "status": "added",
      "additions": 143,
      "deletions": 0,
      "changes": 143,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fchat-scroll.2br.f.e2e.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fchat-scroll.2br.f.e2e.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fspecs%2Fchat-scroll.2br.f.e2e.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,143 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert from '../utils/ty-assert';\n+import server from '../utils/server';\n+import { buildSite } from '../utils/site-builder';\n+import { TyE2eTestBrowser } from '../utils/ty-e2e-test-browser';\n+import c from '../test-constants';\n+\n+let brA: TyE2eTestBrowser;\n+let brB: TyE2eTestBrowser;\n+let owen: Member;\n+let owen_brA: TyE2eTestBrowser;\n+let maria: Member;\n+let maria_brB: TyE2eTestBrowser;\n+let stranger_brB: TyE2eTestBrowser;\n+\n+let site: IdAddress;\n+let forum: TwoCatsTestForum;\n+\n+let chatPageUrl: St;\n+\n+const numMsgs = 150;\n+const lastMsgNr = c.FirstReplyNr + numMsgs - 1;\n+\n+\n+\n+describe(`chat-scroll.2br.f  TyTCHATSCROLL`, () => {\n+\n+  it(`Construct site`, async () => {\n+    const builder = buildSite();\n+    forum = builder.addCatABForum({\n+      title: \"Chat Scroll E2E\",\n+      members: ['maria'],\n+    });\n+\n+    const chatPage: PageJustAdded = builder.addPage({\n+      id: 'chatPageId',\n+      folder: '/',\n+      showId: false,\n+      slug: 'chat-page',\n+      role: c.TestPageRole.JoinlessChat,\n+      title: \"Scroll Test Chat\",\n+      body: \"Note that you can't scroll faster than 6e10 cm per two seconds.\",\n+      categoryId: forum.categories.categoryA.id,\n+      authorId: forum.members.maria.id,\n+    });\n+\n+    // Nrs 2 (c.FirstReplyNr) .. lastMsgNr.\n+    for (let nr = c.FirstReplyNr; nr <= lastMsgNr; nr += 1) {\n+      builder.addPost({\n+        page: chatPage,\n+        nr,\n+        // parentNr: c.BodyNr — not needed for chats. [CHATPRNT]\n+        authorId: forum.members.maria.id,\n+        approvedSource: `Message_nr_${nr}`,\n+      });\n+    }\n+\n+    brA = new TyE2eTestBrowser(wdioBrowserA, 'brA');\n+    brB = new TyE2eTestBrowser(wdioBrowserB, 'brB');\n+\n+    owen = forum.members.owen;\n+    owen_brA = brA;\n+\n+    maria = forum.members.maria;\n+    maria_brB = brB;\n+    stranger_brB = brB;\n+\n+    assert.refEq(builder.getSite(), forum.siteData);\n+  });\n+\n+  it(`Import site`, async () => {\n+    site = await server.importSiteData(forum.siteData);\n+    await server.skipRateLimits(site.id);\n+    chatPageUrl = site.origin + '/chat-page';\n+  });\n+\n+\n+  it(`Owen goes to the chat page`, async () => {\n+    await owen_brA.go2(chatPageUrl);\n+  });\n+  it(`... logs in`, async () => {\n+    await owen_brA.complex.loginWithPasswordViaTopbar(owen);\n+  });\n+\n+  addTestScrollSteps(() => owen_brA, \"Owen\");\n+\n+  // Is this really interesting?  Hmm, maybe not worth the time actually.\n+  //it(`A stranger arrives too`, async () => {\n+  //  await stranger_brB.go2(chatPageUrl);\n+  //  await maria_brB.complex.loginWithPasswordViaTopbar(maria);\n+  //});\n+\n+  // addTestScrollSteps(() => stranger_brB, \"A stranger\");\n+\n+  function addTestScrollSteps(brX: () => TyE2eTestBrowser, who: St) {\n+    it(`${who} can see Message_nr_${lastMsgNr} — the most recent message`, async () => {\n+      await brX().topic.waitForPostNrVisible(lastMsgNr);\n+    });\n+    it(`... and Message_nr_112 — that's far back is included on page load`, async () => {\n+      await brX().topic.waitForPostNrVisible(112);\n+    });\n+    it(`... but not Message_nr_111 — need to scroll up, for it to get inserted`, async () => {\n+      assert.not(await brX().topic.isPostNrVisible(111));\n+    });\n+    it(`... The very first message, #post-${c.FirstReplyNr}, also not visible`, async () => {\n+      assert.not(await brX().topic.isPostNrVisible(c.FirstReplyNr));\n+    });\n+\n+    it(`Han scrolls up to the top of the chat`, async () => {\n+      await brX().scrollTowardsUntilAppears('.c_Chat_Top', '#post-' + c.FirstReplyNr);\n+    });\n+\n+    it(`... but the newest (most recent) message is no longer shown`, async () => {\n+      assert.not(await brX().topic.isPostNrVisible(lastMsgNr));\n+    });\n+\n+    it(`Han scrolls down to the end of the chat`, async () => {\n+      await brX().scrollTowardsUntilAppears('.c_Chat_Bottom', '#post-' + lastMsgNr);\n+    });\n+\n+    it(`... now the oldest (at the very top) no longer shown`, async () => {\n+      assert.not(await brX().topic.isPostNrVisible(c.FirstReplyNr));\n+    });\n+    it(`... but Message_nr_112 is visible again`, async () => {\n+      await brX().topic.waitForPostNrVisible(112);\n+    });\n+    it(`... and Message_nr_51 is visible again\n+                  — we show 100 messages: 51 – 151  [max_chat_msgs_2_show]`, async () => {\n+      await brX().topic.waitForPostNrVisible(51);\n+    });\n+\n+    it(`... not nr 50 though, that would have been 101 messages`, async () => {\n+      assert.not(await brX().topic.isPostNrVisible(50));\n+    });\n+    it(`... and of course not nr 20 (far below 50)`, async () => {\n+      assert.not(await brX().topic.isPostNrVisible(20));\n+    });\n+  }\n+\n+});\n+"
    },
    {
      "sha": "60b0dc89f72e8b25246c92d878cae418a970d061",
      "filename": "tests/e2e-wdio7/specs/embcom.scroll-and-load-more.2br.ec.e2e.ts",
      "status": "renamed",
      "additions": 40,
      "deletions": 46,
      "changes": 86,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fembcom.scroll-and-load-more.2br.ec.e2e.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fembcom.scroll-and-load-more.2br.ec.e2e.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fspecs%2Fembcom.scroll-and-load-more.2br.ec.e2e.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1,21 +1,16 @@\n /// <reference path=\"../test-types.ts\"/>\n \n import * as _ from 'lodash';\n-import assert = require('../utils/ty-assert');\n-import fs = require('fs');\n-import server = require('../utils/server');\n-import utils = require('../utils/utils');\n+import assert from '../utils/ty-assert';\n+import * as fs from 'fs';\n+import server from '../utils/server';\n+import * as utils from '../utils/utils';\n import { buildSite } from '../utils/site-builder';\n-import { TyE2eTestBrowser } from '../utils/pages-for';\n-import settings = require('../utils/settings');\n-import lad = require('../utils/log-and-die');\n-import c = require('../test-constants');\n+import { TyE2eTestBrowser } from '../utils/ty-e2e-test-browser';\n+import * as lad from '../utils/log-and-die';\n+import c from '../test-constants';\n \n \n-\n-\n-\n-let everyonesBrowsers;\n let richBrowserA;\n let richBrowserB;\n let owen: Member;\n@@ -34,12 +29,12 @@ let forum: TwoPagesTestForum;\n const localHostname = 'comments-for-e2e-test-scrlld';\n const embeddingOrigin = 'http://e2e-test-scrlld.localhost:8080';\n \n-let veryLastPostNr;\n+let veryLastPostNr: Nr | U;\n \n \n-describe(\"embedded-comments-scroll-and-load-more.2browsers  TyT603MRKH592S\", () => {\n+describe(\"embcom.scroll-and-load-more.2br.ec  TyT603MRKH592S\", () => {\n \n-  it(\"import a site\", () => {\n+  it(\"import a site\", async () => {\n     const builder = buildSite();\n     forum = builder.addTwoPagesForum({\n       title: \"Emb Cmts Scroll Load Posts E2E Test\",\n@@ -102,16 +97,15 @@ describe(\"embedded-comments-scroll-and-load-more.2browsers  TyT603MRKH592S\", ()\n     forum.siteData.meta.localHostname = localHostname;\n     forum.siteData.settings.allowEmbeddingFrom = embeddingOrigin;\n \n-    siteIdAddress = server.importSiteData(forum.siteData);\n+    siteIdAddress = await server.importSiteData(forum.siteData);\n     siteId = siteIdAddress.id;\n     server.skipRateLimits(siteId);\n     //discussionPageUrl = siteIdAddress.origin + '/' + forum.topics.byMichaelCategoryA.slug;\n   });\n \n-  it(\"initialize people\", () => {\n-    everyonesBrowsers = new TyE2eTestBrowser(wdioBrowser);\n-    richBrowserA = new TyE2eTestBrowser(browserA);\n-    richBrowserB = new TyE2eTestBrowser(browserB);\n+  it(\"initialize people\", async () => {\n+    richBrowserA = new TyE2eTestBrowser(wdioBrowserA, 'brA');\n+    richBrowserB = new TyE2eTestBrowser(wdioBrowserB, 'brB');\n \n     owen = forum.members.owen;\n     owensBrowser = richBrowserA;\n@@ -126,7 +120,7 @@ describe(\"embedded-comments-scroll-and-load-more.2browsers  TyT603MRKH592S\", ()\n   const pageSlug = 'load-and-scroll.html';\n   const blankSlug = 'blank.html';\n \n-  it(\"There's an embedding page\", () => {\n+  it(\"There's an embedding page\", async () => {\n     const dir = 'target';\n \n     fs.writeFileSync(\n@@ -143,54 +137,54 @@ describe(\"embedded-comments-scroll-and-load-more.2browsers  TyT603MRKH592S\", ()\n     }\n   });\n \n-  it(\"A stranger wants to read #comment-30, which needs to be lazy-opened\", () => {\n-    strangersBrowser.go2(embeddingOrigin + '/' + pageSlug);\n+  it(\"A stranger wants to read #comment-30, which needs to be lazy-opened\", async () => {\n+    await strangersBrowser.go2(embeddingOrigin + '/' + pageSlug);\n   });\n \n-  it(\"Post 10 is visible\", () => {\n-    strangersBrowser.topic.waitForPostNrVisible(10);\n+  it(\"Post 10 is visible\", async () => {\n+    await strangersBrowser.topic.waitForPostNrVisible(10);\n   });\n \n-  it(\"But comment 30 is not — when there're many posts, not all are shown\", () => {\n-    assert.not(strangersBrowser.topic.isPostNrVisible(30 + 1));\n+  it(\"But comment 30 is not — when there're many posts, not all are shown\", async () => {\n+    assert.not(await strangersBrowser.topic.isPostNrVisible(30 + 1));\n   });\n \n-  it(\"The stranger leaves\", () => {\n-    strangersBrowser.go2(embeddingOrigin + '/' + blankSlug);\n+  it(\"The stranger leaves\", async () => {\n+    await strangersBrowser.go2(embeddingOrigin + '/' + blankSlug);\n   });\n \n-  it(\"And returns — to see comment 30 (post 31)  TyT03RMET742M\", () => {\n-    strangersBrowser.go2(embeddingOrigin + '/' + pageSlug + '#comment-30');\n+  it(\"And returns — to see comment 30 (post 31)  TyT03RMET742M\", async () => {\n+    await strangersBrowser.go2(embeddingOrigin + '/' + pageSlug + '#comment-30');\n   });\n \n-  it(\"... comment 30 (post 31)  appears\", () => {\n-    strangersBrowser.topic.waitForPostNrVisible(30 + 1);\n-    assert.ok(strangersBrowser.topic.isPostNrVisible(30 + 1));  // tests the test\n+  it(\"... comment 30 (post 31)  appears\", async () => {\n+    await strangersBrowser.topic.waitForPostNrVisible(30 + 1);\n+    assert.ok(await strangersBrowser.topic.isPostNrVisible(30 + 1));  // tests the test\n   });\n \n-  it(\"But not comment 31\", () => {\n-    assert.not(strangersBrowser.topic.isPostNrVisible(31 + 1));\n+  it(\"But not comment 31\", async () => {\n+    assert.not(await strangersBrowser.topic.isPostNrVisible(31 + 1));\n   });\n \n-  it(\"The stranger clicks  'Show more replies...' below — now comment 31 (post 32) appears\", () => {\n-    strangersBrowser.switchToAnyParentFrame(); // cannot scroll in comments iframe\n-    strangersBrowser.switchToEmbCommentsIframeIfNeeded();\n-    strangersBrowser.topic.clickShowMorePosts({ nextPostNr: 32 });\n-    assert.ok(strangersBrowser.topic.isPostNrVisible(31 + 1));  // tests the test\n+  it(\"The stranger clicks  'Show more replies...' below — now comment 31 (post 32) appears\", async () => {\n+    await strangersBrowser.switchToAnyParentFrame(); // cannot scroll in comments iframe\n+    await strangersBrowser.switchToEmbCommentsIframeIfNeeded();\n+    await strangersBrowser.topic.clickShowMorePosts({ nextPostNr: 32 });\n+    assert.ok(await strangersBrowser.topic.isPostNrVisible(31 + 1));  // tests the test\n   });\n \n-  it(\"The stranger wants to read more and more ... Everything!\", () => {\n+  it(\"The stranger wants to read more and more ... Everything!\", async () => {\n     while (true) {\n-      if (strangersBrowser.topic.isPostNrVisible(veryLastPostNr))\n+      if (await strangersBrowser.topic.isPostNrVisible(veryLastPostNr))\n         break;\n \n-      if (strangersBrowser.isVisible('.dw-x-show')) {\n+      if (await strangersBrowser.isVisible('.dw-x-show')) {\n         lad.logMessage(`Clicking Show More ...`);\n-        strangersBrowser.waitAndClickFirst('.dw-x-show', { maybeMoves: true });\n+        await strangersBrowser.waitAndClickFirst('.dw-x-show', { maybeMoves: true });\n       }\n \n       lad.logMessage(`Waiting for more posts to load ...`);\n-      strangersBrowser.pause(250);\n+      await strangersBrowser.pause(250);\n     }\n   });\n ",
      "previous_filename": "tests/e2e/specs/embedded-comments-scroll-and-load-more.2browsers.test.ts"
    },
    {
      "sha": "b1e1ff0b7b7e86039ea0294eb6d6214c6be04f5f",
      "filename": "tests/e2e-wdio7/specs/modn-from-disc-page-appr-befr.2br.f.e2e.ts",
      "status": "added",
      "additions": 292,
      "deletions": 0,
      "changes": 292,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fmodn-from-disc-page-appr-befr.2br.f.e2e.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Fspecs%2Fmodn-from-disc-page-appr-befr.2br.f.e2e.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Fspecs%2Fmodn-from-disc-page-appr-befr.2br.f.e2e.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,292 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert from '../utils/ty-assert';\n+import server from '../utils/server';\n+import { buildSite } from '../utils/site-builder';\n+import { TyE2eTestBrowser, TyAllE2eTestBrowsers } from '../utils/ty-e2e-test-browser';\n+import c from '../test-constants';\n+\n+let everyonesBrowsers: TyAllE2eTestBrowsers;\n+let richBrowserA: TyE2eTestBrowser;\n+let richBrowserB: TyE2eTestBrowser;\n+let owen: Member;\n+let owensBrowser: TyE2eTestBrowser;\n+let mons: Member;\n+let monsBrowser: TyE2eTestBrowser;\n+let modya: Member;\n+let modyasBrowser: TyE2eTestBrowser;\n+let maria: Member;\n+let mariasBrowser: TyE2eTestBrowser;\n+let michael: Member;\n+let michaelsBrowser: TyE2eTestBrowser;\n+let strangersBrowser: TyE2eTestBrowser;\n+\n+let site: IdAddress;\n+let forum: EmptyTestForum;\n+\n+const topicOneTitle = 'topicOneTitle';\n+const topicOneBody = 'topicOneBody';\n+\n+const replA_txt = 'replA_txt';\n+const replA_nr = c.FirstReplyNr;\n+const replB_txt = 'replB_txt';\n+const replB_nr = c.FirstReplyNr + 1;\n+const replC_toRej_txt = 'replC_toRej_txt';\n+const replC_toRej_nr = c.FirstReplyNr + 2;\n+const replD_toApr_txt = 'replD_toApr_txt';\n+const replD_toApr_nr = c.FirstReplyNr + 3;\n+const modyasMoreText = ' modyasMoreText';\n+\n+const topicTwoTitle = 'topicTwoTitle';\n+const topicTwoBody = 'topicTwoBody';\n+\n+\n+describe(`modn-from-disc-page-appr-befr.2br.f  TyTE2E603RTJ`, () => {\n+\n+  it(`construct site`, async () => {\n+    const builder = buildSite();\n+    forum = builder.addEmptyForum({  // or: builder.addLargeForum\n+      title: \"Some E2E Test\",\n+      members: undefined, // default = everyone\n+    });\n+\n+    builder.settings({\n+      numFirstPostsToApprove: 0,\n+      requireApprovalIfTrustLte: c.TestTrustLevel.FullMember,\n+      maxPostsPendApprBefore: 4,\n+      numFirstPostsToReview: 0,\n+    });\n+    builder.getSite().pageNotfPrefs = [{\n+      memberId: forum.members.owen.id,\n+      notfLevel: c.TestPageNotfLevel.Muted,\n+      wholeSite: true,\n+    }];\n+\n+    everyonesBrowsers = new TyE2eTestBrowser(allWdioBrowsers, 'brAll');\n+    richBrowserA = new TyE2eTestBrowser(wdioBrowserA, 'brA');\n+    richBrowserB = new TyE2eTestBrowser(wdioBrowserB, 'brB');\n+\n+    owen = forum.members.owen;\n+    owensBrowser = richBrowserA;\n+    mons = forum.members.mons;\n+    monsBrowser = richBrowserA;\n+    modya = forum.members.modya;\n+    modyasBrowser = richBrowserA;\n+\n+    maria = forum.members.maria;\n+    mariasBrowser = richBrowserB;\n+\n+    michael = forum.members.michael;\n+    michaelsBrowser = richBrowserB;\n+\n+    strangersBrowser = richBrowserB;\n+\n+    assert.refEq(builder.getSite(), forum.siteData);\n+  });\n+\n+  it(`import site`, async () => {\n+    site = await server.importSiteData(forum.siteData);\n+    server.skipRateLimits(site.id);\n+  });\n+\n+  it(`Maria logs in`, async () => {\n+    await mariasBrowser.go2(site.origin + '/');\n+    await mariasBrowser.complex.loginWithPasswordViaTopbar(maria);\n+  });\n+\n+  let topicOneUrl: St;\n+  let topicTwoUrl: St;\n+\n+  it(`... posts a new topic`, async () => {\n+    await mariasBrowser.complex.createAndSaveTopic({\n+          title: topicOneTitle, body: topicOneBody, willBePendingApproval: true });\n+    topicOneUrl = await mariasBrowser.getUrl();\n+  });\n+\n+  it(`... it becomes pending approval`, async () => {\n+    await mariasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n+    await mariasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n+    await mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n+  });\n+\n+  it(`Maria navigates away, ... and back`, async () => {\n+    await mariasBrowser.topbar.clickHome();\n+    await mariasBrowser.forumTopicList.goToTopic(topicOneTitle);\n+  });\n+\n+  it(`... text stil visible, after SPA-navigated away and back  TyTE2E603SKD`, async () => {\n+    await mariasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n+    await mariasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n+    await mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n+  });\n+\n+  it(`... and after reload  TyTE2E603SKD`, async () => {\n+    await mariasBrowser.refresh2();\n+    await mariasBrowser.waitForMyDataAdded();\n+    await mariasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n+    await mariasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n+    await mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n+  });\n+\n+  it(`Maria posts another topic`, async () => {\n+    await mariasBrowser.topbar.clickHome();\n+    await mariasBrowser.complex.createAndSaveTopic({\n+          title: topicTwoTitle, body: topicTwoBody, willBePendingApproval: true });\n+    topicTwoUrl = await mariasBrowser.getUrl();\n+  });\n+\n+  it(`... it becomes pending approval`, async () => {\n+    await mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n+  });\n+\n+  it(`A stranger somehow navigates to the page`, async () => {\n+    await modyasBrowser.go2(topicTwoUrl);  // not yet logged in\n+  });\n+\n+  it(`... but page not visible — not yet approved  TyTE2E603SKD`, async () => {\n+    await modyasBrowser.assertWholePageHidden();  // not yet logged in\n+  });\n+\n+  it(`Modya logs in`, async () => {\n+    await modyasBrowser.loginDialog.loginWithPassword(modya);\n+  });\n+\n+  it(`... the unapproved title & body get loaded via page load  TyTE2E603SKD`, async () => {\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicTwoBody);\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicTwoTitle);\n+  });\n+\n+  it(`Modya rejects topic two`, async () => {\n+    await modyasBrowser.topic.rejectPostNr(c.BodyNr);\n+  });\n+\n+  it(`... that deletes the page`, async () => {\n+    await modyasBrowser.topic.waitUntilPageDeleted();\n+  });\n+\n+  it(`Modya navigates to topic one`, async () => {\n+    await modyasBrowser.topbar.clickHome();\n+    await modyasBrowser.forumTopicList.goToTopic(topicOneTitle);\n+  });\n+\n+  it(`... the unapproved posts get loaded, via SPA navigation  TyTE2E603SKD`, async () => {\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n+    /* Not created yet:\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(replA_nr, replA_txt);\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(replB_nr, replB_txt);\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(replC_toRej_nr, replC_toRej_txt);\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(replD_toApr_nr, replD_toApr_txt);\n+    */\n+  });\n+\n+  it(`... approves topic one`, async () => {\n+    await modyasBrowser.topic.approvePostNr(c.BodyNr);\n+  });\n+\n+\n+  it(`Maria now cannot see topic 2`, async () => {\n+    assert.eq(await mariasBrowser.getUrl(), topicTwoUrl);\n+    await mariasBrowser.refresh2();\n+    await mariasBrowser.assertNotFoundError({ whyNot: 'PageDeleted' });\n+  });\n+\n+  it(`... and that topic one got approved`, async () => {\n+    await mariasBrowser.go2(topicOneUrl);\n+    await mariasBrowser.topic.assertPageNotPendingApproval();\n+  });\n+\n+  it(`Maria posts four replies, in topic one`, async () => {\n+    await mariasBrowser.complex.replyToOrigPost(replA_txt);\n+    await mariasBrowser.complex.replyToOrigPost(replB_txt);\n+    await mariasBrowser.complex.replyToOrigPost(replC_toRej_txt);\n+    await mariasBrowser.complex.replyToOrigPost(replD_toApr_txt);\n+  });\n+\n+  it(`... they become pending-approval`, async () => {\n+    await mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replA_nr);\n+    await mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replB_nr);\n+    await mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replC_toRej_nr);\n+    await mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replD_toApr_nr);\n+  });\n+\n+  it(`Modya rejects reply C`, async () => {\n+    await modyasBrowser.topic.rejectPostNr(replC_toRej_nr);\n+  });\n+\n+  it(`... edits reply D`, async () => {\n+    await modyasBrowser.complex.editPostNr(replD_toApr_nr, modyasMoreText, { append: true });\n+  });\n+\n+  it(`... edititing it won't approve it  TyTE2E407RKS`, async () => {\n+    await modyasBrowser.refresh2();\n+    await modyasBrowser.topic.waitForPostAssertTextMatches(\n+          replD_toApr_nr, replD_toApr_txt + modyasMoreText);\n+    await modyasBrowser.topic.assertPostNeedsApprovalBodyVisible(replD_toApr_nr);\n+    assert.deepEq(await modyasBrowser.topic.countReplies({ skipWait: true }),\n+          { numNormal: 0, numPreviews: 0, numDrafts: 0, numUnapproved: 3, numDeleted: 0 });\n+  });\n+\n+  it(`... approves reply D`, async () => {\n+    await modyasBrowser.topic.approvePostNr(replD_toApr_nr);\n+  });\n+\n+  //  TyT204RKSTEM\n+  //  Mons approves from disc page, Modya approves & rejects from modn page.\n+  //  Mons rejects from disc page, Modya approves & rejects from modn page.\n+\n+  it(`Maria sees the page and reply D got approved`, async () => {\n+    await mariasBrowser.topic.refreshUntilPostNotPendingApproval(replD_toApr_nr);\n+  });\n+\n+  /* Now deleted unapproved posts are no longer loaded.  [opt_show_deld_posts]\n+  it(`... and reply C is deleted`, async () => {\n+    await mariasBrowser.topic.waitForPostVisibleAsDeleted(replC_toRej_nr);\n+  }); */\n+\n+  it(`... and two pending approval`, async () => {\n+    assert.deepEq(await strangersBrowser.topic.countReplies({ skipWait: true }),\n+          { numNormal: 1, numPreviews: 0, numDrafts: 0, numUnapproved: 2, numDeleted: 0 });\n+  });\n+\n+\n+  it(`A stranger sees reply D  TyTE2E603SKD`, async () => {\n+    await mariasBrowser.topbar.clickLogout();\n+    await strangersBrowser.topic.waitForPostAssertTextMatches(\n+          replD_toApr_nr, replD_toApr_txt + modyasMoreText);\n+  });\n+\n+  it(`... A and B still pending approval`, async () => {\n+    await strangersBrowser.topic.assertPostNeedsApprovalBodyHidden(replA_nr);\n+    await strangersBrowser.topic.assertPostNeedsApprovalBodyHidden(replB_nr);\n+  });\n+\n+  it(`... C gone`, async () => {\n+    assert.not(await strangersBrowser.topic.isPostNrVisible(replC_toRej_nr));\n+  });\n+\n+  it(`... those are all posts`, async () => {\n+    assert.deepEq(await strangersBrowser.topic.countReplies({ skipWait: true }),\n+          { numNormal: 1, numPreviews: 0, numDrafts: 0, numUnapproved: 2, numDeleted: 0 });\n+  });\n+\n+\n+  // TESTS_MISSING  TyT204RKSTEM\n+  //  Modya approves from modn page, Mons approves & rejects from disc page.\n+  //  Modya rejects from modn page, Mons approves & rejects from disc page.\n+\n+  it(`Mons tries to approve and reject C and D via the mod page`, async () => {\n+  });\n+\n+  it(`Mons instead approves A and B`, async () => {\n+  });\n+\n+  it(`Modya approves A — before Mons' undo timeout`, async () => {\n+  });\n+\n+  it(`Modya tries to approve B — after Mons' undo timeout`, async () => {\n+  });\n+\n+});\n+"
    },
    {
      "sha": "5161af55ea57d70ed1453c8ed6001984b42baad4",
      "filename": "tests/e2e-wdio7/utils/ty-e2e-test-browser.ts",
      "status": "modified",
      "additions": 38,
      "deletions": 16,
      "changes": 54,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Futils%2Fty-e2e-test-browser.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/tests%2Fe2e-wdio7%2Futils%2Fty-e2e-test-browser.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e-wdio7%2Futils%2Fty-e2e-test-browser.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1472,6 +1472,28 @@ export class TyE2eTestBrowser {\n     }\n \n \n+    /// On chat pages, comments are lazy-loaded when scrolling upwards (or downwards).\n+    /// But then, when a comment does not yet exist, how can we scroll towards it?\n+    /// By scrolling towards *another* selector that's always present.\n+    ///\n+    /// Or is it better to specify a scroll *direction*, and after each scroll step,\n+    /// poll & check if the elem appeared?\n+    /// Is there any risk that we scroll too fast, scroll past the elem?\n+    ///\n+    async scrollTowardsUntilAppears(towardsSel: St, appearsLaterSel: St): Pr<V> {\n+      await this.waitUntil(async (): Pr<Bo> => {\n+        // The chat top & bottom have visibility: hidden, and maybe that's the case for\n+        // most scroll-towards selectors, since they aren't the \"interesting\" thing?\n+        await this._real_scrollIntoViewInPageColumn(towardsSel, { waitForVisible: false });\n+        const isVis = await this.isVisible(appearsLaterSel);\n+        return isVis;\n+      }, {\n+        message: `Scrolling towards: ${towardsSel}  until appears: ${\n+                  appearsLaterSel} ...`,\n+      });\n+    }\n+\n+\n     async scrollIntoViewInPageColumn(selector: St) {   // RENAME to  scrollIntoView\n       dieIf(!selector, '!selector [TyE05RKCD5]');\n \n@@ -1510,9 +1532,10 @@ export class TyE2eTestBrowser {\n     }\n \n \n-    async _real_scrollIntoViewInPageColumn(selector: St) { // RENAME to _scrollIntoViewInPageColumn\n+    async _real_scrollIntoViewInPageColumn(selector: St, ps: { waitForVisible?: false } = {}) { // RENAME to _scrollIntoViewInPageColumn\n       dieIf(!selector, '!selector [TyE5WKT02JK4]');\n-      await this.waitForVisible(selector);\n+      if (ps.waitForVisible === false) await this.waitForExist(selector);\n+      else await this.waitForVisible(selector);\n       let lastScrollY = await this.getPageScrollY();\n       for (let i = 0; i < 60; ++i) {   // try for a bit more than 10 seconds\n         await this.#br.execute(function(selector) {\n@@ -3081,21 +3104,19 @@ export class TyE2eTestBrowser {\n \n     _pageNotFoundOrAccessDenied = 'Page not found, or Access Denied';\n \n-    /* CLEAN_UP  byBrowser probably doesn't work? if so,  REMOVE this.\n     // Also see this.#br.pageTitle.assertPageHidden().  Dupl code [05PKWQ2A]\n     async assertWholePageHidden() {\n-      let resultsByBrowser = byBrowser(await this.#br.getPageSource());\n-      _.forOwn(resultsByBrowser, (text: any, browserName) => {\n-        if (settings.prod) {\n-          tyAssert.includes(text, this._pageNotFoundOrAccessDenied);\n-        }\n-        else {\n-          tyAssert.includes(text, 'EdE0SEEPAGEHIDDEN_');\n-        }\n-      });\n+      const text = await this.#br.getPageSource();\n+      if (settings.prod) {\n+        tyAssert.includes(text, this._pageNotFoundOrAccessDenied);\n+      }\n+      else {\n+        tyAssert.includes(text, 'EdE0SEEPAGEHIDDEN_');\n+      }\n     }\n \n \n+    /*\n     // Also see this.pageTitle.assertPageHidden().  Dupl code [05PKWQ2A]\n     async assertMayNotSeePage() {\n       let resultsByBrowser = byBrowser(await this.#br.getPageSource());\n@@ -3882,10 +3903,11 @@ export class TyE2eTestBrowser {\n         });\n       },\n \n-      waitUntilNumUnreadTopics: async (num: number) => {\n-        assert.ok(num > 0, 'TyE0578WNSYG');\n-        await this.waitForAtLeast(num, '.esWB_T-Unread');\n-        await this.assertExactly(num, '.esWB_T-Unread');\n+      waitUntilNumUnreadTopics: async (ps: HowMany) => {\n+        await this.waitUntil(async () => {\n+          const num = await this.watchbar.numUnreadTopics();\n+          return isOkMany(num, ps);\n+        });\n       },\n \n       goToTopic: async (title: St, opts: { isHome?: true, shouldBeUnread?: Bo } = {}) => {"
    },
    {
      "sha": "fde42ee7173cc081fe14710569f45f4df89490d0",
      "filename": "tests/e2e/specs/chat-basic.2br.mtime.test.ts",
      "status": "removed",
      "additions": 0,
      "deletions": 249,
      "changes": 249,
      "blob_url": "https://github.com/debiki/talkyard/blob/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca/tests%2Fe2e%2Fspecs%2Fchat-basic.2br.mtime.test.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca/tests%2Fe2e%2Fspecs%2Fchat-basic.2br.mtime.test.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e%2Fspecs%2Fchat-basic.2br.mtime.test.ts?ref=1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca",
      "patch": "@@ -1,249 +0,0 @@\n-/// <reference path=\"../test-types.ts\"/>\n-\n-import * as _ from 'lodash';\n-import assert = require('../utils/ty-assert');\n-import server = require('../utils/server');\n-import utils = require('../utils/utils');\n-import { TyE2eTestBrowser } from '../utils/pages-for';\n-import settings = require('../utils/settings');\n-import make = require('../utils/make');\n-import logAndDie = require('../utils/log-and-die');\n-import c = require('../test-constants');\n-\n-let browser: TyE2eTestBrowser;\n-declare let browserA: any;\n-declare let browserB: any;\n-\n-let everyone;\n-let owen;\n-let owensBrowser: TyE2eTestBrowser;\n-let maria;\n-let mariasBrowser: TyE2eTestBrowser;\n-let maja;\n-let michael;\n-let michaelsBrowser: TyE2eTestBrowser;\n-\n-let siteId;\n-\n-\n-describe('chat', function() {\n-\n-  it('create site with two members', function() {\n-    everyone = new TyE2eTestBrowser(wdioBrowser);\n-    owen = _.assign(new TyE2eTestBrowser(browserA), make.memberOwenOwner());\n-    owensBrowser = owen;\n-    maria = _.assign(new TyE2eTestBrowser(browserB), make.memberMaria());\n-    mariasBrowser = maria;\n-    maja = make.memberMaja();\n-    michael = make.memberMichael();\n-    michaelsBrowser = mariasBrowser;\n-\n-    const site: SiteData = make.forumOwnedByOwen('basicchat');\n-    site.members.push(make.memberMaria());\n-    site.members.push(maja);\n-    site.members.push(michael);\n-    const idAddress = server.importSiteData(site);\n-    siteId = idAddress.id;\n-    everyone.go(idAddress.origin);\n-    mariasBrowser.disableRateLimits();\n-    owensBrowser.disableRateLimits();\n-  });\n-\n-  it(\"Owen logs in\", () => {\n-    owensBrowser.watchbar.clickCreateChat();\n-    owensBrowser.loginDialog.loginWithPassword(owen);\n-  });\n-\n-  it(\"... creates a chat topic\", () => {\n-    owensBrowser.editor.editTitle(\"Chat channel title\");\n-    owensBrowser.editor.editText(\"Chat channel purpose\");\n-    owensBrowser.rememberCurrentUrl();\n-    owensBrowser.editor.clickSave();\n-    owensBrowser.waitForNewUrl();\n-    owensBrowser.chat.joinChat();\n-  });\n-\n-\n-  // ----- In public chat, can @mention-notify others  [PRIVCHATNOTFS]\n-\n-  let prevNumEmails: number;\n-\n-  it(\"Owen writes a chat message, mentions @maria\", function() {\n-    prevNumEmails = server.getEmailsSentToAddrs(siteId).num;\n-    owensBrowser.chat.addChatMessage(`Hi, I'm Owen, and my name is Owen. Who is @${maria.username}?`);\n-    owensBrowser.chat.waitForNumMessages(1);\n-    owensBrowser.assertTextMatches('.esC_M', /Owen/);\n-  });\n-  it(\"... Maria gets email notf, since @mentioned, and chat not private [PRIVCHATNOTFS]\", () => {\n-    server.waitUntilLastEmailMatches(\n-        siteId, maria.emailAddress, ['my name is Owen'], mariasBrowser);\n-  });\n-  it(\"... but only Maria\", () => {\n-    const { num, addrsByTimeAsc } = server.getEmailsSentToAddrs(siteId);\n-    assert.eq(num, prevNumEmails + 1, `Emails sent to: ${addrsByTimeAsc}`);\n-    prevNumEmails = num;\n-  });\n-\n-  it(\"Maria opens the chat page\", () => {\n-    mariasBrowser.go(owensBrowser.getUrl());\n-  });\n-\n-  it(\"... sees Owens message\", () => {\n-    mariasBrowser.chat.waitForNumMessages(1);\n-    mariasBrowser.assertTextMatches('.esC_M', /Owen/);\n-  });\n-\n-\n-  // ----- Live updates work\n-\n-  it(\"Maria joins the chat topic\", function() {\n-    mariasBrowser.chat.joinChat();\n-    mariasBrowser.loginDialog.loginWithPassword(maria);\n-  });\n-\n-  it(\"Maria posts a chat message, and sees it\", function() {\n-    mariasBrowser.chat.addChatMessage(\"Hi, I'm Maria.\");\n-    mariasBrowser.chat.waitForNumMessages(2);\n-    mariasBrowser.assertNthTextMatches('.esC_M', 2, /Maria/);\n-  });\n-\n-  it(\"Owen sees it\", function() {\n-    owensBrowser.chat.waitForNumMessages(2);\n-    owensBrowser.assertNthTextMatches('.esC_M', 2, /Maria/);\n-  });\n-\n-  it(\"Owen posts a chat message, and sees it\", function() {\n-    owensBrowser.chat.addChatMessage(\"Hi, and is your name Maria?\");\n-    owensBrowser.assertNthTextMatches('.esC_M', 3, /is your name/);\n-  });\n-\n-  it(\"Maria sees it\", function() {\n-    mariasBrowser.assertNthTextMatches('.esC_M', 3, /is your name/);\n-  });\n-\n-  it(\"A minute elapses, ... the browsers re-send long polling requests\", () => { // break out fn? [4KWBFG5]  [8T5WKBQT]\n-    //const mariaReqNrBefore = mariasBrowser.countLongPollingsDone();\n-    //const owenReqNrBefore = owensBrowser.countLongPollingsDone();\n-\n-    // This'll make the browsers send 2 new long polling requests.\n-    everyone.playTimeSeconds(60);\n-    everyone.pause(c.MagicTimeoutPollMs + 100);  // ... nr 1 gets sent here\n-    everyone.playTimeSeconds(60);\n-    everyone.pause(c.MagicTimeoutPollMs + 100);  // ... nr 2\n-\n-    /*\n-    const mariaReqNrAfter = mariasBrowser.countLongPollingsDone();\n-    const owenReqNrAfter = owensBrowser.countLongPollingsDone();\n-\n-    console.log(`Maria's num long pollings after: ${mariaReqNrAfter}, before: ${mariaReqNrBefore}`);\n-    console.log(`Owen's num long pollings after: ${owenReqNrAfter}, before: ${owenReqNrBefore}`);\n-\n-    TESTS_MISSING  TyT20956QKSP2  these were for LongPolling — are some similar types of tests\n-    needed for WebSocket? Maybe disconnect and reconnect tests?\n-\n-    assert.ok(mariaReqNrAfter > mariaReqNrBefore + 1,\n-        `Maria's browser: Long polling didn't happen? Req nr after: ${mariaReqNrAfter}, ` +\n-        `before: ${mariaReqNrBefore} [TyE4WKBZW1]`);\n-    assert.ok(owenReqNrAfter > owenReqNrBefore + 1,\n-        `Owen's browser: Long polling didn't happen? Req nr after: ${owenReqNrAfter}, ` +\n-        `before: ${owenReqNrBefore} [TyE4WKBZW2]`);\n-        */\n-  });\n-\n-  it(\"Maria replies, and Owen posts another message\", function() {\n-    mariasBrowser.chat.addChatMessage(\"What?\");\n-    //mariasBrowser.pause(3500);\n-    mariasBrowser.chat.addChatMessage(\"Why, yes.\");\n-    owensBrowser.chat.addChatMessage(\"Can I call you Maria then?\");\n-  });\n-\n-  it(\"Owen sees Maria's last chat message — live updates still work, after many minutes\", () => {\n-    owensBrowser.assertNthTextMatches('.esC_M', 4, /Why, yes/);\n-  });\n-\n-  it(\"Maria sees Owen's\", function() {\n-    mariasBrowser.assertNthTextMatches('.esC_M', 5, /Can I call you Maria/);\n-  });\n-\n-\n-  // ----- No notfs in public chat, unless @mentioned  [PRIVCHATNOTFS]\n-\n-  it(\"Maria goes to another page\", () => {\n-    mariasBrowser.topbar.clickHome();\n-  });\n-\n-  it(\"?? BUG Annoyingly, needs to click the chat channel so it stops being unread ??\", () => {\n-    // This makes the topic unread. Why is this needed? Mildly annoying.\n-    mariasBrowser.watchbar.openUnreadTopic();\n-    // Then go back to Home.\n-    mariasBrowser.topbar.clickHome();\n-  });\n-\n-  it(\"Owen posts another message — Maria won't get notified, because \" +\n-     \"not directly to her and isn't a private chat\", () => {\n-    prevNumEmails = server.getEmailsSentToAddrs(siteId).num;\n-    assert.eq(mariasBrowser.watchbar.numUnreadTopics(), 0);\n-    owensBrowser.chat.addChatMessage(`But what is @${michael.username}'s name?`);\n-  });\n-  it(\"... Michael gets notified\", () => {\n-    server.waitUntilLastEmailMatches(\n-        siteId, michael.emailAddress, ['But what is @michael'], michaelsBrowser);\n-  });\n-  it(\"... Maria sees the topic get highlighted in the sidebar\", () => {\n-    mariasBrowser.watchbar.waitUntilNumUnreadTopics(1);\n-    assert.eq(mariasBrowser.watchbar.numUnreadTopics(), 1);\n-  });\n-  it(\"... but she won't get any email notf\", () => {\n-    const { num, addrsByTimeAsc } = server.getEmailsSentToAddrs(siteId);\n-    // Only 1 email, to Michael.\n-    assert.eq(num, prevNumEmails + 1, `Emails sent to: ${addrsByTimeAsc}`);\n-    prevNumEmails = num;\n-  });\n-\n-\n-  // ----- Appends to the last message, unless @mention sbd else   TyT306WKCDE4\n-\n-  let numMessages: number;\n-\n-  it(\"Owen continues typing\", () => {\n-    numMessages = owensBrowser.chat.countMessages({ inclAnyPreview: false }); // [DRAFTS_BUG] ...\n-    // ... namely Owen's browser might show a preview of an empty chat message, after this,\n-    // resulting in +1 more chat messages for Owen, than for Maria;\n-    // then, mariasBrowser.chat.waitForNumMessages(numMessages) below never completes.\n-\n-    owensBrowser.chat.addChatMessage(`Nothing going`);\n-    owensBrowser.chat.addChatMessage(`on here`);\n-  });\n-\n-  it(\"Maria clicks the chat in the watchbar — curious about what's going on\", () => {\n-    mariasBrowser.watchbar.openUnreadTopic();\n-  });\n-\n-  it(\"... She sees Owens last messages in a single post\", () => {\n-    mariasBrowser.chat.waitForNumMessages(numMessages);\n-    assert.eq(mariasBrowser.chat.countMessages(), numMessages);  // but not more\n-  });\n-\n-  // The regex modifier /s makes '.' match line breaks too.\n-  const chatMessage6Regex = /.*michael's name.*Nothing going.*on here/s;\n-\n-  it(\"... with the 3 last texts Owen typed\", () => {\n-    mariasBrowser.chat.assertMessageNrMatches(6, chatMessage6Regex);\n-  });\n-\n-  it(\"Owen continues typing, @mentions Maja\", () => {\n-    owensBrowser.chat.addChatMessage(`@${maja.username} do you know what's ANYONE'S name?`);\n-  });\n-\n-  it(\"... this becomes a separate message, since @mentions sbd else\", () => {\n-    numMessages += 1;\n-    mariasBrowser.chat.waitForNumMessages(numMessages);\n-    mariasBrowser.chat.assertMessageNrMatches(7, /ANYONE'S name/);\n-  });\n-\n-  it(\"... didn't change Owen's previous message\", () => {\n-    mariasBrowser.chat.assertMessageNrMatches(6, chatMessage6Regex);\n-  });\n-\n-});\n-"
    },
    {
      "sha": "f17b473b7a32a551b39d2adcc231091b2d36074a",
      "filename": "tests/e2e/specs/modn-from-disc-page-appr-befr.2browsers.test.ts",
      "status": "removed",
      "additions": 0,
      "deletions": 295,
      "changes": 295,
      "blob_url": "https://github.com/debiki/talkyard/blob/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca/tests%2Fe2e%2Fspecs%2Fmodn-from-disc-page-appr-befr.2browsers.test.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca/tests%2Fe2e%2Fspecs%2Fmodn-from-disc-page-appr-befr.2browsers.test.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests%2Fe2e%2Fspecs%2Fmodn-from-disc-page-appr-befr.2browsers.test.ts?ref=1f1c92bc5a99e46dc90be1f93cf84a75fc6e2cca",
      "patch": "@@ -1,295 +0,0 @@\n-/// <reference path=\"../test-types.ts\"/>\n-\n-import * as _ from 'lodash';\n-import assert = require('../utils/ty-assert');\n-// import fs = require('fs');  EMBCMTS\n-import server = require('../utils/server');\n-import utils = require('../utils/utils');\n-import { buildSite } from '../utils/site-builder';\n-import { TyE2eTestBrowser, TyAllE2eTestBrowsers } from '../utils/pages-for';\n-import settings = require('../utils/settings');\n-import lad = require('../utils/log-and-die');\n-import c = require('../test-constants');\n-\n-\n-let everyonesBrowsers: TyAllE2eTestBrowsers;\n-let richBrowserA: TyE2eTestBrowser;\n-let richBrowserB: TyE2eTestBrowser;\n-let owen: Member;\n-let owensBrowser: TyE2eTestBrowser;\n-let mons: Member;\n-let monsBrowser: TyE2eTestBrowser;\n-let modya: Member;\n-let modyasBrowser: TyE2eTestBrowser;\n-let maria: Member;\n-let mariasBrowser: TyE2eTestBrowser;\n-let michael: Member;\n-let michaelsBrowser: TyE2eTestBrowser;\n-let strangersBrowser: TyE2eTestBrowser;\n-\n-let site: IdAddress;\n-let forum: EmptyTestForum;\n-\n-const topicOneTitle = 'topicOneTitle';\n-const topicOneBody = 'topicOneBody';\n-\n-const replA_txt = 'replA_txt';\n-const replA_nr = c.FirstReplyNr;\n-const replB_txt = 'replB_txt';\n-const replB_nr = c.FirstReplyNr + 1;\n-const replC_toRej_txt = 'replC_toRej_txt';\n-const replC_toRej_nr = c.FirstReplyNr + 2;\n-const replD_toApr_txt = 'replD_toApr_txt';\n-const replD_toApr_nr = c.FirstReplyNr + 3;\n-const modyasMoreText = ' modyasMoreText';\n-\n-const topicTwoTitle = 'topicTwoTitle';\n-const topicTwoBody = 'topicTwoBody';\n-\n-describe(`modn-from-disc-page-approve-before  TyTE2E603RTJ`, () => {\n-\n-  it(`construct site`, () => {\n-    const builder = buildSite();\n-    forum = builder.addEmptyForum({  // or: builder.addLargeForum\n-      title: \"Some E2E Test\",\n-      members: undefined, // default = everyone\n-    });\n-\n-    builder.settings({\n-      numFirstPostsToApprove: 0,\n-      requireApprovalIfTrustLte: c.TestTrustLevel.FullMember,\n-      maxPostsPendApprBefore: 4,\n-      numFirstPostsToReview: 0,\n-    });\n-    builder.getSite().pageNotfPrefs = [{\n-      memberId: forum.members.owen.id,\n-      notfLevel: c.TestPageNotfLevel.Muted,\n-      wholeSite: true,\n-    }];\n-\n-    everyonesBrowsers = new TyE2eTestBrowser(allWdioBrowsers);\n-    richBrowserA = new TyE2eTestBrowser(wdioBrowserA);\n-    richBrowserB = new TyE2eTestBrowser(wdioBrowserB);\n-\n-    owen = forum.members.owen;\n-    owensBrowser = richBrowserA;\n-    mons = forum.members.mons;\n-    monsBrowser = richBrowserA;\n-    modya = forum.members.modya;\n-    modyasBrowser = richBrowserA;\n-\n-    maria = forum.members.maria;\n-    mariasBrowser = richBrowserB;\n-\n-    michael = forum.members.michael;\n-    michaelsBrowser = richBrowserB;\n-\n-    strangersBrowser = richBrowserB;\n-\n-    assert.refEq(builder.getSite(), forum.siteData);\n-  });\n-\n-  it(`import site`, () => {\n-    site = server.importSiteData(forum.siteData);\n-    server.skipRateLimits(site.id);\n-  });\n-\n-  it(`Maria logs in`, () => {\n-    mariasBrowser.go2(site.origin + '/');\n-    mariasBrowser.complex.loginWithPasswordViaTopbar(maria);\n-  });\n-\n-  let topicOneUrl: St;\n-  let topicTwoUrl: St;\n-\n-  it(`... posts a new topic`, () => {\n-    mariasBrowser.complex.createAndSaveTopic({\n-          title: topicOneTitle, body: topicOneBody, willBePendingApproval: true });\n-    topicOneUrl = mariasBrowser.getUrl();\n-  });\n-\n-  it(`... it becomes pending approval`, () => {\n-    mariasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n-    mariasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n-    mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n-  });\n-\n-  it(`Maria navigates away, ... and back`, () => {\n-    mariasBrowser.topbar.clickHome();\n-    mariasBrowser.forumTopicList.goToTopic(topicOneTitle);\n-  });\n-\n-  it(`... text stil visible, after SPA-navigated away and back  TyTE2E603SKD`, () => {\n-    mariasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n-    mariasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n-    mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n-  });\n-\n-  it(`... and after reload  TyTE2E603SKD`, () => {\n-    mariasBrowser.refresh2();\n-    mariasBrowser.waitForMyDataAdded();\n-    mariasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n-    mariasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n-    mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n-  });\n-\n-  it(`Maria posts another topic`, () => {\n-    mariasBrowser.topbar.clickHome();\n-    mariasBrowser.complex.createAndSaveTopic({\n-          title: topicTwoTitle, body: topicTwoBody, willBePendingApproval: true });\n-    topicTwoUrl = mariasBrowser.getUrl();\n-  });\n-\n-  it(`... it becomes pending approval`, () => {\n-    mariasBrowser.topic.assertPagePendingApprovalBodyVisible();\n-  });\n-\n-  it(`A stranger somehow navigates to the page`, () => {\n-    modyasBrowser.go2(topicTwoUrl);  // not yet logged in\n-  });\n-\n-  it(`... but page not visible — not yet approved  TyTE2E603SKD`, () => {\n-    modyasBrowser.assertWholePageHidden();  // not yet logged in\n-  });\n-\n-  it(`Modya logs in`, () => {\n-    modyasBrowser.loginDialog.loginWithPassword(modya);\n-  });\n-\n-  it(`... the unapproved title & body get loaded via page load  TyTE2E603SKD`, () => {\n-    modyasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicTwoBody);\n-    modyasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicTwoTitle);\n-  });\n-\n-  it(`Modya rejects topic two`, () => {\n-    modyasBrowser.topic.rejectPostNr(c.BodyNr);\n-  });\n-\n-  it(`... that deletes the page`, () => {\n-    modyasBrowser.topic.waitUntilPageDeleted();\n-  });\n-\n-  it(`Modya navigates to topic one`, () => {\n-    modyasBrowser.topbar.clickHome();\n-    modyasBrowser.forumTopicList.goToTopic(topicOneTitle);\n-  });\n-\n-  it(`... the unapproved posts get loaded, via SPA navigation  TyTE2E603SKD`, () => {\n-    modyasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, topicOneTitle);\n-    modyasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, topicOneBody);\n-    /* Not created yet:\n-    modyasBrowser.topic.waitForPostAssertTextMatches(replA_nr, replA_txt);\n-    modyasBrowser.topic.waitForPostAssertTextMatches(replB_nr, replB_txt);\n-    modyasBrowser.topic.waitForPostAssertTextMatches(replC_toRej_nr, replC_toRej_txt);\n-    modyasBrowser.topic.waitForPostAssertTextMatches(replD_toApr_nr, replD_toApr_txt);\n-    */\n-  });\n-\n-  it(`... approves topic one`, () => {\n-    modyasBrowser.topic.approvePostNr(c.BodyNr);\n-  });\n-\n-\n-  it(`Maria now cannot see topic 2`, () => {\n-    assert.eq(mariasBrowser.getUrl(), topicTwoUrl);\n-    mariasBrowser.refresh2();\n-    mariasBrowser.assertNotFoundError({ whyNot: 'PageDeleted' });\n-  });\n-\n-  it(`... and that topic one got approved`, () => {\n-    mariasBrowser.go2(topicOneUrl);\n-    mariasBrowser.topic.assertPageNotPendingApproval();\n-  });\n-\n-  it(`Maria posts four replies, in topic one`, () => {\n-    mariasBrowser.complex.replyToOrigPost(replA_txt);\n-    mariasBrowser.complex.replyToOrigPost(replB_txt);\n-    mariasBrowser.complex.replyToOrigPost(replC_toRej_txt);\n-    mariasBrowser.complex.replyToOrigPost(replD_toApr_txt);\n-  });\n-\n-  it(`... they become pending-approval`, () => {\n-    mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replA_nr);\n-    mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replB_nr);\n-    mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replC_toRej_nr);\n-    mariasBrowser.topic.assertPostNeedsApprovalBodyVisible(replD_toApr_nr);\n-  });\n-\n-  it(`Modya rejects reply C`, () => {\n-    modyasBrowser.topic.rejectPostNr(replC_toRej_nr);\n-  });\n-\n-  it(`... edits reply D`, () => {\n-    modyasBrowser.complex.editPostNr(replD_toApr_nr, modyasMoreText, { append: true });\n-  });\n-\n-  it(`... edititing it won't approve it  TyTE2E407RKS`, () => {\n-    modyasBrowser.refresh2();\n-    modyasBrowser.topic.waitForPostAssertTextMatches(\n-          replD_toApr_nr, replD_toApr_txt + modyasMoreText);\n-    modyasBrowser.topic.assertPostNeedsApprovalBodyVisible(replD_toApr_nr);\n-    assert.deepEq(modyasBrowser.topic.countReplies({ skipWait: true }),\n-          { numNormal: 0, numPreviews: 0, numUnapproved: 3, numDeleted: 1 });\n-  });\n-\n-  it(`... approves reply D`, () => {\n-    modyasBrowser.topic.approvePostNr(replD_toApr_nr);\n-  });\n-\n-  //  TyT204RKSTEM\n-  //  Mons approves from disc page, Modya approves & rejects from modn page.\n-  //  Mons rejects from disc page, Modya approves & rejects from modn page.\n-\n-  it(`Maria sees the page and reply D got approved`, () => {\n-    mariasBrowser.topic.refreshUntilPostNotPendingApproval(replD_toApr_nr);\n-  });\n-\n-  it(`... and reply C is deleted`, () => {\n-    mariasBrowser.topic.waitForPostVisibleAsDeleted(replC_toRej_nr);\n-  });\n-\n-  it(`... and two pending approval`, () => {\n-    assert.deepEq(strangersBrowser.topic.countReplies({ skipWait: true }),\n-          { numNormal: 1, numPreviews: 0, numUnapproved: 2, numDeleted: 1 });\n-  });\n-\n-\n-  it(`A stranger sees reply D  TyTE2E603SKD`, () => {\n-    mariasBrowser.topbar.clickLogout();\n-    strangersBrowser.topic.waitForPostAssertTextMatches(\n-          replD_toApr_nr, replD_toApr_txt + modyasMoreText);\n-  });\n-\n-  it(`... A and B still pending approval`, () => {\n-    strangersBrowser.topic.assertPostNeedsApprovalBodyHidden(replA_nr);\n-    strangersBrowser.topic.assertPostNeedsApprovalBodyHidden(replB_nr);\n-  });\n-\n-  it(`... C gone`, () => {\n-    assert.not(strangersBrowser.topic.isPostNrVisible(replC_toRej_nr));\n-  });\n-\n-  it(`... those are all posts`, () => {\n-    assert.deepEq(strangersBrowser.topic.countReplies({ skipWait: true }),\n-          { numNormal: 1, numPreviews: 0, numUnapproved: 2, numDeleted: 0 });\n-  });\n-\n-\n-  // TESTS_MISSING  TyT204RKSTEM\n-  //  Modya approves from modn page, Mons approves & rejects from disc page.\n-  //  Modya rejects from modn page, Mons approves & rejects from disc page.\n-\n-  it(`Mons tries to approve and reject C and D via the mod page`, () => {\n-  });\n-\n-  it(`Mons instead approves A and B`, () => {\n-  });\n-\n-  it(`Modya approves A — before Mons' undo timeout`, () => {\n-  });\n-\n-  it(`Modya tries to approve B — after Mons' undo timeout`, () => {\n-  });\n-\n-});\n-"
    },
    {
      "sha": "f848ac2ce3a446fef927eee8091aa04290a07fa1",
      "filename": "to-talkyard/README.md",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/to-talkyard%2FREADME.md",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/to-talkyard%2FREADME.md",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/to-talkyard%2FREADME.md?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1,3 +1,7 @@\n+Usage:\n+\n+    node to-talkyard/dist/to-talkyard/src/to-talkyard.js --help\n+\n If importing from MySQL / PgSQL etc, maybe: https://github.com/tgriesser/knex\n \n "
    },
    {
      "sha": "7137286dbf42c79ed562378b6e33df32f9a01d44",
      "filename": "to-talkyard/src/to-talkyard.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/to-talkyard%2Fsrc%2Fto-talkyard.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/to-talkyard%2Fsrc%2Fto-talkyard.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/to-talkyard%2Fsrc%2Fto-talkyard.ts?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -82,7 +82,7 @@ Usage:\n   First convert the Disqus (or WordPress, later) export file\n   to Talkyard JSON format:\n \n-      nodejs to-talkyard/dist/to-talkyard/src/to-talkyard.js \\\\\n+      node to-talkyard/dist/to-talkyard/src/to-talkyard.js \\\\\n           --disqusXmlExportFile path/to/file.xml \\\\\n           --writeTo disqus-to-talkyard.typatch.json \\\\\n           --skipLocalhostAndNonStandardPortComments \\\\\n@@ -95,7 +95,7 @@ Usage:\n   Thereafter you can import the JSON file:  (and change the --sendTo server\n   address to your Talkyard site's address)\n \n-      nodejs to-talkyard/dist/to-talkyard/src/to-talkyard.js \\\\\n+      node to-talkyard/dist/to-talkyard/src/to-talkyard.js \\\\\n           --talkyardJsonPatchFile disqus-to-talkyard.typatch.json  \\\\\n           --sendTo https://your-talkyard-site.example.com  \\\\\n           --sysbotApiSecret 'THE_SECRET_YOU_COPIED'"
    },
    {
      "sha": "13b77165fbf9f5e7f48f22b5d4b1d1cd6b2499cb",
      "filename": "version.txt",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/version.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/version.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/version.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1 +1 @@\n-v0.2024.011\n+v0.2025.001"
    },
    {
      "sha": "ce090ef8811925f4fbf01248eb22d9131b58ee4e",
      "filename": "wip/bookmarks/bookmarks-wip.txt",
      "status": "modified",
      "additions": 102,
      "deletions": 1,
      "changes": 103,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/wip%2Fbookmarks%2Fbookmarks-wip.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/wip%2Fbookmarks%2Fbookmarks-wip.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Fbookmarks%2Fbookmarks-wip.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -1,2 +1,103 @@\n+In this file: Bookmarks todos.  [bookmarks_wip]\n \n-[dont_list_bookmarkers]\n+Also see: ../../docs/design-docs/bookmarks.dd.adoc\n+\n+Disabled in prod,\n+      until there are auto tests,  see ^bookmarks in ../../docs/tests-map.txt,\n+      and the below todos fixed.\n+\n+When enabling: Update the renderer version (from 0.00.79 to 0.00.80), and remove the\n+!ifLoggedIn test so the  Go to latest  buton is shown also if logged out, see: [renderer_version].\n+\n+\n+TODO:\n+  - Maybe create new fns:  ReactActions.createBookmark() and editBookmark(),\n+    instead of reusing  ReactActions.saveReply()  etc.\n+    And server enpoints too — the one's for replying & editing do too many off-topic things?\n+\n+  - Review editPostIfAuth & create-post & changePostStatusImpl() again,\n+    so doesn't do weird things w bookmarks:\n+              (Better to instead created a dedicated edit-bookmark? see just above)\n+      No upload refs\n+      No links\n+      Not approved\n+      No review\n+      No spam check tasks\n+      No stats updated (except for posts seen maybe) [0_stats_for_priv_posts]  [0_ln_from_priv]\n+      No notfs  [0_bokm_notfs]\n+  - Done: Websocket, check not bookmark.\n+  - Bug: Add/remove tag to bookmarked post. Bookmark igon gets un-highlighted, as if bookm gone\n+          (but it's there after reload).\n+\n+  - BUG: Bookmarks list not auto updated, when editing or deleting bookmark.\n+    See  [bookmark_edits_and_updates]  in ../../client/app-slim/sidebar/sidebar.ts.\n+    (Need to rewrite to a function component, and use useStoreEvent()?)\n+    Delete & add bookark —> listed twice, until reload (since adding, but not deleting, works)\n+\n+  - Ugly error diag if trying to bookmark sth twice\n+\n+  - Write e2e tests\n+\n+\n+\n+Skip?:\n+  - Shouldn't ids too, not only nrs, be < 0?\n+    Or all ids should be random, but that's an a bit big change now?\n+\n+\n+Later:\n+\n+[how_load_bookmarks]\n+Currently we just load all bookmarks (up to 999), works fine, the feature is new, there\n+aren't many.  Later, load bookmarks ordered by:\n+    - Current page, visible posts first,\n+          then by time recent first.\n+    - Whole forum, recent first.\n+\n+[bookmark_search_sort]\n+Index bookmarks. Private, per user — maybe a dediated index?. Search & sort fields,\n+when listing bookmarks.  And search one's bookmarks only: [is_bokm].\n+\n+[order_bokms]\n+Make it possible to drag-and-drop reorder todos (bookmarks, drafts, tasks) in one's sidebar,\n+and change sort order, e.g. by order, recent first, (oldest first?), or by search query.\n+Use nodes_t / posts3.order_c?\n+\n+[bookmark_tasks]\n+First make it possible to let ordinary comments be tasks. [comment_tasks]\n+Then, expose a make-task & doing UI for bookmarks too?\n+\n+\n+\n+Much later:\n+\n+[bookmark_shapes_colors]\n+Different shapes and colors would be nice? It's pretty useful in Gmail.\n+\n+[tagd_bokms]\n+Make it possible to tag one's bookmarks? Let's say you use Ty for work for days & years,\n+and end up with 1000 bookmarks — could be nice with some structure?\n+\n+  Compare tags:\n+    tag:year:desc>1990  \n+    tag:priority:desc>=3\n+\n+  Then, bookmarks with tags?:\n+    bookmarks:asc<=3             # sorts by  posts3.order_c, ascending, up to 3.0 ?\n+    bookmarks:due-at:asc<=MM-DD  # finds bookmarks tagged  due-at  and due before MM-DD ?\n+\n+  What was I thinking? A dot '.' not ':' like elsewhere?:   Aha, a '.' dot is a field, ':' for tags?\n+    bookmark:to-do.due-at:asc>=now&.open\n+    bookmark:to-do priority:desc>=3\n+\n+  has:priority:desc>=3\n+\n+  priority:desc>=3   // finds tag:priority  and  bookmarks.priority   and  badge:proirity\n+\n+  task:priority>=3   // finds posts (incl bookmarks) with doing status New/Planned/Doing/Done  ?\n+    is:open          // and not Closed (e.g. becuase Done)\n+\n+\n+  Create one's own tag types & bookmark types? E.g. \"Reply-to\", \"Read-later\", \"To-do\", \"Reference\",\n+    and filter on, say, \"Reply-to\" & \"To-do\", to find out what you should\n+    probably do next."
    },
    {
      "sha": "5cc2e69d1b9568df436d681009551f10c394cfd4",
      "filename": "wip/priv-comts/priv-comts-wip.txt",
      "status": "added",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/wip%2Fpriv-comts%2Fpriv-comts-wip.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/wip%2Fpriv-comts%2Fpriv-comts-wip.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Fpriv-comts%2Fpriv-comts-wip.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,37 @@\n+\n+Private comments [priv_comts], also see  maybe-do-later.txt.\n+\n+\n+A better way to implement private comments:  [priv_comts_pages]\n+(Then maybe negative nrs should be \"personal\" rather than \"private\" ?)\n+\n+For each private comment and sub comments, create a new & separate *page*,\n+and let it be a sub page, of PageType.PrivateComments, of the current page.\n+\n+Benefits:\n+ - Won't load private comments by mistake. They're on totally different pages.\n+ - Can use the same access permission to manage who can see a private thread,\n+    as for managing members of a private chat or private DMs.\n+ - Pretty easy & efficient to load all private comments, for those who are\n+    talking in private sub threads: An index on parent page id & child page type,\n+    to load all relevant private comment trees (pages), and then filter on\n+    one's id and groups to know which ones one can see.\n+ - Can reuse for implementing sub tasks [sub_pages].\n+\n+That's better than storing private trees as ordinary comments but with negative ids\n+and inventing a new permission system, like I was thinking when I added\n+   posts3.private_pats_id_c.\n+\n+\n+This could be a nice way to (re)implement flags? A flag is then a separate\n+page linking to the flagged post, [flags_as_posts]  and any discussion about\n+the flagged comment can be shown inline in the discussion with the flagged comment,\n+just like private comment threads. Only the mods could see, and they'll now\n+have all the context (all ancestor comments) & any discussions about the flagged\n+comment visible at once.\n+\n+\n+Related: (sometimes old out-of-date thoughts)\n+  [its_a_node]\n+  [remember_if_bookmarks_or_priv_comts]\n+"
    },
    {
      "sha": "08e93a8a94254bcb9e16116316234db033e37a77",
      "filename": "wip/tags/tags-wip.txt",
      "status": "added",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/debiki/talkyard/blob/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/wip%2Ftags%2Ftags-wip.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/b8a91e87ab9734d3e77dfb4a75b4ca3317d08890/wip%2Ftags%2Ftags-wip.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/wip%2Ftags%2Ftags-wip.txt?ref=b8a91e87ab9734d3e77dfb4a75b4ca3317d08890",
      "patch": "@@ -0,0 +1,16 @@\n+\n+Later:\n+\n+More data types, e.g. dates, date ranges, full text, geo locations,\n+& ways to filter & search, e.g. all pages/events close to a city (coordinate).\n+See Scala object TypeValueType.\n+\n+Distant future:\n+\n+[bottom_up_tags]\n+Let people create their own tag types, own names.\n+These will be scoped by user id, so won't be name conflicts (the db constraints\n+in the tagtypes_t table support this alraedy, e.g.: tagtypes_u_anypat_urlslug).\n+Later, moderators can promote these personal tag types to official tags\n+(if the users want).\n+"
    }
  ]
}
