{
  "sha": "a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
  "node_id": "C_kwDOCQOkhNoAKGE5OGE1MGFiYmU0ZWUyZDZhYTE0NDM3NjExMDg5YjY2Y2IzOGViYjc",
  "commit": {
    "author": {
      "name": "qwqcode",
      "email": "qwqcode@gmail.com",
      "date": "2024-09-16T08:55:38Z"
    },
    "committer": {
      "name": "qwqcode",
      "email": "qwqcode@gmail.com",
      "date": "2024-09-16T08:55:38Z"
    },
    "message": "test(mutex): add tests for keyed mutex",
    "tree": {
      "sha": "bb9a1742ef9556df12ce7194bcff77e33cb2ea4f",
      "url": "https://api.github.com/repos/ArtalkJS/Artalk/git/trees/bb9a1742ef9556df12ce7194bcff77e33cb2ea4f"
    },
    "url": "https://api.github.com/repos/ArtalkJS/Artalk/git/commits/a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQS0Ev3sdPZbHkWwzmLUbg8O6nwTagUCZufyigAKCRDUbg8O6nwT\namCIAPkB1LQ0ksxjckpGn5yHgdYlERL8+k5obeuxe102W6k9KwD/fX66zRUve/zb\nyjDNG1PbH8d0Ch2hu2IQJLXYUxecfAk=\n=xV6f\n-----END PGP SIGNATURE-----",
      "payload": "tree bb9a1742ef9556df12ce7194bcff77e33cb2ea4f\nparent 4bd3537c0d8767532e64e7ad60ef5fd5663893f5\nauthor qwqcode <qwqcode@gmail.com> 1726476938 +0800\ncommitter qwqcode <qwqcode@gmail.com> 1726476938 +0800\n\ntest(mutex): add tests for keyed mutex\n"
    }
  },
  "url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
  "html_url": "https://github.com/ArtalkJS/Artalk/commit/a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
  "comments_url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/comments",
  "author": {
    "login": "qwqcode",
    "id": 22412567,
    "node_id": "MDQ6VXNlcjIyNDEyNTY3",
    "avatar_url": "https://avatars.githubusercontent.com/u/22412567?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/qwqcode",
    "html_url": "https://github.com/qwqcode",
    "followers_url": "https://api.github.com/users/qwqcode/followers",
    "following_url": "https://api.github.com/users/qwqcode/following{/other_user}",
    "gists_url": "https://api.github.com/users/qwqcode/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/qwqcode/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/qwqcode/subscriptions",
    "organizations_url": "https://api.github.com/users/qwqcode/orgs",
    "repos_url": "https://api.github.com/users/qwqcode/repos",
    "events_url": "https://api.github.com/users/qwqcode/events{/privacy}",
    "received_events_url": "https://api.github.com/users/qwqcode/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "qwqcode",
    "id": 22412567,
    "node_id": "MDQ6VXNlcjIyNDEyNTY3",
    "avatar_url": "https://avatars.githubusercontent.com/u/22412567?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/qwqcode",
    "html_url": "https://github.com/qwqcode",
    "followers_url": "https://api.github.com/users/qwqcode/followers",
    "following_url": "https://api.github.com/users/qwqcode/following{/other_user}",
    "gists_url": "https://api.github.com/users/qwqcode/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/qwqcode/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/qwqcode/subscriptions",
    "organizations_url": "https://api.github.com/users/qwqcode/orgs",
    "repos_url": "https://api.github.com/users/qwqcode/repos",
    "events_url": "https://api.github.com/users/qwqcode/events{/privacy}",
    "received_events_url": "https://api.github.com/users/qwqcode/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4bd3537c0d8767532e64e7ad60ef5fd5663893f5",
      "url": "https://api.github.com/repos/ArtalkJS/Artalk/commits/4bd3537c0d8767532e64e7ad60ef5fd5663893f5",
      "html_url": "https://github.com/ArtalkJS/Artalk/commit/4bd3537c0d8767532e64e7ad60ef5fd5663893f5"
    }
  ],
  "stats": {
    "total": 207,
    "additions": 134,
    "deletions": 73
  },
  "files": [
    {
      "sha": "109da7cbd59a06af4f87956d245e0943bc848088",
      "filename": ".github/chglog/config.yml",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/.github%2Fchglog%2Fconfig.yml",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/.github%2Fchglog%2Fconfig.yml",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/.github%2Fchglog%2Fconfig.yml?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -13,6 +13,7 @@ options:\n         - fix\n         - perf\n         - refactor\n+        - test\n         - docs\n   commit_groups:\n     sort_by: Custom\n@@ -21,12 +22,14 @@ options:\n       - fix\n       - perf\n       - refactor\n+      - test\n       - docs\n     title_maps:\n       feat: Features\n       fix: Bug Fixes\n       perf: Performance Improvements\n       refactor: Code Refactoring\n+      test: Testing\n       docs: Documentation\n   header:\n     pattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s\\\\/]*)\\\\))?\\\\:\\\\s(.*)$\""
    },
    {
      "sha": "01f00fe436410a43f6b7d5d09f1fcaea23c750e6",
      "filename": "docs/docs/guide/deploy.md",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/docs%2Fdocs%2Fguide%2Fdeploy.md",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/docs%2Fdocs%2Fguide%2Fdeploy.md",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/docs%2Fdocs%2Fguide%2Fdeploy.md?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -168,12 +168,6 @@ Artalk 后端程序内嵌了前端 JS、CSS 文件，使用公共 CDN 资源请\n >\n > <https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/artalk/:ArtalkVersion:/Artalk.css>\n \n-**Staticfile CDN (境内)**\n-\n-> <https://cdn.staticfile.org/artalk/:ArtalkVersion:/Artalk.js>\n->\n-> <https://cdn.staticfile.org/artalk/:ArtalkVersion:/Artalk.css>\n-\n **UNPKG**\n \n > <https://unpkg.com/artalk@:ArtalkVersion:/dist/Artalk.js>"
    },
    {
      "sha": "c079b23d285872328cde812a10d3b6495695f7a5",
      "filename": "internal/sync/key_mutex.go",
      "status": "modified",
      "additions": 13,
      "deletions": 23,
      "changes": 36,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/internal%2Fsync%2Fkey_mutex.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/internal%2Fsync%2Fkey_mutex.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fsync%2Fkey_mutex.go?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -2,34 +2,24 @@ package sync\n \n import \"sync\"\n \n+// KeyMutex provides a per-key mutex mechanism\n type KeyMutex[T any] struct {\n-\tlocks map[any]*sync.Mutex\n-\n-\tmapLock sync.Mutex // to make the map safe concurrently\n+\tlocks sync.Map // sync.Map for concurrent access\n }\n \n+// NewKeyMutex creates a new KeyMutex\n func NewKeyMutex[T any]() *KeyMutex[T] {\n-\treturn &KeyMutex[T]{locks: make(map[any]*sync.Mutex)}\n+\treturn &KeyMutex[T]{}\n }\n \n-func (l *KeyMutex[T]) getLockBy(key T) *sync.Mutex {\n-\tl.mapLock.Lock()\n-\tdefer l.mapLock.Unlock()\n-\n-\tret, found := l.locks[key]\n-\tif found {\n-\t\treturn ret\n+// GetLock returns the mutex associated with the given key, creating it if necessary\n+func (l *KeyMutex[T]) GetLock(key T) *sync.Mutex {\n+\tif lock, ok := l.locks.Load(key); ok {\n+\t\treturn lock.(*sync.Mutex)\n \t}\n-\n-\tret = &sync.Mutex{}\n-\tl.locks[key] = ret\n-\treturn ret\n-}\n-\n-func (l *KeyMutex[T]) Lock(key T) {\n-\tl.getLockBy(key).Lock()\n-}\n-\n-func (l *KeyMutex[T]) Unlock(key T) {\n-\tl.getLockBy(key).Unlock()\n+\t// Create a new mutex if not found\n+\tnewLock := &sync.Mutex{}\n+\t// Ensure only one mutex is added for the key\n+\tactualLock, _ := l.locks.LoadOrStore(key, newLock)\n+\treturn actualLock.(*sync.Mutex)\n }"
    },
    {
      "sha": "8602d4fa136a1d08f6c31fe735ad35d693a992a8",
      "filename": "internal/sync/key_mutex_test.go",
      "status": "added",
      "additions": 97,
      "deletions": 0,
      "changes": 97,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/internal%2Fsync%2Fkey_mutex_test.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/internal%2Fsync%2Fkey_mutex_test.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fsync%2Fkey_mutex_test.go?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -0,0 +1,97 @@\n+package sync_test\n+\n+import (\n+\tgo_sync \"sync\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/ArtalkJS/Artalk/internal/sync\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestKeyMutex_LockAndUnlock(t *testing.T) {\n+\tkeyMutex := sync.NewKeyMutex[int]()\n+\n+\t// Test that the same key is locked/unlocked correctly\n+\tkey := 1\n+\tmutex := keyMutex.GetLock(key)\n+\tmutex.Lock()\n+\n+\tunlocked := false\n+\n+\tgo func() {\n+\t\tmutex.Lock()\n+\t\tunlocked = true\n+\t\tmutex.Unlock()\n+\t}()\n+\n+\t// Ensure the key is still locked\n+\ttime.Sleep(100 * time.Millisecond)\n+\tassert.False(t, unlocked, \"Key should be locked\")\n+\n+\t// Unlock the key\n+\tmutex.Unlock()\n+\n+\t// Ensure the key is unlocked now\n+\ttime.Sleep(100 * time.Millisecond)\n+\tassert.True(t, unlocked, \"Key should be unlocked now\")\n+}\n+\n+func TestKeyMutex_ConcurrentAccess(t *testing.T) {\n+\tkeyMutex := sync.NewKeyMutex[string]()\n+\n+\tvar wg go_sync.WaitGroup\n+\tkey := \"test-key\"\n+\n+\tcounter := 0\n+\t// Use the same key in multiple goroutines to test concurrent access\n+\tfor i := 0; i < 100; i++ {\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tmutex := keyMutex.GetLock(key)\n+\t\t\tmutex.Lock()\n+\t\t\tdefer mutex.Unlock()\n+\n+\t\t\t// Critical section\n+\t\t\tcounter++\n+\t\t}()\n+\t}\n+\n+\twg.Wait()\n+\tassert.Equal(t, 100, counter, \"Counter should be incremented 100 times\")\n+}\n+\n+func TestKeyMutex_DifferentKeys(t *testing.T) {\n+\tkeyMutex := sync.NewKeyMutex[int]()\n+\n+\tvar wg go_sync.WaitGroup\n+\tcounter1, counter2 := 0, 0\n+\tkey1, key2 := 1, 2\n+\n+\t// Lock different keys in different goroutines\n+\tfor i := 0; i < 50; i++ {\n+\t\twg.Add(2)\n+\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tmutex := keyMutex.GetLock(key1)\n+\t\t\tmutex.Lock()\n+\t\t\tdefer mutex.Unlock()\n+\t\t\tcounter1++\n+\t\t}()\n+\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tmutex := keyMutex.GetLock(key2)\n+\t\t\tmutex.Lock()\n+\t\t\tdefer mutex.Unlock()\n+\t\t\tcounter2++\n+\t\t}()\n+\t}\n+\n+\twg.Wait()\n+\n+\tassert.Equal(t, 50, counter1, \"Counter1 should be incremented 50 times\")\n+\tassert.Equal(t, 50, counter2, \"Counter2 should be incremented 50 times\")\n+}"
    },
    {
      "sha": "aa780b472c752ba4d764a5dd838e616707f26e40",
      "filename": "internal/sync/key_rw_mutex.go",
      "status": "modified",
      "additions": 12,
      "deletions": 37,
      "changes": 49,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/internal%2Fsync%2Fkey_rw_mutex.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/internal%2Fsync%2Fkey_rw_mutex.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/internal%2Fsync%2Fkey_rw_mutex.go?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -1,50 +1,25 @@\n package sync\n \n-import (\n-\t\"sync\"\n-)\n+import \"sync\"\n \n // KeyRWMutex is a read-write lock with keys\n type KeyRWMutex[T any] struct {\n-\tmutex sync.Mutex\n-\tlocks map[any]*sync.RWMutex\n+\tlocks sync.Map // use sync.Map for concurrent access\n }\n \n // NewKeyRWMutex creates a new KeyRWMutex\n func NewKeyRWMutex[T any]() *KeyRWMutex[T] {\n-\treturn &KeyRWMutex[T]{locks: make(map[any]*sync.RWMutex)}\n+\treturn &KeyRWMutex[T]{}\n }\n \n-// getLockByKey retrieves the lock for the given key\n-func (kl *KeyRWMutex[T]) getLockByKey(key string) *sync.RWMutex {\n-\tkl.mutex.Lock()\n-\tdefer kl.mutex.Unlock()\n-\n-\tval, ok := kl.locks[key]\n-\tif !ok {\n-\t\tlock := &sync.RWMutex{}\n-\t\tkl.locks[key] = lock\n-\t\treturn lock\n+// GetLock retrieves or creates the lock for the given key\n+func (kl *KeyRWMutex[T]) GetLock(key T) *sync.RWMutex {\n+\tif lock, ok := kl.locks.Load(key); ok {\n+\t\treturn lock.(*sync.RWMutex)\n \t}\n-\treturn val\n-}\n-\n-// Lock acquires the write lock for the given key\n-func (kl *KeyRWMutex[T]) Lock(key string) {\n-\tkl.getLockByKey(key).Lock()\n-}\n-\n-// Unlock releases the write lock for the given key\n-func (kl *KeyRWMutex[T]) Unlock(key string) {\n-\tkl.getLockByKey(key).Unlock()\n-}\n-\n-// RLock acquires the read lock for the given key\n-func (kl *KeyRWMutex[T]) RLock(key string) {\n-\tkl.getLockByKey(key).RLock()\n-}\n-\n-// RUnlock releases the read lock for the given key\n-func (kl *KeyRWMutex[T]) RUnlock(key string) {\n-\tkl.getLockByKey(key).RUnlock()\n+\t// Create a new RWMutex if not found\n+\tnewLock := &sync.RWMutex{}\n+\t// Ensure only one RWMutex is added for the key\n+\tactualLock, _ := kl.locks.LoadOrStore(key, newLock)\n+\treturn actualLock.(*sync.RWMutex)\n }"
    },
    {
      "sha": "1ece55d13e3a365cf54ba4982acbfba608c018fd",
      "filename": "server/handler/auth_email_send.go",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/server%2Fhandler%2Fauth_email_send.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/server%2Fhandler%2Fauth_email_send.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/server%2Fhandler%2Fauth_email_send.go?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -52,8 +52,9 @@ func AuthEmailSend(app *core.App, router fiber.Router) {\n \t\t}\n \n \t\t// Mutex for each email to avoid frequency check fail concurrently\n-\t\tmutexMap.Lock(p.Email)\n-\t\tdefer mutexMap.Unlock(p.Email)\n+\t\tmutex := mutexMap.GetLock(p.Email)\n+\t\tmutex.Lock()\n+\t\tdefer mutex.Unlock()\n \n \t\t// check if had send email verify code in 1 minutes\n \t\tif err := app.Dao().DB().Model(&entity.UserEmailVerify{}).Where(\"email = ? OR ip = ?\", p.Email, c.IP()).Where(\"updated_at > ?\", time.Now().Add(-time.Minute*1)).First(&entity.UserEmailVerify{}).Error; err == nil {"
    },
    {
      "sha": "057e75a3e47d79636280538c1b3010e3dfcd82af",
      "filename": "server/handler/auth_merge_apply.go",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/server%2Fhandler%2Fauth_merge_apply.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/server%2Fhandler%2Fauth_merge_apply.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/server%2Fhandler%2Fauth_merge_apply.go?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -44,8 +44,9 @@ func AuthMergeApply(app *core.App, router fiber.Router) {\n \n \trouter.Post(\"/auth/merge\", common.LoginGuard(app, func(c *fiber.Ctx, user entity.User) error {\n \t\t// Mutex for each user to avoid concurrent merge operation\n-\t\tmutexMap.Lock(user.ID)\n-\t\tdefer mutexMap.Unlock(user.ID)\n+\t\tmutex := mutexMap.GetLock(user.ID)\n+\t\tmutex.Lock()\n+\t\tdefer mutex.Unlock()\n \n \t\tif user.Email == \"\" {\n \t\t\treturn common.RespError(c, 500, \"User email is empty\")"
    },
    {
      "sha": "f3dfe24570ab9f1125eab47e81578a872f6c1c74",
      "filename": "server/handler/page_pv.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/ArtalkJS/Artalk/blob/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/server%2Fhandler%2Fpage_pv.go",
      "raw_url": "https://github.com/ArtalkJS/Artalk/raw/a98a50abbe4ee2d6aa14437611089b66cb38ebb7/server%2Fhandler%2Fpage_pv.go",
      "contents_url": "https://api.github.com/repos/ArtalkJS/Artalk/contents/server%2Fhandler%2Fpage_pv.go?ref=a98a50abbe4ee2d6aa14437611089b66cb38ebb7",
      "patch": "@@ -35,9 +35,9 @@ func PagePV(app *core.App, router fiber.Router) {\n \t\t\treturn resp\n \t\t}\n \n-\t\tlockKey := p.PageKey + \"_\" + p.SiteName\n-\t\tmutexMap.Lock(lockKey)\n-\t\tdefer mutexMap.Unlock(lockKey)\n+\t\tmutex := mutexMap.GetLock(p.PageKey + \"_\" + p.SiteName)\n+\t\tmutex.Lock()\n+\t\tdefer mutex.Unlock()\n \n \t\t// find page\n \t\tpage := app.Dao().FindCreatePage(p.PageKey, p.PageTitle, p.SiteName)"
    }
  ]
}
