{
  "sha": "5d7ed7708775e3d4864382cca88d2d73ff875864",
  "node_id": "MDY6Q29tbWl0Mzg4ODA1NTU6NWQ3ZWQ3NzA4Nzc1ZTNkNDg2NDM4MmNjYTg4ZDJkNzNmZjg3NTg2NA==",
  "commit": {
    "author": {
      "name": "Alex Waibel",
      "email": "alexwaibel@users.noreply.github.com",
      "date": "2020-07-06T15:57:23Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2020-07-06T15:57:23Z"
    },
    "message": "Fix incorrect error handling (#342) (#346)\n\n* Convert error handler to more modern class declaration.\r\n* Make GitHub and GitService actually throw errors rather than return them\r\n* Fix some broken unit and acceptance tests",
    "tree": {
      "sha": "064c1c78a9cb030e946face714b929f5f29ddda6",
      "url": "https://api.github.com/repos/eduardoboucas/staticman/git/trees/064c1c78a9cb030e946face714b929f5f29ddda6"
    },
    "url": "https://api.github.com/repos/eduardoboucas/staticman/git/commits/5d7ed7708775e3d4864382cca88d2d73ff875864",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfA0njCRBK7hj4Ov3rIwAAdHIIAGs7JUJlSEGrKT4sXrJAbDxO\nDLA+g+Iz5NxgC+3qixgjXyKCKqC9TAUeg0RnAA+T05En7kkPBz02XMgGkI6Kbkjb\nC1MYqba95+SlwQqwrr9tqi7PkdDN4IWeCuSaWQta6rMrAaO8Voe4XXQnff/mFWDg\nxlgGl5QYUtkm/7pHBKTfHhW0Nq7PHPS3iDUpbZuvNv0qc6uHqiAXVVtjrdbWcyoL\nxSRMgRposP+zTHMs/HUb+kplHnAB2XYfOwUGtSxQIirtNBhyZLwRypJv3Yo6XBKD\nxiK8Xnq6C3UkIBeWOLoeSltSAh45wuYehiwg/oDKFvMU2FmZRZtHdhDcE8OOjj4=\n=JtRe\n-----END PGP SIGNATURE-----\n",
      "payload": "tree 064c1c78a9cb030e946face714b929f5f29ddda6\nparent 31ab851a14f64a9f299aa9cd55232014b9aee479\nauthor Alex Waibel <alexwaibel@users.noreply.github.com> 1594051043 -0400\ncommitter GitHub <noreply@github.com> 1594051043 -0400\n\nFix incorrect error handling (#342) (#346)\n\n* Convert error handler to more modern class declaration.\r\n* Make GitHub and GitService actually throw errors rather than return them\r\n* Fix some broken unit and acceptance tests"
    }
  },
  "url": "https://api.github.com/repos/eduardoboucas/staticman/commits/5d7ed7708775e3d4864382cca88d2d73ff875864",
  "html_url": "https://github.com/eduardoboucas/staticman/commit/5d7ed7708775e3d4864382cca88d2d73ff875864",
  "comments_url": "https://api.github.com/repos/eduardoboucas/staticman/commits/5d7ed7708775e3d4864382cca88d2d73ff875864/comments",
  "author": {
    "login": "alexwaibel",
    "id": 7026879,
    "node_id": "MDQ6VXNlcjcwMjY4Nzk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7026879?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alexwaibel",
    "html_url": "https://github.com/alexwaibel",
    "followers_url": "https://api.github.com/users/alexwaibel/followers",
    "following_url": "https://api.github.com/users/alexwaibel/following{/other_user}",
    "gists_url": "https://api.github.com/users/alexwaibel/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alexwaibel/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alexwaibel/subscriptions",
    "organizations_url": "https://api.github.com/users/alexwaibel/orgs",
    "repos_url": "https://api.github.com/users/alexwaibel/repos",
    "events_url": "https://api.github.com/users/alexwaibel/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alexwaibel/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "31ab851a14f64a9f299aa9cd55232014b9aee479",
      "url": "https://api.github.com/repos/eduardoboucas/staticman/commits/31ab851a14f64a9f299aa9cd55232014b9aee479",
      "html_url": "https://github.com/eduardoboucas/staticman/commit/31ab851a14f64a9f299aa9cd55232014b9aee479"
    }
  ],
  "stats": {
    "total": 288,
    "additions": 173,
    "deletions": 115
  },
  "files": [
    {
      "sha": "cc5734de4fc8d1faf8a21d6acef2c8e42df0f8f3",
      "filename": "lib/ErrorHandler.js",
      "status": "modified",
      "additions": 58,
      "deletions": 56,
      "changes": 114,
      "blob_url": "https://github.com/eduardoboucas/staticman/blob/5d7ed7708775e3d4864382cca88d2d73ff875864/lib%2FErrorHandler.js",
      "raw_url": "https://github.com/eduardoboucas/staticman/raw/5d7ed7708775e3d4864382cca88d2d73ff875864/lib%2FErrorHandler.js",
      "contents_url": "https://api.github.com/repos/eduardoboucas/staticman/contents/lib%2FErrorHandler.js?ref=5d7ed7708775e3d4864382cca88d2d73ff875864",
      "patch": "@@ -17,81 +17,83 @@ class ApiError {\n   }\n }\n \n-const ErrorHandler = function () {\n-  this.ERROR_MESSAGES = {\n-    'missing-input-secret': 'reCAPTCHA: The secret parameter is missing',\n-    'invalid-input-secret': 'reCAPTCHA: The secret parameter is invalid or malformed',\n-    'missing-input-response': 'reCAPTCHA: The response parameter is missing',\n-    'invalid-input-response': 'reCAPTCHA: The response parameter is invalid or malformed',\n-    'RECAPTCHA_MISSING_CREDENTIALS': 'Missing reCAPTCHA API credentials',\n-    'RECAPTCHA_FAILED_DECRYPT': 'Could not decrypt reCAPTCHA secret',\n-    'RECAPTCHA_CONFIG_MISMATCH': 'reCAPTCHA options do not match Staticman config',\n-    'PARSING_ERROR': 'Error whilst parsing config file',\n-    'GITHUB_AUTH_TOKEN_MISSING': 'The site requires a valid GitHub authentication token to be supplied in the `options[github-token]` field',\n-    'MISSING_CONFIG_BLOCK': 'Error whilst parsing Staticman config file'\n+class ErrorHandler {\n+  constructor () {\n+    this.ERROR_MESSAGES = {\n+      'missing-input-secret': 'reCAPTCHA: The secret parameter is missing',\n+      'invalid-input-secret': 'reCAPTCHA: The secret parameter is invalid or malformed',\n+      'missing-input-response': 'reCAPTCHA: The response parameter is missing',\n+      'invalid-input-response': 'reCAPTCHA: The response parameter is invalid or malformed',\n+      'RECAPTCHA_MISSING_CREDENTIALS': 'Missing reCAPTCHA API credentials',\n+      'RECAPTCHA_FAILED_DECRYPT': 'Could not decrypt reCAPTCHA secret',\n+      'RECAPTCHA_CONFIG_MISMATCH': 'reCAPTCHA options do not match Staticman config',\n+      'PARSING_ERROR': 'Error whilst parsing config file',\n+      'GITHUB_AUTH_TOKEN_MISSING': 'The site requires a valid GitHub authentication token to be supplied in the `options[github-token]` field',\n+      'MISSING_CONFIG_BLOCK': 'Error whilst parsing Staticman config file'\n+    }\n+\n+    this.ERROR_CODE_ALIASES = {\n+      'missing-input-secret': 'RECAPTCHA_MISSING_INPUT_SECRET',\n+      'invalid-input-secret': 'RECAPTCHA_INVALID_INPUT_SECRET',\n+      'missing-input-response': 'RECAPTCHA_MISSING_INPUT_RESPONSE',\n+      'invalid-input-response': 'RECAPTCHA_INVALID_INPUT_RESPONSE'\n+    }\n   }\n \n-  this.ERROR_CODE_ALIASES = {\n-    'missing-input-secret': 'RECAPTCHA_MISSING_INPUT_SECRET',\n-    'invalid-input-secret': 'RECAPTCHA_INVALID_INPUT_SECRET',\n-    'missing-input-response': 'RECAPTCHA_MISSING_INPUT_RESPONSE',\n-    'invalid-input-response': 'RECAPTCHA_INVALID_INPUT_RESPONSE'\n+  getErrorCode (error) {\n+    return this.ERROR_CODE_ALIASES[error] || error\n   }\n-}\n \n-ErrorHandler.prototype.getErrorCode = function (error) {\n-  return this.ERROR_CODE_ALIASES[error] || error\n-}\n+  getMessage (error) {\n+    return this.ERROR_MESSAGES[error]\n+  }\n \n-ErrorHandler.prototype.getMessage = function (error) {\n-  return this.ERROR_MESSAGES[error]\n-}\n+  log (err, instance) {\n+    let parameters = {}\n+    let prefix = ''\n \n-ErrorHandler.prototype.log = function (err, instance) {\n-  let parameters = {}\n-  let prefix = ''\n+    if (instance) {\n+      parameters = instance.getParameters()\n \n-  if (instance) {\n-    parameters = instance.getParameters()\n+      prefix += `${parameters.username}/${parameters.repository}`\n+    }\n \n-    prefix += `${parameters.username}/${parameters.repository}`\n+    console.log(`${prefix}`, err)\n   }\n \n-  console.log(`${prefix}`, err)\n-}\n+  _save (errorCode, data = {}) {\n+    const {err} = data\n \n-ErrorHandler.prototype._save = function (errorCode, data = {}) {\n-  const {err} = data\n+    if (err) {\n+      err._smErrorCode = err._smErrorCode || errorCode\n \n-  if (err) {\n-    err._smErrorCode = err._smErrorCode || errorCode\n+      // Re-wrap API request errors as these could expose\n+      // request/response details that the user should not\n+      // be allowed to see e.g. access tokens.\n+      // `request-promise` is the primary offender here,\n+      // but we similarly do not want others to leak too.\n+      if (\n+        err instanceof StatusCodeError ||\n+        err instanceof RequestError\n+      ) {\n+        const statusCode = err.statusCode || err.code\n \n-    // Re-wrap API request errors as these could expose\n-    // request/response details that the user should not\n-    // be allowed to see e.g. access tokens.\n-    // `request-promise` is the primary offender here,\n-    // but we similarly do not want others to leak too.\n-    if (\n-      err instanceof StatusCodeError ||\n-      err instanceof RequestError\n-    ) {\n-      const statusCode = err.statusCode || err.code\n+        return new ApiError(err.message, statusCode, err._smErrorCode)\n+      }\n \n-      return new ApiError(err.message, statusCode, err._smErrorCode)\n+      return err\n     }\n \n-    return err\n-  }\n+    let payload = {\n+      _smErrorCode: errorCode\n+    }\n \n-  let payload = {\n-    _smErrorCode: errorCode\n-  }\n+    if (data.data) {\n+      payload.data = data.data\n+    }\n \n-  if (data.data) {\n-    payload.data = data.data\n+    return payload\n   }\n-\n-  return payload\n }\n \n const errorHandler = new ErrorHandler()"
    },
    {
      "sha": "67558241e9249a012095e0ae025a91e1d027bc1a",
      "filename": "lib/GitHub.js",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/eduardoboucas/staticman/blob/5d7ed7708775e3d4864382cca88d2d73ff875864/lib%2FGitHub.js",
      "raw_url": "https://github.com/eduardoboucas/staticman/raw/5d7ed7708775e3d4864382cca88d2d73ff875864/lib%2FGitHub.js",
      "contents_url": "https://api.github.com/repos/eduardoboucas/staticman/contents/lib%2FGitHub.js?ref=5d7ed7708775e3d4864382cca88d2d73ff875864",
      "patch": "@@ -117,7 +117,7 @@ class GitHub extends GitService {\n           console.log(err)\n         }\n \n-        return Promise.reject(errorHandler('GITHUB_WRITING_FILE', {err}))\n+        return Promise.reject(errorHandler('GITHUB_WRITING_FILE'))\n       })\n   }\n \n@@ -182,7 +182,7 @@ class GitHub extends GitService {\n     try {\n       return await super.readFile(filePath, getFullResponse)\n     } catch (err) {\n-      return errorHandler('GITHUB_READING_FILE', {err})\n+      throw errorHandler('GITHUB_READING_FILE', {err})\n     }\n   }\n "
    },
    {
      "sha": "1cc79663121b6cc603f2575332861836acf279bc",
      "filename": "lib/GitService.js",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/eduardoboucas/staticman/blob/5d7ed7708775e3d4864382cca88d2d73ff875864/lib%2FGitService.js",
      "raw_url": "https://github.com/eduardoboucas/staticman/raw/5d7ed7708775e3d4864382cca88d2d73ff875864/lib%2FGitService.js",
      "contents_url": "https://api.github.com/repos/eduardoboucas/staticman/contents/lib%2FGitService.js?ref=5d7ed7708775e3d4864382cca88d2d73ff875864",
      "patch": "@@ -51,7 +51,7 @@ class GitService {\n     try {\n       content = Buffer.from(res.content, 'base64').toString()\n     } catch (err) {\n-      return errorHandler('GITHUB_READING_FILE', {err})\n+      throw errorHandler('GITHUB_READING_FILE', {err})\n     }\n \n     try {\n@@ -85,7 +85,7 @@ class GitService {\n         errorData.data = err.message\n       }\n \n-      return errorHandler('PARSING_ERROR', errorData)\n+      throw errorHandler('PARSING_ERROR', errorData)\n     }\n   }\n "
    },
    {
      "sha": "36758afcd0cbb80121940c75b0066c5e3614d60c",
      "filename": "test/acceptance/api.test.js",
      "status": "modified",
      "additions": 56,
      "deletions": 43,
      "changes": 99,
      "blob_url": "https://github.com/eduardoboucas/staticman/blob/5d7ed7708775e3d4864382cca88d2d73ff875864/test%2Facceptance%2Fapi.test.js",
      "raw_url": "https://github.com/eduardoboucas/staticman/raw/5d7ed7708775e3d4864382cca88d2d73ff875864/test%2Facceptance%2Fapi.test.js",
      "contents_url": "https://api.github.com/repos/eduardoboucas/staticman/contents/test%2Facceptance%2Fapi.test.js?ref=5d7ed7708775e3d4864382cca88d2d73ff875864",
      "patch": "@@ -26,7 +26,7 @@ afterAll(done => {\n })\n \n describe('Connect endpoint', () => {\n-  test('accepts the invitation if one is found and replies with \"OK!\"', () => {\n+  test('accepts the invitation if one is found and replies with \"OK!\"', async () => {\n     const invitationId = 123\n \n     const reqListInvititations = nock('https://api.github.com', {\n@@ -52,15 +52,13 @@ describe('Connect endpoint', () => {\n       .patch(`/user/repository_invitations/${invitationId}`)\n       .reply(204)\n \n-    return request('/v2/connect/johndoe/foobar')\n-      .then(response => {\n-        expect(reqListInvititations.isDone()).toBe(true)\n-        expect(reqAcceptInvitation.isDone()).toBe(true)\n-        expect(response).toBe('OK!')\n-      })\n+    let response = await request('/v2/connect/johndoe/foobar')\n+    expect(reqListInvititations.isDone()).toBe(true)\n+    expect(reqAcceptInvitation.isDone()).toBe(true)\n+    expect(response).toBe('OK!')\n   })\n \n-  test('returns a 404 and an error message if a matching invitation is not found', () => {\n+  test('returns a 404 and an error message if a matching invitation is not found', async () => {\n     const invitationId = 123\n     const reqListInvititations = nock('https://api.github.com', {\n       reqheaders: {\n@@ -85,18 +83,21 @@ describe('Connect endpoint', () => {\n       .patch(`/user/repository_invitations/${invitationId}`)\n       .reply(204)\n \n-    return request('/v2/connect/johndoe/foobar')\n-      .catch(err => {\n+    expect.assertions(4)\n+\n+    try {\n+      await request('/v2/connect/johndoe/foobar')\n+    } catch (err) {\n         expect(reqListInvititations.isDone()).toBe(true)\n         expect(reqAcceptInvitation.isDone()).toBe(false)\n         expect(err.response.body).toBe('Invitation not found')\n         expect(err.statusCode).toBe(404)\n-      })\n+    }\n   })\n })\n \n describe('Entry endpoint', () => {\n-  test('outputs a RECAPTCHA_CONFIG_MISMATCH error if reCaptcha options do not match (wrong site key)', () => {\n+  test('outputs a RECAPTCHA_CONFIG_MISMATCH error if reCaptcha options do not match (wrong site key)', async () => {\n     const data = Object.assign({}, helpers.getParameters(), {\n       path: 'staticman.yml'\n     })\n@@ -136,23 +137,27 @@ describe('Entry endpoint', () => {\n     }\n     const formData = querystring.stringify(form)\n \n-    return request({\n-      body: formData,\n-      method: 'POST',\n-      uri: `/v2/entry/${data.username}/${data.repository}/${data.branch}/${data.property}`,\n-      headers: {\n-        'content-type': 'application/x-www-form-urlencoded'\n-      }\n-    }).catch((response) => {\n+    expect.assertions(3)\n+\n+    try {\n+      await request({\n+        body: formData,\n+        method: 'POST',\n+        uri: `/v2/entry/${data.username}/${data.repository}/${data.branch}/${data.property}`,\n+        headers: {\n+          'content-type': 'application/x-www-form-urlencoded'\n+        }\n+      })\n+    } catch(response) {\n       const error = JSON.parse(response.error)\n \n       expect(error.success).toBe(false)\n       expect(error.errorCode).toBe('RECAPTCHA_CONFIG_MISMATCH')\n       expect(error.message).toBe('reCAPTCHA options do not match Staticman config')\n-    })\n+    }\n   })\n \n-  test('outputs a RECAPTCHA_CONFIG_MISMATCH error if reCaptcha options do not match (wrong secret)', () => {\n+  test('outputs a RECAPTCHA_CONFIG_MISMATCH error if reCaptcha options do not match (wrong secret)', async () => {\n     const data = Object.assign({}, helpers.getParameters(), {\n       path: 'staticman.yml'\n     })\n@@ -192,23 +197,27 @@ describe('Entry endpoint', () => {\n     }\n     const formData = querystring.stringify(form)\n \n-    return request({\n-      body: formData,\n-      method: 'POST',\n-      uri: '/v2/entry/johndoe/foobar/master/comments',\n-      headers: {\n-        'content-type': 'application/x-www-form-urlencoded'\n-      }\n-    }).catch(response => {\n+    expect.assertions(3)\n+\n+    try {\n+      await request({\n+        body: formData,\n+        method: 'POST',\n+        uri: '/v2/entry/johndoe/foobar/master/comments',\n+        headers: {\n+          'content-type': 'application/x-www-form-urlencoded'\n+        }\n+      })\n+    } catch (response) {\n       const error = JSON.parse(response.error)\n \n       expect(error.success).toBe(false)\n       expect(error.errorCode).toBe('RECAPTCHA_CONFIG_MISMATCH')\n       expect(error.message).toBe('reCAPTCHA options do not match Staticman config')\n-    })\n+    }\n   })\n \n-  test('outputs a MISSING_CONFIG_BLOCK error if the site config is malformed', () => {\n+  test('outputs a PARSING_ERROR error if the site config is malformed', async () => {\n     const data = Object.assign({}, helpers.getParameters(), {\n       path: 'staticman.yml'\n     })\n@@ -243,20 +252,24 @@ describe('Entry endpoint', () => {\n     }\n     const formData = querystring.stringify(form)\n \n-    return request({\n-      body: formData,\n-      method: 'POST',\n-      uri: '/v2/entry/johndoe/foobar/master/comments',\n-      headers: {\n-        'content-type': 'application/x-www-form-urlencoded'\n-      }\n-    }).catch(response => {\n+    expect.assertions(4)\n+\n+    try {\n+      await request({\n+        body: formData,\n+        method: 'POST',\n+        uri: '/v2/entry/johndoe/foobar/master/comments',\n+        headers: {\n+          'content-type': 'application/x-www-form-urlencoded'\n+        }\n+      })\n+    } catch (response) {\n       const error = JSON.parse(response.error)\n \n       expect(error.success).toBe(false)\n-      expect(error.errorCode).toBe('MISSING_CONFIG_BLOCK')\n-      expect(error.message).toBe('Error whilst parsing Staticman config file')\n+      expect(error.errorCode).toBe('PARSING_ERROR')\n+      expect(error.message).toBe('Error whilst parsing config file')\n       expect(error.rawError).toBeDefined()\n-    })\n+    }\n   })\n })"
    },
    {
      "sha": "7b3955cae254892e843181d84f2af0f1c0e8bf63",
      "filename": "test/helpers/sampleData.js",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/eduardoboucas/staticman/blob/5d7ed7708775e3d4864382cca88d2d73ff875864/test%2Fhelpers%2FsampleData.js",
      "raw_url": "https://github.com/eduardoboucas/staticman/raw/5d7ed7708775e3d4864382cca88d2d73ff875864/test%2Fhelpers%2FsampleData.js",
      "contents_url": "https://api.github.com/repos/eduardoboucas/staticman/contents/test%2Fhelpers%2FsampleData.js?ref=5d7ed7708775e3d4864382cca88d2d73ff875864",
      "patch": "@@ -150,6 +150,13 @@ module.exports.config3 = `comments:\n     siteKey: \"123456789\"\n     secret: \"@reCaptchaSecret@\"`\n \n+module.exports.configInvalidYML = `invalid:\n+- x\n+y\n+    foo\n+bar\n+`\n+\n module.exports.prBody1 = `Dear human,\n \n Here's a new entry for your approval. :tada:"
    },
    {
      "sha": "24bc50980aa1f4c396fefe6ddc2be40ea0553b03",
      "filename": "test/unit/lib/GitHub.test.js",
      "status": "modified",
      "additions": 48,
      "deletions": 12,
      "changes": 60,
      "blob_url": "https://github.com/eduardoboucas/staticman/blob/5d7ed7708775e3d4864382cca88d2d73ff875864/test%2Funit%2Flib%2FGitHub.test.js",
      "raw_url": "https://github.com/eduardoboucas/staticman/raw/5d7ed7708775e3d4864382cca88d2d73ff875864/test%2Funit%2Flib%2FGitHub.test.js",
      "contents_url": "https://api.github.com/repos/eduardoboucas/staticman/contents/test%2Funit%2Flib%2FGitHub.test.js?ref=5d7ed7708775e3d4864382cca88d2d73ff875864",
      "patch": "@@ -100,6 +100,8 @@ describe('GitHub interface', () => {\n \n       const githubInstance = await new GitHub(req.params)\n \n+      expect.assertions(2)\n+\n       try {\n         await githubInstance.readFile(filePath)\n       } catch (err) {\n@@ -109,18 +111,46 @@ describe('GitHub interface', () => {\n       expect(scope.isDone()).toBe(true)\n     })\n \n-    test('returns an error if parsing fails for the given file', async () => {\n+    test('returns an error if the config file cannot be read', async () => {\n       const filePath = 'path/to/file.yml'\n       const githubInstance = await new GitHub(req.params)\n \n+      expect.assertions(2)\n+\n       try {\n         await githubInstance.readFile(filePath)\n       } catch (err) {\n-        expect(err._smErrorCode).toEqual('PARSING_ERROR')\n+        expect(err._smErrorCode).toEqual('GITHUB_READING_FILE')\n         expect(err.message).toBeDefined()\n       }\n     })\n \n+    test('returns an error if the config file cannot be parsed', async () => {\n+        const scope = nock((/api\\.github\\.com/), {\n+          reqheaders: {\n+            authorization: 'token '.concat('1q2w3e4r')\n+          }\n+        })\n+          .get('/repos/johndoe/foobar/contents/path/to/file.yml?ref=master')\n+          .reply(200, {\n+            content: btoa(sampleData.configInvalidYML)\n+          })\n+\n+        const filePath = 'path/to/file.yml'\n+        const githubInstance = await new GitHub(req.params)\n+\n+        expect.assertions(3)\n+\n+        try {\n+          await githubInstance.readFile(filePath)\n+        } catch (err) {\n+          expect(err._smErrorCode).toEqual('PARSING_ERROR')\n+          expect(err.message).toBeDefined()\n+        }\n+\n+        expect(scope.isDone()).toBe(true)\n+      })\n+\n     test('reads a YAML file and returns its parsed contents', async () => {\n       const filePath = 'path/to/file.yml'\n       const parsedConfig = yaml.safeLoad(sampleData.config1, 'utf8')\n@@ -284,12 +314,12 @@ describe('GitHub interface', () => {\n         }\n       })\n         .put('/repos/johndoe/foobar/contents/path/to/file.txt')\n-        .reply(200, {\n-          number: 123\n-        })\n+        .replyWithError('An error')\n \n       const githubInstance = await new GitHub(req.params)\n \n+      expect.assertions(2)\n+\n       try {\n         await githubInstance.writeFile(\n           options.path,\n@@ -361,22 +391,24 @@ describe('GitHub interface', () => {\n           id: 1\n         })\n \n+      expect.assertions(5)\n+\n       const githubInstance = await new GitHub(req.params)\n \n-      await githubInstance.writeFileAndSendReview(\n+      const data = await githubInstance.writeFileAndSendReview(\n         options.path,\n         options.content,\n         options.newBranch,\n         options.commitTitle,\n         options.commitBody\n       )\n \n-      setTimeout(() => {\n-        expect(branchScope.isDone()).toBe(true)\n-        expect(refsScope.isDone()).toBe(true)\n-        expect(fileScope.isDone()).toBe(true)\n-        expect(pullScope.isDone()).toBe(true)\n-      })\n+      expect(data).toEqual({\"id\": 1})\n+\n+      expect(branchScope.isDone()).toBe(true)\n+      expect(refsScope.isDone()).toBe(true)\n+      expect(fileScope.isDone()).toBe(true)\n+      expect(pullScope.isDone()).toBe(true)\n     })\n \n     // TODO: Figure out why this works with no mocks\n@@ -401,6 +433,8 @@ describe('GitHub interface', () => {\n \n       const githubInstance = await new GitHub(req.params)\n \n+      expect.assertions(2)\n+\n       try {\n         await githubInstance.writeFileAndSendReview(\n           options.path,\n@@ -448,6 +482,8 @@ describe('GitHub interface', () => {\n \n       const githubInstance = await new GitHub(req.params)\n \n+      expect.assertions(2)\n+\n       try {\n         await githubInstance.getCurrentUser()\n       } catch (err) {"
    }
  ]
}
